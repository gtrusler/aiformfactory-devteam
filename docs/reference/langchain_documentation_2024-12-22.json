[{
  "url": "https://python.langchain.com/docs/how_to/",
  "markdown": "# giscus\n\n## How-to guides\n\nHere you’ll find answers to “How do I….?” types of questions. These guides are _goal-oriented_ and _concrete_; they're meant to help you complete a specific task. For conceptual explanations see the [Conceptual guide](https://python.langchain.com/docs/concepts/). For end-to-end walkthroughs see [Tutorials](https://python.langchain.com/docs/tutorials/). For comprehensive descriptions of every class and function see the [API Reference](https://python.langchain.com/api_reference/).\n\n## Installation[​](#installation \"Direct link to Installation\")\n\n*   [How to: install LangChain packages](https://python.langchain.com/docs/how_to/installation/)\n*   [How to: use LangChain with different Pydantic versions](https://python.langchain.com/docs/how_to/pydantic_compatibility/)\n\n## Key features[​](#key-features \"Direct link to Key features\")\n\nThis highlights functionality that is core to using LangChain.\n\n*   [How to: return structured data from a model](https://python.langchain.com/docs/how_to/structured_output/)\n*   [How to: use a model to call tools](https://python.langchain.com/docs/how_to/tool_calling/)\n*   [How to: stream runnables](https://python.langchain.com/docs/how_to/streaming/)\n*   [How to: debug your LLM apps](https://python.langchain.com/docs/how_to/debugging/)\n\n## LangChain Expression Language (LCEL)[​](#langchain-expression-language-lcel \"Direct link to LangChain Expression Language (LCEL)\")\n\n[LangChain Expression Language](https://python.langchain.com/docs/concepts/lcel/) is a way to create arbitrary custom chains. It is built on the [Runnable](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html) protocol.\n\n[**LCEL cheatsheet**](https://python.langchain.com/docs/how_to/lcel_cheatsheet/): For a quick overview of how to use the main LCEL primitives.\n\n[**Migration guide**](https://python.langchain.com/docs/versions/migrating_chains/): For migrating legacy chain abstractions to LCEL.\n\n*   [How to: chain runnables](https://python.langchain.com/docs/how_to/sequence/)\n*   [How to: stream runnables](https://python.langchain.com/docs/how_to/streaming/)\n*   [How to: invoke runnables in parallel](https://python.langchain.com/docs/how_to/parallel/)\n*   [How to: add default invocation args to runnables](https://python.langchain.com/docs/how_to/binding/)\n*   [How to: turn any function into a runnable](https://python.langchain.com/docs/how_to/functions/)\n*   [How to: pass through inputs from one chain step to the next](https://python.langchain.com/docs/how_to/passthrough/)\n*   [How to: configure runnable behavior at runtime](https://python.langchain.com/docs/how_to/configure/)\n*   [How to: add message history (memory) to a chain](https://python.langchain.com/docs/how_to/message_history/)\n*   [How to: route between sub-chains](https://python.langchain.com/docs/how_to/routing/)\n*   [How to: create a dynamic (self-constructing) chain](https://python.langchain.com/docs/how_to/dynamic_chain/)\n*   [How to: inspect runnables](https://python.langchain.com/docs/how_to/inspect/)\n*   [How to: add fallbacks to a runnable](https://python.langchain.com/docs/how_to/fallbacks/)\n*   [How to: pass runtime secrets to a runnable](https://python.langchain.com/docs/how_to/runnable_runtime_secrets/)\n\n## Components[​](#components \"Direct link to Components\")\n\nThese are the core building blocks you can use when building applications.\n\n### Prompt templates[​](#prompt-templates \"Direct link to Prompt templates\")\n\n[Prompt Templates](https://python.langchain.com/docs/concepts/prompt_templates/) are responsible for formatting user input into a format that can be passed to a language model.\n\n*   [How to: use few shot examples](https://python.langchain.com/docs/how_to/few_shot_examples/)\n*   [How to: use few shot examples in chat models](https://python.langchain.com/docs/how_to/few_shot_examples_chat/)\n*   [How to: partially format prompt templates](https://python.langchain.com/docs/how_to/prompts_partial/)\n*   [How to: compose prompts together](https://python.langchain.com/docs/how_to/prompts_composition/)\n\n### Example selectors[​](#example-selectors \"Direct link to Example selectors\")\n\n[Example Selectors](https://python.langchain.com/docs/concepts/example_selectors/) are responsible for selecting the correct few shot examples to pass to the prompt.\n\n*   [How to: use example selectors](https://python.langchain.com/docs/how_to/example_selectors/)\n*   [How to: select examples by length](https://python.langchain.com/docs/how_to/example_selectors_length_based/)\n*   [How to: select examples by semantic similarity](https://python.langchain.com/docs/how_to/example_selectors_similarity/)\n*   [How to: select examples by semantic ngram overlap](https://python.langchain.com/docs/how_to/example_selectors_ngram/)\n*   [How to: select examples by maximal marginal relevance](https://python.langchain.com/docs/how_to/example_selectors_mmr/)\n*   [How to: select examples from LangSmith few-shot datasets](https://python.langchain.com/docs/how_to/example_selectors_langsmith/)\n\n### Chat models[​](#chat-models \"Direct link to Chat models\")\n\n[Chat Models](https://python.langchain.com/docs/concepts/chat_models/) are newer forms of language models that take messages in and output a message. See [supported integrations](https://python.langchain.com/docs/integrations/chat/) for details on getting started with chat models from a specific provider.\n\n*   [How to: do function/tool calling](https://python.langchain.com/docs/how_to/tool_calling/)\n*   [How to: get models to return structured output](https://python.langchain.com/docs/how_to/structured_output/)\n*   [How to: cache model responses](https://python.langchain.com/docs/how_to/chat_model_caching/)\n*   [How to: get log probabilities](https://python.langchain.com/docs/how_to/logprobs/)\n*   [How to: create a custom chat model class](https://python.langchain.com/docs/how_to/custom_chat_model/)\n*   [How to: stream a response back](https://python.langchain.com/docs/how_to/chat_streaming/)\n*   [How to: track token usage](https://python.langchain.com/docs/how_to/chat_token_usage_tracking/)\n*   [How to: track response metadata across providers](https://python.langchain.com/docs/how_to/response_metadata/)\n*   [How to: use chat model to call tools](https://python.langchain.com/docs/how_to/tool_calling/)\n*   [How to: stream tool calls](https://python.langchain.com/docs/how_to/tool_streaming/)\n*   [How to: handle rate limits](https://python.langchain.com/docs/how_to/chat_model_rate_limiting/)\n*   [How to: few shot prompt tool behavior](https://python.langchain.com/docs/how_to/tools_few_shot/)\n*   [How to: bind model-specific formatted tools](https://python.langchain.com/docs/how_to/tools_model_specific/)\n*   [How to: force a specific tool call](https://python.langchain.com/docs/how_to/tool_choice/)\n*   [How to: work with local models](https://python.langchain.com/docs/how_to/local_llms/)\n*   [How to: init any model in one line](https://python.langchain.com/docs/how_to/chat_models_universal_init/)\n\n### Messages[​](#messages \"Direct link to Messages\")\n\n[Messages](https://python.langchain.com/docs/concepts/messages/) are the input and output of chat models. They have some `content` and a `role`, which describes the source of the message.\n\n*   [How to: trim messages](https://python.langchain.com/docs/how_to/trim_messages/)\n*   [How to: filter messages](https://python.langchain.com/docs/how_to/filter_messages/)\n*   [How to: merge consecutive messages of the same type](https://python.langchain.com/docs/how_to/merge_message_runs/)\n\n### LLMs[​](#llms \"Direct link to LLMs\")\n\nWhat LangChain calls [LLMs](https://python.langchain.com/docs/concepts/text_llms/) are older forms of language models that take a string in and output a string.\n\n*   [How to: cache model responses](https://python.langchain.com/docs/how_to/llm_caching/)\n*   [How to: create a custom LLM class](https://python.langchain.com/docs/how_to/custom_llm/)\n*   [How to: stream a response back](https://python.langchain.com/docs/how_to/streaming_llm/)\n*   [How to: track token usage](https://python.langchain.com/docs/how_to/llm_token_usage_tracking/)\n*   [How to: work with local models](https://python.langchain.com/docs/how_to/local_llms/)\n\n### Output parsers[​](#output-parsers \"Direct link to Output parsers\")\n\n[Output Parsers](https://python.langchain.com/docs/concepts/output_parsers/) are responsible for taking the output of an LLM and parsing into more structured format.\n\n*   [How to: parse text from message objects](https://python.langchain.com/docs/how_to/output_parser_string/)\n*   [How to: use output parsers to parse an LLM response into structured format](https://python.langchain.com/docs/how_to/output_parser_structured/)\n*   [How to: parse JSON output](https://python.langchain.com/docs/how_to/output_parser_json/)\n*   [How to: parse XML output](https://python.langchain.com/docs/how_to/output_parser_xml/)\n*   [How to: parse YAML output](https://python.langchain.com/docs/how_to/output_parser_yaml/)\n*   [How to: retry when output parsing errors occur](https://python.langchain.com/docs/how_to/output_parser_retry/)\n*   [How to: try to fix errors in output parsing](https://python.langchain.com/docs/how_to/output_parser_fixing/)\n*   [How to: write a custom output parser class](https://python.langchain.com/docs/how_to/output_parser_custom/)\n\n### Document loaders[​](#document-loaders \"Direct link to Document loaders\")\n\n[Document Loaders](https://python.langchain.com/docs/concepts/document_loaders/) are responsible for loading documents from a variety of sources.\n\n*   [How to: load PDF files](https://python.langchain.com/docs/how_to/document_loader_pdf/)\n*   [How to: load web pages](https://python.langchain.com/docs/how_to/document_loader_web/)\n*   [How to: load CSV data](https://python.langchain.com/docs/how_to/document_loader_csv/)\n*   [How to: load data from a directory](https://python.langchain.com/docs/how_to/document_loader_directory/)\n*   [How to: load HTML data](https://python.langchain.com/docs/how_to/document_loader_html/)\n*   [How to: load JSON data](https://python.langchain.com/docs/how_to/document_loader_json/)\n*   [How to: load Markdown data](https://python.langchain.com/docs/how_to/document_loader_markdown/)\n*   [How to: load Microsoft Office data](https://python.langchain.com/docs/how_to/document_loader_office_file/)\n*   [How to: write a custom document loader](https://python.langchain.com/docs/how_to/document_loader_custom/)\n\n### Text splitters[​](#text-splitters \"Direct link to Text splitters\")\n\n[Text Splitters](https://python.langchain.com/docs/concepts/text_splitters/) take a document and split into chunks that can be used for retrieval.\n\n*   [How to: recursively split text](https://python.langchain.com/docs/how_to/recursive_text_splitter/)\n*   [How to: split HTML](https://python.langchain.com/docs/how_to/split_html/)\n*   [How to: split by character](https://python.langchain.com/docs/how_to/character_text_splitter/)\n*   [How to: split code](https://python.langchain.com/docs/how_to/code_splitter/)\n*   [How to: split Markdown by headers](https://python.langchain.com/docs/how_to/markdown_header_metadata_splitter/)\n*   [How to: recursively split JSON](https://python.langchain.com/docs/how_to/recursive_json_splitter/)\n*   [How to: split text into semantic chunks](https://python.langchain.com/docs/how_to/semantic-chunker/)\n*   [How to: split by tokens](https://python.langchain.com/docs/how_to/split_by_token/)\n\n### Embedding models[​](#embedding-models \"Direct link to Embedding models\")\n\n[Embedding Models](https://python.langchain.com/docs/concepts/embedding_models/) take a piece of text and create a numerical representation of it. See [supported integrations](https://python.langchain.com/docs/integrations/text_embedding/) for details on getting started with embedding models from a specific provider.\n\n*   [How to: embed text data](https://python.langchain.com/docs/how_to/embed_text/)\n*   [How to: cache embedding results](https://python.langchain.com/docs/how_to/caching_embeddings/)\n*   [How to: create a custom embeddings class](https://python.langchain.com/docs/how_to/custom_embeddings/)\n\n### Vector stores[​](#vector-stores \"Direct link to Vector stores\")\n\n[Vector stores](https://python.langchain.com/docs/concepts/vectorstores/) are databases that can efficiently store and retrieve embeddings. See [supported integrations](https://python.langchain.com/docs/integrations/vectorstores/) for details on getting started with vector stores from a specific provider.\n\n*   [How to: use a vector store to retrieve data](https://python.langchain.com/docs/how_to/vectorstores/)\n\n### Retrievers[​](#retrievers \"Direct link to Retrievers\")\n\n[Retrievers](https://python.langchain.com/docs/concepts/retrievers/) are responsible for taking a query and returning relevant documents.\n\n*   [How to: use a vector store to retrieve data](https://python.langchain.com/docs/how_to/vectorstore_retriever/)\n*   [How to: generate multiple queries to retrieve data for](https://python.langchain.com/docs/how_to/MultiQueryRetriever/)\n*   [How to: use contextual compression to compress the data retrieved](https://python.langchain.com/docs/how_to/contextual_compression/)\n*   [How to: write a custom retriever class](https://python.langchain.com/docs/how_to/custom_retriever/)\n*   [How to: add similarity scores to retriever results](https://python.langchain.com/docs/how_to/add_scores_retriever/)\n*   [How to: combine the results from multiple retrievers](https://python.langchain.com/docs/how_to/ensemble_retriever/)\n*   [How to: reorder retrieved results to mitigate the \"lost in the middle\" effect](https://python.langchain.com/docs/how_to/long_context_reorder/)\n*   [How to: generate multiple embeddings per document](https://python.langchain.com/docs/how_to/multi_vector/)\n*   [How to: retrieve the whole document for a chunk](https://python.langchain.com/docs/how_to/parent_document_retriever/)\n*   [How to: generate metadata filters](https://python.langchain.com/docs/how_to/self_query/)\n*   [How to: create a time-weighted retriever](https://python.langchain.com/docs/how_to/time_weighted_vectorstore/)\n*   [How to: use hybrid vector and keyword retrieval](https://python.langchain.com/docs/how_to/hybrid/)\n\n### Indexing[​](#indexing \"Direct link to Indexing\")\n\nIndexing is the process of keeping your vectorstore in-sync with the underlying data source.\n\n*   [How to: reindex data to keep your vectorstore in-sync with the underlying data source](https://python.langchain.com/docs/how_to/indexing/)\n\n### Tools[​](#tools \"Direct link to Tools\")\n\nLangChain [Tools](https://python.langchain.com/docs/concepts/tools/) contain a description of the tool (to pass to the language model) as well as the implementation of the function to call. Refer [here](https://python.langchain.com/docs/integrations/tools/) for a list of pre-buit tools.\n\n*   [How to: create tools](https://python.langchain.com/docs/how_to/custom_tools/)\n*   [How to: use built-in tools and toolkits](https://python.langchain.com/docs/how_to/tools_builtin/)\n*   [How to: use chat models to call tools](https://python.langchain.com/docs/how_to/tool_calling/)\n*   [How to: pass tool outputs to chat models](https://python.langchain.com/docs/how_to/tool_results_pass_to_model/)\n*   [How to: pass run time values to tools](https://python.langchain.com/docs/how_to/tool_runtime/)\n*   [How to: add a human-in-the-loop for tools](https://python.langchain.com/docs/how_to/tools_human/)\n*   [How to: handle tool errors](https://python.langchain.com/docs/how_to/tools_error/)\n*   [How to: force models to call a tool](https://python.langchain.com/docs/how_to/tool_choice/)\n*   [How to: disable parallel tool calling](https://python.langchain.com/docs/how_to/tool_calling_parallel/)\n*   [How to: access the `RunnableConfig` from a tool](https://python.langchain.com/docs/how_to/tool_configure/)\n*   [How to: stream events from a tool](https://python.langchain.com/docs/how_to/tool_stream_events/)\n*   [How to: return artifacts from a tool](https://python.langchain.com/docs/how_to/tool_artifacts/)\n*   [How to: convert Runnables to tools](https://python.langchain.com/docs/how_to/convert_runnable_to_tool/)\n*   [How to: add ad-hoc tool calling capability to models](https://python.langchain.com/docs/how_to/tools_prompting/)\n*   [How to: pass in runtime secrets](https://python.langchain.com/docs/how_to/runnable_runtime_secrets/)\n\n### Multimodal[​](#multimodal \"Direct link to Multimodal\")\n\n*   [How to: pass multimodal data directly to models](https://python.langchain.com/docs/how_to/multimodal_inputs/)\n*   [How to: use multimodal prompts](https://python.langchain.com/docs/how_to/multimodal_prompts/)\n\n### Agents[​](#agents \"Direct link to Agents\")\n\nnote\n\nFor in depth how-to guides for agents, please check out [LangGraph](https://langchain-ai.github.io/langgraph/) documentation.\n\n*   [How to: use legacy LangChain Agents (AgentExecutor)](https://python.langchain.com/docs/how_to/agent_executor/)\n*   [How to: migrate from legacy LangChain agents to LangGraph](https://python.langchain.com/docs/how_to/migrate_agent/)\n\n### Callbacks[​](#callbacks \"Direct link to Callbacks\")\n\n[Callbacks](https://python.langchain.com/docs/concepts/callbacks/) allow you to hook into the various stages of your LLM application's execution.\n\n*   [How to: pass in callbacks at runtime](https://python.langchain.com/docs/how_to/callbacks_runtime/)\n*   [How to: attach callbacks to a module](https://python.langchain.com/docs/how_to/callbacks_attach/)\n*   [How to: pass callbacks into a module constructor](https://python.langchain.com/docs/how_to/callbacks_constructor/)\n*   [How to: create custom callback handlers](https://python.langchain.com/docs/how_to/custom_callbacks/)\n*   [How to: use callbacks in async environments](https://python.langchain.com/docs/how_to/callbacks_async/)\n*   [How to: dispatch custom callback events](https://python.langchain.com/docs/how_to/callbacks_custom_events/)\n\n### Custom[​](#custom \"Direct link to Custom\")\n\nAll of LangChain components can easily be extended to support your own versions.\n\n*   [How to: create a custom chat model class](https://python.langchain.com/docs/how_to/custom_chat_model/)\n*   [How to: create a custom LLM class](https://python.langchain.com/docs/how_to/custom_llm/)\n*   [How to: create a custom embeddings class](https://python.langchain.com/docs/how_to/custom_embeddings/)\n*   [How to: write a custom retriever class](https://python.langchain.com/docs/how_to/custom_retriever/)\n*   [How to: write a custom document loader](https://python.langchain.com/docs/how_to/document_loader_custom/)\n*   [How to: write a custom output parser class](https://python.langchain.com/docs/how_to/output_parser_custom/)\n*   [How to: create custom callback handlers](https://python.langchain.com/docs/how_to/custom_callbacks/)\n*   [How to: define a custom tool](https://python.langchain.com/docs/how_to/custom_tools/)\n*   [How to: dispatch custom callback events](https://python.langchain.com/docs/how_to/callbacks_custom_events/)\n\n### Serialization[​](#serialization \"Direct link to Serialization\")\n\n*   [How to: save and load LangChain objects](https://python.langchain.com/docs/how_to/serialization/)\n\n## Use cases[​](#use-cases \"Direct link to Use cases\")\n\nThese guides cover use-case specific details.\n\n### Q&A with RAG[​](#qa-with-rag \"Direct link to Q&A with RAG\")\n\nRetrieval Augmented Generation (RAG) is a way to connect LLMs to external sources of data. For a high-level tutorial on RAG, check out [this guide](https://python.langchain.com/docs/tutorials/rag/).\n\n*   [How to: add chat history](https://python.langchain.com/docs/how_to/qa_chat_history_how_to/)\n*   [How to: stream](https://python.langchain.com/docs/how_to/qa_streaming/)\n*   [How to: return sources](https://python.langchain.com/docs/how_to/qa_sources/)\n*   [How to: return citations](https://python.langchain.com/docs/how_to/qa_citations/)\n*   [How to: do per-user retrieval](https://python.langchain.com/docs/how_to/qa_per_user/)\n\nExtraction is when you use LLMs to extract structured information from unstructured text. For a high level tutorial on extraction, check out [this guide](https://python.langchain.com/docs/tutorials/extraction/).\n\n*   [How to: use reference examples](https://python.langchain.com/docs/how_to/extraction_examples/)\n*   [How to: handle long text](https://python.langchain.com/docs/how_to/extraction_long_text/)\n*   [How to: do extraction without using function calling](https://python.langchain.com/docs/how_to/extraction_parse/)\n\n### Chatbots[​](#chatbots \"Direct link to Chatbots\")\n\nChatbots involve using an LLM to have a conversation. For a high-level tutorial on building chatbots, check out [this guide](https://python.langchain.com/docs/tutorials/chatbot/).\n\n*   [How to: manage memory](https://python.langchain.com/docs/how_to/chatbots_memory/)\n*   [How to: do retrieval](https://python.langchain.com/docs/how_to/chatbots_retrieval/)\n*   [How to: use tools](https://python.langchain.com/docs/how_to/chatbots_tools/)\n*   [How to: manage large chat history](https://python.langchain.com/docs/how_to/trim_messages/)\n\n### Query analysis[​](#query-analysis \"Direct link to Query analysis\")\n\nQuery Analysis is the task of using an LLM to generate a query to send to a retriever. For a high-level tutorial on query analysis, check out [this guide](https://python.langchain.com/docs/tutorials/rag/#query-analysis).\n\n*   [How to: add examples to the prompt](https://python.langchain.com/docs/how_to/query_few_shot/)\n*   [How to: handle cases where no queries are generated](https://python.langchain.com/docs/how_to/query_no_queries/)\n*   [How to: handle multiple queries](https://python.langchain.com/docs/how_to/query_multiple_queries/)\n*   [How to: handle multiple retrievers](https://python.langchain.com/docs/how_to/query_multiple_retrievers/)\n*   [How to: construct filters](https://python.langchain.com/docs/how_to/query_constructing_filters/)\n*   [How to: deal with high cardinality categorical variables](https://python.langchain.com/docs/how_to/query_high_cardinality/)\n\n### Q&A over SQL + CSV[​](#qa-over-sql--csv \"Direct link to Q&A over SQL + CSV\")\n\nYou can use LLMs to do question answering over tabular data. For a high-level tutorial, check out [this guide](https://python.langchain.com/docs/tutorials/sql_qa/).\n\n*   [How to: use prompting to improve results](https://python.langchain.com/docs/how_to/sql_prompting/)\n*   [How to: do query validation](https://python.langchain.com/docs/how_to/sql_query_checking/)\n*   [How to: deal with large databases](https://python.langchain.com/docs/how_to/sql_large_db/)\n*   [How to: deal with CSV files](https://python.langchain.com/docs/how_to/sql_csv/)\n\n### Q&A over graph databases[​](#qa-over-graph-databases \"Direct link to Q&A over graph databases\")\n\nYou can use an LLM to do question answering over graph databases. For a high-level tutorial, check out [this guide](https://python.langchain.com/docs/tutorials/graph/).\n\n*   [How to: add a semantic layer over the database](https://python.langchain.com/docs/how_to/graph_semantic/)\n*   [How to: construct knowledge graphs](https://python.langchain.com/docs/how_to/graph_constructing/)\n\n### Summarization[​](#summarization \"Direct link to Summarization\")\n\nLLMs can summarize and otherwise distill desired information from text, including large volumes of text. For a high-level tutorial, check out [this guide](https://python.langchain.com/docs/tutorials/summarization/).\n\n*   [How to: summarize text in a single LLM call](https://python.langchain.com/docs/how_to/summarize_stuff/)\n*   [How to: summarize text through parallelization](https://python.langchain.com/docs/how_to/summarize_map_reduce/)\n*   [How to: summarize text through iterative refinement](https://python.langchain.com/docs/how_to/summarize_refine/)\n\n## [LangGraph](https://langchain-ai.github.io/langgraph)[​](#langgraph \"Direct link to langgraph\")\n\nLangGraph is an extension of LangChain aimed at building robust and stateful multi-actor applications with LLMs by modeling steps as edges and nodes in a graph.\n\nLangGraph documentation is currently hosted on a separate site. You can peruse [LangGraph how-to guides here](https://langchain-ai.github.io/langgraph/how-tos/).\n\n## [LangSmith](https://docs.smith.langchain.com/)[​](#langsmith \"Direct link to langsmith\")\n\nLangSmith allows you to closely trace, monitor and evaluate your LLM application. It seamlessly integrates with LangChain and LangGraph, and you can use it to inspect and debug individual steps of your chains and agents as you build.\n\nLangSmith documentation is hosted on a separate site. You can peruse [LangSmith how-to guides here](https://docs.smith.langchain.com/how_to_guides/), but we'll highlight a few sections that are particularly relevant to LangChain below:\n\n### Evaluation[​](#evaluation \"Direct link to Evaluation\")\n\nEvaluating performance is a vital part of building LLM-powered applications. LangSmith helps with every step of the process from creating a dataset to defining metrics to running evaluators.\n\nTo learn more, check out the [LangSmith evaluation how-to guides](https://docs.smith.langchain.com/how_to_guides#evaluation).\n\n### Tracing[​](#tracing \"Direct link to Tracing\")\n\nTracing gives you observability inside your chains and agents, and is vital in diagnosing issues.\n\n*   [How to: trace with LangChain](https://docs.smith.langchain.com/how_to_guides/tracing/trace_with_langchain)\n*   [How to: add metadata and tags to traces](https://docs.smith.langchain.com/how_to_guides/tracing/trace_with_langchain#add-metadata-and-tags-to-traces)\n\nYou can see general tracing-related how-tos [in this section of the LangSmith docs](https://docs.smith.langchain.com/how_to_guides/tracing)."
},
{
  "url": "https://python.langchain.com/docs/how_to/output_parser_json/",
  "markdown": "# giscus\n\n## How to parse JSON output\n\nWhile some model providers support [built-in ways to return structured output](https://python.langchain.com/docs/how_to/structured_output/), not all do. We can use an output parser to help users to specify an arbitrary JSON schema via the prompt, query a model for outputs that conform to that schema, and finally parse that schema as JSON.\n\nnote\n\nKeep in mind that large language models are leaky abstractions! You'll have to use an LLM with sufficient capacity to generate well-formed JSON.\n\nThe [`JsonOutputParser`](https://python.langchain.com/api_reference/core/output_parsers/langchain_core.output_parsers.json.JsonOutputParser.html) is one built-in option for prompting for and then parsing JSON output. While it is similar in functionality to the [`PydanticOutputParser`](https://python.langchain.com/api_reference/core/output_parsers/langchain_core.output_parsers.pydantic.PydanticOutputParser.html), it also supports streaming back partial JSON objects.\n\nHere's an example of how it can be used alongside [Pydantic](https://docs.pydantic.dev/) to conveniently declare the expected schema:\n\n```\n%pip install -qU langchain langchain-openaiimport osfrom getpass import getpassif \"OPENAI_API_KEY\" not in os.environ:    os.environ[\"OPENAI_API_KEY\"] = getpass()\n```\n\n```\nfrom langchain_core.output_parsers import JsonOutputParserfrom langchain_core.prompts import PromptTemplatefrom langchain_openai import ChatOpenAIfrom pydantic import BaseModel, Fieldmodel = ChatOpenAI(temperature=0)# Define your desired data structure.class Joke(BaseModel):    setup: str = Field(description=\"question to set up a joke\")    punchline: str = Field(description=\"answer to resolve the joke\")# And a query intented to prompt a language model to populate the data structure.joke_query = \"Tell me a joke.\"# Set up a parser + inject instructions into the prompt template.parser = JsonOutputParser(pydantic_object=Joke)prompt = PromptTemplate(    template=\"Answer the user query.\\n{format_instructions}\\n{query}\\n\",    input_variables=[\"query\"],    partial_variables={\"format_instructions\": parser.get_format_instructions()},)chain = prompt | model | parserchain.invoke({\"query\": joke_query})\n```\n\n```\n{'setup': \"Why couldn't the bicycle stand up by itself?\", 'punchline': 'Because it was two tired!'}\n```\n\nNote that we are passing `format_instructions` from the parser directly into the prompt. You can and should experiment with adding your own formatting hints in the other parts of your prompt to either augment or replace the default instructions:\n\n```\nparser.get_format_instructions()\n```\n\n```\n'The output should be formatted as a JSON instance that conforms to the JSON schema below.\\n\\nAs an example, for the schema {\"properties\": {\"foo\": {\"title\": \"Foo\", \"description\": \"a list of strings\", \"type\": \"array\", \"items\": {\"type\": \"string\"}}}, \"required\": [\"foo\"]}\\nthe object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted instance of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"]}} is not well-formatted.\\n\\nHere is the output schema:\\n\\`\\`\\`\\n{\"properties\": {\"setup\": {\"title\": \"Setup\", \"description\": \"question to set up a joke\", \"type\": \"string\"}, \"punchline\": {\"title\": \"Punchline\", \"description\": \"answer to resolve the joke\", \"type\": \"string\"}}, \"required\": [\"setup\", \"punchline\"]}\\n\\`\\`\\`'\n```\n\n## Streaming[​](#streaming \"Direct link to Streaming\")\n\nAs mentioned above, a key difference between the `JsonOutputParser` and the `PydanticOutputParser` is that the `JsonOutputParser` output parser supports streaming partial chunks. Here's what that looks like:\n\n```\nfor s in chain.stream({\"query\": joke_query}):    print(s)\n```\n\n```\n{}{'setup': ''}{'setup': 'Why'}{'setup': 'Why couldn'}{'setup': \"Why couldn't\"}{'setup': \"Why couldn't the\"}{'setup': \"Why couldn't the bicycle\"}{'setup': \"Why couldn't the bicycle stand\"}{'setup': \"Why couldn't the bicycle stand up\"}{'setup': \"Why couldn't the bicycle stand up by\"}{'setup': \"Why couldn't the bicycle stand up by itself\"}{'setup': \"Why couldn't the bicycle stand up by itself?\"}{'setup': \"Why couldn't the bicycle stand up by itself?\", 'punchline': ''}{'setup': \"Why couldn't the bicycle stand up by itself?\", 'punchline': 'Because'}{'setup': \"Why couldn't the bicycle stand up by itself?\", 'punchline': 'Because it'}{'setup': \"Why couldn't the bicycle stand up by itself?\", 'punchline': 'Because it was'}{'setup': \"Why couldn't the bicycle stand up by itself?\", 'punchline': 'Because it was two'}{'setup': \"Why couldn't the bicycle stand up by itself?\", 'punchline': 'Because it was two tired'}{'setup': \"Why couldn't the bicycle stand up by itself?\", 'punchline': 'Because it was two tired!'}\n```\n\n## Without Pydantic[​](#without-pydantic \"Direct link to Without Pydantic\")\n\nYou can also use the `JsonOutputParser` without Pydantic. This will prompt the model to return JSON, but doesn't provide specifics about what the schema should be.\n\n```\njoke_query = \"Tell me a joke.\"parser = JsonOutputParser()prompt = PromptTemplate(    template=\"Answer the user query.\\n{format_instructions}\\n{query}\\n\",    input_variables=[\"query\"],    partial_variables={\"format_instructions\": parser.get_format_instructions()},)chain = prompt | model | parserchain.invoke({\"query\": joke_query})\n```\n\n```\n{'response': \"Sure! Here's a joke for you: Why couldn't the bicycle stand up by itself? Because it was two tired!\"}\n```\n\n## Next steps[​](#next-steps \"Direct link to Next steps\")\n\nYou've now learned one way to prompt a model to return structured JSON. Next, check out the [broader guide on obtaining structured output](https://python.langchain.com/docs/how_to/structured_output/) for other techniques."
},
{
  "url": "https://python.langchain.com/docs/how_to/chatbots_tools/",
  "markdown": "# giscus\n\n## How to add tools to chatbots\n\nThis section will cover how to create conversational agents: chatbots that can interact with other systems and APIs using tools.\n\nnote\n\nThis how-to guide previously built a chatbot using [RunnableWithMessageHistory](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.history.RunnableWithMessageHistory.html). You can access this version of the guide in the [v0.2 docs](https://python.langchain.com/v0.2/docs/how_to/chatbots_tools/).\n\nAs of the v0.3 release of LangChain, we recommend that LangChain users take advantage of [LangGraph persistence](https://langchain-ai.github.io/langgraph/concepts/persistence/) to incorporate `memory` into new LangChain applications.\n\nIf your code is already relying on `RunnableWithMessageHistory` or `BaseChatMessageHistory`, you do **not** need to make any changes. We do not plan on deprecating this functionality in the near future as it works for simple chat applications and any code that uses `RunnableWithMessageHistory` will continue to work as expected.\n\nPlease see [How to migrate to LangGraph Memory](https://python.langchain.com/docs/versions/migrating_memory/) for more details.\n\n## Setup[​](#setup \"Direct link to Setup\")\n\nFor this guide, we'll be using a [tool calling agent](https://langchain-ai.github.io/langgraph/concepts/agentic_concepts/#tool-calling-agent) with a single tool for searching the web. The default will be powered by [Tavily](https://python.langchain.com/docs/integrations/tools/tavily_search/), but you can switch it out for any similar tool. The rest of this section will assume you're using Tavily.\n\nYou'll need to [sign up for an account](https://tavily.com/) on the Tavily website, and install the following packages:\n\n```\n%pip install --upgrade --quiet langchain-community langchain-openai tavily-python langgraphimport getpassimport osif not os.environ.get(\"OPENAI_API_KEY\"):    os.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"OpenAI API Key:\")if not os.environ.get(\"TAVILY_API_KEY\"):    os.environ[\"TAVILY_API_KEY\"] = getpass.getpass(\"Tavily API Key:\")\n```\n\n```\nOpenAI API Key: ········Tavily API Key: ········\n```\n\nYou will also need your OpenAI key set as `OPENAI_API_KEY` and your Tavily API key set as `TAVILY_API_KEY`.\n\n## Creating an agent[​](#creating-an-agent \"Direct link to Creating an agent\")\n\nOur end goal is to create an agent that can respond conversationally to user questions while looking up information as needed.\n\nFirst, let's initialize Tavily and an OpenAI [chat model](https://python.langchain.com/docs/concepts/chat_models/) capable of tool calling:\n\n```\nfrom langchain_community.tools.tavily_search import TavilySearchResultsfrom langchain_openai import ChatOpenAItools = [TavilySearchResults(max_results=1)]# Choose the LLM that will drive the agent# Only certain models support thismodel = ChatOpenAI(model=\"gpt-4o-mini\", temperature=0)\n```\n\nTo make our agent conversational, we can also specify a prompt. Here's an example:\n\n```\nprompt = (    \"You are a helpful assistant. \"    \"You may not need to use tools for every query - the user may just want to chat!\")\n```\n\nGreat! Now let's assemble our agent using LangGraph's prebuilt [create\\_react\\_agent](https://langchain-ai.github.io/langgraph/reference/prebuilt/#create_react_agent), which allows you to create a [tool-calling agent](https://langchain-ai.github.io/langgraph/concepts/agentic_concepts/#tool-calling-agent):\n\n```\nfrom langgraph.prebuilt import create_react_agent# state_modifier allows you to preprocess the inputs to the model inside ReAct agent# in this case, since we're passing a prompt string, we'll just always add a SystemMessage# with this prompt string before any other messages sent to the modelagent = create_react_agent(model, tools, state_modifier=prompt)\n```\n\n## Running the agent[​](#running-the-agent \"Direct link to Running the agent\")\n\nNow that we've set up our agent, let's try interacting with it! It can handle both trivial queries that require no lookup:\n\n```\nfrom langchain_core.messages import HumanMessageagent.invoke({\"messages\": [HumanMessage(content=\"I'm Nemo!\")]})\n```\n\n```\n{'messages': [HumanMessage(content=\"I'm Nemo!\", additional_kwargs={}, response_metadata={}, id='39e715c7-bd1c-426f-8e14-c05586b3d221'),  AIMessage(content='Hi Nemo! How can I assist you today?', additional_kwargs={'refusal': None}, response_metadata={'token_usage': {'completion_tokens': 11, 'prompt_tokens': 107, 'total_tokens': 118, 'completion_tokens_details': {'reasoning_tokens': 0}}, 'model_name': 'gpt-4o-mini-2024-07-18', 'system_fingerprint': 'fp_1bb46167f9', 'finish_reason': 'stop', 'logprobs': None}, id='run-6937c944-d702-40bb-9a9f-4141ddde9f78-0', usage_metadata={'input_tokens': 107, 'output_tokens': 11, 'total_tokens': 118})]}\n```\n\nOr, it can use of the passed search tool to get up to date information if needed:\n\n```\nagent.invoke(    {        \"messages\": [            HumanMessage(                content=\"What is the current conservation status of the Great Barrier Reef?\"            )        ],    })\n```\n\n```\n{'messages': [HumanMessage(content='What is the current conservation status of the Great Barrier Reef?', additional_kwargs={}, response_metadata={}, id='a74cc581-8ad5-4401-b3a5-f028d69e4b21'),  AIMessage(content='', additional_kwargs={'tool_calls': [{'id': 'call_aKOItwvAb4DHQCwaasKphGHq', 'function': {'arguments': '{\"query\":\"current conservation status of the Great Barrier Reef 2023\"}', 'name': 'tavily_search_results_json'}, 'type': 'function'}], 'refusal': None}, response_metadata={'token_usage': {'completion_tokens': 28, 'prompt_tokens': 116, 'total_tokens': 144, 'completion_tokens_details': {'reasoning_tokens': 0}}, 'model_name': 'gpt-4o-mini-2024-07-18', 'system_fingerprint': 'fp_1bb46167f9', 'finish_reason': 'tool_calls', 'logprobs': None}, id='run-267ff8a8-d866-4ae5-9534-ad87ebbdc954-0', tool_calls=[{'name': 'tavily_search_results_json', 'args': {'query': 'current conservation status of the Great Barrier Reef 2023'}, 'id': 'call_aKOItwvAb4DHQCwaasKphGHq', 'type': 'tool_call'}], usage_metadata={'input_tokens': 116, 'output_tokens': 28, 'total_tokens': 144}),  ToolMessage(content='[{\"url\": \"https://www.aims.gov.au/monitoring-great-barrier-reef/gbr-condition-summary-2023-24\", \"content\": \"This report summarises the condition of coral reefs in the Northern, Central and Southern\\xa0Great Barrier Reef (GBR) from the Long-Term Monitoring Program (LTMP) surveys of 94 reefs conducted between August\\xa02023 and June 2024 (reported as ‘2024’). Over the past 38 years of monitoring by the Australian Institute of Marine Science (AIMS), hard coral cover on reefs of the GBR has decreased and increased in response to cycles of disturbance and recovery. It is relatively rare for GBR reefs to have 75% to 100% hard coral cover and AIMS defines >30% – 50% hard coral cover as a high value, based on historical surveys across the GBR.\"}]', name='tavily_search_results_json', id='05b3fab7-9ac8-42bb-9612-ff2a896dbb67', tool_call_id='call_aKOItwvAb4DHQCwaasKphGHq', artifact={'query': 'current conservation status of the Great Barrier Reef 2023', 'follow_up_questions': None, 'answer': None, 'images': [], 'results': [{'title': 'Annual Summary Report of Coral Reef Condition 2023/24', 'url': 'https://www.aims.gov.au/monitoring-great-barrier-reef/gbr-condition-summary-2023-24', 'content': 'This report summarises the condition of coral reefs in the Northern, Central and Southern\\xa0Great Barrier Reef (GBR) from the Long-Term Monitoring Program (LTMP) surveys of 94 reefs conducted between August\\xa02023 and June 2024 (reported as ‘2024’). Over the past 38 years of monitoring by the Australian Institute of Marine Science (AIMS), hard coral cover on reefs of the GBR has decreased and increased in response to cycles of disturbance and recovery. It is relatively rare for GBR reefs to have 75% to 100% hard coral cover and AIMS defines >30% – 50% hard coral cover as a high value, based on historical surveys across the GBR.', 'score': 0.95991266, 'raw_content': None}], 'response_time': 4.22}),  AIMessage(content='The current conservation status of the Great Barrier Reef (GBR) indicates ongoing challenges and fluctuations in coral health. According to a report from the Australian Institute of Marine Science (AIMS), the condition of coral reefs in the GBR has been monitored over the years, showing cycles of disturbance and recovery. \\n\\nAs of the latest surveys conducted between August 2023 and June 2024, hard coral cover on the GBR has experienced both decreases and increases. AIMS defines a hard coral cover of over 30% to 50% as high value, but it is relatively rare for GBR reefs to achieve 75% to 100% hard coral cover.\\n\\nFor more detailed information, you can refer to the [AIMS report](https://www.aims.gov.au/monitoring-great-barrier-reef/gbr-condition-summary-2023-24).', additional_kwargs={'refusal': None}, response_metadata={'token_usage': {'completion_tokens': 174, 'prompt_tokens': 337, 'total_tokens': 511, 'completion_tokens_details': {'reasoning_tokens': 0}}, 'model_name': 'gpt-4o-mini-2024-07-18', 'system_fingerprint': 'fp_1bb46167f9', 'finish_reason': 'stop', 'logprobs': None}, id='run-bec32925-0dba-445d-8b55-87358ef482bb-0', usage_metadata={'input_tokens': 337, 'output_tokens': 174, 'total_tokens': 511})]}\n```\n\n## Conversational responses[​](#conversational-responses \"Direct link to Conversational responses\")\n\nBecause our prompt contains a placeholder for chat history messages, our agent can also take previous interactions into account and respond conversationally like a standard chatbot:\n\n```\nfrom langchain_core.messages import AIMessage, HumanMessageagent.invoke(    {        \"messages\": [            HumanMessage(content=\"I'm Nemo!\"),            AIMessage(content=\"Hello Nemo! How can I assist you today?\"),            HumanMessage(content=\"What is my name?\"),        ],    })\n```\n\n```\n{'messages': [HumanMessage(content=\"I'm Nemo!\", additional_kwargs={}, response_metadata={}, id='2c8e58bf-ad20-45a4-940b-84393c6b3a03'),  AIMessage(content='Hello Nemo! How can I assist you today?', additional_kwargs={}, response_metadata={}, id='5e014114-7e9d-42c3-b63e-a662b3a49bef'),  HumanMessage(content='What is my name?', additional_kwargs={}, response_metadata={}, id='d92be4e1-6497-4037-9a9a-83d3e7b760d5'),  AIMessage(content='Your name is Nemo!', additional_kwargs={'refusal': None}, response_metadata={'token_usage': {'completion_tokens': 6, 'prompt_tokens': 130, 'total_tokens': 136, 'completion_tokens_details': {'reasoning_tokens': 0}}, 'model_name': 'gpt-4o-mini-2024-07-18', 'system_fingerprint': 'fp_1bb46167f9', 'finish_reason': 'stop', 'logprobs': None}, id='run-17db96f8-8dbd-4f25-a80d-e4e872967641-0', usage_metadata={'input_tokens': 130, 'output_tokens': 6, 'total_tokens': 136})]}\n```\n\nIf preferred, you can also add memory to the LangGraph agent to manage the history of messages. Let's redeclare it this way:\n\n```\nfrom langgraph.checkpoint.memory import MemorySavermemory = MemorySaver()agent = create_react_agent(model, tools, state_modifier=prompt, checkpointer=memory)\n```\n\n```\nagent.invoke(    {\"messages\": [HumanMessage(\"I'm Nemo!\")]},    config={\"configurable\": {\"thread_id\": \"1\"}},)\n```\n\n```\n{'messages': [HumanMessage(content=\"I'm Nemo!\", additional_kwargs={}, response_metadata={}, id='117b2cfc-c6cc-449c-bba9-26fc545d0afa'),  AIMessage(content='Hi Nemo! How can I assist you today?', additional_kwargs={'refusal': None}, response_metadata={'token_usage': {'completion_tokens': 11, 'prompt_tokens': 107, 'total_tokens': 118, 'completion_tokens_details': {'reasoning_tokens': 0}}, 'model_name': 'gpt-4o-mini-2024-07-18', 'system_fingerprint': 'fp_1bb46167f9', 'finish_reason': 'stop', 'logprobs': None}, id='run-ba16cc0b-fba1-4ec5-9d99-e010c3b702d0-0', usage_metadata={'input_tokens': 107, 'output_tokens': 11, 'total_tokens': 118})]}\n```\n\nAnd then if we rerun our wrapped agent executor:\n\n```\nagent.invoke(    {\"messages\": [HumanMessage(\"What is my name?\")]},    config={\"configurable\": {\"thread_id\": \"1\"}},)\n```\n\n```\n{'messages': [HumanMessage(content=\"I'm Nemo!\", additional_kwargs={}, response_metadata={}, id='117b2cfc-c6cc-449c-bba9-26fc545d0afa'),  AIMessage(content='Hi Nemo! How can I assist you today?', additional_kwargs={'refusal': None}, response_metadata={'token_usage': {'completion_tokens': 11, 'prompt_tokens': 107, 'total_tokens': 118, 'completion_tokens_details': {'reasoning_tokens': 0}}, 'model_name': 'gpt-4o-mini-2024-07-18', 'system_fingerprint': 'fp_1bb46167f9', 'finish_reason': 'stop', 'logprobs': None}, id='run-ba16cc0b-fba1-4ec5-9d99-e010c3b702d0-0', usage_metadata={'input_tokens': 107, 'output_tokens': 11, 'total_tokens': 118}),  HumanMessage(content='What is my name?', additional_kwargs={}, response_metadata={}, id='53ac8d34-99bb-43a7-9103-80e26b7ee6cc'),  AIMessage(content='Your name is Nemo!', additional_kwargs={'refusal': None}, response_metadata={'token_usage': {'completion_tokens': 6, 'prompt_tokens': 130, 'total_tokens': 136, 'completion_tokens_details': {'reasoning_tokens': 0}}, 'model_name': 'gpt-4o-mini-2024-07-18', 'system_fingerprint': 'fp_1bb46167f9', 'finish_reason': 'stop', 'logprobs': None}, id='run-b3f224a5-902a-4973-84ff-9b683615b0e2-0', usage_metadata={'input_tokens': 130, 'output_tokens': 6, 'total_tokens': 136})]}\n```\n\nThis [LangSmith trace](https://smith.langchain.com/public/9e6b000d-08aa-4c5a-ac83-2fdf549523cb/r) shows what's going on under the hood.\n\n## Further reading[​](#further-reading \"Direct link to Further reading\")\n\nFor more on how to build agents, check these [LangGraph](https://langchain-ai.github.io/langgraph/) guides:\n\n*   [agents conceptual guide](https://langchain-ai.github.io/langgraph/concepts/agentic_concepts/)\n*   [agents tutorials](https://langchain-ai.github.io/langgraph/tutorials/multi_agent/multi-agent-collaboration/)\n*   [create\\_react\\_agent](https://langchain-ai.github.io/langgraph/how-tos/create-react-agent/)\n\nFor more on tool usage, you can also check out [this use case section](https://python.langchain.com/docs/how_to/#tools)."
},
{
  "url": "https://python.langchain.com/docs/how_to/code_splitter/",
  "markdown": "# giscus\n\n## How to split code\n\n[RecursiveCharacterTextSplitter](https://python.langchain.com/api_reference/text_splitters/character/langchain_text_splitters.character.RecursiveCharacterTextSplitter.html) includes pre-built lists of separators that are useful for [splitting text](https://python.langchain.com/docs/concepts/text_splitters/) in a specific programming language.\n\nSupported languages are stored in the `langchain_text_splitters.Language` enum. They include:\n\n```\n\"cpp\",\"go\",\"java\",\"kotlin\",\"js\",\"ts\",\"php\",\"proto\",\"python\",\"rst\",\"ruby\",\"rust\",\"scala\",\"swift\",\"markdown\",\"latex\",\"html\",\"sol\",\"csharp\",\"cobol\",\"c\",\"lua\",\"perl\",\"haskell\"\n```\n\nTo view the list of separators for a given language, pass a value from this enum into\n\n```\nRecursiveCharacterTextSplitter.get_separators_for_language`\n```\n\nTo instantiate a splitter that is tailored for a specific language, pass a value from the enum into\n\n```\nRecursiveCharacterTextSplitter.from_language\n```\n\nBelow we demonstrate examples for the various languages.\n\n```\n%pip install -qU langchain-text-splitters\n```\n\n```\nfrom langchain_text_splitters import (    Language,    RecursiveCharacterTextSplitter,)\n```\n\nTo view the full list of supported languages:\n\n```\n[e.value for e in Language]\n```\n\n```\n['cpp', 'go', 'java', 'kotlin', 'js', 'ts', 'php', 'proto', 'python', 'rst', 'ruby', 'rust', 'scala', 'swift', 'markdown', 'latex', 'html', 'sol', 'csharp', 'cobol', 'c', 'lua', 'perl', 'haskell']\n```\n\nYou can also see the separators used for a given language:\n\n```\nRecursiveCharacterTextSplitter.get_separators_for_language(Language.PYTHON)\n```\n\n```\n['\\nclass ', '\\ndef ', '\\n\\tdef ', '\\n\\n', '\\n', ' ', '']\n```\n\n## Python[​](#python \"Direct link to Python\")\n\nHere's an example using the PythonTextSplitter:\n\n```\nPYTHON_CODE = \"\"\"def hello_world():    print(\"Hello, World!\")# Call the functionhello_world()\"\"\"python_splitter = RecursiveCharacterTextSplitter.from_language(    language=Language.PYTHON, chunk_size=50, chunk_overlap=0)python_docs = python_splitter.create_documents([PYTHON_CODE])python_docs\n```\n\n```\n[Document(page_content='def hello_world():\\n    print(\"Hello, World!\")'), Document(page_content='# Call the function\\nhello_world()')]\n```\n\n## JS[​](#js \"Direct link to JS\")\n\nHere's an example using the JS text splitter:\n\n```\nJS_CODE = \"\"\"function helloWorld() {  console.log(\"Hello, World!\");}// Call the functionhelloWorld();\"\"\"js_splitter = RecursiveCharacterTextSplitter.from_language(    language=Language.JS, chunk_size=60, chunk_overlap=0)js_docs = js_splitter.create_documents([JS_CODE])js_docs\n```\n\n```\n[Document(page_content='function helloWorld() {\\n  console.log(\"Hello, World!\");\\n}'), Document(page_content='// Call the function\\nhelloWorld();')]\n```\n\n## TS[​](#ts \"Direct link to TS\")\n\nHere's an example using the TS text splitter:\n\n```\nTS_CODE = \"\"\"function helloWorld(): void {  console.log(\"Hello, World!\");}// Call the functionhelloWorld();\"\"\"ts_splitter = RecursiveCharacterTextSplitter.from_language(    language=Language.TS, chunk_size=60, chunk_overlap=0)ts_docs = ts_splitter.create_documents([TS_CODE])ts_docs\n```\n\n```\n[Document(page_content='function helloWorld(): void {'), Document(page_content='console.log(\"Hello, World!\");\\n}'), Document(page_content='// Call the function\\nhelloWorld();')]\n```\n\n## Markdown[​](#markdown \"Direct link to Markdown\")\n\nHere's an example using the Markdown text splitter:\n\n```\nmarkdown_text = \"\"\"# 🦜️🔗 LangChain⚡ Building applications with LLMs through composability ⚡## What is LangChain?# Hopefully this code block isn't splitLangChain is a framework for...As an open-source project in a rapidly developing field, we are extremely open to contributions.\"\"\"\n```\n\n```\nmd_splitter = RecursiveCharacterTextSplitter.from_language(    language=Language.MARKDOWN, chunk_size=60, chunk_overlap=0)md_docs = md_splitter.create_documents([markdown_text])md_docs\n```\n\n```\n[Document(metadata={}, page_content='# 🦜️🔗 LangChain'), Document(metadata={}, page_content='⚡ Building applications with LLMs through composability ⚡'), Document(metadata={}, page_content='## What is LangChain?'), Document(metadata={}, page_content=\"# Hopefully this code block isn't split\"), Document(metadata={}, page_content='LangChain is a framework for...'), Document(metadata={}, page_content='As an open-source project in a rapidly developing field, we'), Document(metadata={}, page_content='are extremely open to contributions.')]\n```\n\n## Latex[​](#latex \"Direct link to Latex\")\n\nHere's an example on Latex text:\n\n```\nlatex_text = \"\"\"\\documentclass{article}\\begin{document}\\maketitle\\section{Introduction}Large language models (LLMs) are a type of machine learning model that can be trained on vast amounts of text data to generate human-like language. In recent years, LLMs have made significant advances in a variety of natural language processing tasks, including language translation, text generation, and sentiment analysis.\\subsection{History of LLMs}The earliest LLMs were developed in the 1980s and 1990s, but they were limited by the amount of data that could be processed and the computational power available at the time. In the past decade, however, advances in hardware and software have made it possible to train LLMs on massive datasets, leading to significant improvements in performance.\\subsection{Applications of LLMs}LLMs have many applications in industry, including chatbots, content creation, and virtual assistants. They can also be used in academia for research in linguistics, psychology, and computational linguistics.\\end{document}\"\"\"\n```\n\n```\nlatex_splitter = RecursiveCharacterTextSplitter.from_language(    language=Language.MARKDOWN, chunk_size=60, chunk_overlap=0)latex_docs = latex_splitter.create_documents([latex_text])latex_docs\n```\n\n```\n[Document(page_content='\\\\documentclass{article}\\n\\n\\x08egin{document}\\n\\n\\\\maketitle'), Document(page_content='\\\\section{Introduction}'), Document(page_content='Large language models (LLMs) are a type of machine learning'), Document(page_content='model that can be trained on vast amounts of text data to'), Document(page_content='generate human-like language. In recent years, LLMs have'), Document(page_content='made significant advances in a variety of natural language'), Document(page_content='processing tasks, including language translation, text'), Document(page_content='generation, and sentiment analysis.'), Document(page_content='\\\\subsection{History of LLMs}'), Document(page_content='The earliest LLMs were developed in the 1980s and 1990s,'), Document(page_content='but they were limited by the amount of data that could be'), Document(page_content='processed and the computational power available at the'), Document(page_content='time. In the past decade, however, advances in hardware and'), Document(page_content='software have made it possible to train LLMs on massive'), Document(page_content='datasets, leading to significant improvements in'), Document(page_content='performance.'), Document(page_content='\\\\subsection{Applications of LLMs}'), Document(page_content='LLMs have many applications in industry, including'), Document(page_content='chatbots, content creation, and virtual assistants. They'), Document(page_content='can also be used in academia for research in linguistics,'), Document(page_content='psychology, and computational linguistics.'), Document(page_content='\\\\end{document}')]\n```\n\n## HTML[​](#html \"Direct link to HTML\")\n\nHere's an example using an HTML text splitter:\n\n```\nhtml_text = \"\"\"<!DOCTYPE html><html>    <head>        <title>🦜️🔗 LangChain</title>        <style>            body {                font-family: Arial, sans-serif;            }            h1 {                color: darkblue;            }        </style>    </head>    <body>        <div>            <h1>🦜️🔗 LangChain</h1>            <p>⚡ Building applications with LLMs through composability ⚡</p>        </div>        <div>            As an open-source project in a rapidly developing field, we are extremely open to contributions.        </div>    </body></html>\"\"\"\n```\n\n```\nhtml_splitter = RecursiveCharacterTextSplitter.from_language(    language=Language.HTML, chunk_size=60, chunk_overlap=0)html_docs = html_splitter.create_documents([html_text])html_docs\n```\n\n```\n[Document(page_content='<!DOCTYPE html>\\n<html>'), Document(page_content='<head>\\n        <title>🦜️🔗 LangChain</title>'), Document(page_content='<style>\\n            body {\\n                font-family: Aria'), Document(page_content='l, sans-serif;\\n            }\\n            h1 {'), Document(page_content='color: darkblue;\\n            }\\n        </style>\\n    </head'), Document(page_content='>'), Document(page_content='<body>'), Document(page_content='<div>\\n            <h1>🦜️🔗 LangChain</h1>'), Document(page_content='<p>⚡ Building applications with LLMs through composability ⚡'), Document(page_content='</p>\\n        </div>'), Document(page_content='<div>\\n            As an open-source project in a rapidly dev'), Document(page_content='eloping field, we are extremely open to contributions.'), Document(page_content='</div>\\n    </body>\\n</html>')]\n```\n\n## Solidity[​](#solidity \"Direct link to Solidity\")\n\nHere's an example using the Solidity text splitter:\n\n```\nSOL_CODE = \"\"\"pragma solidity ^0.8.20;contract HelloWorld {   function add(uint a, uint b) pure public returns(uint) {       return a + b;   }}\"\"\"sol_splitter = RecursiveCharacterTextSplitter.from_language(    language=Language.SOL, chunk_size=128, chunk_overlap=0)sol_docs = sol_splitter.create_documents([SOL_CODE])sol_docs\n```\n\n```\n[Document(page_content='pragma solidity ^0.8.20;'), Document(page_content='contract HelloWorld {\\n   function add(uint a, uint b) pure public returns(uint) {\\n       return a + b;\\n   }\\n}')]\n```\n\n## C#[​](#c \"Direct link to C#\")\n\nHere's an example using the C# text splitter:\n\n```\nC_CODE = \"\"\"using System;class Program{    static void Main()    {        int age = 30; // Change the age value as needed        // Categorize the age without any console output        if (age < 18)        {            // Age is under 18        }        else if (age >= 18 && age < 65)        {            // Age is an adult        }        else        {            // Age is a senior citizen        }    }}\"\"\"c_splitter = RecursiveCharacterTextSplitter.from_language(    language=Language.CSHARP, chunk_size=128, chunk_overlap=0)c_docs = c_splitter.create_documents([C_CODE])c_docs\n```\n\n```\n[Document(page_content='using System;'), Document(page_content='class Program\\n{\\n    static void Main()\\n    {\\n        int age = 30; // Change the age value as needed'), Document(page_content='// Categorize the age without any console output\\n        if (age < 18)\\n        {\\n            // Age is under 18'), Document(page_content='}\\n        else if (age >= 18 && age < 65)\\n        {\\n            // Age is an adult\\n        }\\n        else\\n        {'), Document(page_content='// Age is a senior citizen\\n        }\\n    }\\n}')]\n```\n\n## Haskell[​](#haskell \"Direct link to Haskell\")\n\nHere's an example using the Haskell text splitter:\n\n```\nHASKELL_CODE = \"\"\"main :: IO ()main = do    putStrLn \"Hello, World!\"-- Some sample functionsadd :: Int -> Int -> Intadd x y = x + y\"\"\"haskell_splitter = RecursiveCharacterTextSplitter.from_language(    language=Language.HASKELL, chunk_size=50, chunk_overlap=0)haskell_docs = haskell_splitter.create_documents([HASKELL_CODE])haskell_docs\n```\n\n```\n[Document(page_content='main :: IO ()'), Document(page_content='main = do\\n    putStrLn \"Hello, World!\"\\n-- Some'), Document(page_content='sample functions\\nadd :: Int -> Int -> Int\\nadd x y'), Document(page_content='= x + y')]\n```\n\n## PHP[​](#php \"Direct link to PHP\")\n\nHere's an example using the PHP text splitter:\n\n```\nPHP_CODE = \"\"\"<?phpnamespace foo;class Hello {    public function __construct() { }}function hello() {    echo \"Hello World!\";}interface Human {    public function breath();}trait Foo { }enum Color{    case Red;    case Blue;}\"\"\"php_splitter = RecursiveCharacterTextSplitter.from_language(    language=Language.PHP, chunk_size=50, chunk_overlap=0)php_docs = php_splitter.create_documents([PHP_CODE])php_docs\n```\n\n```\n[Document(page_content='<?php\\nnamespace foo;'), Document(page_content='class Hello {'), Document(page_content='public function __construct() { }\\n}'), Document(page_content='function hello() {\\n    echo \"Hello World!\";\\n}'), Document(page_content='interface Human {\\n    public function breath();\\n}'), Document(page_content='trait Foo { }\\nenum Color\\n{\\n    case Red;'), Document(page_content='case Blue;\\n}')]\n```\n\n## PowerShell[​](#powershell \"Direct link to PowerShell\")\n\nHere's an example using the PowerShell text splitter:\n\n```\nPOWERSHELL_CODE = \"\"\"$directoryPath = Get-Location$items = Get-ChildItem -Path $directoryPath$files = $items | Where-Object { -not $_.PSIsContainer }$sortedFiles = $files | Sort-Object LastWriteTimeforeach ($file in $sortedFiles) {    Write-Output (\"Name: \" + $file.Name + \" | Last Write Time: \" + $file.LastWriteTime)}\"\"\"powershell_splitter = RecursiveCharacterTextSplitter.from_language(    language=Language.POWERSHELL, chunk_size=100, chunk_overlap=0)powershell_docs = powershell_splitter.create_documents([POWERSHELL_CODE])powershell_docs\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/output_parser_retry/",
  "markdown": "# giscus\n\n[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/langchain-ai/langchain/blob/master/docs/docs/how_to/output_parser_retry.ipynb)[![Open on GitHub](https://img.shields.io/badge/Open%20on%20GitHub-grey?logo=github&logoColor=white)](https://github.com/langchain-ai/langchain/blob/master/docs/docs/how_to/output_parser_retry.ipynb)\n\n## How to retry when a parsing error occurs\n\nWhile in some cases it is possible to fix any parsing mistakes by only looking at the output, in other cases it isn't. An example of this is when the output is not just in the incorrect format, but is partially complete. Consider the below example.\n\n```\nfrom langchain.output_parsers import OutputFixingParserfrom langchain_core.exceptions import OutputParserExceptionfrom langchain_core.output_parsers import PydanticOutputParserfrom langchain_core.prompts import PromptTemplatefrom langchain_openai import ChatOpenAI, OpenAIfrom pydantic import BaseModel, Field\n```\n\n```\ntemplate = \"\"\"Based on the user question, provide an Action and Action Input for what step should be taken.{format_instructions}Question: {query}Response:\"\"\"class Action(BaseModel):    action: str = Field(description=\"action to take\")    action_input: str = Field(description=\"input to the action\")parser = PydanticOutputParser(pydantic_object=Action)\n```\n\n```\nprompt = PromptTemplate(    template=\"Answer the user query.\\n{format_instructions}\\n{query}\\n\",    input_variables=[\"query\"],    partial_variables={\"format_instructions\": parser.get_format_instructions()},)\n```\n\n```\nprompt_value = prompt.format_prompt(query=\"who is leo di caprios gf?\")\n```\n\n```\nbad_response = '{\"action\": \"search\"}'\n```\n\nIf we try to parse this response as is, we will get an error:\n\n```\ntry:    parser.parse(bad_response)except OutputParserException as e:    print(e)\n```\n\n```\nFailed to parse Action from completion {\"action\": \"search\"}. Got: 1 validation error for Actionaction_input  Field required [type=missing, input_value={'action': 'search'}, input_type=dict]    For further information visit https://errors.pydantic.dev/2.9/v/missingFor troubleshooting, visit: https://python.langchain.com/docs/troubleshooting/errors/OUTPUT_PARSING_FAILURE\n```\n\nIf we try to use the `OutputFixingParser` to fix this error, it will be confused - namely, it doesn't know what to actually put for action input.\n\n```\nfix_parser = OutputFixingParser.from_llm(parser=parser, llm=ChatOpenAI())\n```\n\n```\nfix_parser.parse(bad_response)\n```\n\n```\nAction(action='search', action_input='input')\n```\n\nInstead, we can use the RetryOutputParser, which passes in the prompt (as well as the original output) to try again to get a better response.\n\n```\nfrom langchain.output_parsers import RetryOutputParser\n```\n\n```\nretry_parser = RetryOutputParser.from_llm(parser=parser, llm=OpenAI(temperature=0))\n```\n\n```\nretry_parser.parse_with_prompt(bad_response, prompt_value)\n```\n\n```\nAction(action='search', action_input='leo di caprio girlfriend')\n```\n\nWe can also add the RetryOutputParser easily with a custom chain which transform the raw LLM/ChatModel output into a more workable format.\n\n```\nfrom langchain_core.runnables import RunnableLambda, RunnableParallelcompletion_chain = prompt | OpenAI(temperature=0)main_chain = RunnableParallel(    completion=completion_chain, prompt_value=prompt) | RunnableLambda(lambda x: retry_parser.parse_with_prompt(**x))main_chain.invoke({\"query\": \"who is leo di caprios gf?\"})\n```\n\n```\nAction(action='search', action_input='leo di caprio girlfriend')\n```\n\nFind out api documentation for [RetryOutputParser](https://python.langchain.com/api_reference/langchain/output_parsers/langchain.output_parsers.retry.RetryOutputParser.html#langchain.output_parsers.retry.RetryOutputParser)."
},
{
  "url": "https://python.langchain.com/docs/how_to/output_parser_string/",
  "markdown": "# giscus\n\n## How to parse text from message objects\n\nLangChain [message](https://python.langchain.com/docs/concepts/messages/) objects support content in a [variety of formats](https://python.langchain.com/docs/concepts/messages/#content), including text, [multimodal data](https://python.langchain.com/docs/concepts/multimodality/), and a list of [content block](https://python.langchain.com/docs/concepts/messages/#aimessage) dicts.\n\nThe format of [Chat model](https://python.langchain.com/docs/concepts/chat_models/) response content may depend on the provider. For example, the chat model for [Anthropic](https://python.langchain.com/docs/integrations/chat/anthropic/) will return string content for typical string input:\n\n```\nfrom langchain_anthropic import ChatAnthropicllm = ChatAnthropic(model=\"claude-3-5-haiku-latest\")response = llm.invoke(\"Hello\")response.content\n```\n\n```\n'Hi there! How are you doing today? Is there anything I can help you with?'\n```\n\nBut when tool calls are generated, the response content is structured into content blocks that convey the model's reasoning process:\n\n```\nfrom langchain_core.tools import tool@tooldef get_weather(location: str) -> str:    \"\"\"Get the weather from a location.\"\"\"    return \"Sunny.\"llm_with_tools = llm.bind_tools([get_weather])response = llm_with_tools.invoke(\"What's the weather in San Francisco, CA?\")response.content\n```\n\n**API Reference:**[tool](https://python.langchain.com/api_reference/core/tools/langchain_core.tools.convert.tool.html)\n\n```\n[{'text': \"I'll help you get the current weather for San Francisco, California. Let me check that for you right away.\",  'type': 'text'}, {'id': 'toolu_015PwwcKxWYctKfY3pruHFyy',  'input': {'location': 'San Francisco, CA'},  'name': 'get_weather',  'type': 'tool_use'}]\n```\n\nTo automatically parse text from message objects irrespective of the format of the underlying content, we can use [StrOutputParser](https://python.langchain.com/api_reference/core/output_parsers/langchain_core.output_parsers.string.StrOutputParser.html). We can compose it with a chat model as follows:\n\n```\nfrom langchain_core.output_parsers import StrOutputParserchain = llm_with_tools | StrOutputParser()\n```\n\n[StrOutputParser](https://python.langchain.com/api_reference/core/output_parsers/langchain_core.output_parsers.string.StrOutputParser.html) simplifies the extraction of text from message objects:\n\n```\nresponse = chain.invoke(\"What's the weather in San Francisco, CA?\")print(response)\n```\n\n```\nI'll help you check the weather in San Francisco, CA right away.\n```\n\nThis is particularly useful in streaming contexts:\n\n```\nfor chunk in chain.stream(\"What's the weather in San Francisco, CA?\"):    print(chunk, end=\"|\")\n```\n\n```\n|I'll| help| you get| the current| weather for| San Francisco, California|. Let| me retrieve| that| information for you.||||||||||\n```\n\nSee the [API Reference](https://python.langchain.com/api_reference/core/output_parsers/langchain_core.output_parsers.string.StrOutputParser.html) for more information."
},
{
  "url": "https://python.langchain.com/docs/how_to/contextual_compression/",
  "markdown": "# giscus\n\n## How to do retrieval with contextual compression\n\nOne challenge with [retrieval](https://python.langchain.com/docs/concepts/retrieval/) is that usually you don't know the specific queries your document storage system will face when you ingest data into the system. This means that the information most relevant to a query may be buried in a document with a lot of irrelevant text. Passing that full document through your application can lead to more expensive LLM calls and poorer responses.\n\nContextual compression is meant to fix this. The idea is simple: instead of immediately returning retrieved documents as-is, you can compress them using the context of the given query, so that only the relevant information is returned. “Compressing” here refers to both compressing the contents of an individual document and filtering out documents wholesale.\n\nTo use the Contextual Compression Retriever, you'll need:\n\n*   a base [retriever](https://python.langchain.com/docs/concepts/retrievers/)\n*   a Document Compressor\n\nThe Contextual Compression Retriever passes queries to the base retriever, takes the initial documents and passes them through the Document Compressor. The Document Compressor takes a list of documents and shortens it by reducing the contents of documents or dropping documents altogether.\n\n## Get started[​](#get-started \"Direct link to Get started\")\n\n```\n# Helper function for printing docsdef pretty_print_docs(docs):    print(        f\"\\n{'-' * 100}\\n\".join(            [f\"Document {i+1}:\\n\\n\" + d.page_content for i, d in enumerate(docs)]        )    )\n```\n\n## Using a vanilla vector store retriever[​](#using-a-vanilla-vector-store-retriever \"Direct link to Using a vanilla vector store retriever\")\n\nLet's start by initializing a simple vector store retriever and storing the 2023 State of the Union speech (in chunks). We can see that given an example question our retriever returns one or two relevant docs and a few irrelevant docs. And even the relevant docs have a lot of irrelevant information in them.\n\n```\nfrom langchain_community.document_loaders import TextLoaderfrom langchain_community.vectorstores import FAISSfrom langchain_openai import OpenAIEmbeddingsfrom langchain_text_splitters import CharacterTextSplitterdocuments = TextLoader(\"state_of_the_union.txt\").load()text_splitter = CharacterTextSplitter(chunk_size=1000, chunk_overlap=0)texts = text_splitter.split_documents(documents)retriever = FAISS.from_documents(texts, OpenAIEmbeddings()).as_retriever()docs = retriever.invoke(\"What did the president say about Ketanji Brown Jackson\")pretty_print_docs(docs)\n```\n\n```\nDocument 1:Tonight. I call on the Senate to: Pass the Freedom to Vote Act. Pass the John Lewis Voting Rights Act. And while you’re at it, pass the Disclose Act so Americans can know who is funding our elections. Tonight, I’d like to honor someone who has dedicated his life to serve this country: Justice Stephen Breyer—an Army veteran, Constitutional scholar, and retiring Justice of the United States Supreme Court. Justice Breyer, thank you for your service. One of the most serious constitutional responsibilities a President has is nominating someone to serve on the United States Supreme Court. And I did that 4 days ago, when I nominated Circuit Court of Appeals Judge Ketanji Brown Jackson. One of our nation’s top legal minds, who will continue Justice Breyer’s legacy of excellence.----------------------------------------------------------------------------------------------------Document 2:A former top litigator in private practice. A former federal public defender. And from a family of public school educators and police officers. A consensus builder. Since she’s been nominated, she’s received a broad range of support—from the Fraternal Order of Police to former judges appointed by Democrats and Republicans. And if we are to advance liberty and justice, we need to secure the Border and fix the immigration system. We can do both. At our border, we’ve installed new technology like cutting-edge scanners to better detect drug smuggling.  We’ve set up joint patrols with Mexico and Guatemala to catch more human traffickers.  We’re putting in place dedicated immigration judges so families fleeing persecution and violence can have their cases heard faster. We’re securing commitments and supporting partners in South and Central America to host more refugees and secure their own borders.----------------------------------------------------------------------------------------------------Document 3:And for our LGBTQ+ Americans, let’s finally get the bipartisan Equality Act to my desk. The onslaught of state laws targeting transgender Americans and their families is wrong. As I said last year, especially to our younger transgender Americans, I will always have your back as your President, so you can be yourself and reach your God-given potential. While it often appears that we never agree, that isn’t true. I signed 80 bipartisan bills into law last year. From preventing government shutdowns to protecting Asian-Americans from still-too-common hate crimes to reforming military justice. And soon, we’ll strengthen the Violence Against Women Act that I first wrote three decades ago. It is important for us to show the nation that we can come together and do big things. So tonight I’m offering a Unity Agenda for the Nation. Four big things we can do together.  First, beat the opioid epidemic.----------------------------------------------------------------------------------------------------Document 4:Tonight, I’m announcing a crackdown on these companies overcharging American businesses and consumers. And as Wall Street firms take over more nursing homes, quality in those homes has gone down and costs have gone up.  That ends on my watch. Medicare is going to set higher standards for nursing homes and make sure your loved ones get the care they deserve and expect. We’ll also cut costs and keep the economy going strong by giving workers a fair shot, provide more training and apprenticeships, hire them based on their skills not degrees. Let’s pass the Paycheck Fairness Act and paid leave.  Raise the minimum wage to $15 an hour and extend the Child Tax Credit, so no one has to raise a family in poverty. Let’s increase Pell Grants and increase our historic support of HBCUs, and invest in what Jill—our First Lady who teaches full-time—calls America’s best-kept secret: community colleges.\n```\n\nNow let's wrap our base retriever with a `ContextualCompressionRetriever`. We'll add an `LLMChainExtractor`, which will iterate over the initially returned documents and extract from each only the content that is relevant to the query.\n\n```\nfrom langchain.retrievers import ContextualCompressionRetrieverfrom langchain.retrievers.document_compressors import LLMChainExtractorfrom langchain_openai import OpenAIllm = OpenAI(temperature=0)compressor = LLMChainExtractor.from_llm(llm)compression_retriever = ContextualCompressionRetriever(    base_compressor=compressor, base_retriever=retriever)compressed_docs = compression_retriever.invoke(    \"What did the president say about Ketanji Jackson Brown\")pretty_print_docs(compressed_docs)\n```\n\n```\nDocument 1:I did that 4 days ago, when I nominated Circuit Court of Appeals Judge Ketanji Brown Jackson.\n```\n\n## More built-in compressors: filters[​](#more-built-in-compressors-filters \"Direct link to More built-in compressors: filters\")\n\n### `LLMChainFilter`[​](#llmchainfilter \"Direct link to llmchainfilter\")\n\nThe `LLMChainFilter` is slightly simpler but more robust compressor that uses an LLM chain to decide which of the initially retrieved documents to filter out and which ones to return, without manipulating the document contents.\n\n```\nfrom langchain.retrievers.document_compressors import LLMChainFilter_filter = LLMChainFilter.from_llm(llm)compression_retriever = ContextualCompressionRetriever(    base_compressor=_filter, base_retriever=retriever)compressed_docs = compression_retriever.invoke(    \"What did the president say about Ketanji Jackson Brown\")pretty_print_docs(compressed_docs)\n```\n\n```\nDocument 1:Tonight. I call on the Senate to: Pass the Freedom to Vote Act. Pass the John Lewis Voting Rights Act. And while you’re at it, pass the Disclose Act so Americans can know who is funding our elections. Tonight, I’d like to honor someone who has dedicated his life to serve this country: Justice Stephen Breyer—an Army veteran, Constitutional scholar, and retiring Justice of the United States Supreme Court. Justice Breyer, thank you for your service. One of the most serious constitutional responsibilities a President has is nominating someone to serve on the United States Supreme Court. And I did that 4 days ago, when I nominated Circuit Court of Appeals Judge Ketanji Brown Jackson. One of our nation’s top legal minds, who will continue Justice Breyer’s legacy of excellence.\n```\n\n### `LLMListwiseRerank`[​](#llmlistwisererank \"Direct link to llmlistwisererank\")\n\n[LLMListwiseRerank](https://python.langchain.com/api_reference/langchain/retrievers/langchain.retrievers.document_compressors.listwise_rerank.LLMListwiseRerank.html) uses [zero-shot listwise document reranking](https://arxiv.org/pdf/2305.02156) and functions similarly to `LLMChainFilter` as a robust but more expensive option. It is recommended to use a more powerful LLM.\n\nNote that `LLMListwiseRerank` requires a model with the [with\\_structured\\_output](https://python.langchain.com/docs/integrations/chat/) method implemented.\n\n```\nfrom langchain.retrievers.document_compressors import LLMListwiseRerankfrom langchain_openai import ChatOpenAIllm = ChatOpenAI(model=\"gpt-4o-mini\", temperature=0)_filter = LLMListwiseRerank.from_llm(llm, top_n=1)compression_retriever = ContextualCompressionRetriever(    base_compressor=_filter, base_retriever=retriever)compressed_docs = compression_retriever.invoke(    \"What did the president say about Ketanji Jackson Brown\")pretty_print_docs(compressed_docs)\n```\n\n```\nDocument 1:Tonight. I call on the Senate to: Pass the Freedom to Vote Act. Pass the John Lewis Voting Rights Act. And while you’re at it, pass the Disclose Act so Americans can know who is funding our elections. Tonight, I’d like to honor someone who has dedicated his life to serve this country: Justice Stephen Breyer—an Army veteran, Constitutional scholar, and retiring Justice of the United States Supreme Court. Justice Breyer, thank you for your service. One of the most serious constitutional responsibilities a President has is nominating someone to serve on the United States Supreme Court. And I did that 4 days ago, when I nominated Circuit Court of Appeals Judge Ketanji Brown Jackson. One of our nation’s top legal minds, who will continue Justice Breyer’s legacy of excellence.\n```\n\n### `EmbeddingsFilter`[​](#embeddingsfilter \"Direct link to embeddingsfilter\")\n\nMaking an extra LLM call over each retrieved document is expensive and slow. The `EmbeddingsFilter` provides a cheaper and faster option by embedding the documents and query and only returning those documents which have sufficiently similar embeddings to the query.\n\n```\nfrom langchain.retrievers.document_compressors import EmbeddingsFilterfrom langchain_openai import OpenAIEmbeddingsembeddings = OpenAIEmbeddings()embeddings_filter = EmbeddingsFilter(embeddings=embeddings, similarity_threshold=0.76)compression_retriever = ContextualCompressionRetriever(    base_compressor=embeddings_filter, base_retriever=retriever)compressed_docs = compression_retriever.invoke(    \"What did the president say about Ketanji Jackson Brown\")pretty_print_docs(compressed_docs)\n```\n\n```\nDocument 1:Tonight. I call on the Senate to: Pass the Freedom to Vote Act. Pass the John Lewis Voting Rights Act. And while you’re at it, pass the Disclose Act so Americans can know who is funding our elections. Tonight, I’d like to honor someone who has dedicated his life to serve this country: Justice Stephen Breyer—an Army veteran, Constitutional scholar, and retiring Justice of the United States Supreme Court. Justice Breyer, thank you for your service. One of the most serious constitutional responsibilities a President has is nominating someone to serve on the United States Supreme Court. And I did that 4 days ago, when I nominated Circuit Court of Appeals Judge Ketanji Brown Jackson. One of our nation’s top legal minds, who will continue Justice Breyer’s legacy of excellence.----------------------------------------------------------------------------------------------------Document 2:A former top litigator in private practice. A former federal public defender. And from a family of public school educators and police officers. A consensus builder. Since she’s been nominated, she’s received a broad range of support—from the Fraternal Order of Police to former judges appointed by Democrats and Republicans. And if we are to advance liberty and justice, we need to secure the Border and fix the immigration system. We can do both. At our border, we’ve installed new technology like cutting-edge scanners to better detect drug smuggling.  We’ve set up joint patrols with Mexico and Guatemala to catch more human traffickers.  We’re putting in place dedicated immigration judges so families fleeing persecution and violence can have their cases heard faster. We’re securing commitments and supporting partners in South and Central America to host more refugees and secure their own borders.\n```\n\n## Stringing compressors and document transformers together[​](#stringing-compressors-and-document-transformers-together \"Direct link to Stringing compressors and document transformers together\")\n\nUsing the `DocumentCompressorPipeline` we can also easily combine multiple compressors in sequence. Along with compressors we can add `BaseDocumentTransformer`s to our pipeline, which don't perform any contextual compression but simply perform some transformation on a set of documents. For example `TextSplitter`s can be used as document transformers to split documents into smaller pieces, and the `EmbeddingsRedundantFilter` can be used to filter out redundant documents based on embedding similarity between documents.\n\nBelow we create a compressor pipeline by first splitting our docs into smaller chunks, then removing redundant documents, and then filtering based on relevance to the query.\n\n```\nfrom langchain.retrievers.document_compressors import DocumentCompressorPipelinefrom langchain_community.document_transformers import EmbeddingsRedundantFilterfrom langchain_text_splitters import CharacterTextSplittersplitter = CharacterTextSplitter(chunk_size=300, chunk_overlap=0, separator=\". \")redundant_filter = EmbeddingsRedundantFilter(embeddings=embeddings)relevant_filter = EmbeddingsFilter(embeddings=embeddings, similarity_threshold=0.76)pipeline_compressor = DocumentCompressorPipeline(    transformers=[splitter, redundant_filter, relevant_filter])\n```\n\n```\ncompression_retriever = ContextualCompressionRetriever(    base_compressor=pipeline_compressor, base_retriever=retriever)compressed_docs = compression_retriever.invoke(    \"What did the president say about Ketanji Jackson Brown\")pretty_print_docs(compressed_docs)\n```\n\n```\nDocument 1:One of the most serious constitutional responsibilities a President has is nominating someone to serve on the United States Supreme Court. And I did that 4 days ago, when I nominated Circuit Court of Appeals Judge Ketanji Brown Jackson----------------------------------------------------------------------------------------------------Document 2:As I said last year, especially to our younger transgender Americans, I will always have your back as your President, so you can be yourself and reach your God-given potential. While it often appears that we never agree, that isn’t true. I signed 80 bipartisan bills into law last year----------------------------------------------------------------------------------------------------Document 3:A former top litigator in private practice. A former federal public defender. And from a family of public school educators and police officers. A consensus builder----------------------------------------------------------------------------------------------------Document 4:Since she’s been nominated, she’s received a broad range of support—from the Fraternal Order of Police to former judges appointed by Democrats and Republicans. And if we are to advance liberty and justice, we need to secure the Border and fix the immigration system. We can do both\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/convert_runnable_to_tool/",
  "markdown": "# giscus\n\n## How to convert Runnables to Tools\n\nHere we will demonstrate how to convert a LangChain `Runnable` into a tool that can be used by agents, chains, or chat models.\n\n## Dependencies[​](#dependencies \"Direct link to Dependencies\")\n\n**Note**: this guide requires `langchain-core` >= 0.2.13. We will also use [OpenAI](https://python.langchain.com/docs/integrations/providers/openai/) for embeddings, but any LangChain embeddings should suffice. We will use a simple [LangGraph](https://langchain-ai.github.io/langgraph/) agent for demonstration purposes.\n\n```\n%%capture --no-stderr%pip install -U langchain-core langchain-openai langgraph\n```\n\nLangChain [tools](https://python.langchain.com/docs/concepts/tools/) are interfaces that an agent, chain, or chat model can use to interact with the world. See [here](https://python.langchain.com/docs/how_to/#tools) for how-to guides covering tool-calling, built-in tools, custom tools, and more information.\n\nLangChain tools-- instances of [BaseTool](https://python.langchain.com/api_reference/core/tools/langchain_core.tools.BaseTool.html)\\-- are [Runnables](https://python.langchain.com/docs/concepts/runnables/) with additional constraints that enable them to be invoked effectively by language models:\n\n*   Their inputs are constrained to be serializable, specifically strings and Python `dict` objects;\n*   They contain names and descriptions indicating how and when they should be used;\n*   They may contain a detailed [args\\_schema](https://python.langchain.com/docs/how_to/custom_tools/) for their arguments. That is, while a tool (as a `Runnable`) might accept a single `dict` input, the specific keys and type information needed to populate a dict should be specified in the `args_schema`.\n\nRunnables that accept string or `dict` input can be converted to tools using the [as\\_tool](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.as_tool) method, which allows for the specification of names, descriptions, and additional schema information for arguments.\n\n## Basic usage[​](#basic-usage \"Direct link to Basic usage\")\n\nWith typed `dict` input:\n\n```\nfrom typing import Listfrom langchain_core.runnables import RunnableLambdafrom typing_extensions import TypedDictclass Args(TypedDict):    a: int    b: List[int]def f(x: Args) -> str:    return str(x[\"a\"] * max(x[\"b\"]))runnable = RunnableLambda(f)as_tool = runnable.as_tool(    name=\"My tool\",    description=\"Explanation of when to use tool.\",)\n```\n\n```\nprint(as_tool.description)as_tool.args_schema.schema()\n```\n\n```\nExplanation of when to use tool.\n```\n\n```\n{'title': 'My tool', 'type': 'object', 'properties': {'a': {'title': 'A', 'type': 'integer'},  'b': {'title': 'B', 'type': 'array', 'items': {'type': 'integer'}}}, 'required': ['a', 'b']}\n```\n\n```\nas_tool.invoke({\"a\": 3, \"b\": [1, 2]})\n```\n\nWithout typing information, arg types can be specified via `arg_types`:\n\n```\nfrom typing import Any, Dictdef g(x: Dict[str, Any]) -> str:    return str(x[\"a\"] * max(x[\"b\"]))runnable = RunnableLambda(g)as_tool = runnable.as_tool(    name=\"My tool\",    description=\"Explanation of when to use tool.\",    arg_types={\"a\": int, \"b\": List[int]},)\n```\n\nAlternatively, the schema can be fully specified by directly passing the desired [args\\_schema](https://python.langchain.com/api_reference/core/tools/langchain_core.tools.BaseTool.html#langchain_core.tools.BaseTool.args_schema) for the tool:\n\n```\nfrom pydantic import BaseModel, Fieldclass GSchema(BaseModel):    \"\"\"Apply a function to an integer and list of integers.\"\"\"    a: int = Field(..., description=\"Integer\")    b: List[int] = Field(..., description=\"List of ints\")runnable = RunnableLambda(g)as_tool = runnable.as_tool(GSchema)\n```\n\nString input is also supported:\n\n```\ndef f(x: str) -> str:    return x + \"a\"def g(x: str) -> str:    return x + \"z\"runnable = RunnableLambda(f) | gas_tool = runnable.as_tool()\n```\n\n## In agents[​](#in-agents \"Direct link to In agents\")\n\nBelow we will incorporate LangChain Runnables as tools in an [agent](https://python.langchain.com/docs/concepts/agents/) application. We will demonstrate with:\n\n*   a document [retriever](https://python.langchain.com/docs/concepts/retrievers/);\n*   a simple [RAG](https://python.langchain.com/docs/tutorials/rag/) chain, allowing an agent to delegate relevant queries to it.\n\nWe first instantiate a chat model that supports [tool calling](https://python.langchain.com/docs/how_to/tool_calling/):\n\n```\npip install -qU langchain-openai\n```\n\n```\nimport getpassimport osif not os.environ.get(\"OPENAI_API_KEY\"):  os.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"Enter API key for OpenAI: \")from langchain_openai import ChatOpenAIllm = ChatOpenAI(model=\"gpt-4o-mini\")\n```\n\nFollowing the [RAG tutorial](https://python.langchain.com/docs/tutorials/rag/), let's first construct a retriever:\n\n```\nfrom langchain_core.documents import Documentfrom langchain_core.vectorstores import InMemoryVectorStorefrom langchain_openai import OpenAIEmbeddingsdocuments = [    Document(        page_content=\"Dogs are great companions, known for their loyalty and friendliness.\",    ),    Document(        page_content=\"Cats are independent pets that often enjoy their own space.\",    ),]vectorstore = InMemoryVectorStore.from_documents(    documents, embedding=OpenAIEmbeddings())retriever = vectorstore.as_retriever(    search_type=\"similarity\",    search_kwargs={\"k\": 1},)\n```\n\nWe next create use a simple pre-built [LangGraph agent](https://python.langchain.com/docs/tutorials/agents/) and provide it the tool:\n\n```\nfrom langgraph.prebuilt import create_react_agenttools = [    retriever.as_tool(        name=\"pet_info_retriever\",        description=\"Get information about pets.\",    )]agent = create_react_agent(llm, tools)\n```\n\n```\nfor chunk in agent.stream({\"messages\": [(\"human\", \"What are dogs known for?\")]}):    print(chunk)    print(\"----\")\n```\n\n```\n{'agent': {'messages': [AIMessage(content='', additional_kwargs={'tool_calls': [{'id': 'call_W8cnfOjwqEn4cFcg19LN9mYD', 'function': {'arguments': '{\"__arg1\":\"dogs\"}', 'name': 'pet_info_retriever'}, 'type': 'function'}]}, response_metadata={'token_usage': {'completion_tokens': 19, 'prompt_tokens': 60, 'total_tokens': 79}, 'model_name': 'gpt-4o-mini', 'system_fingerprint': None, 'finish_reason': 'tool_calls', 'logprobs': None}, id='run-d7f81de9-1fb7-4caf-81ed-16dcdb0b2ab4-0', tool_calls=[{'name': 'pet_info_retriever', 'args': {'__arg1': 'dogs'}, 'id': 'call_W8cnfOjwqEn4cFcg19LN9mYD'}], usage_metadata={'input_tokens': 60, 'output_tokens': 19, 'total_tokens': 79})]}}----{'tools': {'messages': [ToolMessage(content=\"[Document(id='86f835fe-4bbe-4ec6-aeb4-489a8b541707', page_content='Dogs are great companions, known for their loyalty and friendliness.')]\", name='pet_info_retriever', tool_call_id='call_W8cnfOjwqEn4cFcg19LN9mYD')]}}----{'agent': {'messages': [AIMessage(content='Dogs are known for being great companions, known for their loyalty and friendliness.', response_metadata={'token_usage': {'completion_tokens': 18, 'prompt_tokens': 134, 'total_tokens': 152}, 'model_name': 'gpt-4o-mini', 'system_fingerprint': None, 'finish_reason': 'stop', 'logprobs': None}, id='run-9ca5847a-a5eb-44c0-a774-84cc2c5bbc5b-0', usage_metadata={'input_tokens': 134, 'output_tokens': 18, 'total_tokens': 152})]}}----\n```\n\nSee [LangSmith trace](https://smith.langchain.com/public/44e438e3-2faf-45bd-b397-5510fc145eb9/r) for the above run.\n\nGoing further, we can create a simple [RAG](https://python.langchain.com/docs/tutorials/rag/) chain that takes an additional parameter-- here, the \"style\" of the answer.\n\n```\nfrom operator import itemgetterfrom langchain_core.output_parsers import StrOutputParserfrom langchain_core.prompts import ChatPromptTemplatefrom langchain_core.runnables import RunnablePassthroughsystem_prompt = \"\"\"You are an assistant for question-answering tasks.Use the below context to answer the question. Ifyou don't know the answer, say you don't know.Use three sentences maximum and keep the answerconcise.Answer in the style of {answer_style}.Question: {question}Context: {context}\"\"\"prompt = ChatPromptTemplate.from_messages([(\"system\", system_prompt)])rag_chain = (    {        \"context\": itemgetter(\"question\") | retriever,        \"question\": itemgetter(\"question\"),        \"answer_style\": itemgetter(\"answer_style\"),    }    | prompt    | llm    | StrOutputParser())\n```\n\nNote that the input schema for our chain contains the required arguments, so it converts to a tool without further specification:\n\n```\nrag_chain.input_schema.schema()\n```\n\n```\n{'title': 'RunnableParallel<context,question,answer_style>Input', 'type': 'object', 'properties': {'question': {'title': 'Question'},  'answer_style': {'title': 'Answer Style'}}}\n```\n\n```\nrag_tool = rag_chain.as_tool(    name=\"pet_expert\",    description=\"Get information about pets.\",)\n```\n\nBelow we again invoke the agent. Note that the agent populates the required parameters in its `tool_calls`:\n\n```\nagent = create_react_agent(llm, [rag_tool])for chunk in agent.stream(    {\"messages\": [(\"human\", \"What would a pirate say dogs are known for?\")]}):    print(chunk)    print(\"----\")\n```\n\n```\n{'agent': {'messages': [AIMessage(content='', additional_kwargs={'tool_calls': [{'id': 'call_17iLPWvOD23zqwd1QVQ00Y63', 'function': {'arguments': '{\"question\":\"What are dogs known for according to pirates?\",\"answer_style\":\"quote\"}', 'name': 'pet_expert'}, 'type': 'function'}]}, response_metadata={'token_usage': {'completion_tokens': 28, 'prompt_tokens': 59, 'total_tokens': 87}, 'model_name': 'gpt-4o-mini', 'system_fingerprint': None, 'finish_reason': 'tool_calls', 'logprobs': None}, id='run-7fef44f3-7bba-4e63-8c51-2ad9c5e65e2e-0', tool_calls=[{'name': 'pet_expert', 'args': {'question': 'What are dogs known for according to pirates?', 'answer_style': 'quote'}, 'id': 'call_17iLPWvOD23zqwd1QVQ00Y63'}], usage_metadata={'input_tokens': 59, 'output_tokens': 28, 'total_tokens': 87})]}}----{'tools': {'messages': [ToolMessage(content='\"Dogs are known for their loyalty and friendliness, making them great companions for pirates on long sea voyages.\"', name='pet_expert', tool_call_id='call_17iLPWvOD23zqwd1QVQ00Y63')]}}----{'agent': {'messages': [AIMessage(content='According to pirates, dogs are known for their loyalty and friendliness, making them great companions for pirates on long sea voyages.', response_metadata={'token_usage': {'completion_tokens': 27, 'prompt_tokens': 119, 'total_tokens': 146}, 'model_name': 'gpt-4o-mini', 'system_fingerprint': None, 'finish_reason': 'stop', 'logprobs': None}, id='run-5a30edc3-7be0-4743-b980-ca2f8cad9b8d-0', usage_metadata={'input_tokens': 119, 'output_tokens': 27, 'total_tokens': 146})]}}----\n```\n\nSee [LangSmith trace](https://smith.langchain.com/public/147ae4e6-4dfb-4dd9-8ca0-5c5b954f08ac/r) for the above run."
},
{
  "url": "https://python.langchain.com/docs/how_to/output_parser_xml/",
  "markdown": "# giscus\n\n[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/langchain-ai/langchain/blob/master/docs/docs/how_to/output_parser_xml.ipynb)[![Open on GitHub](https://img.shields.io/badge/Open%20on%20GitHub-grey?logo=github&logoColor=white)](https://github.com/langchain-ai/langchain/blob/master/docs/docs/how_to/output_parser_xml.ipynb)\n\n## How to parse XML output\n\nLLMs from different providers often have different strengths depending on the specific data they are trained on. This also means that some may be \"better\" and more reliable at generating output in formats other than JSON.\n\nThis guide shows you how to use the [`XMLOutputParser`](https://python.langchain.com/api_reference/core/output_parsers/langchain_core.output_parsers.xml.XMLOutputParser.html) to prompt models for XML output, then and [parse](https://python.langchain.com/docs/concepts/output_parsers/) that output into a usable format.\n\nnote\n\nKeep in mind that large language models are leaky abstractions! You'll have to use an LLM with sufficient capacity to generate well-formed XML.\n\nIn the following examples, we use Anthropic's Claude-2 model ([https://docs.anthropic.com/claude/docs](https://docs.anthropic.com/claude/docs)), which is one such model that is optimized for XML tags.\n\n```\n%pip install -qU langchain langchain-anthropicimport osfrom getpass import getpassif \"ANTHROPIC_API_KEY\" not in os.environ:    os.environ[\"ANTHROPIC_API_KEY\"] = getpass()\n```\n\nLet's start with a simple request to the model.\n\n```\nfrom langchain_anthropic import ChatAnthropicfrom langchain_core.output_parsers import XMLOutputParserfrom langchain_core.prompts import PromptTemplatemodel = ChatAnthropic(model=\"claude-2.1\", max_tokens_to_sample=512, temperature=0.1)actor_query = \"Generate the shortened filmography for Tom Hanks.\"output = model.invoke(    f\"\"\"{actor_query}Please enclose the movies in <movie></movie> tags\"\"\")print(output.content)\n```\n\n```\nHere is the shortened filmography for Tom Hanks, with movies enclosed in XML tags:<movie>Splash</movie><movie>Big</movie><movie>A League of Their Own</movie><movie>Sleepless in Seattle</movie><movie>Forrest Gump</movie><movie>Toy Story</movie><movie>Apollo 13</movie><movie>Saving Private Ryan</movie><movie>Cast Away</movie><movie>The Da Vinci Code</movie>\n```\n\nThis actually worked pretty well! But it would be nice to parse that XML into a more easily usable format. We can use the `XMLOutputParser` to both add default format instructions to the prompt and parse outputted XML into a dict:\n\n```\nparser = XMLOutputParser()# We will add these instructions to the prompt belowparser.get_format_instructions()\n```\n\n```\n'The output should be formatted as a XML file.\\n1. Output should conform to the tags below. \\n2. If tags are not given, make them on your own.\\n3. Remember to always open and close all the tags.\\n\\nAs an example, for the tags [\"foo\", \"bar\", \"baz\"]:\\n1. String \"<foo>\\n   <bar>\\n      <baz></baz>\\n   </bar>\\n</foo>\" is a well-formatted instance of the schema. \\n2. String \"<foo>\\n   <bar>\\n   </foo>\" is a badly-formatted instance.\\n3. String \"<foo>\\n   <tag>\\n   </tag>\\n</foo>\" is a badly-formatted instance.\\n\\nHere are the output tags:\\n\\`\\`\\`\\nNone\\n\\`\\`\\`'\n```\n\n```\nprompt = PromptTemplate(    template=\"\"\"{query}\\n{format_instructions}\"\"\",    input_variables=[\"query\"],    partial_variables={\"format_instructions\": parser.get_format_instructions()},)chain = prompt | model | parseroutput = chain.invoke({\"query\": actor_query})print(output)\n```\n\n```\n{'filmography': [{'movie': [{'title': 'Big'}, {'year': '1988'}]}, {'movie': [{'title': 'Forrest Gump'}, {'year': '1994'}]}, {'movie': [{'title': 'Toy Story'}, {'year': '1995'}]}, {'movie': [{'title': 'Saving Private Ryan'}, {'year': '1998'}]}, {'movie': [{'title': 'Cast Away'}, {'year': '2000'}]}]}\n```\n\nWe can also add some tags to tailor the output to our needs. You can and should experiment with adding your own formatting hints in the other parts of your prompt to either augment or replace the default instructions:\n\n```\nparser = XMLOutputParser(tags=[\"movies\", \"actor\", \"film\", \"name\", \"genre\"])# We will add these instructions to the prompt belowparser.get_format_instructions()\n```\n\n```\n'The output should be formatted as a XML file.\\n1. Output should conform to the tags below. \\n2. If tags are not given, make them on your own.\\n3. Remember to always open and close all the tags.\\n\\nAs an example, for the tags [\"foo\", \"bar\", \"baz\"]:\\n1. String \"<foo>\\n   <bar>\\n      <baz></baz>\\n   </bar>\\n</foo>\" is a well-formatted instance of the schema. \\n2. String \"<foo>\\n   <bar>\\n   </foo>\" is a badly-formatted instance.\\n3. String \"<foo>\\n   <tag>\\n   </tag>\\n</foo>\" is a badly-formatted instance.\\n\\nHere are the output tags:\\n\\`\\`\\`\\n[\\'movies\\', \\'actor\\', \\'film\\', \\'name\\', \\'genre\\']\\n\\`\\`\\`'\n```\n\n```\nprompt = PromptTemplate(    template=\"\"\"{query}\\n{format_instructions}\"\"\",    input_variables=[\"query\"],    partial_variables={\"format_instructions\": parser.get_format_instructions()},)chain = prompt | model | parseroutput = chain.invoke({\"query\": actor_query})print(output)\n```\n\n```\n{'movies': [{'actor': [{'name': 'Tom Hanks'}, {'film': [{'name': 'Forrest Gump'}, {'genre': 'Drama'}]}, {'film': [{'name': 'Cast Away'}, {'genre': 'Adventure'}]}, {'film': [{'name': 'Saving Private Ryan'}, {'genre': 'War'}]}]}]}\n```\n\nThis output parser also supports streaming of partial chunks. Here's an example:\n\n```\nfor s in chain.stream({\"query\": actor_query}):    print(s)\n```\n\n```\n{'movies': [{'actor': [{'name': 'Tom Hanks'}]}]}{'movies': [{'actor': [{'film': [{'name': 'Forrest Gump'}]}]}]}{'movies': [{'actor': [{'film': [{'genre': 'Drama'}]}]}]}{'movies': [{'actor': [{'film': [{'name': 'Cast Away'}]}]}]}{'movies': [{'actor': [{'film': [{'genre': 'Adventure'}]}]}]}{'movies': [{'actor': [{'film': [{'name': 'Saving Private Ryan'}]}]}]}{'movies': [{'actor': [{'film': [{'genre': 'War'}]}]}]}\n```\n\n## Next steps[​](#next-steps \"Direct link to Next steps\")\n\nYou've now learned how to prompt a model to return XML. Next, check out the [broader guide on obtaining structured output](https://python.langchain.com/docs/how_to/structured_output/) for other related techniques."
},
{
  "url": "https://python.langchain.com/docs/how_to/graph_constructing/",
  "markdown": "# giscus\n\n## How to construct knowledge graphs\n\nIn this guide we'll go over the basic ways of constructing a knowledge graph based on unstructured text. The constructured graph can then be used as knowledge base in a [RAG](https://python.langchain.com/docs/concepts/rag/) application.\n\n## ⚠️ Security note ⚠️[​](#️-security-note-️ \"Direct link to ⚠️ Security note ⚠️\")\n\nConstructing knowledge graphs requires executing write access to the database. There are inherent risks in doing this. Make sure that you verify and validate data before importing it. For more on general security best practices, [see here](https://python.langchain.com/docs/security/).\n\n## Architecture[​](#architecture \"Direct link to Architecture\")\n\nAt a high-level, the steps of constructing a knowledge graph from text are:\n\n1.  **Extracting structured information from text**: Model is used to extract structured graph information from text.\n2.  **Storing into graph database**: Storing the extracted structured graph information into a graph database enables downstream RAG applications\n\n## Setup[​](#setup \"Direct link to Setup\")\n\nFirst, get required packages and set environment variables. In this example, we will be using Neo4j graph database.\n\n```\n%pip install --upgrade --quiet  langchain langchain-neo4j langchain-openai langchain-experimental neo4j\n```\n\n```\n\u001b[1m[\u001b[0m\u001b[34;49mnotice\u001b[0m\u001b[1;39;49m]\u001b[0m\u001b[39;49m A new release of pip is available: \u001b[0m\u001b[31;49m24.0\u001b[0m\u001b[39;49m -> \u001b[0m\u001b[32;49m24.3.1\u001b[0m\u001b[1m[\u001b[0m\u001b[34;49mnotice\u001b[0m\u001b[1;39;49m]\u001b[0m\u001b[39;49m To update, run: \u001b[0m\u001b[32;49mpip install --upgrade pip\u001b[0mNote: you may need to restart the kernel to use updated packages.\n```\n\nWe default to OpenAI models in this guide.\n\n```\nimport getpassimport osos.environ[\"OPENAI_API_KEY\"] = getpass.getpass()# Uncomment the below to use LangSmith. Not required.# os.environ[\"LANGCHAIN_API_KEY\"] = getpass.getpass()# os.environ[\"LANGCHAIN_TRACING_V2\"] = \"true\"\n```\n\nNext, we need to define Neo4j credentials and connection. Follow [these installation steps](https://neo4j.com/docs/operations-manual/current/installation/) to set up a Neo4j database.\n\n```\nimport osfrom langchain_neo4j import Neo4jGraphos.environ[\"NEO4J_URI\"] = \"bolt://localhost:7687\"os.environ[\"NEO4J_USERNAME\"] = \"neo4j\"os.environ[\"NEO4J_PASSWORD\"] = \"password\"graph = Neo4jGraph(refresh_schema=False)\n```\n\n## LLM Graph Transformer[​](#llm-graph-transformer \"Direct link to LLM Graph Transformer\")\n\nExtracting graph data from text enables the transformation of unstructured information into structured formats, facilitating deeper insights and more efficient navigation through complex relationships and patterns. The `LLMGraphTransformer` converts text documents into structured graph documents by leveraging a LLM to parse and categorize entities and their relationships. The selection of the LLM model significantly influences the output by determining the accuracy and nuance of the extracted graph data.\n\n```\nimport osfrom langchain_experimental.graph_transformers import LLMGraphTransformerfrom langchain_openai import ChatOpenAIllm = ChatOpenAI(temperature=0, model_name=\"gpt-4-turbo\")llm_transformer = LLMGraphTransformer(llm=llm)\n```\n\nNow we can pass in example text and examine the results.\n\n```\nfrom langchain_core.documents import Documenttext = \"\"\"Marie Curie, born in 1867, was a Polish and naturalised-French physicist and chemist who conducted pioneering research on radioactivity.She was the first woman to win a Nobel Prize, the first person to win a Nobel Prize twice, and the only person to win a Nobel Prize in two scientific fields.Her husband, Pierre Curie, was a co-winner of her first Nobel Prize, making them the first-ever married couple to win the Nobel Prize and launching the Curie family legacy of five Nobel Prizes.She was, in 1906, the first woman to become a professor at the University of Paris.\"\"\"documents = [Document(page_content=text)]graph_documents = llm_transformer.convert_to_graph_documents(documents)print(f\"Nodes:{graph_documents[0].nodes}\")print(f\"Relationships:{graph_documents[0].relationships}\")\n```\n\n```\nNodes:[Node(id='Marie Curie', type='Person', properties={}), Node(id='Pierre Curie', type='Person', properties={}), Node(id='University Of Paris', type='Organization', properties={})]Relationships:[Relationship(source=Node(id='Marie Curie', type='Person', properties={}), target=Node(id='Pierre Curie', type='Person', properties={}), type='MARRIED', properties={}), Relationship(source=Node(id='Marie Curie', type='Person', properties={}), target=Node(id='University Of Paris', type='Organization', properties={}), type='PROFESSOR', properties={})]\n```\n\nExamine the following image to better grasp the structure of the generated knowledge graph.\n\n![graph_construction1.png](https://python.langchain.com/assets/images/graph_construction1-2b4d31978d58696d5a6a52ad92ae088f.png)\n\nNote that the graph construction process is non-deterministic since we are using LLM. Therefore, you might get slightly different results on each execution.\n\nAdditionally, you have the flexibility to define specific types of nodes and relationships for extraction according to your requirements.\n\n```\nllm_transformer_filtered = LLMGraphTransformer(    llm=llm,    allowed_nodes=[\"Person\", \"Country\", \"Organization\"],    allowed_relationships=[\"NATIONALITY\", \"LOCATED_IN\", \"WORKED_AT\", \"SPOUSE\"],)graph_documents_filtered = llm_transformer_filtered.convert_to_graph_documents(    documents)print(f\"Nodes:{graph_documents_filtered[0].nodes}\")print(f\"Relationships:{graph_documents_filtered[0].relationships}\")\n```\n\n```\nNodes:[Node(id='Marie Curie', type='Person', properties={}), Node(id='Pierre Curie', type='Person', properties={}), Node(id='University Of Paris', type='Organization', properties={})]Relationships:[Relationship(source=Node(id='Marie Curie', type='Person', properties={}), target=Node(id='Pierre Curie', type='Person', properties={}), type='SPOUSE', properties={}), Relationship(source=Node(id='Marie Curie', type='Person', properties={}), target=Node(id='University Of Paris', type='Organization', properties={}), type='WORKED_AT', properties={})]\n```\n\nTo define the graph schema more precisely, consider using a three-tuple approach for relationships. In this approach, each tuple consists of three elements: the source node, the relationship type, and the target node.\n\n```\nallowed_relationships = [    (\"Person\", \"SPOUSE\", \"Person\"),    (\"Person\", \"NATIONALITY\", \"Country\"),    (\"Person\", \"WORKED_AT\", \"Organization\"),]llm_transformer_tuple = LLMGraphTransformer(    llm=llm,    allowed_nodes=[\"Person\", \"Country\", \"Organization\"],    allowed_relationships=allowed_relationships,)graph_documents_filtered = llm_transformer_tuple.convert_to_graph_documents(documents)print(f\"Nodes:{graph_documents_filtered[0].nodes}\")print(f\"Relationships:{graph_documents_filtered[0].relationships}\")\n```\n\n```\nNodes:[Node(id='Marie Curie', type='Person', properties={}), Node(id='Pierre Curie', type='Person', properties={}), Node(id='University Of Paris', type='Organization', properties={})]Relationships:[Relationship(source=Node(id='Marie Curie', type='Person', properties={}), target=Node(id='Pierre Curie', type='Person', properties={}), type='SPOUSE', properties={}), Relationship(source=Node(id='Marie Curie', type='Person', properties={}), target=Node(id='University Of Paris', type='Organization', properties={}), type='WORKED_AT', properties={})]\n```\n\nFor a better understanding of the generated graph, we can again visualize it.\n\n![graph_construction2.png](https://python.langchain.com/assets/images/graph_construction2-8b43506ae0fb3a006eaa4ba83fea8af5.png)\n\nThe `node_properties` parameter enables the extraction of node properties, allowing the creation of a more detailed graph. When set to `True`, LLM autonomously identifies and extracts relevant node properties. Conversely, if `node_properties` is defined as a list of strings, the LLM selectively retrieves only the specified properties from the text.\n\n```\nllm_transformer_props = LLMGraphTransformer(    llm=llm,    allowed_nodes=[\"Person\", \"Country\", \"Organization\"],    allowed_relationships=[\"NATIONALITY\", \"LOCATED_IN\", \"WORKED_AT\", \"SPOUSE\"],    node_properties=[\"born_year\"],)graph_documents_props = llm_transformer_props.convert_to_graph_documents(documents)print(f\"Nodes:{graph_documents_props[0].nodes}\")print(f\"Relationships:{graph_documents_props[0].relationships}\")\n```\n\n```\nNodes:[Node(id='Marie Curie', type='Person', properties={'born_year': '1867'}), Node(id='Pierre Curie', type='Person', properties={}), Node(id='University Of Paris', type='Organization', properties={}), Node(id='Poland', type='Country', properties={}), Node(id='France', type='Country', properties={})]Relationships:[Relationship(source=Node(id='Marie Curie', type='Person', properties={}), target=Node(id='Poland', type='Country', properties={}), type='NATIONALITY', properties={}), Relationship(source=Node(id='Marie Curie', type='Person', properties={}), target=Node(id='France', type='Country', properties={}), type='NATIONALITY', properties={}), Relationship(source=Node(id='Marie Curie', type='Person', properties={}), target=Node(id='Pierre Curie', type='Person', properties={}), type='SPOUSE', properties={}), Relationship(source=Node(id='Marie Curie', type='Person', properties={}), target=Node(id='University Of Paris', type='Organization', properties={}), type='WORKED_AT', properties={})]\n```\n\n## Storing to graph database[​](#storing-to-graph-database \"Direct link to Storing to graph database\")\n\nThe generated graph documents can be stored to a graph database using the `add_graph_documents` method.\n\n```\ngraph.add_graph_documents(graph_documents_props)\n```\n\nMost graph databases support indexes to optimize data import and retrieval. Since we might not know all the node labels in advance, we can handle this by adding a secondary base label to each node using the `baseEntityLabel` parameter.\n\n```\ngraph.add_graph_documents(graph_documents, baseEntityLabel=True)\n```\n\nResults will look like:\n\n![graph_construction3.png](https://python.langchain.com/assets/images/graph_construction3-86cbbef451d33d8b6fa50c2d79af6103.png)\n\nThe final option is to also import the source documents for the extracted nodes and relationships. This approach lets us track which documents each entity appeared in.\n\n```\ngraph.add_graph_documents(graph_documents, include_source=True)\n```\n\nGraph will have the following structure:\n\n![graph_construction4.png](https://python.langchain.com/assets/images/graph_construction4-e41087302ef4c331c2c95b57467f4c62.png)\n\nIn this visualization, the source document is highlighted in blue, with all entities extracted from it connected by `MENTIONS` relationships."
},
{
  "url": "https://python.langchain.com/docs/how_to/custom_callbacks/",
  "markdown": "# giscus\n\nLangChain has some built-in callback handlers, but you will often want to create your own handlers with custom logic.\n\nTo create a custom callback handler, we need to determine the [event(s)](https://python.langchain.com/api_reference/core/callbacks/langchain_core.callbacks.base.BaseCallbackHandler.html#langchain-core-callbacks-base-basecallbackhandler) we want our callback handler to handle as well as what we want our callback handler to do when the event is triggered. Then all we need to do is attach the callback handler to the object, for example via [the constructor](https://python.langchain.com/docs/how_to/callbacks_constructor/) or [at runtime](https://python.langchain.com/docs/how_to/callbacks_runtime/).\n\nIn the example below, we'll implement streaming with a custom handler.\n\nIn our custom callback handler `MyCustomHandler`, we implement the `on_llm_new_token` handler to print the token we have just received. We then attach our custom handler to the model object as a constructor callback.\n\n```\nfrom langchain_anthropic import ChatAnthropicfrom langchain_core.callbacks import BaseCallbackHandlerfrom langchain_core.prompts import ChatPromptTemplateclass MyCustomHandler(BaseCallbackHandler):    def on_llm_new_token(self, token: str, **kwargs) -> None:        print(f\"My custom handler, token: {token}\")prompt = ChatPromptTemplate.from_messages([\"Tell me a joke about {animal}\"])# To enable streaming, we pass in `streaming=True` to the ChatModel constructor# Additionally, we pass in our custom handler as a list to the callbacks parametermodel = ChatAnthropic(    model=\"claude-3-sonnet-20240229\", streaming=True, callbacks=[MyCustomHandler()])chain = prompt | modelresponse = chain.invoke({\"animal\": \"bears\"})\n```\n\n```\nMy custom handler, token: HereMy custom handler, token: 'sMy custom handler, token:  aMy custom handler, token:  bearMy custom handler, token:  jokeMy custom handler, token:  forMy custom handler, token:  youMy custom handler, token: :My custom handler, token: WhyMy custom handler, token:  diMy custom handler, token: d theMy custom handler, token:  bearMy custom handler, token:  dissolMy custom handler, token: veMy custom handler, token:  inMy custom handler, token:  waterMy custom handler, token: ?My custom handler, token: BecauseMy custom handler, token:  itMy custom handler, token:  wasMy custom handler, token:  aMy custom handler, token:  polarMy custom handler, token:  bearMy custom handler, token: !\n```\n\nYou can see [this reference page](https://python.langchain.com/api_reference/core/callbacks/langchain_core.callbacks.base.BaseCallbackHandler.html#langchain-core-callbacks-base-basecallbackhandler) for a list of events you can handle. Note that the `handle_chain_*` events run for most LCEL runnables.\n\nYou've now learned how to create your own custom callback handlers."
},
{
  "url": "https://python.langchain.com/docs/how_to/output_parser_yaml/",
  "markdown": "# giscus\n\n## How to parse YAML output\n\nLLMs from different providers often have different strengths depending on the specific data they are trained on. This also means that some may be \"better\" and more reliable at generating output in formats other than JSON.\n\nThis output parser allows users to specify an arbitrary schema and query LLMs for outputs that conform to that schema, using YAML to format their response.\n\nnote\n\nKeep in mind that large language models are leaky abstractions! You'll have to use an LLM with sufficient capacity to generate well-formed YAML.\n\n```\n%pip install -qU langchain langchain-openaiimport osfrom getpass import getpassif \"OPENAI_API_KEY\" not in os.environ:    os.environ[\"OPENAI_API_KEY\"] = getpass()\n```\n\nWe use [Pydantic](https://docs.pydantic.dev/) with the [`YamlOutputParser`](https://python.langchain.com/api_reference/langchain/output_parsers/langchain.output_parsers.yaml.YamlOutputParser.html#langchain.output_parsers.yaml.YamlOutputParser) to declare our data model and give the model more context as to what type of YAML it should generate:\n\n```\nfrom langchain.output_parsers import YamlOutputParserfrom langchain_core.prompts import PromptTemplatefrom langchain_openai import ChatOpenAIfrom pydantic import BaseModel, Field# Define your desired data structure.class Joke(BaseModel):    setup: str = Field(description=\"question to set up a joke\")    punchline: str = Field(description=\"answer to resolve the joke\")model = ChatOpenAI(temperature=0)# And a query intented to prompt a language model to populate the data structure.joke_query = \"Tell me a joke.\"# Set up a parser + inject instructions into the prompt template.parser = YamlOutputParser(pydantic_object=Joke)prompt = PromptTemplate(    template=\"Answer the user query.\\n{format_instructions}\\n{query}\\n\",    input_variables=[\"query\"],    partial_variables={\"format_instructions\": parser.get_format_instructions()},)chain = prompt | model | parserchain.invoke({\"query\": joke_query})\n```\n\n```\nJoke(setup=\"Why couldn't the bicycle find its way home?\", punchline='Because it lost its bearings!')\n```\n\nThe parser will automatically parse the output YAML and create a Pydantic model with the data. We can see the parser's `format_instructions`, which get added to the prompt:\n\n```\nparser.get_format_instructions()\n```\n\n```\n'The output should be formatted as a YAML instance that conforms to the given JSON schema below.\\n\\n# Examples\\n## Schema\\n\\`\\`\\`\\n{\"title\": \"Players\", \"description\": \"A list of players\", \"type\": \"array\", \"items\": {\"$ref\": \"#/definitions/Player\"}, \"definitions\": {\"Player\": {\"title\": \"Player\", \"type\": \"object\", \"properties\": {\"name\": {\"title\": \"Name\", \"description\": \"Player name\", \"type\": \"string\"}, \"avg\": {\"title\": \"Avg\", \"description\": \"Batting average\", \"type\": \"number\"}}, \"required\": [\"name\", \"avg\"]}}}\\n\\`\\`\\`\\n## Well formatted instance\\n\\`\\`\\`\\n- name: John Doe\\n  avg: 0.3\\n- name: Jane Maxfield\\n  avg: 1.4\\n\\`\\`\\`\\n\\n## Schema\\n\\`\\`\\`\\n{\"properties\": {\"habit\": { \"description\": \"A common daily habit\", \"type\": \"string\" }, \"sustainable_alternative\": { \"description\": \"An environmentally friendly alternative to the habit\", \"type\": \"string\"}}, \"required\": [\"habit\", \"sustainable_alternative\"]}\\n\\`\\`\\`\\n## Well formatted instance\\n\\`\\`\\`\\nhabit: Using disposable water bottles for daily hydration.\\nsustainable_alternative: Switch to a reusable water bottle to reduce plastic waste and decrease your environmental footprint.\\n\\`\\`\\` \\n\\nPlease follow the standard YAML formatting conventions with an indent of 2 spaces and make sure that the data types adhere strictly to the following JSON schema: \\n\\`\\`\\`\\n{\"properties\": {\"setup\": {\"title\": \"Setup\", \"description\": \"question to set up a joke\", \"type\": \"string\"}, \"punchline\": {\"title\": \"Punchline\", \"description\": \"answer to resolve the joke\", \"type\": \"string\"}}, \"required\": [\"setup\", \"punchline\"]}\\n\\`\\`\\`\\n\\nMake sure to always enclose the YAML output in triple backticks (\\`\\`\\`). Please do not add anything other than valid YAML output!'\n```\n\nYou can and should experiment with adding your own formatting hints in the other parts of your prompt to either augment or replace the default instructions.\n\n## Next steps[​](#next-steps \"Direct link to Next steps\")\n\nYou've now learned how to prompt a model to return XML. Next, check out the [broader guide on obtaining structured output](https://python.langchain.com/docs/how_to/structured_output/) for other related techniques."
},
{
  "url": "https://python.langchain.com/docs/how_to/parent_document_retriever/",
  "markdown": "# giscus\n\n## How to use the Parent Document Retriever\n\nWhen splitting documents for [retrieval](https://python.langchain.com/docs/concepts/retrieval/), there are often conflicting desires:\n\n1.  You may want to have small documents, so that their embeddings can most accurately reflect their meaning. If too long, then the embeddings can lose meaning.\n2.  You want to have long enough documents that the context of each chunk is retained.\n\nThe `ParentDocumentRetriever` strikes that balance by splitting and storing small chunks of data. During retrieval, it first fetches the small chunks but then looks up the parent ids for those chunks and returns those larger documents.\n\nNote that \"parent document\" refers to the document that a small chunk originated from. This can either be the whole raw document OR a larger chunk.\n\n```\nfrom langchain.retrievers import ParentDocumentRetriever\n```\n\n```\nfrom langchain.storage import InMemoryStorefrom langchain_chroma import Chromafrom langchain_community.document_loaders import TextLoaderfrom langchain_openai import OpenAIEmbeddingsfrom langchain_text_splitters import RecursiveCharacterTextSplitter\n```\n\n```\nloaders = [    TextLoader(\"paul_graham_essay.txt\"),    TextLoader(\"state_of_the_union.txt\"),]docs = []for loader in loaders:    docs.extend(loader.load())\n```\n\n## Retrieving full documents[​](#retrieving-full-documents \"Direct link to Retrieving full documents\")\n\nIn this mode, we want to retrieve the full documents. Therefore, we only specify a child [splitter](https://python.langchain.com/docs/concepts/text_splitters/).\n\n```\n# This text splitter is used to create the child documentschild_splitter = RecursiveCharacterTextSplitter(chunk_size=400)# The vectorstore to use to index the child chunksvectorstore = Chroma(    collection_name=\"full_documents\", embedding_function=OpenAIEmbeddings())# The storage layer for the parent documentsstore = InMemoryStore()retriever = ParentDocumentRetriever(    vectorstore=vectorstore,    docstore=store,    child_splitter=child_splitter,)\n```\n\n```\nretriever.add_documents(docs, ids=None)\n```\n\nThis should yield two keys, because we added two documents.\n\n```\n['9a63376c-58cc-42c9-b0f7-61f0e1a3a688', '40091598-e918-4a18-9be0-f46413a95ae4']\n```\n\nLet's now call the vector store search functionality - we should see that it returns small chunks (since we're storing the small chunks).\n\n```\nsub_docs = vectorstore.similarity_search(\"justice breyer\")\n```\n\n```\nprint(sub_docs[0].page_content)\n```\n\n```\nTonight, I’d like to honor someone who has dedicated his life to serve this country: Justice Stephen Breyer—an Army veteran, Constitutional scholar, and retiring Justice of the United States Supreme Court. Justice Breyer, thank you for your service. One of the most serious constitutional responsibilities a President has is nominating someone to serve on the United States Supreme Court.\n```\n\nLet's now retrieve from the overall retriever. This should return large documents - since it returns the documents where the smaller chunks are located.\n\n```\nretrieved_docs = retriever.invoke(\"justice breyer\")\n```\n\n```\nlen(retrieved_docs[0].page_content)\n```\n\n## Retrieving larger chunks[​](#retrieving-larger-chunks \"Direct link to Retrieving larger chunks\")\n\nSometimes, the full documents can be too big to want to retrieve them as is. In that case, what we really want to do is to first split the raw documents into larger chunks, and then split it into smaller chunks. We then index the smaller chunks, but on retrieval we retrieve the larger chunks (but still not the full documents).\n\n```\n# This text splitter is used to create the parent documentsparent_splitter = RecursiveCharacterTextSplitter(chunk_size=2000)# This text splitter is used to create the child documents# It should create documents smaller than the parentchild_splitter = RecursiveCharacterTextSplitter(chunk_size=400)# The vectorstore to use to index the child chunksvectorstore = Chroma(    collection_name=\"split_parents\", embedding_function=OpenAIEmbeddings())# The storage layer for the parent documentsstore = InMemoryStore()\n```\n\n```\nretriever = ParentDocumentRetriever(    vectorstore=vectorstore,    docstore=store,    child_splitter=child_splitter,    parent_splitter=parent_splitter,)\n```\n\n```\nretriever.add_documents(docs)\n```\n\nWe can see that there are much more than two documents now - these are the larger chunks.\n\n```\nlen(list(store.yield_keys()))\n```\n\nLet's make sure the underlying vector store still retrieves the small chunks.\n\n```\nsub_docs = vectorstore.similarity_search(\"justice breyer\")\n```\n\n```\nprint(sub_docs[0].page_content)\n```\n\n```\nTonight, I’d like to honor someone who has dedicated his life to serve this country: Justice Stephen Breyer—an Army veteran, Constitutional scholar, and retiring Justice of the United States Supreme Court. Justice Breyer, thank you for your service. One of the most serious constitutional responsibilities a President has is nominating someone to serve on the United States Supreme Court.\n```\n\n```\nretrieved_docs = retriever.invoke(\"justice breyer\")\n```\n\n```\nlen(retrieved_docs[0].page_content)\n```\n\n```\nprint(retrieved_docs[0].page_content)\n```\n\n```\nIn state after state, new laws have been passed, not only to suppress the vote, but to subvert entire elections. We cannot let this happen. Tonight. I call on the Senate to: Pass the Freedom to Vote Act. Pass the John Lewis Voting Rights Act. And while you’re at it, pass the Disclose Act so Americans can know who is funding our elections. Tonight, I’d like to honor someone who has dedicated his life to serve this country: Justice Stephen Breyer—an Army veteran, Constitutional scholar, and retiring Justice of the United States Supreme Court. Justice Breyer, thank you for your service. One of the most serious constitutional responsibilities a President has is nominating someone to serve on the United States Supreme Court. And I did that 4 days ago, when I nominated Circuit Court of Appeals Judge Ketanji Brown Jackson. One of our nation’s top legal minds, who will continue Justice Breyer’s legacy of excellence. A former top litigator in private practice. A former federal public defender. And from a family of public school educators and police officers. A consensus builder. Since she’s been nominated, she’s received a broad range of support—from the Fraternal Order of Police to former judges appointed by Democrats and Republicans. And if we are to advance liberty and justice, we need to secure the Border and fix the immigration system. We can do both. At our border, we’ve installed new technology like cutting-edge scanners to better detect drug smuggling.  We’ve set up joint patrols with Mexico and Guatemala to catch more human traffickers.  We’re putting in place dedicated immigration judges so families fleeing persecution and violence can have their cases heard faster. We’re securing commitments and supporting partners in South and Central America to host more refugees and secure their own borders.\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/prompts_partial/",
  "markdown": "# giscus\n\n## How to partially format prompt templates\n\nPrerequisites\n\nThis guide assumes familiarity with the following concepts:\n\n*   [Prompt templates](https://python.langchain.com/docs/concepts/prompt_templates/)\n\nLike partially binding arguments to a function, it can make sense to \"partial\" a [prompt template](https://python.langchain.com/docs/concepts/prompt_templates/) - e.g. pass in a subset of the required values, as to create a new prompt template which expects only the remaining subset of values.\n\nLangChain supports this in two ways:\n\n1.  Partial formatting with string values.\n2.  Partial formatting with functions that return string values.\n\nIn the examples below, we go over the motivations for both use cases as well as how to do it in LangChain.\n\n## Partial with strings[​](#partial-with-strings \"Direct link to Partial with strings\")\n\nOne common use case for wanting to partial a prompt template is if you get access to some of the variables in a prompt before others. For example, suppose you have a prompt template that requires two variables, `foo` and `baz`. If you get the `foo` value early on in your chain, but the `baz` value later, it can be inconvenient to pass both variables all the way through the chain. Instead, you can partial the prompt template with the `foo` value, and then pass the partialed prompt template along and just use that. Below is an example of doing this:\n\n```\nfrom langchain_core.prompts import PromptTemplateprompt = PromptTemplate.from_template(\"{foo}{bar}\")partial_prompt = prompt.partial(foo=\"foo\")print(partial_prompt.format(bar=\"baz\"))\n```\n\nYou can also just initialize the prompt with the partialed variables.\n\n```\nprompt = PromptTemplate(    template=\"{foo}{bar}\", input_variables=[\"bar\"], partial_variables={\"foo\": \"foo\"})print(prompt.format(bar=\"baz\"))\n```\n\n## Partial with functions[​](#partial-with-functions \"Direct link to Partial with functions\")\n\nThe other common use is to partial with a function. The use case for this is when you have a variable you know that you always want to fetch in a common way. A prime example of this is with date or time. Imagine you have a prompt which you always want to have the current date. You can't hard code it in the prompt, and passing it along with the other input variables is inconvenient. In this case, it's handy to be able to partial the prompt with a function that always returns the current date.\n\n```\nfrom datetime import datetimedef _get_datetime():    now = datetime.now()    return now.strftime(\"%m/%d/%Y, %H:%M:%S\")prompt = PromptTemplate(    template=\"Tell me a {adjective} joke about the day {date}\",    input_variables=[\"adjective\", \"date\"],)partial_prompt = prompt.partial(date=_get_datetime)print(partial_prompt.format(adjective=\"funny\"))\n```\n\n```\nTell me a funny joke about the day 04/21/2024, 19:43:57\n```\n\nYou can also just initialize the prompt with the partialed variables, which often makes more sense in this workflow.\n\n```\nprompt = PromptTemplate(    template=\"Tell me a {adjective} joke about the day {date}\",    input_variables=[\"adjective\"],    partial_variables={\"date\": _get_datetime},)print(prompt.format(adjective=\"funny\"))\n```\n\n```\nTell me a funny joke about the day 04/21/2024, 19:43:57\n```\n\n## Next steps[​](#next-steps \"Direct link to Next steps\")\n\nYou've now learned how to partially apply variables to your prompt templates.\n\nNext, check out the other how-to guides on prompt templates in this section, like [adding few-shot examples to your prompt templates](https://python.langchain.com/docs/how_to/few_shot_examples_chat/)."
},
{
  "url": "https://python.langchain.com/docs/how_to/custom_chat_model/",
  "markdown": "# giscus\n\n## How to create a custom chat model class\n\nPrerequisites\n\nThis guide assumes familiarity with the following concepts:\n\n*   [Chat models](https://python.langchain.com/docs/concepts/chat_models/)\n\nIn this guide, we'll learn how to create a custom [chat model](https://python.langchain.com/docs/concepts/chat_models/) using LangChain abstractions.\n\nWrapping your LLM with the standard [`BaseChatModel`](https://python.langchain.com/api_reference/core/language_models/langchain_core.language_models.chat_models.BaseChatModel.html) interface allow you to use your LLM in existing LangChain programs with minimal code modifications!\n\nAs an bonus, your LLM will automatically become a LangChain [Runnable](https://python.langchain.com/docs/concepts/runnables/) and will benefit from some optimizations out of the box (e.g., batch via a threadpool), async support, the `astream_events` API, etc.\n\n## Inputs and outputs[​](#inputs-and-outputs \"Direct link to Inputs and outputs\")\n\nFirst, we need to talk about **[messages](https://python.langchain.com/docs/concepts/messages/)**, which are the inputs and outputs of chat models.\n\n### Messages[​](#messages \"Direct link to Messages\")\n\nChat models take messages as inputs and return a message as output.\n\nLangChain has a few [built-in message types](https://python.langchain.com/docs/concepts/messages/):\n\n| Message Type | Description |\n| --- | --- |\n| `SystemMessage` | Used for priming AI behavior, usually passed in as the first of a sequence of input messages. |\n| `HumanMessage` | Represents a message from a person interacting with the chat model. |\n| `AIMessage` | Represents a message from the chat model. This can be either text or a request to invoke a tool. |\n| `FunctionMessage` / `ToolMessage` | Message for passing the results of tool invocation back to the model. |\n| `AIMessageChunk` / `HumanMessageChunk` / ... | Chunk variant of each type of message. |\n\nnote\n\n`ToolMessage` and `FunctionMessage` closely follow OpenAI's `function` and `tool` roles.\n\nThis is a rapidly developing field and as more models add function calling capabilities. Expect that there will be additions to this schema.\n\n```\nfrom langchain_core.messages import (    AIMessage,    BaseMessage,    FunctionMessage,    HumanMessage,    SystemMessage,    ToolMessage,)\n```\n\n### Streaming Variant[​](#streaming-variant \"Direct link to Streaming Variant\")\n\nAll the chat messages have a streaming variant that contains `Chunk` in the name.\n\n```\nfrom langchain_core.messages import (    AIMessageChunk,    FunctionMessageChunk,    HumanMessageChunk,    SystemMessageChunk,    ToolMessageChunk,)\n```\n\nThese chunks are used when streaming output from chat models, and they all define an additive property!\n\n```\nAIMessageChunk(content=\"Hello\") + AIMessageChunk(content=\" World!\")\n```\n\n```\nAIMessageChunk(content='Hello World!')\n```\n\n## Base Chat Model[​](#base-chat-model \"Direct link to Base Chat Model\")\n\nLet's implement a chat model that echoes back the first `n` characters of the last message in the prompt!\n\nTo do so, we will inherit from `BaseChatModel` and we'll need to implement the following:\n\n| Method/Property | Description | Required/Optional |\n| --- | --- | --- |\n| `_generate` | Use to generate a chat result from a prompt | Required |\n| `_llm_type` (property) | Used to uniquely identify the type of the model. Used for logging. | Required |\n| `_identifying_params` (property) | Represent model parameterization for tracing purposes. | Optional |\n| `_stream` | Use to implement streaming. | Optional |\n| `_agenerate` | Use to implement a native async method. | Optional |\n| `_astream` | Use to implement async version of `_stream`. | Optional |\n\ntip\n\nThe `_astream` implementation uses `run_in_executor` to launch the sync `_stream` in a separate thread if `_stream` is implemented, otherwise it fallsback to use `_agenerate`.\n\nYou can use this trick if you want to reuse the `_stream` implementation, but if you're able to implement code that's natively async that's a better solution since that code will run with less overhead.\n\n### Implementation[​](#implementation \"Direct link to Implementation\")\n\n```\nfrom typing import Any, Dict, Iterator, List, Optionalfrom langchain_core.callbacks import (    CallbackManagerForLLMRun,)from langchain_core.language_models import BaseChatModelfrom langchain_core.messages import (    AIMessage,    AIMessageChunk,    BaseMessage,)from langchain_core.messages.ai import UsageMetadatafrom langchain_core.outputs import ChatGeneration, ChatGenerationChunk, ChatResultfrom pydantic import Fieldclass ChatParrotLink(BaseChatModel):    \"\"\"A custom chat model that echoes the first `parrot_buffer_length` characters    of the input.    When contributing an implementation to LangChain, carefully document    the model including the initialization parameters, include    an example of how to initialize the model and include any relevant    links to the underlying models documentation or API.    Example:        .. code-block:: python            model = ChatParrotLink(parrot_buffer_length=2, model=\"bird-brain-001\")            result = model.invoke([HumanMessage(content=\"hello\")])            result = model.batch([[HumanMessage(content=\"hello\")],                                 [HumanMessage(content=\"world\")]])    \"\"\"    model_name: str = Field(alias=\"model\")    \"\"\"The name of the model\"\"\"    parrot_buffer_length: int    \"\"\"The number of characters from the last message of the prompt to be echoed.\"\"\"    temperature: Optional[float] = None    max_tokens: Optional[int] = None    timeout: Optional[int] = None    stop: Optional[List[str]] = None    max_retries: int = 2    def _generate(        self,        messages: List[BaseMessage],        stop: Optional[List[str]] = None,        run_manager: Optional[CallbackManagerForLLMRun] = None,        **kwargs: Any,    ) -> ChatResult:        \"\"\"Override the _generate method to implement the chat model logic.        This can be a call to an API, a call to a local model, or any other        implementation that generates a response to the input prompt.        Args:            messages: the prompt composed of a list of messages.            stop: a list of strings on which the model should stop generating.                  If generation stops due to a stop token, the stop token itself                  SHOULD BE INCLUDED as part of the output. This is not enforced                  across models right now, but it's a good practice to follow since                  it makes it much easier to parse the output of the model                  downstream and understand why generation stopped.            run_manager: A run manager with callbacks for the LLM.        \"\"\"        # Replace this with actual logic to generate a response from a list        # of messages.        last_message = messages[-1]        tokens = last_message.content[: self.parrot_buffer_length]        ct_input_tokens = sum(len(message.content) for message in messages)        ct_output_tokens = len(tokens)        message = AIMessage(            content=tokens,            additional_kwargs={},  # Used to add additional payload to the message            response_metadata={  # Use for response metadata                \"time_in_seconds\": 3,            },            usage_metadata={                \"input_tokens\": ct_input_tokens,                \"output_tokens\": ct_output_tokens,                \"total_tokens\": ct_input_tokens + ct_output_tokens,            },        )        ##        generation = ChatGeneration(message=message)        return ChatResult(generations=[generation])    def _stream(        self,        messages: List[BaseMessage],        stop: Optional[List[str]] = None,        run_manager: Optional[CallbackManagerForLLMRun] = None,        **kwargs: Any,    ) -> Iterator[ChatGenerationChunk]:        \"\"\"Stream the output of the model.        This method should be implemented if the model can generate output        in a streaming fashion. If the model does not support streaming,        do not implement it. In that case streaming requests will be automatically        handled by the _generate method.        Args:            messages: the prompt composed of a list of messages.            stop: a list of strings on which the model should stop generating.                  If generation stops due to a stop token, the stop token itself                  SHOULD BE INCLUDED as part of the output. This is not enforced                  across models right now, but it's a good practice to follow since                  it makes it much easier to parse the output of the model                  downstream and understand why generation stopped.            run_manager: A run manager with callbacks for the LLM.        \"\"\"        last_message = messages[-1]        tokens = str(last_message.content[: self.parrot_buffer_length])        ct_input_tokens = sum(len(message.content) for message in messages)        for token in tokens:            usage_metadata = UsageMetadata(                {                    \"input_tokens\": ct_input_tokens,                    \"output_tokens\": 1,                    \"total_tokens\": ct_input_tokens + 1,                }            )            ct_input_tokens = 0            chunk = ChatGenerationChunk(                message=AIMessageChunk(content=token, usage_metadata=usage_metadata)            )            if run_manager:                # This is optional in newer versions of LangChain                # The on_llm_new_token will be called automatically                run_manager.on_llm_new_token(token, chunk=chunk)            yield chunk        # Let's add some other information (e.g., response metadata)        chunk = ChatGenerationChunk(            message=AIMessageChunk(content=\"\", response_metadata={\"time_in_sec\": 3})        )        if run_manager:            # This is optional in newer versions of LangChain            # The on_llm_new_token will be called automatically            run_manager.on_llm_new_token(token, chunk=chunk)        yield chunk    @property    def _llm_type(self) -> str:        \"\"\"Get the type of language model used by this chat model.\"\"\"        return \"echoing-chat-model-advanced\"    @property    def _identifying_params(self) -> Dict[str, Any]:        \"\"\"Return a dictionary of identifying parameters.        This information is used by the LangChain callback system, which        is used for tracing purposes make it possible to monitor LLMs.        \"\"\"        return {            # The model name allows users to specify custom token counting            # rules in LLM monitoring applications (e.g., in LangSmith users            # can provide per token pricing for their model and monitor            # costs for the given LLM.)            \"model_name\": self.model_name,        }\n```\n\n### Let's test it 🧪[​](#lets-test-it- \"Direct link to Let's test it 🧪\")\n\nThe chat model will implement the standard `Runnable` interface of LangChain which many of the LangChain abstractions support!\n\n```\nmodel = ChatParrotLink(parrot_buffer_length=3, model=\"my_custom_model\")model.invoke(    [        HumanMessage(content=\"hello!\"),        AIMessage(content=\"Hi there human!\"),        HumanMessage(content=\"Meow!\"),    ])\n```\n\n```\nAIMessage(content='Meo', additional_kwargs={}, response_metadata={'time_in_seconds': 3}, id='run-cf11aeb6-8ab6-43d7-8c68-c1ef89b6d78e-0', usage_metadata={'input_tokens': 26, 'output_tokens': 3, 'total_tokens': 29})\n```\n\n```\nAIMessage(content='hel', additional_kwargs={}, response_metadata={'time_in_seconds': 3}, id='run-618e5ed4-d611-4083-8cf1-c270726be8d9-0', usage_metadata={'input_tokens': 5, 'output_tokens': 3, 'total_tokens': 8})\n```\n\n```\nmodel.batch([\"hello\", \"goodbye\"])\n```\n\n```\n[AIMessage(content='hel', additional_kwargs={}, response_metadata={'time_in_seconds': 3}, id='run-eea4ed7d-d750-48dc-90c0-7acca1ff388f-0', usage_metadata={'input_tokens': 5, 'output_tokens': 3, 'total_tokens': 8}), AIMessage(content='goo', additional_kwargs={}, response_metadata={'time_in_seconds': 3}, id='run-07cfc5c1-3c62-485f-b1e0-3d46e1547287-0', usage_metadata={'input_tokens': 7, 'output_tokens': 3, 'total_tokens': 10})]\n```\n\n```\nfor chunk in model.stream(\"cat\"):    print(chunk.content, end=\"|\")\n```\n\nPlease see the implementation of `_astream` in the model! If you do not implement it, then no output will stream.!\n\n```\nasync for chunk in model.astream(\"cat\"):    print(chunk.content, end=\"|\")\n```\n\nLet's try to use the astream events API which will also help double check that all the callbacks were implemented!\n\n```\nasync for event in model.astream_events(\"cat\", version=\"v1\"):    print(event)\n```\n\n```\n{'event': 'on_chat_model_start', 'run_id': '3f0b5501-5c78-45b3-92fc-8322a6a5024a', 'name': 'ChatParrotLink', 'tags': [], 'metadata': {}, 'data': {'input': 'cat'}, 'parent_ids': []}{'event': 'on_chat_model_stream', 'run_id': '3f0b5501-5c78-45b3-92fc-8322a6a5024a', 'tags': [], 'metadata': {}, 'name': 'ChatParrotLink', 'data': {'chunk': AIMessageChunk(content='c', additional_kwargs={}, response_metadata={}, id='run-3f0b5501-5c78-45b3-92fc-8322a6a5024a', usage_metadata={'input_tokens': 3, 'output_tokens': 1, 'total_tokens': 4})}, 'parent_ids': []}{'event': 'on_chat_model_stream', 'run_id': '3f0b5501-5c78-45b3-92fc-8322a6a5024a', 'tags': [], 'metadata': {}, 'name': 'ChatParrotLink', 'data': {'chunk': AIMessageChunk(content='a', additional_kwargs={}, response_metadata={}, id='run-3f0b5501-5c78-45b3-92fc-8322a6a5024a', usage_metadata={'input_tokens': 0, 'output_tokens': 1, 'total_tokens': 1})}, 'parent_ids': []}{'event': 'on_chat_model_stream', 'run_id': '3f0b5501-5c78-45b3-92fc-8322a6a5024a', 'tags': [], 'metadata': {}, 'name': 'ChatParrotLink', 'data': {'chunk': AIMessageChunk(content='t', additional_kwargs={}, response_metadata={}, id='run-3f0b5501-5c78-45b3-92fc-8322a6a5024a', usage_metadata={'input_tokens': 0, 'output_tokens': 1, 'total_tokens': 1})}, 'parent_ids': []}{'event': 'on_chat_model_stream', 'run_id': '3f0b5501-5c78-45b3-92fc-8322a6a5024a', 'tags': [], 'metadata': {}, 'name': 'ChatParrotLink', 'data': {'chunk': AIMessageChunk(content='', additional_kwargs={}, response_metadata={'time_in_sec': 3}, id='run-3f0b5501-5c78-45b3-92fc-8322a6a5024a')}, 'parent_ids': []}{'event': 'on_chat_model_end', 'name': 'ChatParrotLink', 'run_id': '3f0b5501-5c78-45b3-92fc-8322a6a5024a', 'tags': [], 'metadata': {}, 'data': {'output': AIMessageChunk(content='cat', additional_kwargs={}, response_metadata={'time_in_sec': 3}, id='run-3f0b5501-5c78-45b3-92fc-8322a6a5024a', usage_metadata={'input_tokens': 3, 'output_tokens': 3, 'total_tokens': 6})}, 'parent_ids': []}\n```\n\n## Contributing[​](#contributing \"Direct link to Contributing\")\n\nWe appreciate all chat model integration contributions.\n\nHere's a checklist to help make sure your contribution gets added to LangChain:\n\nDocumentation:\n\n*   The model contains doc-strings for all initialization arguments, as these will be surfaced in the [API Reference](https://python.langchain.com/api_reference/langchain/index.html).\n*   The class doc-string for the model contains a link to the model API if the model is powered by a service.\n\nTests:\n\n*   Add unit or integration tests to the overridden methods. Verify that `invoke`, `ainvoke`, `batch`, `stream` work if you've over-ridden the corresponding code.\n\nStreaming (if you're implementing it):\n\n*   Implement the \\_stream method to get streaming working\n\nStop Token Behavior:\n\n*   Stop token should be respected\n*   Stop token should be INCLUDED as part of the response\n\nSecret API Keys:\n\n*   If your model connects to an API it will likely accept API keys as part of its initialization. Use Pydantic's `SecretStr` type for secrets, so they don't get accidentally printed out when folks print the model.\n\nIdentifying Params:\n\n*   Include a `model_name` in identifying params\n\nOptimizations:\n\nConsider providing native async support to reduce the overhead from the model!\n\n*   Provided a native async of `_agenerate` (used by `ainvoke`)\n*   Provided a native async of `_astream` (used by `astream`)\n\n## Next steps[​](#next-steps \"Direct link to Next steps\")\n\nYou've now learned how to create your own custom chat models.\n\nNext, check out the other how-to guides chat models in this section, like [how to get a model to return structured output](https://python.langchain.com/docs/how_to/structured_output/) or [how to track chat model token usage](https://python.langchain.com/docs/how_to/chat_token_usage_tracking/)."
},
{
  "url": "https://python.langchain.com/docs/how_to/query_multiple_queries/",
  "markdown": "# giscus\n\n## How to handle multiple queries when doing query analysis\n\nSometimes, a query analysis technique may allow for multiple queries to be generated. In these cases, we need to remember to run all queries and then to combine the results. We will show a simple example (using mock data) of how to do that.\n\n## Setup[​](#setup \"Direct link to Setup\")\n\n#### Install dependencies[​](#install-dependencies \"Direct link to Install dependencies\")\n\n```\n%pip install -qU langchain langchain-community langchain-openai langchain-chroma\n```\n\n```\nNote: you may need to restart the kernel to use updated packages.\n```\n\n#### Set environment variables[​](#set-environment-variables \"Direct link to Set environment variables\")\n\nWe'll use OpenAI in this example:\n\n```\nimport getpassimport osif \"OPENAI_API_KEY\" not in os.environ:    os.environ[\"OPENAI_API_KEY\"] = getpass.getpass()# Optional, uncomment to trace runs with LangSmith. Sign up here: https://smith.langchain.com.# os.environ[\"LANGCHAIN_TRACING_V2\"] = \"true\"# os.environ[\"LANGCHAIN_API_KEY\"] = getpass.getpass()\n```\n\n### Create Index[​](#create-index \"Direct link to Create Index\")\n\nWe will create a vectorstore over fake information.\n\n```\nfrom langchain_chroma import Chromafrom langchain_openai import OpenAIEmbeddingsfrom langchain_text_splitters import RecursiveCharacterTextSplittertexts = [\"Harrison worked at Kensho\", \"Ankush worked at Facebook\"]embeddings = OpenAIEmbeddings(model=\"text-embedding-3-small\")vectorstore = Chroma.from_texts(    texts,    embeddings,)retriever = vectorstore.as_retriever(search_kwargs={\"k\": 1})\n```\n\n## Query analysis[​](#query-analysis \"Direct link to Query analysis\")\n\nWe will use function calling to structure the output. We will let it return multiple queries.\n\n```\nfrom typing import List, Optionalfrom pydantic import BaseModel, Fieldclass Search(BaseModel):    \"\"\"Search over a database of job records.\"\"\"    queries: List[str] = Field(        ...,        description=\"Distinct queries to search for\",    )\n```\n\n```\nfrom langchain_core.output_parsers.openai_tools import PydanticToolsParserfrom langchain_core.prompts import ChatPromptTemplatefrom langchain_core.runnables import RunnablePassthroughfrom langchain_openai import ChatOpenAIoutput_parser = PydanticToolsParser(tools=[Search])system = \"\"\"You have the ability to issue search queries to get information to help answer user information.If you need to look up two distinct pieces of information, you are allowed to do that!\"\"\"prompt = ChatPromptTemplate.from_messages(    [        (\"system\", system),        (\"human\", \"{question}\"),    ])llm = ChatOpenAI(model=\"gpt-4o-mini\", temperature=0)structured_llm = llm.with_structured_output(Search)query_analyzer = {\"question\": RunnablePassthrough()} | prompt | structured_llm\n```\n\nWe can see that this allows for creating multiple queries\n\n```\nquery_analyzer.invoke(\"where did Harrison Work\")\n```\n\n```\nSearch(queries=['Harrison Work', 'Harrison employment history'])\n```\n\n```\nquery_analyzer.invoke(\"where did Harrison and ankush Work\")\n```\n\n```\nSearch(queries=['Harrison work history', 'Ankush work history'])\n```\n\n## Retrieval with query analysis[​](#retrieval-with-query-analysis \"Direct link to Retrieval with query analysis\")\n\nSo how would we include this in a chain? One thing that will make this a lot easier is if we call our retriever asyncronously - this will let us loop over the queries and not get blocked on the response time.\n\n```\nfrom langchain_core.runnables import chain\n```\n\n```\n@chainasync def custom_chain(question):    response = await query_analyzer.ainvoke(question)    docs = []    for query in response.queries:        new_docs = await retriever.ainvoke(query)        docs.extend(new_docs)    # You probably want to think about reranking or deduplicating documents here    # But that is a separate topic    return docs\n```\n\n```\nawait custom_chain.ainvoke(\"where did Harrison Work\")\n```\n\n```\n[Document(page_content='Harrison worked at Kensho'), Document(page_content='Harrison worked at Kensho')]\n```\n\n```\nawait custom_chain.ainvoke(\"where did Harrison and ankush Work\")\n```\n\n```\n[Document(page_content='Harrison worked at Kensho'), Document(page_content='Ankush worked at Facebook')]\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/example_selectors_ngram/",
  "markdown": "# giscus\n\nThe `NGramOverlapExampleSelector` selects and orders examples based on which examples are most similar to the input, according to an ngram overlap score. The ngram overlap score is a float between 0.0 and 1.0, inclusive.\n\nThe [selector](https://python.langchain.com/docs/concepts/example_selectors/) allows for a threshold score to be set. Examples with an ngram overlap score less than or equal to the threshold are excluded. The threshold is set to -1.0, by default, so will not exclude any examples, only reorder them. Setting the threshold to 0.0 will exclude examples that have no ngram overlaps with the input.\n\n```\nfrom langchain_community.example_selectors import NGramOverlapExampleSelectorfrom langchain_core.prompts import FewShotPromptTemplate, PromptTemplateexample_prompt = PromptTemplate(    input_variables=[\"input\", \"output\"],    template=\"Input: {input}\\nOutput: {output}\",)# Examples of a fictional translation task.examples = [    {\"input\": \"See Spot run.\", \"output\": \"Ver correr a Spot.\"},    {\"input\": \"My dog barks.\", \"output\": \"Mi perro ladra.\"},    {\"input\": \"Spot can run.\", \"output\": \"Spot puede correr.\"},]\n```\n\n```\nexample_selector = NGramOverlapExampleSelector(    # The examples it has available to choose from.    examples=examples,    # The PromptTemplate being used to format the examples.    example_prompt=example_prompt,    # The threshold, at which selector stops.    # It is set to -1.0 by default.    threshold=-1.0,    # For negative threshold:    # Selector sorts examples by ngram overlap score, and excludes none.    # For threshold greater than 1.0:    # Selector excludes all examples, and returns an empty list.    # For threshold equal to 0.0:    # Selector sorts examples by ngram overlap score,    # and excludes those with no ngram overlap with input.)dynamic_prompt = FewShotPromptTemplate(    # We provide an ExampleSelector instead of examples.    example_selector=example_selector,    example_prompt=example_prompt,    prefix=\"Give the Spanish translation of every input\",    suffix=\"Input: {sentence}\\nOutput:\",    input_variables=[\"sentence\"],)\n```\n\n```\n# You can add examples to NGramOverlapExampleSelector as well.new_example = {\"input\": \"Spot plays fetch.\", \"output\": \"Spot juega a buscar.\"}example_selector.add_example(new_example)print(dynamic_prompt.format(sentence=\"Spot can run fast.\"))\n```\n\n```\n# You can set a threshold at which examples are excluded.# For example, setting threshold equal to 0.0# excludes examples with no ngram overlaps with input.# Since \"My dog barks.\" has no ngram overlaps with \"Spot can run fast.\"# it is excluded.example_selector.threshold = 0.0print(dynamic_prompt.format(sentence=\"Spot can run fast.\"))\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/custom_embeddings/",
  "markdown": "# giscus\n\n## Custom Embeddings\n\nLangChain is integrated with many [3rd party embedding models](https://python.langchain.com/docs/integrations/text_embedding/). In this guide we'll show you how to create a custom Embedding class, in case a built-in one does not already exist. Embeddings are critical in natural language processing applications as they convert text into a numerical form that algorithms can understand, thereby enabling a wide range of applications such as similarity search, text classification, and clustering.\n\nImplementing embeddings using the standard [Embeddings](https://python.langchain.com/api_reference/core/embeddings/langchain_core.embeddings.embeddings.Embeddings.html) interface will allow your embeddings to be utilized in existing `LangChain` abstractions (e.g., as the embeddings powering a [VectorStore](https://python.langchain.com/api_reference/core/vectorstores/langchain_core.vectorstores.base.VectorStore.html) or cached using [CacheBackedEmbeddings](https://python.langchain.com/docs/how_to/caching_embeddings/)).\n\n## Interface[​](#interface \"Direct link to Interface\")\n\nThe current `Embeddings` abstraction in LangChain is designed to operate on text data. In this implementation, the inputs are either single strings or lists of strings, and the outputs are lists of numerical arrays (vectors), where each vector represents an embedding of the input text into some n-dimensional space.\n\nYour custom embedding must implement the following methods:\n\n| Method/Property | Description | Required/Optional |\n| --- | --- | --- |\n| `embed_documents(texts)` | Generates embeddings for a list of strings. | Required |\n| `embed_query(text)` | Generates an embedding for a single text query. | Required |\n| `aembed_documents(texts)` | Asynchronously generates embeddings for a list of strings. | Optional |\n| `aembed_query(text)` | Asynchronously generates an embedding for a single text query. | Optional |\n\nThese methods ensure that your embedding model can be integrated seamlessly into the LangChain framework, providing both synchronous and asynchronous capabilities for scalability and performance optimization.\n\nnote\n\n`Embeddings` do not currently implement the [Runnable](https://python.langchain.com/docs/concepts/runnables/) interface and are also **not** instances of pydantic `BaseModel`.\n\n### Embedding queries vs documents[​](#embedding-queries-vs-documents \"Direct link to Embedding queries vs documents\")\n\nThe `embed_query` and `embed_documents` methods are required. These methods both operate on string inputs. The accessing of `Document.page_content` attributes is handled by the vector store using the embedding model for legacy reasons.\n\n`embed_query` takes in a single string and returns a single embedding as a list of floats. If your model has different modes for embedding queries vs the underlying documents, you can implement this method to handle that.\n\n`embed_documents` takes in a list of strings and returns a list of embeddings as a list of lists of floats.\n\nnote\n\n`embed_documents` takes in a list of plain text, not a list of LangChain `Document` objects. The name of this method may change in future versions of LangChain.\n\n## Implementation[​](#implementation \"Direct link to Implementation\")\n\nAs an example, we'll implement a simple embeddings model that returns a constant vector. This model is for illustrative purposes only.\n\n```\nfrom typing import Listfrom langchain_core.embeddings import Embeddingsclass ParrotLinkEmbeddings(Embeddings):    \"\"\"ParrotLink embedding model integration.    # TODO: Populate with relevant params.    Key init args — completion params:        model: str            Name of ParrotLink model to use.    See full list of supported init args and their descriptions in the params section.    # TODO: Replace with relevant init params.    Instantiate:        .. code-block:: python            from langchain_parrot_link import ParrotLinkEmbeddings            embed = ParrotLinkEmbeddings(                model=\"...\",                # api_key=\"...\",                # other params...            )    Embed single text:        .. code-block:: python            input_text = \"The meaning of life is 42\"            embed.embed_query(input_text)        .. code-block:: python            # TODO: Example output.    # TODO: Delete if token-level streaming isn't supported.    Embed multiple text:        .. code-block:: python             input_texts = [\"Document 1...\", \"Document 2...\"]            embed.embed_documents(input_texts)        .. code-block:: python            # TODO: Example output.    # TODO: Delete if native async isn't supported.    Async:        .. code-block:: python            await embed.aembed_query(input_text)            # multiple:            # await embed.aembed_documents(input_texts)        .. code-block:: python            # TODO: Example output.    \"\"\"    def __init__(self, model: str):        self.model = model    def embed_documents(self, texts: List[str]) -> List[List[float]]:        \"\"\"Embed search docs.\"\"\"        return [[0.5, 0.6, 0.7] for _ in texts]    def embed_query(self, text: str) -> List[float]:        \"\"\"Embed query text.\"\"\"        return self.embed_documents([text])[0]    # optional: add custom async implementations here    # you can also delete these, and the base class will    # use the default implementation, which calls the sync    # version in an async executor:    # async def aembed_documents(self, texts: List[str]) -> List[List[float]]:    #     \"\"\"Asynchronous Embed search docs.\"\"\"    #     ...    # async def aembed_query(self, text: str) -> List[float]:    #     \"\"\"Asynchronous Embed query text.\"\"\"    #     ...\n```\n\n### Let's test it 🧪[​](#lets-test-it- \"Direct link to Let's test it 🧪\")\n\n```\nembeddings = ParrotLinkEmbeddings(\"test-model\")print(embeddings.embed_documents([\"Hello\", \"world\"]))print(embeddings.embed_query(\"Hello\"))\n```\n\n```\n[[0.5, 0.6, 0.7], [0.5, 0.6, 0.7]][0.5, 0.6, 0.7]\n```\n\n## Contributing[​](#contributing \"Direct link to Contributing\")\n\nWe welcome contributions of Embedding models to the LangChain code base.\n\nIf you aim to contribute an embedding model for a new provider (e.g., with a new set of dependencies or SDK), we encourage you to publish your implementation in a separate `langchain-*` integration package. This will enable you to appropriately manage dependencies and version your package. Please refer to our [contributing guide](https://python.langchain.com/docs/contributing/how_to/integrations/) for a walkthrough of this process."
},
{
  "url": "https://python.langchain.com/docs/how_to/pydantic_compatibility/",
  "markdown": "# giscus\n\n## How to use LangChain with different Pydantic versions\n\nAs of the `0.3` release, LangChain uses Pydantic 2 internally.\n\nUsers should install Pydantic 2 and are advised to **avoid** using the `pydantic.v1` namespace of Pydantic 2 with LangChain APIs.\n\nIf you're working with prior versions of LangChain, please see the following guide on [Pydantic compatibility](https://python.langchain.com/v0.2/docs/how_to/pydantic_compatibility)."
},
{
  "url": "https://python.langchain.com/docs/how_to/custom_llm/",
  "markdown": "# giscus\n\n## How to create a custom LLM class\n\nThis notebook goes over how to create a custom LLM wrapper, in case you want to use your own LLM or a different wrapper than one that is supported in LangChain.\n\nWrapping your LLM with the standard `LLM` interface allow you to use your LLM in existing LangChain programs with minimal code modifications.\n\nAs an bonus, your LLM will automatically become a LangChain `Runnable` and will benefit from some optimizations out of the box, async support, the `astream_events` API, etc.\n\n## Implementation[​](#implementation \"Direct link to Implementation\")\n\nThere are only two required things that a custom LLM needs to implement:\n\n| Method | Description |\n| --- | --- |\n| `_call` | Takes in a string and some optional stop words, and returns a string. Used by `invoke`. |\n| `_llm_type` | A property that returns a string, used for logging purposes only. |\n\nOptional implementations:\n\n| Method | Description |\n| --- | --- |\n| `_identifying_params` | Used to help with identifying the model and printing the LLM; should return a dictionary. This is a **@property**. |\n| `_acall` | Provides an async native implementation of `_call`, used by `ainvoke`. |\n| `_stream` | Method to stream the output token by token. |\n| `_astream` | Provides an async native implementation of `_stream`; in newer LangChain versions, defaults to `_stream`. |\n\nLet's implement a simple custom LLM that just returns the first n characters of the input.\n\n```\nfrom typing import Any, Dict, Iterator, List, Mapping, Optionalfrom langchain_core.callbacks.manager import CallbackManagerForLLMRunfrom langchain_core.language_models.llms import LLMfrom langchain_core.outputs import GenerationChunkclass CustomLLM(LLM):    \"\"\"A custom chat model that echoes the first `n` characters of the input.    When contributing an implementation to LangChain, carefully document    the model including the initialization parameters, include    an example of how to initialize the model and include any relevant    links to the underlying models documentation or API.    Example:        .. code-block:: python            model = CustomChatModel(n=2)            result = model.invoke([HumanMessage(content=\"hello\")])            result = model.batch([[HumanMessage(content=\"hello\")],                                 [HumanMessage(content=\"world\")]])    \"\"\"    n: int    \"\"\"The number of characters from the last message of the prompt to be echoed.\"\"\"    def _call(        self,        prompt: str,        stop: Optional[List[str]] = None,        run_manager: Optional[CallbackManagerForLLMRun] = None,        **kwargs: Any,    ) -> str:        \"\"\"Run the LLM on the given input.        Override this method to implement the LLM logic.        Args:            prompt: The prompt to generate from.            stop: Stop words to use when generating. Model output is cut off at the                first occurrence of any of the stop substrings.                If stop tokens are not supported consider raising NotImplementedError.            run_manager: Callback manager for the run.            **kwargs: Arbitrary additional keyword arguments. These are usually passed                to the model provider API call.        Returns:            The model output as a string. Actual completions SHOULD NOT include the prompt.        \"\"\"        if stop is not None:            raise ValueError(\"stop kwargs are not permitted.\")        return prompt[: self.n]    def _stream(        self,        prompt: str,        stop: Optional[List[str]] = None,        run_manager: Optional[CallbackManagerForLLMRun] = None,        **kwargs: Any,    ) -> Iterator[GenerationChunk]:        \"\"\"Stream the LLM on the given prompt.        This method should be overridden by subclasses that support streaming.        If not implemented, the default behavior of calls to stream will be to        fallback to the non-streaming version of the model and return        the output as a single chunk.        Args:            prompt: The prompt to generate from.            stop: Stop words to use when generating. Model output is cut off at the                first occurrence of any of these substrings.            run_manager: Callback manager for the run.            **kwargs: Arbitrary additional keyword arguments. These are usually passed                to the model provider API call.        Returns:            An iterator of GenerationChunks.        \"\"\"        for char in prompt[: self.n]:            chunk = GenerationChunk(text=char)            if run_manager:                run_manager.on_llm_new_token(chunk.text, chunk=chunk)            yield chunk    @property    def _identifying_params(self) -> Dict[str, Any]:        \"\"\"Return a dictionary of identifying parameters.\"\"\"        return {            # The model name allows users to specify custom token counting            # rules in LLM monitoring applications (e.g., in LangSmith users            # can provide per token pricing for their model and monitor            # costs for the given LLM.)            \"model_name\": \"CustomChatModel\",        }    @property    def _llm_type(self) -> str:        \"\"\"Get the type of language model used by this chat model. Used for logging purposes only.\"\"\"        return \"custom\"\n```\n\n### Let's test it 🧪[​](#lets-test-it- \"Direct link to Let's test it 🧪\")\n\nThis LLM will implement the standard `Runnable` interface of LangChain which many of the LangChain abstractions support!\n\n```\nllm = CustomLLM(n=5)print(llm)\n```\n\n```\n\u001b[1mCustomLLM\u001b[0mParams: {'model_name': 'CustomChatModel'}\n```\n\n```\nllm.invoke(\"This is a foobar thing\")\n```\n\n```\nawait llm.ainvoke(\"world\")\n```\n\n```\nllm.batch([\"woof woof woof\", \"meow meow meow\"])\n```\n\n```\nawait llm.abatch([\"woof woof woof\", \"meow meow meow\"])\n```\n\n```\nasync for token in llm.astream(\"hello\"):    print(token, end=\"|\", flush=True)\n```\n\nLet's confirm that in integrates nicely with other `LangChain` APIs.\n\n```\nfrom langchain_core.prompts import ChatPromptTemplate\n```\n\n```\nprompt = ChatPromptTemplate.from_messages(    [(\"system\", \"you are a bot\"), (\"human\", \"{input}\")])\n```\n\n```\nllm = CustomLLM(n=7)chain = prompt | llm\n```\n\n```\nidx = 0async for event in chain.astream_events({\"input\": \"hello there!\"}, version=\"v1\"):    print(event)    idx += 1    if idx > 7:        # Truncate        break\n```\n\n```\n{'event': 'on_chain_start', 'run_id': '05f24b4f-7ea3-4fb6-8417-3aa21633462f', 'name': 'RunnableSequence', 'tags': [], 'metadata': {}, 'data': {'input': {'input': 'hello there!'}}}{'event': 'on_prompt_start', 'name': 'ChatPromptTemplate', 'run_id': '7e996251-a926-4344-809e-c425a9846d21', 'tags': ['seq:step:1'], 'metadata': {}, 'data': {'input': {'input': 'hello there!'}}}{'event': 'on_prompt_end', 'name': 'ChatPromptTemplate', 'run_id': '7e996251-a926-4344-809e-c425a9846d21', 'tags': ['seq:step:1'], 'metadata': {}, 'data': {'input': {'input': 'hello there!'}, 'output': ChatPromptValue(messages=[SystemMessage(content='you are a bot'), HumanMessage(content='hello there!')])}}{'event': 'on_llm_start', 'name': 'CustomLLM', 'run_id': 'a8766beb-10f4-41de-8750-3ea7cf0ca7e2', 'tags': ['seq:step:2'], 'metadata': {}, 'data': {'input': {'prompts': ['System: you are a bot\\nHuman: hello there!']}}}{'event': 'on_llm_stream', 'name': 'CustomLLM', 'run_id': 'a8766beb-10f4-41de-8750-3ea7cf0ca7e2', 'tags': ['seq:step:2'], 'metadata': {}, 'data': {'chunk': 'S'}}{'event': 'on_chain_stream', 'run_id': '05f24b4f-7ea3-4fb6-8417-3aa21633462f', 'tags': [], 'metadata': {}, 'name': 'RunnableSequence', 'data': {'chunk': 'S'}}{'event': 'on_llm_stream', 'name': 'CustomLLM', 'run_id': 'a8766beb-10f4-41de-8750-3ea7cf0ca7e2', 'tags': ['seq:step:2'], 'metadata': {}, 'data': {'chunk': 'y'}}{'event': 'on_chain_stream', 'run_id': '05f24b4f-7ea3-4fb6-8417-3aa21633462f', 'tags': [], 'metadata': {}, 'name': 'RunnableSequence', 'data': {'chunk': 'y'}}\n```\n\n## Contributing[​](#contributing \"Direct link to Contributing\")\n\nWe appreciate all chat model integration contributions.\n\nHere's a checklist to help make sure your contribution gets added to LangChain:\n\nDocumentation:\n\n*   The model contains doc-strings for all initialization arguments, as these will be surfaced in the [APIReference](https://python.langchain.com/api_reference/langchain/index.html).\n*   The class doc-string for the model contains a link to the model API if the model is powered by a service.\n\nTests:\n\n*   Add unit or integration tests to the overridden methods. Verify that `invoke`, `ainvoke`, `batch`, `stream` work if you've over-ridden the corresponding code.\n\nStreaming (if you're implementing it):\n\n*   Make sure to invoke the `on_llm_new_token` callback\n*   `on_llm_new_token` is invoked BEFORE yielding the chunk\n\nStop Token Behavior:\n\n*   Stop token should be respected\n*   Stop token should be INCLUDED as part of the response\n\nSecret API Keys:\n\n*   If your model connects to an API it will likely accept API keys as part of its initialization. Use Pydantic's `SecretStr` type for secrets, so they don't get accidentally printed out when folks print the model."
},
{
  "url": "https://python.langchain.com/docs/how_to/qa_chat_history_how_to/",
  "markdown": "# giscus\n\n## How to add chat history\n\nnote\n\nThis guide previously used the [RunnableWithMessageHistory](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.history.RunnableWithMessageHistory.html) abstraction. You can access this version of the documentation in the [v0.2 docs](https://python.langchain.com/v0.2/docs/how_to/qa_chat_history_how_to/).\n\nAs of the v0.3 release of LangChain, we recommend that LangChain users take advantage of [LangGraph persistence](https://langchain-ai.github.io/langgraph/concepts/persistence/) to incorporate `memory` into new LangChain applications.\n\nIf your code is already relying on `RunnableWithMessageHistory` or `BaseChatMessageHistory`, you do **not** need to make any changes. We do not plan on deprecating this functionality in the near future as it works for simple chat applications and any code that uses `RunnableWithMessageHistory` will continue to work as expected.\n\nPlease see [How to migrate to LangGraph Memory](https://python.langchain.com/docs/versions/migrating_memory/) for more details.\n\nIn many [Q&A applications](https://python.langchain.com/docs/concepts/rag/) we want to allow the user to have a back-and-forth conversation, meaning the application needs some sort of \"memory\" of past questions and answers, and some logic for incorporating those into its current thinking.\n\nIn this guide we focus on **adding logic for incorporating historical messages.**\n\nThis is largely a condensed version of the [Conversational RAG tutorial](https://python.langchain.com/docs/tutorials/qa_chat_history/).\n\nWe will cover two approaches:\n\n1.  [Chains](https://python.langchain.com/docs/how_to/qa_chat_history_how_to/#chains), in which we always execute a retrieval step;\n2.  [Agents](https://python.langchain.com/docs/how_to/qa_chat_history_how_to/#agents), in which we give an LLM discretion over whether and how to execute a retrieval step (or multiple steps).\n\nFor the external knowledge source, we will use the same [LLM Powered Autonomous Agents](https://lilianweng.github.io/posts/2023-06-23-agent/) blog post by Lilian Weng from the [RAG tutorial](https://python.langchain.com/docs/tutorials/rag/).\n\nBoth approaches leverage [LangGraph](https://langchain-ai.github.io/langgraph/) as an orchestration framework. LangGraph implements a built-in [persistence layer](https://langchain-ai.github.io/langgraph/concepts/persistence/), making it ideal for chat applications that support multiple conversational turns.\n\n## Setup[​](#setup \"Direct link to Setup\")\n\n### Dependencies[​](#dependencies \"Direct link to Dependencies\")\n\nWe'll use OpenAI embeddings and an InMemory vector store in this walkthrough, but everything shown here works with any [Embeddings](https://python.langchain.com/docs/concepts/embedding_models/), and [VectorStore](https://python.langchain.com/docs/concepts/vectorstores/) or [Retriever](https://python.langchain.com/docs/concepts/retrievers/).\n\nWe'll use the following packages:\n\n```\n%%capture --no-stderr%pip install --upgrade --quiet langgraph langchain-community beautifulsoup4\n```\n\n### LangSmith[​](#langsmith \"Direct link to LangSmith\")\n\nMany of the applications you build with LangChain will contain multiple steps with multiple invocations of LLM calls. As these applications get more and more complex, it becomes crucial to be able to inspect what exactly is going on inside your chain or agent. The best way to do this is with [LangSmith](https://smith.langchain.com/).\n\nNote that LangSmith is not needed, but it is helpful. If you do want to use LangSmith, after you sign up at the link above, make sure to set your environment variables to start logging traces:\n\n```\nos.environ[\"LANGCHAIN_TRACING_V2\"] = \"true\"if not os.environ.get(\"LANGCHAIN_API_KEY\"):    os.environ[\"LANGCHAIN_API_KEY\"] = getpass.getpass()\n```\n\n### Components[​](#components \"Direct link to Components\")\n\nWe will need to select three components from LangChain's suite of integrations.\n\nA [chat model](https://python.langchain.com/docs/integrations/chat/):\n\n```\npip install -qU langchain-openai\n```\n\n```\nimport getpassimport osif not os.environ.get(\"OPENAI_API_KEY\"):  os.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"Enter API key for OpenAI: \")from langchain_openai import ChatOpenAIllm = ChatOpenAI(model=\"gpt-4o-mini\")\n```\n\nAn [embedding model](https://python.langchain.com/docs/integrations/text_embedding/):\n\n```\npip install -qU langchain-openai\n```\n\n```\nimport getpassimport osif not os.environ.get(\"OPENAI_API_KEY\"):  os.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"Enter API key for OpenAI: \")from langchain_openai import OpenAIEmbeddingsembeddings = OpenAIEmbeddings(model=\"text-embedding-3-large\")\n```\n\nAnd a [vector store](https://python.langchain.com/docs/integrations/vectorstores/):\n\n```\npip install -qU langchain-core\n```\n\n```\nfrom langchain_core.vectorstores import InMemoryVectorStorevector_store = InMemoryVectorStore(embeddings)\n```\n\n## Chains[​](#chains \"Direct link to Chains\")\n\nThe [RAG Tutorial](https://python.langchain.com/docs/tutorials/rag/) indexes an [LLM Powered Autonomous Agents](https://lilianweng.github.io/posts/2023-06-23-agent/) blog post by Lilian Weng. We will repeat that here. Below we load the content of the page, split it into sub-documents, and embed the documents into our [vector store](https://python.langchain.com/docs/concepts/vectorstores/):\n\n```\nimport bs4from langchain import hubfrom langchain_community.document_loaders import WebBaseLoaderfrom langchain_core.documents import Documentfrom langchain_text_splitters import RecursiveCharacterTextSplitterfrom typing_extensions import List, TypedDict# Load and chunk contents of the blogloader = WebBaseLoader(    web_paths=(\"https://lilianweng.github.io/posts/2023-06-23-agent/\",),    bs_kwargs=dict(        parse_only=bs4.SoupStrainer(            class_=(\"post-content\", \"post-title\", \"post-header\")        )    ),)docs = loader.load()text_splitter = RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=200)all_splits = text_splitter.split_documents(docs)\n```\n\n```\n# Index chunks_ = vector_store.add_documents(documents=all_splits)\n```\n\nAs detailed in [Part 2](https://python.langchain.com/docs/tutorials/qa_chat_history/) of the RAG tutorial, we can naturally support a conversational experience by representing the flow of the RAG application as a sequence of [messages](https://python.langchain.com/docs/concepts/messages/):\n\n1.  User input as a `HumanMessage`;\n2.  Vector store query as an `AIMessage` with tool calls;\n3.  Retrieved documents as a `ToolMessage`;\n4.  Final response as a `AIMessage`.\n\nWe will use [tool-calling](https://python.langchain.com/docs/concepts/tool_calling/) to facilitate this, which additionally allows the query to be generated by the LLM. We can build a [tool](https://python.langchain.com/docs/concepts/tools/) to execute the retrieval step:\n\n```\nfrom langchain_core.tools import tool@tool(response_format=\"content_and_artifact\")def retrieve(query: str):    \"\"\"Retrieve information related to a query.\"\"\"    retrieved_docs = vector_store.similarity_search(query, k=2)    serialized = \"\\n\\n\".join(        (f\"Source: {doc.metadata}\\n\" f\"Content: {doc.page_content}\")        for doc in retrieved_docs    )    return serialized, retrieved_docs\n```\n\n**API Reference:**[tool](https://python.langchain.com/api_reference/core/tools/langchain_core.tools.convert.tool.html)\n\nWe can now build our LangGraph application.\n\nNote that we compile it with a [checkpointer](https://langchain-ai.github.io/langgraph/concepts/persistence/) to support a back-and-forth conversation. LangGraph comes with a simple [in-memory checkpointer](https://langchain-ai.github.io/langgraph/reference/checkpoints/#memorysaver), which we use below. See its documentation for more detail, including how to use different persistence backends (e.g., SQLite or Postgres).\n\n```\nfrom langchain_core.messages import SystemMessagefrom langgraph.checkpoint.memory import MemorySaverfrom langgraph.graph import END, MessagesState, StateGraphfrom langgraph.prebuilt import ToolNode, tools_condition# Step 1: Generate an AIMessage that may include a tool-call to be sent.def query_or_respond(state: MessagesState):    \"\"\"Generate tool call for retrieval or respond.\"\"\"    llm_with_tools = llm.bind_tools([retrieve])    response = llm_with_tools.invoke(state[\"messages\"])    # MessagesState appends messages to state instead of overwriting    return {\"messages\": [response]}# Step 2: Execute the retrieval.tools = ToolNode([retrieve])# Step 3: Generate a response using the retrieved content.def generate(state: MessagesState):    \"\"\"Generate answer.\"\"\"    # Get generated ToolMessages    recent_tool_messages = []    for message in reversed(state[\"messages\"]):        if message.type == \"tool\":            recent_tool_messages.append(message)        else:            break    tool_messages = recent_tool_messages[::-1]    # Format into prompt    docs_content = \"\\n\\n\".join(doc.content for doc in tool_messages)    system_message_content = (        \"You are an assistant for question-answering tasks. \"        \"Use the following pieces of retrieved context to answer \"        \"the question. If you don't know the answer, say that you \"        \"don't know. Use three sentences maximum and keep the \"        \"answer concise.\"        \"\\n\\n\"        f\"{docs_content}\"    )    conversation_messages = [        message        for message in state[\"messages\"]        if message.type in (\"human\", \"system\")        or (message.type == \"ai\" and not message.tool_calls)    ]    prompt = [SystemMessage(system_message_content)] + conversation_messages    # Run    response = llm.invoke(prompt)    return {\"messages\": [response]}# Build graphgraph_builder = StateGraph(MessagesState)graph_builder.add_node(query_or_respond)graph_builder.add_node(tools)graph_builder.add_node(generate)graph_builder.set_entry_point(\"query_or_respond\")graph_builder.add_conditional_edges(    \"query_or_respond\",    tools_condition,    {END: END, \"tools\": \"tools\"},)graph_builder.add_edge(\"tools\", \"generate\")graph_builder.add_edge(\"generate\", END)memory = MemorySaver()graph = graph_builder.compile(checkpointer=memory)\n```\n\n```\nfrom IPython.display import Image, displaydisplay(Image(graph.get_graph().draw_mermaid_png()))\n```\n\n![](data:image/png;base64,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)\n\nLet's test our application.\n\nNote that it responds appropriately to messages that do not require an additional retrieval step:\n\n```\n# Specify an ID for the threadconfig = {\"configurable\": {\"thread_id\": \"abc123\"}}\n```\n\n```\ninput_message = \"Hello\"for step in graph.stream(    {\"messages\": [{\"role\": \"user\", \"content\": input_message}]},    stream_mode=\"values\",    config=config,):    step[\"messages\"][-1].pretty_print()\n```\n\n```\n================================\u001b[1m Human Message \u001b[0m=================================Hello==================================\u001b[1m Ai Message \u001b[0m==================================Hello! How can I assist you today?\n```\n\nAnd when executing a search, we can stream the steps to observe the query generation, retrieval, and answer generation:\n\n```\ninput_message = \"What is Task Decomposition?\"for step in graph.stream(    {\"messages\": [{\"role\": \"user\", \"content\": input_message}]},    stream_mode=\"values\",    config=config,):    step[\"messages\"][-1].pretty_print()\n```\n\n```\n================================\u001b[1m Human Message \u001b[0m=================================What is Task Decomposition?==================================\u001b[1m Ai Message \u001b[0m==================================Tool Calls:  retrieve (call_RntwX5GMt531biEE9MqSbgLV) Call ID: call_RntwX5GMt531biEE9MqSbgLV  Args:    query: Task Decomposition=================================\u001b[1m Tool Message \u001b[0m=================================Name: retrieveSource: {'source': 'https://lilianweng.github.io/posts/2023-06-23-agent/'}Content: Fig. 1. Overview of a LLM-powered autonomous agent system.Component One: Planning#A complicated task usually involves many steps. An agent needs to know what they are and plan ahead.Task Decomposition#Chain of thought (CoT; Wei et al. 2022) has become a standard prompting technique for enhancing model performance on complex tasks. The model is instructed to “think step by step” to utilize more test-time computation to decompose hard tasks into smaller and simpler steps. CoT transforms big tasks into multiple manageable tasks and shed lights into an interpretation of the model’s thinking process.Source: {'source': 'https://lilianweng.github.io/posts/2023-06-23-agent/'}Content: Tree of Thoughts (Yao et al. 2023) extends CoT by exploring multiple reasoning possibilities at each step. It first decomposes the problem into multiple thought steps and generates multiple thoughts per step, creating a tree structure. The search process can be BFS (breadth-first search) or DFS (depth-first search) with each state evaluated by a classifier (via a prompt) or majority vote.Task decomposition can be done (1) by LLM with simple prompting like \"Steps for XYZ.\\n1.\", \"What are the subgoals for achieving XYZ?\", (2) by using task-specific instructions; e.g. \"Write a story outline.\" for writing a novel, or (3) with human inputs.==================================\u001b[1m Ai Message \u001b[0m==================================Task Decomposition is the process of breaking down a complicated task into smaller, more manageable steps. It often involves techniques like Chain of Thought (CoT), where the model is prompted to \"think step by step,\" allowing for better handling of complex tasks. This approach enhances model performance and provides insight into the model's reasoning process.\n```\n\nFinally, because we have compiled our application with a [checkpointer](https://langchain-ai.github.io/langgraph/concepts/persistence/), historical messages are maintained in the state. This allows the model to contextualize user queries:\n\n```\ninput_message = \"Can you look up some common ways of doing it?\"for step in graph.stream(    {\"messages\": [{\"role\": \"user\", \"content\": input_message}]},    stream_mode=\"values\",    config=config,):    step[\"messages\"][-1].pretty_print()\n```\n\n```\n================================\u001b[1m Human Message \u001b[0m=================================Can you look up some common ways of doing it?==================================\u001b[1m Ai Message \u001b[0m==================================Tool Calls:  retrieve (call_kwO5rYPyJ0MftYKoKRFjKpZM) Call ID: call_kwO5rYPyJ0MftYKoKRFjKpZM  Args:    query: common methods for task decomposition=================================\u001b[1m Tool Message \u001b[0m=================================Name: retrieveSource: {'source': 'https://lilianweng.github.io/posts/2023-06-23-agent/'}Content: Tree of Thoughts (Yao et al. 2023) extends CoT by exploring multiple reasoning possibilities at each step. It first decomposes the problem into multiple thought steps and generates multiple thoughts per step, creating a tree structure. The search process can be BFS (breadth-first search) or DFS (depth-first search) with each state evaluated by a classifier (via a prompt) or majority vote.Task decomposition can be done (1) by LLM with simple prompting like \"Steps for XYZ.\\n1.\", \"What are the subgoals for achieving XYZ?\", (2) by using task-specific instructions; e.g. \"Write a story outline.\" for writing a novel, or (3) with human inputs.Source: {'source': 'https://lilianweng.github.io/posts/2023-06-23-agent/'}Content: Fig. 1. Overview of a LLM-powered autonomous agent system.Component One: Planning#A complicated task usually involves many steps. An agent needs to know what they are and plan ahead.Task Decomposition#Chain of thought (CoT; Wei et al. 2022) has become a standard prompting technique for enhancing model performance on complex tasks. The model is instructed to “think step by step” to utilize more test-time computation to decompose hard tasks into smaller and simpler steps. CoT transforms big tasks into multiple manageable tasks and shed lights into an interpretation of the model’s thinking process.==================================\u001b[1m Ai Message \u001b[0m==================================Common ways of Task Decomposition include: (1) using large language models (LLMs) with simple prompts like \"Steps for XYZ\" or \"What are the subgoals for achieving XYZ?\"; (2) utilizing task-specific instructions, such as \"Write a story outline\" for creative tasks; and (3) incorporating human inputs to guide the decomposition process.\n```\n\nNote that we can observe the full sequence of messages sent to the chat model-- including tool calls and retrieved context-- in the [LangSmith trace](https://smith.langchain.com/public/3c85919e-9609-4a0d-8df1-21726f8f3e5c/r).\n\nThe conversation history can also be inspected via the state of the application:\n\n```\nchat_history = graph.get_state(config).values[\"messages\"]for message in chat_history:    message.pretty_print()\n```\n\n```\n================================\u001b[1m Human Message \u001b[0m=================================Hello==================================\u001b[1m Ai Message \u001b[0m==================================Hello! How can I assist you today?================================\u001b[1m Human Message \u001b[0m=================================What is Task Decomposition?==================================\u001b[1m Ai Message \u001b[0m==================================Tool Calls:  retrieve (call_RntwX5GMt531biEE9MqSbgLV) Call ID: call_RntwX5GMt531biEE9MqSbgLV  Args:    query: Task Decomposition=================================\u001b[1m Tool Message \u001b[0m=================================Name: retrieveSource: {'source': 'https://lilianweng.github.io/posts/2023-06-23-agent/'}Content: Fig. 1. Overview of a LLM-powered autonomous agent system.Component One: Planning#A complicated task usually involves many steps. An agent needs to know what they are and plan ahead.Task Decomposition#Chain of thought (CoT; Wei et al. 2022) has become a standard prompting technique for enhancing model performance on complex tasks. The model is instructed to “think step by step” to utilize more test-time computation to decompose hard tasks into smaller and simpler steps. CoT transforms big tasks into multiple manageable tasks and shed lights into an interpretation of the model’s thinking process.Source: {'source': 'https://lilianweng.github.io/posts/2023-06-23-agent/'}Content: Tree of Thoughts (Yao et al. 2023) extends CoT by exploring multiple reasoning possibilities at each step. It first decomposes the problem into multiple thought steps and generates multiple thoughts per step, creating a tree structure. The search process can be BFS (breadth-first search) or DFS (depth-first search) with each state evaluated by a classifier (via a prompt) or majority vote.Task decomposition can be done (1) by LLM with simple prompting like \"Steps for XYZ.\\n1.\", \"What are the subgoals for achieving XYZ?\", (2) by using task-specific instructions; e.g. \"Write a story outline.\" for writing a novel, or (3) with human inputs.==================================\u001b[1m Ai Message \u001b[0m==================================Task Decomposition is the process of breaking down a complicated task into smaller, more manageable steps. It often involves techniques like Chain of Thought (CoT), where the model is prompted to \"think step by step,\" allowing for better handling of complex tasks. This approach enhances model performance and provides insight into the model's reasoning process.================================\u001b[1m Human Message \u001b[0m=================================Can you look up some common ways of doing it?==================================\u001b[1m Ai Message \u001b[0m==================================Tool Calls:  retrieve (call_kwO5rYPyJ0MftYKoKRFjKpZM) Call ID: call_kwO5rYPyJ0MftYKoKRFjKpZM  Args:    query: common methods for task decomposition=================================\u001b[1m Tool Message \u001b[0m=================================Name: retrieveSource: {'source': 'https://lilianweng.github.io/posts/2023-06-23-agent/'}Content: Tree of Thoughts (Yao et al. 2023) extends CoT by exploring multiple reasoning possibilities at each step. It first decomposes the problem into multiple thought steps and generates multiple thoughts per step, creating a tree structure. The search process can be BFS (breadth-first search) or DFS (depth-first search) with each state evaluated by a classifier (via a prompt) or majority vote.Task decomposition can be done (1) by LLM with simple prompting like \"Steps for XYZ.\\n1.\", \"What are the subgoals for achieving XYZ?\", (2) by using task-specific instructions; e.g. \"Write a story outline.\" for writing a novel, or (3) with human inputs.Source: {'source': 'https://lilianweng.github.io/posts/2023-06-23-agent/'}Content: Fig. 1. Overview of a LLM-powered autonomous agent system.Component One: Planning#A complicated task usually involves many steps. An agent needs to know what they are and plan ahead.Task Decomposition#Chain of thought (CoT; Wei et al. 2022) has become a standard prompting technique for enhancing model performance on complex tasks. The model is instructed to “think step by step” to utilize more test-time computation to decompose hard tasks into smaller and simpler steps. CoT transforms big tasks into multiple manageable tasks and shed lights into an interpretation of the model’s thinking process.==================================\u001b[1m Ai Message \u001b[0m==================================Common ways of Task Decomposition include: (1) using large language models (LLMs) with simple prompts like \"Steps for XYZ\" or \"What are the subgoals for achieving XYZ?\"; (2) utilizing task-specific instructions, such as \"Write a story outline\" for creative tasks; and (3) incorporating human inputs to guide the decomposition process.\n```\n\n## Agents[​](#agents \"Direct link to Agents\")\n\n[Agents](https://python.langchain.com/docs/concepts/agents/) leverage the reasoning capabilities of LLMs to make decisions during execution. Using agents allows you to offload additional discretion over the retrieval process. Although their behavior is less predictable than the above \"chain\", they are able to execute multiple retrieval steps in service of a query, or iterate on a single search.\n\nBelow we assemble a minimal RAG agent. Using LangGraph's [pre-built ReAct agent constructor](https://langchain-ai.github.io/langgraph/how-tos/#langgraph.prebuilt.chat_agent_executor.create_react_agent), we can do this in one line.\n\ntip\n\nCheck out LangGraph's [Agentic RAG](https://langchain-ai.github.io/langgraph/tutorials/rag/langgraph_agentic_rag/) tutorial for more advanced formulations.\n\n```\nfrom langgraph.prebuilt import create_react_agentagent_executor = create_react_agent(llm, [retrieve], checkpointer=memory)\n```\n\nLet's inspect the graph:\n\n```\ndisplay(Image(agent_executor.get_graph().draw_mermaid_png()))\n```\n\n![](data:image/png;base64,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)\n\nThe key difference from our earlier implementation is that instead of a final generation step that ends the run, here the tool invocation loops back to the original LLM call. The model can then either answer the question using the retrieved context, or generate another tool call to obtain more information.\n\nLet's test this out. We construct a question that would typically require an iterative sequence of retrieval steps to answer:\n\n```\nconfig = {\"configurable\": {\"thread_id\": \"def234\"}}input_message = (    \"What is the standard method for Task Decomposition?\\n\\n\"    \"Once you get the answer, look up common extensions of that method.\")for event in agent_executor.stream(    {\"messages\": [{\"role\": \"user\", \"content\": input_message}]},    stream_mode=\"values\",    config=config,):    event[\"messages\"][-1].pretty_print()\n```\n\n```\n================================\u001b[1m Human Message \u001b[0m=================================What is the standard method for Task Decomposition?Once you get the answer, look up common extensions of that method.==================================\u001b[1m Ai Message \u001b[0m==================================Tool Calls:  retrieve (call_rxBqio7dxthnMuzjr4AIquSZ) Call ID: call_rxBqio7dxthnMuzjr4AIquSZ  Args:    query: standard method for Task Decomposition=================================\u001b[1m Tool Message \u001b[0m=================================Name: retrieveSource: {'source': 'https://lilianweng.github.io/posts/2023-06-23-agent/'}Content: Tree of Thoughts (Yao et al. 2023) extends CoT by exploring multiple reasoning possibilities at each step. It first decomposes the problem into multiple thought steps and generates multiple thoughts per step, creating a tree structure. The search process can be BFS (breadth-first search) or DFS (depth-first search) with each state evaluated by a classifier (via a prompt) or majority vote.Task decomposition can be done (1) by LLM with simple prompting like \"Steps for XYZ.\\n1.\", \"What are the subgoals for achieving XYZ?\", (2) by using task-specific instructions; e.g. \"Write a story outline.\" for writing a novel, or (3) with human inputs.Source: {'source': 'https://lilianweng.github.io/posts/2023-06-23-agent/'}Content: Fig. 1. Overview of a LLM-powered autonomous agent system.Component One: Planning#A complicated task usually involves many steps. An agent needs to know what they are and plan ahead.Task Decomposition#Chain of thought (CoT; Wei et al. 2022) has become a standard prompting technique for enhancing model performance on complex tasks. The model is instructed to “think step by step” to utilize more test-time computation to decompose hard tasks into smaller and simpler steps. CoT transforms big tasks into multiple manageable tasks and shed lights into an interpretation of the model’s thinking process.==================================\u001b[1m Ai Message \u001b[0m==================================Tool Calls:  retrieve (call_kmQMRWCKeBdtXdlJi8yZD9CO) Call ID: call_kmQMRWCKeBdtXdlJi8yZD9CO  Args:    query: common extensions of Task Decomposition methods=================================\u001b[1m Tool Message \u001b[0m=================================Name: retrieveSource: {'source': 'https://lilianweng.github.io/posts/2023-06-23-agent/'}Content: Tree of Thoughts (Yao et al. 2023) extends CoT by exploring multiple reasoning possibilities at each step. It first decomposes the problem into multiple thought steps and generates multiple thoughts per step, creating a tree structure. The search process can be BFS (breadth-first search) or DFS (depth-first search) with each state evaluated by a classifier (via a prompt) or majority vote.Task decomposition can be done (1) by LLM with simple prompting like \"Steps for XYZ.\\n1.\", \"What are the subgoals for achieving XYZ?\", (2) by using task-specific instructions; e.g. \"Write a story outline.\" for writing a novel, or (3) with human inputs.Source: {'source': 'https://lilianweng.github.io/posts/2023-06-23-agent/'}Content: Fig. 1. Overview of a LLM-powered autonomous agent system.Component One: Planning#A complicated task usually involves many steps. An agent needs to know what they are and plan ahead.Task Decomposition#Chain of thought (CoT; Wei et al. 2022) has become a standard prompting technique for enhancing model performance on complex tasks. The model is instructed to “think step by step” to utilize more test-time computation to decompose hard tasks into smaller and simpler steps. CoT transforms big tasks into multiple manageable tasks and shed lights into an interpretation of the model’s thinking process.==================================\u001b[1m Ai Message \u001b[0m==================================The standard method for Task Decomposition involves breaking down complex tasks into smaller, manageable steps. Here are the main techniques:1. **Chain of Thought (CoT)**: This prompting technique encourages a model to \"think step by step,\" allowing it to utilize more computational resources during testing to decompose challenging tasks into simpler parts. CoT not only simplifies tasks but also provides insights into the model's reasoning process.2. **Simple Prompting**: This can involve straightforward queries like \"Steps for XYZ\" or \"What are the subgoals for achieving XYZ?\" to guide the model in identifying the necessary steps.3. **Task-specific Instructions**: Using specific prompts tailored to the task at hand, such as \"Write a story outline\" for creative writing, allows for more directed decomposition.4. **Human Inputs**: Involving human expertise can also aid in breaking down tasks effectively.### Common Extensions of Task Decomposition Methods1. **Tree of Thoughts**: This method extends CoT by exploring multiple reasoning possibilities at each step. It decomposes the problem into various thought steps and generates multiple thoughts per step, forming a tree structure. This can utilize search processes like breadth-first search (BFS) or depth-first search (DFS) to evaluate states through classifiers or majority voting.These extensions build on the basic principles of task decomposition, enhancing the depth and breadth of reasoning applied to complex tasks.\n```\n\nNote that the agent:\n\n1.  Generates a query to search for a standard method for task decomposition;\n2.  Receiving the answer, generates a second query to search for common extensions of it;\n3.  Having received all necessary context, answers the question.\n\nWe can see the full sequence of steps, along with latency and other metadata, in the [LangSmith trace](https://smith.langchain.com/public/48cbd35e-9ac1-49ab-8c09-500d54c06b81/r).\n\n## Next steps[​](#next-steps \"Direct link to Next steps\")\n\nWe've covered the steps to build a basic conversational Q&A application:\n\n*   We used chains to build a predictable application that generates search queries for each user input;\n*   We used agents to build an application that \"decides\" when and how to generate search queries.\n\nTo explore different types of retrievers and retrieval strategies, visit the [retrievers](https://python.langchain.com/docs/how_to/#retrievers) section of the how-to guides.\n\nFor a detailed walkthrough of LangChain's conversation memory abstractions, visit the [How to add message history (memory)](https://python.langchain.com/docs/how_to/message_history/) LCEL page.\n\nTo learn more about agents, head to the [Agents Modules](https://python.langchain.com/docs/tutorials/agents/)."
},
{
  "url": "https://python.langchain.com/docs/how_to/example_selectors_similarity/",
  "markdown": "# giscus\n\nThis object selects [examples](https://python.langchain.com/docs/concepts/example_selectors/) based on similarity to the inputs. It does this by finding the examples with the embeddings that have the greatest cosine similarity with the inputs.\n\n```\nfrom langchain_chroma import Chromafrom langchain_core.example_selectors import SemanticSimilarityExampleSelectorfrom langchain_core.prompts import FewShotPromptTemplate, PromptTemplatefrom langchain_openai import OpenAIEmbeddingsexample_prompt = PromptTemplate(    input_variables=[\"input\", \"output\"],    template=\"Input: {input}\\nOutput: {output}\",)# Examples of a pretend task of creating antonyms.examples = [    {\"input\": \"happy\", \"output\": \"sad\"},    {\"input\": \"tall\", \"output\": \"short\"},    {\"input\": \"energetic\", \"output\": \"lethargic\"},    {\"input\": \"sunny\", \"output\": \"gloomy\"},    {\"input\": \"windy\", \"output\": \"calm\"},]\n```\n\n```\nexample_selector = SemanticSimilarityExampleSelector.from_examples(    # The list of examples available to select from.    examples,    # The embedding class used to produce embeddings which are used to measure semantic similarity.    OpenAIEmbeddings(),    # The VectorStore class that is used to store the embeddings and do a similarity search over.    Chroma,    # The number of examples to produce.    k=1,)similar_prompt = FewShotPromptTemplate(    # We provide an ExampleSelector instead of examples.    example_selector=example_selector,    example_prompt=example_prompt,    prefix=\"Give the antonym of every input\",    suffix=\"Input: {adjective}\\nOutput:\",    input_variables=[\"adjective\"],)\n```\n\n```\n# You can add new examples to the SemanticSimilarityExampleSelector as wellsimilar_prompt.example_selector.add_example(    {\"input\": \"enthusiastic\", \"output\": \"apathetic\"})print(similar_prompt.format(adjective=\"passionate\"))\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/tools_builtin/",
  "markdown": "# giscus\n\n[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/langchain-ai/langchain/blob/master/docs/docs/how_to/tools_builtin.ipynb)[![Open on GitHub](https://img.shields.io/badge/Open%20on%20GitHub-grey?logo=github&logoColor=white)](https://github.com/langchain-ai/langchain/blob/master/docs/docs/how_to/tools_builtin.ipynb)\n\n## How to use built-in tools and toolkits\n\nLangChain has a large collection of 3rd party tools. Please visit [Tool Integrations](https://python.langchain.com/docs/integrations/tools/) for a list of the available tools.\n\nimportant\n\nWhen using 3rd party tools, make sure that you understand how the tool works, what permissions it has. Read over its documentation and check if anything is required from you from a security point of view. Please see our [security](https://python.langchain.com/docs/security/) guidelines for more information.\n\nLet's try out the [Wikipedia integration](https://python.langchain.com/docs/integrations/tools/wikipedia/).\n\n```\n!pip install -qU langchain-community wikipedia\n```\n\n```\nfrom langchain_community.tools import WikipediaQueryRunfrom langchain_community.utilities import WikipediaAPIWrapperapi_wrapper = WikipediaAPIWrapper(top_k_results=1, doc_content_chars_max=100)tool = WikipediaQueryRun(api_wrapper=api_wrapper)print(tool.invoke({\"query\": \"langchain\"}))\n```\n\n```\nPage: LangChainSummary: LangChain is a framework designed to simplify the creation of applications\n```\n\nThe tool has the following defaults associated with it:\n\n```\nprint(f\"Name: {tool.name}\")print(f\"Description: {tool.description}\")print(f\"args schema: {tool.args}\")print(f\"returns directly?: {tool.return_direct}\")\n```\n\n```\nName: wikipediaDescription: A wrapper around Wikipedia. Useful for when you need to answer general questions about people, places, companies, facts, historical events, or other subjects. Input should be a search query.args schema: {'query': {'description': 'query to look up on wikipedia', 'title': 'Query', 'type': 'string'}}returns directly?: False\n```\n\nWe can also modify the built in name, description, and JSON schema of the arguments.\n\nWhen defining the JSON schema of the arguments, it is important that the inputs remain the same as the function, so you shouldn't change that. But you can define custom descriptions for each input easily.\n\n```\nfrom langchain_community.tools import WikipediaQueryRunfrom langchain_community.utilities import WikipediaAPIWrapperfrom pydantic import BaseModel, Fieldclass WikiInputs(BaseModel):    \"\"\"Inputs to the wikipedia tool.\"\"\"    query: str = Field(        description=\"query to look up in Wikipedia, should be 3 or less words\"    )tool = WikipediaQueryRun(    name=\"wiki-tool\",    description=\"look up things in wikipedia\",    args_schema=WikiInputs,    api_wrapper=api_wrapper,    return_direct=True,)print(tool.run(\"langchain\"))\n```\n\n```\nPage: LangChainSummary: LangChain is a framework designed to simplify the creation of applications\n```\n\n```\nprint(f\"Name: {tool.name}\")print(f\"Description: {tool.description}\")print(f\"args schema: {tool.args}\")print(f\"returns directly?: {tool.return_direct}\")\n```\n\n```\nName: wiki-toolDescription: look up things in wikipediaargs schema: {'query': {'description': 'query to look up in Wikipedia, should be 3 or less words', 'title': 'Query', 'type': 'string'}}returns directly?: True\n```\n\nToolkits are collections of tools that are designed to be used together for specific tasks. They have convenient loading methods.\n\nAll Toolkits expose a `get_tools` method which returns a list of tools.\n\nYou're usually meant to use them this way:\n\n```\n# Initialize a toolkittoolkit = ExampleTookit(...)# Get list of toolstools = toolkit.get_tools()\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/tools_chain/",
  "markdown": "# giscus\n\n## How to use tools in a chain\n\nIn this guide, we will go over the basic ways to create Chains and Agents that call [Tools](https://python.langchain.com/docs/concepts/tools/). Tools can be just about anything — APIs, functions, databases, etc. Tools allow us to extend the capabilities of a model beyond just outputting text/messages. The key to using models with tools is correctly prompting a model and parsing its response so that it chooses the right tools and provides the right inputs for them.\n\n## Setup[​](#setup \"Direct link to Setup\")\n\nWe'll need to install the following packages for this guide:\n\n```\n%pip install --upgrade --quiet langchain\n```\n\nIf you'd like to trace your runs in [LangSmith](https://docs.smith.langchain.com/) uncomment and set the following environment variables:\n\n```\nimport getpassimport os# os.environ[\"LANGCHAIN_TRACING_V2\"] = \"true\"# os.environ[\"LANGCHAIN_API_KEY\"] = getpass.getpass()\n```\n\nFirst, we need to create a tool to call. For this example, we will create a custom tool from a function. For more information on creating custom tools, please see [this guide](https://python.langchain.com/docs/how_to/custom_tools/).\n\n```\nfrom langchain_core.tools import tool@tooldef multiply(first_int: int, second_int: int) -> int:    \"\"\"Multiply two integers together.\"\"\"    return first_int * second_int\n```\n\n**API Reference:**[tool](https://python.langchain.com/api_reference/core/tools/langchain_core.tools.convert.tool.html)\n\n```\nprint(multiply.name)print(multiply.description)print(multiply.args)\n```\n\n```\nmultiplymultiply(first_int: int, second_int: int) -> int - Multiply two integers together.{'first_int': {'title': 'First Int', 'type': 'integer'}, 'second_int': {'title': 'Second Int', 'type': 'integer'}}\n```\n\n```\nmultiply.invoke({\"first_int\": 4, \"second_int\": 5})\n```\n\n## Chains[​](#chains \"Direct link to Chains\")\n\nIf we know that we only need to use a tool a fixed number of times, we can create a chain for doing so. Let's create a simple chain that just multiplies user-specified numbers.\n\n![chain](https://python.langchain.com/assets/images/tool_chain-3571e7fbc481d648aff93a2630f812ab.svg)\n\n### Tool/function calling[​](#toolfunction-calling \"Direct link to Tool/function calling\")\n\nOne of the most reliable ways to use tools with LLMs is with [tool calling](https://python.langchain.com/docs/concepts/tool_calling/) APIs (also sometimes called function calling). This only works with models that explicitly support tool calling. You can see which models support tool calling [here](https://python.langchain.com/docs/integrations/chat/), and learn more about how to use tool calling in [this guide](https://python.langchain.com/docs/how_to/function_calling/).\n\nFirst we'll define our model and tools. We'll start with just a single tool, `multiply`.\n\n```\npip install -qU langchain-openai\n```\n\n```\nimport getpassimport osif not os.environ.get(\"OPENAI_API_KEY\"):  os.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"Enter API key for OpenAI: \")from langchain_openai import ChatOpenAIllm = ChatOpenAI(model=\"gpt-4o-mini\")\n```\n\nWe'll use `bind_tools` to pass the definition of our tool in as part of each call to the model, so that the model can invoke the tool when appropriate:\n\n```\nllm_with_tools = llm.bind_tools([multiply])\n```\n\nWhen the model invokes the tool, this will show up in the `AIMessage.tool_calls` attribute of the output:\n\n```\nmsg = llm_with_tools.invoke(\"whats 5 times forty two\")msg.tool_calls\n```\n\n```\n[{'name': 'multiply',  'args': {'first_int': 5, 'second_int': 42},  'id': 'call_cCP9oA3tRz7HDrjFn1FdmDaG'}]\n```\n\nCheck out the [LangSmith trace here](https://smith.langchain.com/public/81ff0cbd-e05b-4720-bf61-2c9807edb708/r).\n\n### Invoking the tool[​](#invoking-the-tool \"Direct link to Invoking the tool\")\n\nGreat! We're able to generate tool invocations. But what if we want to actually call the tool? To do so we'll need to pass the generated tool args to our tool. As a simple example we'll just extract the arguments of the first tool\\_call:\n\n```\nfrom operator import itemgetterchain = llm_with_tools | (lambda x: x.tool_calls[0][\"args\"]) | multiplychain.invoke(\"What's four times 23\")\n```\n\nCheck out the [LangSmith trace here](https://smith.langchain.com/public/16bbabb9-fc9b-41e5-a33d-487c42df4f85/r).\n\n## Agents[​](#agents \"Direct link to Agents\")\n\nChains are great when we know the specific sequence of tool usage needed for any user input. But for certain use cases, how many times we use tools depends on the input. In these cases, we want to let the model itself decide how many times to use tools and in what order. [Agents](https://python.langchain.com/docs/tutorials/agents/) let us do just this.\n\nLangChain comes with a number of built-in agents that are optimized for different use cases. Read about all the [agent types here](https://python.langchain.com/docs/concepts/agents/).\n\nWe'll use the [tool calling agent](https://python.langchain.com/api_reference/langchain/agents/langchain.agents.tool_calling_agent.base.create_tool_calling_agent.html), which is generally the most reliable kind and the recommended one for most use cases.\n\n![agent](https://python.langchain.com/assets/images/tool_agent-d25fafc271da3ee950ac1fba59cdf490.svg)\n\n```\nfrom langchain import hubfrom langchain.agents import AgentExecutor, create_tool_calling_agent\n```\n\n```\n# Get the prompt to use - can be replaced with any prompt that includes variables \"agent_scratchpad\" and \"input\"!prompt = hub.pull(\"hwchase17/openai-tools-agent\")prompt.pretty_print()\n```\n\n```\n================================\u001b[1m System Message \u001b[0m================================You are a helpful assistant=============================\u001b[1m Messages Placeholder \u001b[0m=============================\u001b[33;1m\u001b[1;3m{chat_history}\u001b[0m================================\u001b[1m Human Message \u001b[0m=================================\u001b[33;1m\u001b[1;3m{input}\u001b[0m=============================\u001b[1m Messages Placeholder \u001b[0m=============================\u001b[33;1m\u001b[1;3m{agent_scratchpad}\u001b[0m\n```\n\nAgents are also great because they make it easy to use multiple tools.\n\n```\n@tooldef add(first_int: int, second_int: int) -> int:    \"Add two integers.\"    return first_int + second_int@tooldef exponentiate(base: int, exponent: int) -> int:    \"Exponentiate the base to the exponent power.\"    return base**exponenttools = [multiply, add, exponentiate]\n```\n\n```\n# Construct the tool calling agentagent = create_tool_calling_agent(llm, tools, prompt)\n```\n\n```\n# Create an agent executor by passing in the agent and toolsagent_executor = AgentExecutor(agent=agent, tools=tools, verbose=True)\n```\n\nWith an agent, we can ask questions that require arbitrarily-many uses of our tools:\n\n```\nagent_executor.invoke(    {        \"input\": \"Take 3 to the fifth power and multiply that by the sum of twelve and three, then square the whole result\"    })\n```\n\n```\n\u001b[1m> Entering new AgentExecutor chain...\u001b[0m\u001b[32;1m\u001b[1;3mInvoking: `exponentiate` with `{'base': 3, 'exponent': 5}`\u001b[0m\u001b[38;5;200m\u001b[1;3m243\u001b[0m\u001b[32;1m\u001b[1;3mInvoking: `add` with `{'first_int': 12, 'second_int': 3}`\u001b[0m\u001b[33;1m\u001b[1;3m15\u001b[0m\u001b[32;1m\u001b[1;3mInvoking: `multiply` with `{'first_int': 243, 'second_int': 15}`\u001b[0m\u001b[36;1m\u001b[1;3m3645\u001b[0m\u001b[32;1m\u001b[1;3mInvoking: `exponentiate` with `{'base': 405, 'exponent': 2}`\u001b[0m\u001b[38;5;200m\u001b[1;3m13286025\u001b[0m\u001b[32;1m\u001b[1;3mThe result of taking 3 to the fifth power is 243. The sum of twelve and three is 15. Multiplying 243 by 15 gives 3645. Finally, squaring 3645 gives 13286025.\u001b[0m\u001b[1m> Finished chain.\u001b[0m\n```\n\n```\n{'input': 'Take 3 to the fifth power and multiply that by the sum of twelve and three, then square the whole result', 'output': 'The result of taking 3 to the fifth power is 243. \\n\\nThe sum of twelve and three is 15. \\n\\nMultiplying 243 by 15 gives 3645. \\n\\nFinally, squaring 3645 gives 13286025.'}\n```\n\nCheck out the [LangSmith trace here](https://smith.langchain.com/public/eeeb27a4-a2f8-4f06-a3af-9c983f76146c/r)."
},
{
  "url": "https://python.langchain.com/docs/how_to/custom_retriever/",
  "markdown": "# giscus\n\n[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/langchain-ai/langchain/blob/master/docs/docs/how_to/custom_retriever.ipynb)[![Open on GitHub](https://img.shields.io/badge/Open%20on%20GitHub-grey?logo=github&logoColor=white)](https://github.com/langchain-ai/langchain/blob/master/docs/docs/how_to/custom_retriever.ipynb)\n\n## How to create a custom Retriever\n\n## Overview[​](#overview \"Direct link to Overview\")\n\nMany LLM applications involve retrieving information from external data sources using a [Retriever](https://python.langchain.com/docs/concepts/retrievers/).\n\nA retriever is responsible for retrieving a list of relevant [Documents](https://python.langchain.com/api_reference/core/documents/langchain_core.documents.base.Document.html) to a given user `query`.\n\nThe retrieved documents are often formatted into prompts that are fed into an LLM, allowing the LLM to use the information in the to generate an appropriate response (e.g., answering a user question based on a knowledge base).\n\n## Interface[​](#interface \"Direct link to Interface\")\n\nTo create your own retriever, you need to extend the `BaseRetriever` class and implement the following methods:\n\n| Method | Description | Required/Optional |\n| --- | --- | --- |\n| `_get_relevant_documents` | Get documents relevant to a query. | Required |\n| `_aget_relevant_documents` | Implement to provide async native support. | Optional |\n\nThe logic inside of `_get_relevant_documents` can involve arbitrary calls to a database or to the web using requests.\n\ntip\n\nBy inherting from `BaseRetriever`, your retriever automatically becomes a LangChain [Runnable](https://python.langchain.com/docs/concepts/runnables/) and will gain the standard `Runnable` functionality out of the box!\n\ninfo\n\nYou can use a `RunnableLambda` or `RunnableGenerator` to implement a retriever.\n\nThe main benefit of implementing a retriever as a `BaseRetriever` vs. a `RunnableLambda` (a custom [runnable function](https://python.langchain.com/docs/how_to/functions/)) is that a `BaseRetriever` is a well known LangChain entity so some tooling for monitoring may implement specialized behavior for retrievers. Another difference is that a `BaseRetriever` will behave slightly differently from `RunnableLambda` in some APIs; e.g., the `start` event in `astream_events` API will be `on_retriever_start` instead of `on_chain_start`.\n\n## Example[​](#example \"Direct link to Example\")\n\nLet's implement a toy retriever that returns all documents whose text contains the text in the user query.\n\n```\nfrom typing import Listfrom langchain_core.callbacks import CallbackManagerForRetrieverRunfrom langchain_core.documents import Documentfrom langchain_core.retrievers import BaseRetrieverclass ToyRetriever(BaseRetriever):    \"\"\"A toy retriever that contains the top k documents that contain the user query.    This retriever only implements the sync method _get_relevant_documents.    If the retriever were to involve file access or network access, it could benefit    from a native async implementation of `_aget_relevant_documents`.    As usual, with Runnables, there's a default async implementation that's provided    that delegates to the sync implementation running on another thread.    \"\"\"    documents: List[Document]    \"\"\"List of documents to retrieve from.\"\"\"    k: int    \"\"\"Number of top results to return\"\"\"    def _get_relevant_documents(        self, query: str, *, run_manager: CallbackManagerForRetrieverRun    ) -> List[Document]:        \"\"\"Sync implementations for retriever.\"\"\"        matching_documents = []        for document in documents:            if len(matching_documents) > self.k:                return matching_documents            if query.lower() in document.page_content.lower():                matching_documents.append(document)        return matching_documents    # Optional: Provide a more efficient native implementation by overriding    # _aget_relevant_documents    # async def _aget_relevant_documents(    #     self, query: str, *, run_manager: AsyncCallbackManagerForRetrieverRun    # ) -> List[Document]:    #     \"\"\"Asynchronously get documents relevant to a query.    #     Args:    #         query: String to find relevant documents for    #         run_manager: The callbacks handler to use    #     Returns:    #         List of relevant documents    #     \"\"\"\n```\n\n## Test it 🧪[​](#test-it- \"Direct link to Test it 🧪\")\n\n```\ndocuments = [    Document(        page_content=\"Dogs are great companions, known for their loyalty and friendliness.\",        metadata={\"type\": \"dog\", \"trait\": \"loyalty\"},    ),    Document(        page_content=\"Cats are independent pets that often enjoy their own space.\",        metadata={\"type\": \"cat\", \"trait\": \"independence\"},    ),    Document(        page_content=\"Goldfish are popular pets for beginners, requiring relatively simple care.\",        metadata={\"type\": \"fish\", \"trait\": \"low maintenance\"},    ),    Document(        page_content=\"Parrots are intelligent birds capable of mimicking human speech.\",        metadata={\"type\": \"bird\", \"trait\": \"intelligence\"},    ),    Document(        page_content=\"Rabbits are social animals that need plenty of space to hop around.\",        metadata={\"type\": \"rabbit\", \"trait\": \"social\"},    ),]retriever = ToyRetriever(documents=documents, k=3)\n```\n\n```\n[Document(page_content='Cats are independent pets that often enjoy their own space.', metadata={'type': 'cat', 'trait': 'independence'}), Document(page_content='Rabbits are social animals that need plenty of space to hop around.', metadata={'type': 'rabbit', 'trait': 'social'})]\n```\n\nIt's a **runnable** so it'll benefit from the standard Runnable Interface! 🤩\n\n```\nawait retriever.ainvoke(\"that\")\n```\n\n```\n[Document(page_content='Cats are independent pets that often enjoy their own space.', metadata={'type': 'cat', 'trait': 'independence'}), Document(page_content='Rabbits are social animals that need plenty of space to hop around.', metadata={'type': 'rabbit', 'trait': 'social'})]\n```\n\n```\nretriever.batch([\"dog\", \"cat\"])\n```\n\n```\n[[Document(page_content='Dogs are great companions, known for their loyalty and friendliness.', metadata={'type': 'dog', 'trait': 'loyalty'})], [Document(page_content='Cats are independent pets that often enjoy their own space.', metadata={'type': 'cat', 'trait': 'independence'})]]\n```\n\n```\nasync for event in retriever.astream_events(\"bar\", version=\"v1\"):    print(event)\n```\n\n```\n{'event': 'on_retriever_start', 'run_id': 'f96f268d-8383-4921-b175-ca583924d9ff', 'name': 'ToyRetriever', 'tags': [], 'metadata': {}, 'data': {'input': 'bar'}}{'event': 'on_retriever_stream', 'run_id': 'f96f268d-8383-4921-b175-ca583924d9ff', 'tags': [], 'metadata': {}, 'name': 'ToyRetriever', 'data': {'chunk': []}}{'event': 'on_retriever_end', 'name': 'ToyRetriever', 'run_id': 'f96f268d-8383-4921-b175-ca583924d9ff', 'tags': [], 'metadata': {}, 'data': {'output': []}}\n```\n\n## Contributing[​](#contributing \"Direct link to Contributing\")\n\nWe appreciate contributions of interesting retrievers!\n\nHere's a checklist to help make sure your contribution gets added to LangChain:\n\nDocumentation:\n\n*   The retriever contains doc-strings for all initialization arguments, as these will be surfaced in the [API Reference](https://python.langchain.com/api_reference/langchain/index.html).\n*   The class doc-string for the model contains a link to any relevant APIs used for the retriever (e.g., if the retriever is retrieving from wikipedia, it'll be good to link to the wikipedia API!)\n\nTests:\n\n*   Add unit or integration tests to verify that `invoke` and `ainvoke` work.\n\nOptimizations:\n\nIf the retriever is connecting to external data sources (e.g., an API or a file), it'll almost certainly benefit from an async native optimization!\n\n*   Provide a native async implementation of `_aget_relevant_documents` (used by `ainvoke`)"
},
{
  "url": "https://python.langchain.com/docs/how_to/qa_citations/",
  "markdown": "# giscus\n\n## How to get a RAG application to add citations\n\nThis guide reviews methods to get a model to cite which parts of the source documents it referenced in generating its response.\n\nWe will cover five methods:\n\n1.  Using tool-calling to cite document IDs;\n2.  Using tool-calling to cite documents IDs and provide text snippets;\n3.  Direct prompting;\n4.  Retrieval post-processing (i.e., compressing the retrieved context to make it more relevant);\n5.  Generation post-processing (i.e., issuing a second LLM call to annotate a generated answer with citations).\n\nWe generally suggest using the first item of the list that works for your use-case. That is, if your model supports tool-calling, try methods 1 or 2; otherwise, or if those fail, advance down the list.\n\nLet's first create a simple [RAG](https://python.langchain.com/docs/concepts/rag/) chain. To start we'll just retrieve from Wikipedia using the [WikipediaRetriever](https://python.langchain.com/api_reference/community/retrievers/langchain_community.retrievers.wikipedia.WikipediaRetriever.html). We will use the same [LangGraph](https://python.langchain.com/docs/concepts/architecture/#langgraph) implementation from the [RAG Tutorial](https://python.langchain.com/docs/tutorials/rag/).\n\n## Setup[​](#setup \"Direct link to Setup\")\n\nFirst we'll need to install some dependencies:\n\n```\n%pip install -qU langchain-community wikipedia\n```\n\nLet's first select a LLM:\n\n```\npip install -qU langchain-openai\n```\n\n```\nimport getpassimport osif not os.environ.get(\"OPENAI_API_KEY\"):  os.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"Enter API key for OpenAI: \")from langchain_openai import ChatOpenAIllm = ChatOpenAI(model=\"gpt-4o-mini\")\n```\n\nWe can now load a [retriever](https://python.langchain.com/docs/concepts/retrievers/) and construct our [prompt](https://python.langchain.com/docs/concepts/prompt_templates/):\n\n```\nfrom langchain_community.retrievers import WikipediaRetrieverfrom langchain_core.prompts import ChatPromptTemplatesystem_prompt = (    \"You're a helpful AI assistant. Given a user question \"    \"and some Wikipedia article snippets, answer the user \"    \"question. If none of the articles answer the question, \"    \"just say you don't know.\"    \"\\n\\nHere are the Wikipedia articles: \"    \"{context}\")retriever = WikipediaRetriever(top_k_results=6, doc_content_chars_max=2000)prompt = ChatPromptTemplate.from_messages(    [        (\"system\", system_prompt),        (\"human\", \"{question}\"),    ])prompt.pretty_print()\n```\n\n```\n================================\u001b[1m System Message \u001b[0m================================You're a helpful AI assistant. Given a user question and some Wikipedia article snippets, answer the user question. If none of the articles answer the question, just say you don't know.Here are the Wikipedia articles: \u001b[33;1m\u001b[1;3m{context}\u001b[0m================================\u001b[1m Human Message \u001b[0m=================================\u001b[33;1m\u001b[1;3m{question}\u001b[0m\n```\n\nNow that we've got a [model](https://python.langchain.com/docs/concepts/chat_models/), [retriver](https://python.langchain.com/docs/concepts/retrievers/) and [prompt](https://python.langchain.com/docs/concepts/prompt_templates/), let's chain them all together. Following the how-to guide on [adding citations](https://python.langchain.com/docs/how_to/qa_citations/) to a RAG application, we'll make it so our chain returns both the answer and the retrieved Documents. This uses the same [LangGraph](https://python.langchain.com/docs/concepts/architecture/#langgraph) implementation as in the [RAG Tutorial](https://python.langchain.com/docs/tutorials/rag/).\n\n```\nfrom langchain_core.documents import Documentfrom langgraph.graph import START, StateGraphfrom typing_extensions import List, TypedDict# Define state for applicationclass State(TypedDict):    question: str    context: List[Document]    answer: str# Define application stepsdef retrieve(state: State):    retrieved_docs = retriever.invoke(state[\"question\"])    return {\"context\": retrieved_docs}def generate(state: State):    docs_content = \"\\n\\n\".join(doc.page_content for doc in state[\"context\"])    messages = prompt.invoke({\"question\": state[\"question\"], \"context\": docs_content})    response = llm.invoke(messages)    return {\"answer\": response.content}# Compile application and testgraph_builder = StateGraph(State).add_sequence([retrieve, generate])graph_builder.add_edge(START, \"retrieve\")graph = graph_builder.compile()\n```\n\n```\nfrom IPython.display import Image, displaydisplay(Image(graph.get_graph().draw_mermaid_png()))\n```\n\n![](data:image/png;base64,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)\n\n```\nresult = graph.invoke({\"question\": \"How fast are cheetahs?\"})sources = [doc.metadata[\"source\"] for doc in result[\"context\"]]print(f\"Sources: {sources}\\n\\n\")print(f'Answer: {result[\"answer\"]}')\n```\n\n```\nSources: ['https://en.wikipedia.org/wiki/Cheetah', 'https://en.wikipedia.org/wiki/Southeast_African_cheetah', 'https://en.wikipedia.org/wiki/Footspeed', 'https://en.wikipedia.org/wiki/Fastest_animals', 'https://en.wikipedia.org/wiki/Pursuit_predation', 'https://en.wikipedia.org/wiki/Gepard-class_fast_attack_craft']Answer: Cheetahs are capable of running at speeds between 93 to 104 km/h (58 to 65 mph).\n```\n\nCheck out the [LangSmith trace](https://smith.langchain.com/public/ed043789-8599-44de-b88e-ba463ea454a3/r).\n\nIf your LLM of choice implements a [tool-calling](https://python.langchain.com/docs/concepts/tool_calling/) feature, you can use it to make the model specify which of the provided documents it's referencing when generating its answer. LangChain tool-calling models implement a `.with_structured_output` method which will force generation adhering to a desired schema (see details [here](https://python.langchain.com/docs/how_to/structured_output/)).\n\n### Cite documents[​](#cite-documents \"Direct link to Cite documents\")\n\nTo cite documents using an identifier, we format the identifiers into the prompt, then use `.with_structured_output` to coerce the LLM to reference these identifiers in its output.\n\nFirst we define a schema for the output. The `.with_structured_output` supports multiple formats, including JSON schema and Pydantic. Here we will use Pydantic:\n\n```\nfrom pydantic import BaseModel, Fieldclass CitedAnswer(BaseModel):    \"\"\"Answer the user question based only on the given sources, and cite the sources used.\"\"\"    answer: str = Field(        ...,        description=\"The answer to the user question, which is based only on the given sources.\",    )    citations: List[int] = Field(        ...,        description=\"The integer IDs of the SPECIFIC sources which justify the answer.\",    )\n```\n\nLet's see what the model output is like when we pass in our functions and a user input:\n\n```\nstructured_llm = llm.with_structured_output(CitedAnswer)example_q = \"\"\"What Brian's height?Source: 1Information: Suzy is 6'2\"Source: 2Information: Jeremiah is blondeSource: 3Information: Brian is 3 inches shorter than Suzy\"\"\"result = structured_llm.invoke(example_q)result\n```\n\n```\nCitedAnswer(answer='Brian is 5\\'11\".', citations=[1, 3])\n```\n\nOr as a dict:\n\n```\n{'answer': 'Brian is 5\\'11\".', 'citations': [1, 3]}\n```\n\nNow we structure the source identifiers into the prompt to replicate with our chain. We will make three changes:\n\n1.  Update the prompt to include source identifiers;\n2.  Use the `structured_llm` (i.e., `llm.with_structured_output(CitedAnswer)`);\n3.  Return the Pydantic object in the output.\n\n```\ndef format_docs_with_id(docs: List[Document]) -> str:    formatted = [        f\"Source ID: {i}\\nArticle Title: {doc.metadata['title']}\\nArticle Snippet: {doc.page_content}\"        for i, doc in enumerate(docs)    ]    return \"\\n\\n\" + \"\\n\\n\".join(formatted)class State(TypedDict):    question: str    context: List[Document]    answer: CitedAnswerdef generate(state: State):    formatted_docs = format_docs_with_id(state[\"context\"])    messages = prompt.invoke({\"question\": state[\"question\"], \"context\": formatted_docs})    structured_llm = llm.with_structured_output(CitedAnswer)    response = structured_llm.invoke(messages)    return {\"answer\": response}graph_builder = StateGraph(State).add_sequence([retrieve, generate])graph_builder.add_edge(START, \"retrieve\")graph = graph_builder.compile()\n```\n\n```\nresult = graph.invoke({\"question\": \"How fast are cheetahs?\"})result[\"answer\"]\n```\n\n```\nCitedAnswer(answer='Cheetahs are capable of running at speeds between 93 to 104 km/h (58 to 65 mph).', citations=[0, 3])\n```\n\nWe can inspect the document at index 0, which the model cited:\n\n```\nprint(result[\"context\"][0])\n```\n\n```\npage_content='The cheetah (Acinonyx jubatus) is a large cat and the fastest land animal. It has a tawny to creamy white or pale buff fur that is marked with evenly spaced, solid black spots. The head is small and rounded, with a short snout and black tear-like facial streaks. It reaches 67–94 cm (26–37 in) at the shoulder, and the head-and-body length is between 1.1 and 1.5 m (3 ft 7 in and 4 ft 11 in). Adults weigh between 21 and 72 kg (46 and 159 lb). The cheetah is capable of running at 93 to 104 km/h (58 to 65 mph); it has evolved specialized adaptations for speed, including a light build, long thin legs and a long tail.The cheetah was first described in the late 18th century. Four subspecies are recognised today that are native to Africa and central Iran. An African subspecies was introduced to India in 2022. It is now distributed mainly in small, fragmented populations in northwestern, eastern and southern Africa and central Iran. It lives in a variety of habitats such as savannahs in the Serengeti, arid mountain ranges in the Sahara, and hilly desert terrain.The cheetah lives in three main social groups: females and their cubs, male \"coalitions\", and solitary males. While females lead a nomadic life searching for prey in large home ranges, males are more sedentary and instead establish much smaller territories in areas with plentiful prey and access to females. The cheetah is active during the day, with peaks during dawn and dusk. It feeds on small- to medium-sized prey, mostly weighing under 40 kg (88 lb), and prefers medium-sized ungulates such as impala, springbok and Thomson's gazelles. The cheetah typically stalks its prey within 60–100 m (200–330 ft) before charging towards it, trips it during the chase and bites its throat to suffocate it to death. It breeds throughout the year. After a gestation of nearly three months, females give birth to a litter of three or four cubs. Cheetah cubs are highly vulnerable to predation by other large carnivores. They are weaned a' metadata={'title': 'Cheetah', 'summary': 'The cheetah (Acinonyx jubatus) is a large cat and the fastest land animal. It has a tawny to creamy white or pale buff fur that is marked with evenly spaced, solid black spots. The head is small and rounded, with a short snout and black tear-like facial streaks. It reaches 67–94 cm (26–37 in) at the shoulder, and the head-and-body length is between 1.1 and 1.5 m (3 ft 7 in and 4 ft 11 in). Adults weigh between 21 and 72 kg (46 and 159 lb). The cheetah is capable of running at 93 to 104 km/h (58 to 65 mph); it has evolved specialized adaptations for speed, including a light build, long thin legs and a long tail.\\nThe cheetah was first described in the late 18th century. Four subspecies are recognised today that are native to Africa and central Iran. An African subspecies was introduced to India in 2022. It is now distributed mainly in small, fragmented populations in northwestern, eastern and southern Africa and central Iran. It lives in a variety of habitats such as savannahs in the Serengeti, arid mountain ranges in the Sahara, and hilly desert terrain.\\nThe cheetah lives in three main social groups: females and their cubs, male \"coalitions\", and solitary males. While females lead a nomadic life searching for prey in large home ranges, males are more sedentary and instead establish much smaller territories in areas with plentiful prey and access to females. The cheetah is active during the day, with peaks during dawn and dusk. It feeds on small- to medium-sized prey, mostly weighing under 40 kg (88 lb), and prefers medium-sized ungulates such as impala, springbok and Thomson\\'s gazelles. The cheetah typically stalks its prey within 60–100 m (200–330 ft) before charging towards it, trips it during the chase and bites its throat to suffocate it to death. It breeds throughout the year. After a gestation of nearly three months, females give birth to a litter of three or four cubs. Cheetah cubs are highly vulnerable to predation by other large carnivores. They are weaned at around four months and are independent by around 20 months of age.\\nThe cheetah is threatened by habitat loss, conflict with humans, poaching and high susceptibility to diseases. The global cheetah population was estimated in 2021 at 6,517; it is listed as Vulnerable on the IUCN Red List. It has been widely depicted in art, literature, advertising, and animation. It was tamed in ancient Egypt and trained for hunting ungulates in the Arabian Peninsula and India. It has been kept in zoos since the early 19th century.', 'source': 'https://en.wikipedia.org/wiki/Cheetah'}\n```\n\nLangSmith trace: [https://smith.langchain.com/public/6f34d136-451d-4625-90c8-2d8decebc21a/r](https://smith.langchain.com/public/6f34d136-451d-4625-90c8-2d8decebc21a/r)\n\n### Cite snippets[​](#cite-snippets \"Direct link to Cite snippets\")\n\nTo return text spans (perhaps in addition to source identifiers), we can use the same approach. The only change will be to build a more complex output schema, here using Pydantic, that includes a \"quote\" alongside a source identifier.\n\n_Aside: Note that if we break up our documents so that we have many documents with only a sentence or two instead of a few long documents, citing documents becomes roughly equivalent to citing snippets, and may be easier for the model because the model just needs to return an identifier for each snippet instead of the actual text. Probably worth trying both approaches and evaluating._\n\n```\nclass Citation(BaseModel):    source_id: int = Field(        ...,        description=\"The integer ID of a SPECIFIC source which justifies the answer.\",    )    quote: str = Field(        ...,        description=\"The VERBATIM quote from the specified source that justifies the answer.\",    )class QuotedAnswer(BaseModel):    \"\"\"Answer the user question based only on the given sources, and cite the sources used.\"\"\"    answer: str = Field(        ...,        description=\"The answer to the user question, which is based only on the given sources.\",    )    citations: List[Citation] = Field(        ..., description=\"Citations from the given sources that justify the answer.\"    )\n```\n\n```\nclass State(TypedDict):    question: str    context: List[Document]    answer: QuotedAnswerdef generate(state: State):    formatted_docs = format_docs_with_id(state[\"context\"])    messages = prompt.invoke({\"question\": state[\"question\"], \"context\": formatted_docs})    structured_llm = llm.with_structured_output(QuotedAnswer)    response = structured_llm.invoke(messages)    return {\"answer\": response}graph_builder = StateGraph(State).add_sequence([retrieve, generate])graph_builder.add_edge(START, \"retrieve\")graph = graph_builder.compile()\n```\n\nHere we see that the model has extracted a relevant snippet of text from source 0:\n\n```\nresult = graph.invoke({\"question\": \"How fast are cheetahs?\"})result[\"answer\"]\n```\n\n```\nQuotedAnswer(answer='Cheetahs are capable of running at speeds of 93 to 104 km/h (58 to 65 mph).', citations=[Citation(source_id=0, quote='The cheetah is capable of running at 93 to 104 km/h (58 to 65 mph); it has evolved specialized adaptations for speed.')])\n```\n\nLangSmith trace: [https://smith.langchain.com/public/e16dc72f-4261-4f25-a9a7-906238737283/r](https://smith.langchain.com/public/e16dc72f-4261-4f25-a9a7-906238737283/r)\n\n## Direct prompting[​](#direct-prompting \"Direct link to Direct prompting\")\n\nSome models don't support function-calling. We can achieve similar results with direct prompting. Let's try instructing a model to generate structured XML for its output:\n\n```\nxml_system = \"\"\"You're a helpful AI assistant. Given a user question and some Wikipedia article snippets, \\answer the user question and provide citations. If none of the articles answer the question, just say you don't know.Remember, you must return both an answer and citations. A citation consists of a VERBATIM quote that \\justifies the answer and the ID of the quote article. Return a citation for every quote across all articles \\that justify the answer. Use the following format for your final output:<cited_answer>    <answer></answer>    <citations>        <citation><source_id></source_id><quote></quote></citation>        <citation><source_id></source_id><quote></quote></citation>        ...    </citations></cited_answer>Here are the Wikipedia articles:{context}\"\"\"xml_prompt = ChatPromptTemplate.from_messages(    [(\"system\", xml_system), (\"human\", \"{question}\")])\n```\n\nWe now make similar small updates to our chain:\n\n1.  We update the formatting function to wrap the retrieved context in XML tags;\n2.  We do not use `.with_structured_output` (e.g., because it does not exist for a model);\n3.  We use [XMLOutputParser](https://python.langchain.com/api_reference/core/output_parsers/langchain_core.output_parsers.xml.XMLOutputParser.html) to parse the answer into a dict.\n\n```\nfrom langchain_core.output_parsers import XMLOutputParserdef format_docs_xml(docs: List[Document]) -> str:    formatted = []    for i, doc in enumerate(docs):        doc_str = f\"\"\"\\    <source id=\\\"{i}\\\">        <title>{doc.metadata['title']}</title>        <article_snippet>{doc.page_content}</article_snippet>    </source>\"\"\"        formatted.append(doc_str)    return \"\\n\\n<sources>\" + \"\\n\".join(formatted) + \"</sources>\"class State(TypedDict):    question: str    context: List[Document]    answer: dictdef generate(state: State):    formatted_docs = format_docs_xml(state[\"context\"])    messages = xml_prompt.invoke(        {\"question\": state[\"question\"], \"context\": formatted_docs}    )    response = llm.invoke(messages)    parsed_response = XMLOutputParser().invoke(response)    return {\"answer\": parsed_response}graph_builder = StateGraph(State).add_sequence([retrieve, generate])graph_builder.add_edge(START, \"retrieve\")graph = graph_builder.compile()\n```\n\nNote that citations are again structured into the answer:\n\n```\nresult = graph.invoke({\"question\": \"How fast are cheetahs?\"})result[\"answer\"]\n```\n\n```\n{'cited_answer': [{'answer': 'Cheetahs can run at speeds of 93 to 104 km/h (58 to 65 mph).'},  {'citations': [{'citation': [{'source_id': '0'},      {'quote': 'The cheetah is capable of running at 93 to 104 km/h (58 to 65 mph);'}]},    {'citation': [{'source_id': '3'},      {'quote': 'The fastest land animal is the cheetah.'}]}]}]}\n```\n\nLangSmith trace: [https://smith.langchain.com/public/0c45f847-c640-4b9a-a5fa-63559e413527/r](https://smith.langchain.com/public/0c45f847-c640-4b9a-a5fa-63559e413527/r)\n\n## Retrieval post-processing[​](#retrieval-post-processing \"Direct link to Retrieval post-processing\")\n\nAnother approach is to post-process our retrieved documents to compress the content, so that the source content is already minimal enough that we don't need the model to cite specific sources or spans. For example, we could break up each document into a sentence or two, embed those and keep only the most relevant ones. LangChain has some built-in components for this. Here we'll use a [RecursiveCharacterTextSplitter](https://python.langchain.com/api_reference/text_splitters/text_splitter/langchain_text_splitters.RecursiveCharacterTextSplitter.html#langchain_text_splitters.RecursiveCharacterTextSplitter), which creates chunks of a specified size by splitting on separator substrings, and an [EmbeddingsFilter](https://python.langchain.com/api_reference/langchain/retrievers/langchain.retrievers.document_compressors.embeddings_filter.EmbeddingsFilter.html#langchain.retrievers.document_compressors.embeddings_filter.EmbeddingsFilter), which keeps only the texts with the most relevant embeddings.\n\nThis approach effectively updates our `retrieve` step to compress the documents. Let's first select an [embedding model](https://python.langchain.com/docs/integrations/text_embedding/):\n\n```\npip install -qU langchain-openai\n```\n\n```\nimport getpassimport osif not os.environ.get(\"OPENAI_API_KEY\"):  os.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"Enter API key for OpenAI: \")from langchain_openai import OpenAIEmbeddingsembeddings = OpenAIEmbeddings(model=\"text-embedding-3-large\")\n```\n\nWe can now rewrite the `retrieve` step:\n\n```\nfrom langchain.retrievers.document_compressors import EmbeddingsFilterfrom langchain_core.runnables import RunnableParallelfrom langchain_text_splitters import RecursiveCharacterTextSplittersplitter = RecursiveCharacterTextSplitter(    chunk_size=400,    chunk_overlap=0,    separators=[\"\\n\\n\", \"\\n\", \".\", \" \"],    keep_separator=False,)compressor = EmbeddingsFilter(embeddings=embeddings, k=10)class State(TypedDict):    question: str    context: List[Document]    answer: strdef retrieve(state: State):    retrieved_docs = retriever.invoke(state[\"question\"])    split_docs = splitter.split_documents(retrieved_docs)    stateful_docs = compressor.compress_documents(split_docs, state[\"question\"])    return {\"context\": stateful_docs}\n```\n\nLet's test this out:\n\n```\nretrieval_result = retrieve({\"question\": \"How fast are cheetahs?\"})for doc in retrieval_result[\"context\"]:    print(f\"{doc.page_content}\\n\\n\")\n```\n\n```\nAdults weigh between 21 and 72 kg (46 and 159 lb). The cheetah is capable of running at 93 to 104 km/h (58 to 65 mph); it has evolved specialized adaptations for speed, including a light build, long thin legs and a long tailThe cheetah (Acinonyx jubatus) is a large cat and the fastest land animal. It has a tawny to creamy white or pale buff fur that is marked with evenly spaced, solid black spots. The head is small and rounded, with a short snout and black tear-like facial streaks. It reaches 67–94 cm (26–37 in) at the shoulder, and the head-and-body length is between 1.1 and 1.5 m (3 ft 7 in and 4 ft 11 in)2 mph), or 171 body lengths per second. The cheetah, the fastest land mammal, scores at only 16 body lengths per secondIt feeds on small- to medium-sized prey, mostly weighing under 40 kg (88 lb), and prefers medium-sized ungulates such as impala, springbok and Thomson's gazelles. The cheetah typically stalks its prey within 60–100 m (200–330 ft) before charging towards it, trips it during the chase and bites its throat to suffocate it to death. It breeds throughout the yearThe cheetah was first described in the late 18th century. Four subspecies are recognised today that are native to Africa and central Iran. An African subspecies was introduced to India in 2022. It is now distributed mainly in small, fragmented populations in northwestern, eastern and southern Africa and central IranThe cheetah lives in three main social groups: females and their cubs, male \"coalitions\", and solitary males. While females lead a nomadic life searching for prey in large home ranges, males are more sedentary and instead establish much smaller territories in areas with plentiful prey and access to females. The cheetah is active during the day, with peaks during dawn and duskThe Southeast African cheetah (Acinonyx jubatus jubatus) is the nominate cheetah subspecies native to East and Southern Africa. The Southern African cheetah lives mainly in the lowland areas and deserts of the Kalahari, the savannahs of Okavango Delta, and the grasslands of the Transvaal region in South Africa. In Namibia, cheetahs are mostly found in farmlandsSubpopulations have been called \"South African cheetah\" and \"Namibian cheetah.\"In India, four cheetahs of the subspecies are living in Kuno National Park in Madhya Pradesh after having been introduced thereAcinonyx jubatus velox proposed in 1913 by Edmund Heller on basis of a cheetah that was shot by Kermit Roosevelt in June 1909 in the Kenyan highlands.Acinonyx rex proposed in 1927 by Reginald Innes Pocock on basis of a specimen from the Umvukwe Range in Rhodesia.\n```\n\nNext, we assemble it into our chain as before:\n\n```\n# This step is unchanged from our original RAG implementationdef generate(state: State):    docs_content = \"\\n\\n\".join(doc.page_content for doc in state[\"context\"])    messages = prompt.invoke({\"question\": state[\"question\"], \"context\": docs_content})    response = llm.invoke(messages)    return {\"answer\": response.content}graph_builder = StateGraph(State).add_sequence([retrieve, generate])graph_builder.add_edge(START, \"retrieve\")graph = graph_builder.compile()\n```\n\n```\nresult = graph.invoke({\"question\": \"How fast are cheetahs?\"})print(result[\"answer\"])\n```\n\n```\nCheetahs are capable of running at speeds between 93 to 104 km/h (58 to 65 mph). They are known as the fastest land animals.\n```\n\nNote that the document content is now compressed, although the document objects retain the original content in a \"summary\" key in their metadata. These summaries are not passed to the model; only the condensed content is.\n\n```\nresult[\"context\"][0].page_content  # passed to model\n```\n\n```\n'Adults weigh between 21 and 72 kg (46 and 159 lb). The cheetah is capable of running at 93 to 104 km/h (58 to 65 mph); it has evolved specialized adaptations for speed, including a light build, long thin legs and a long tail'\n```\n\n```\nresult[\"context\"][0].metadata[\"summary\"]  # original document  # original document\n```\n\n```\n'The cheetah (Acinonyx jubatus) is a large cat and the fastest land animal. It has a tawny to creamy white or pale buff fur that is marked with evenly spaced, solid black spots. The head is small and rounded, with a short snout and black tear-like facial streaks. It reaches 67–94 cm (26–37 in) at the shoulder, and the head-and-body length is between 1.1 and 1.5 m (3 ft 7 in and 4 ft 11 in). Adults weigh between 21 and 72 kg (46 and 159 lb). The cheetah is capable of running at 93 to 104 km/h (58 to 65 mph); it has evolved specialized adaptations for speed, including a light build, long thin legs and a long tail.\\nThe cheetah was first described in the late 18th century. Four subspecies are recognised today that are native to Africa and central Iran. An African subspecies was introduced to India in 2022. It is now distributed mainly in small, fragmented populations in northwestern, eastern and southern Africa and central Iran. It lives in a variety of habitats such as savannahs in the Serengeti, arid mountain ranges in the Sahara, and hilly desert terrain.\\nThe cheetah lives in three main social groups: females and their cubs, male \"coalitions\", and solitary males. While females lead a nomadic life searching for prey in large home ranges, males are more sedentary and instead establish much smaller territories in areas with plentiful prey and access to females. The cheetah is active during the day, with peaks during dawn and dusk. It feeds on small- to medium-sized prey, mostly weighing under 40 kg (88 lb), and prefers medium-sized ungulates such as impala, springbok and Thomson\\'s gazelles. The cheetah typically stalks its prey within 60–100 m (200–330 ft) before charging towards it, trips it during the chase and bites its throat to suffocate it to death. It breeds throughout the year. After a gestation of nearly three months, females give birth to a litter of three or four cubs. Cheetah cubs are highly vulnerable to predation by other large carnivores. They are weaned at around four months and are independent by around 20 months of age.\\nThe cheetah is threatened by habitat loss, conflict with humans, poaching and high susceptibility to diseases. The global cheetah population was estimated in 2021 at 6,517; it is listed as Vulnerable on the IUCN Red List. It has been widely depicted in art, literature, advertising, and animation. It was tamed in ancient Egypt and trained for hunting ungulates in the Arabian Peninsula and India. It has been kept in zoos since the early 19th century.'\n```\n\nLangSmith trace: [https://smith.langchain.com/public/21b0dc15-d70a-4293-9402-9c70f9178e66/r](https://smith.langchain.com/public/21b0dc15-d70a-4293-9402-9c70f9178e66/r)\n\n## Generation post-processing[​](#generation-post-processing \"Direct link to Generation post-processing\")\n\nAnother approach is to post-process our model generation. In this example we'll first generate just an answer, and then we'll ask the model to annotate it's own answer with citations. The downside of this approach is of course that it is slower and more expensive, because two model calls need to be made.\n\nLet's apply this to our initial chain. If desired, we can implement this via a third step in our application.\n\n```\nclass Citation(BaseModel):    source_id: int = Field(        ...,        description=\"The integer ID of a SPECIFIC source which justifies the answer.\",    )    quote: str = Field(        ...,        description=\"The VERBATIM quote from the specified source that justifies the answer.\",    )class AnnotatedAnswer(BaseModel):    \"\"\"Annotate the answer to the user question with quote citations that justify the answer.\"\"\"    citations: List[Citation] = Field(        ..., description=\"Citations from the given sources that justify the answer.\"    )structured_llm = llm.with_structured_output(AnnotatedAnswer)\n```\n\n```\nclass State(TypedDict):    question: str    context: List[Document]    answer: str    annotations: AnnotatedAnswerdef retrieve(state: State):    retrieved_docs = retriever.invoke(state[\"question\"])    return {\"context\": retrieved_docs}def generate(state: State):    docs_content = \"\\n\\n\".join(doc.page_content for doc in state[\"context\"])    messages = prompt.invoke({\"question\": state[\"question\"], \"context\": docs_content})    response = llm.invoke(messages)    return {\"answer\": response.content}def annotate(state: State):    formatted_docs = format_docs_with_id(state[\"context\"])    messages = [        (\"system\", system_prompt.format(context=formatted_docs)),        (\"human\", state[\"question\"]),        (\"ai\", state[\"answer\"]),        (\"human\", \"Annotate your answer with citations.\"),    ]    response = structured_llm.invoke(messages)    return {\"annotations\": response}graph_builder = StateGraph(State).add_sequence([retrieve, generate, annotate])graph_builder.add_edge(START, \"retrieve\")graph = graph_builder.compile()\n```\n\n```\ndisplay(Image(graph.get_graph().draw_mermaid_png()))\n```\n\n![](data:image/png;base64,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)\n\n```\nresult = graph.invoke({\"question\": \"How fast are cheetahs?\"})print(result[\"answer\"])\n```\n\n```\nCheetahs are capable of running at speeds between 93 to 104 km/h (58 to 65 mph).\n```\n\n```\nAnnotatedAnswer(citations=[Citation(source_id=0, quote='The cheetah is capable of running at 93 to 104 km/h (58 to 65 mph)')])\n```\n\nLangSmith trace: [https://smith.langchain.com/public/b8257417-573b-47c4-a750-74e542035f19/r](https://smith.langchain.com/public/b8257417-573b-47c4-a750-74e542035f19/r)"
},
{
  "url": "https://python.langchain.com/docs/how_to/extraction_examples/",
  "markdown": "# giscus\n\n## How to use reference examples when doing extraction\n\nThe quality of extractions can often be improved by providing reference examples to the LLM.\n\nData extraction attempts to generate [structured representations](https://python.langchain.com/docs/concepts/structured_outputs/) of information found in text and other unstructured or semi-structured formats. [Tool-calling](https://python.langchain.com/docs/concepts/tool_calling/) LLM features are often used in this context. This guide demonstrates how to build few-shot examples of tool calls to help steer the behavior of extraction and similar applications.\n\ntip\n\nWhile this guide focuses how to use examples with a tool calling model, this technique is generally applicable, and will work also with JSON more or prompt based techniques.\n\nLangChain implements a [tool-call attribute](https://python.langchain.com/api_reference/core/messages/langchain_core.messages.ai.AIMessage.html#langchain_core.messages.ai.AIMessage.tool_calls) on messages from LLMs that include tool calls. See our [how-to guide on tool calling](https://python.langchain.com/docs/how_to/tool_calling/) for more detail. To build reference examples for data extraction, we build a chat history containing a sequence of:\n\n*   [HumanMessage](https://python.langchain.com/api_reference/core/messages/langchain_core.messages.human.HumanMessage.html) containing example inputs;\n*   [AIMessage](https://python.langchain.com/api_reference/core/messages/langchain_core.messages.ai.AIMessage.html) containing example tool calls;\n*   [ToolMessage](https://python.langchain.com/api_reference/core/messages/langchain_core.messages.tool.ToolMessage.html) containing example tool outputs.\n\nLangChain adopts this convention for structuring tool calls into conversation across LLM model providers.\n\nFirst we build a prompt template that includes a placeholder for these messages:\n\n```\nfrom langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder# Define a custom prompt to provide instructions and any additional context.# 1) You can add examples into the prompt template to improve extraction quality# 2) Introduce additional parameters to take context into account (e.g., include metadata#    about the document from which the text was extracted.)prompt = ChatPromptTemplate.from_messages(    [        (            \"system\",            \"You are an expert extraction algorithm. \"            \"Only extract relevant information from the text. \"            \"If you do not know the value of an attribute asked \"            \"to extract, return null for the attribute's value.\",        ),        # ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓        MessagesPlaceholder(\"examples\"),  # <-- EXAMPLES!        # ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑        (\"human\", \"{text}\"),    ])\n```\n\nTest out the template:\n\n```\nfrom langchain_core.messages import (    HumanMessage,)prompt.invoke(    {\"text\": \"this is some text\", \"examples\": [HumanMessage(content=\"testing 1 2 3\")]})\n```\n\n```\nChatPromptValue(messages=[SystemMessage(content=\"You are an expert extraction algorithm. Only extract relevant information from the text. If you do not know the value of an attribute asked to extract, return null for the attribute's value.\", additional_kwargs={}, response_metadata={}), HumanMessage(content='testing 1 2 3', additional_kwargs={}, response_metadata={}), HumanMessage(content='this is some text', additional_kwargs={}, response_metadata={})])\n```\n\n## Define the schema[​](#define-the-schema \"Direct link to Define the schema\")\n\nLet's re-use the person schema from the [extraction tutorial](https://python.langchain.com/docs/tutorials/extraction/).\n\n```\nfrom typing import List, Optionalfrom langchain_openai import ChatOpenAIfrom pydantic import BaseModel, Fieldclass Person(BaseModel):    \"\"\"Information about a person.\"\"\"    # ^ Doc-string for the entity Person.    # This doc-string is sent to the LLM as the description of the schema Person,    # and it can help to improve extraction results.    # Note that:    # 1. Each field is an `optional` -- this allows the model to decline to extract it!    # 2. Each field has a `description` -- this description is used by the LLM.    # Having a good description can help improve extraction results.    name: Optional[str] = Field(..., description=\"The name of the person\")    hair_color: Optional[str] = Field(        ..., description=\"The color of the person's hair if known\"    )    height_in_meters: Optional[str] = Field(..., description=\"Height in METERs\")class Data(BaseModel):    \"\"\"Extracted data about people.\"\"\"    # Creates a model so that we can extract multiple entities.    people: List[Person]\n```\n\n## Define reference examples[​](#define-reference-examples \"Direct link to Define reference examples\")\n\nExamples can be defined as a list of input-output pairs.\n\nEach example contains an example `input` text and an example `output` showing what should be extracted from the text.\n\nimportant\n\nThis is a bit in the weeds, so feel free to skip.\n\nThe format of the example needs to match the API used (e.g., tool calling or JSON mode etc.).\n\nHere, the formatted examples will match the format expected for the tool calling API since that's what we're using.\n\n```\nimport uuidfrom typing import Dict, List, TypedDictfrom langchain_core.messages import (    AIMessage,    BaseMessage,    HumanMessage,    SystemMessage,    ToolMessage,)from pydantic import BaseModel, Fieldclass Example(TypedDict):    \"\"\"A representation of an example consisting of text input and expected tool calls.    For extraction, the tool calls are represented as instances of pydantic model.    \"\"\"    input: str  # This is the example text    tool_calls: List[BaseModel]  # Instances of pydantic model that should be extracteddef tool_example_to_messages(example: Example) -> List[BaseMessage]:    \"\"\"Convert an example into a list of messages that can be fed into an LLM.    This code is an adapter that converts our example to a list of messages    that can be fed into a chat model.    The list of messages per example corresponds to:    1) HumanMessage: contains the content from which content should be extracted.    2) AIMessage: contains the extracted information from the model    3) ToolMessage: contains confirmation to the model that the model requested a tool correctly.    The ToolMessage is required because some of the chat models are hyper-optimized for agents    rather than for an extraction use case.    \"\"\"    messages: List[BaseMessage] = [HumanMessage(content=example[\"input\"])]    tool_calls = []    for tool_call in example[\"tool_calls\"]:        tool_calls.append(            {                \"id\": str(uuid.uuid4()),                \"args\": tool_call.dict(),                # The name of the function right now corresponds                # to the name of the pydantic model                # This is implicit in the API right now,                # and will be improved over time.                \"name\": tool_call.__class__.__name__,            },        )    messages.append(AIMessage(content=\"\", tool_calls=tool_calls))    tool_outputs = example.get(\"tool_outputs\") or [        \"You have correctly called this tool.\"    ] * len(tool_calls)    for output, tool_call in zip(tool_outputs, tool_calls):        messages.append(ToolMessage(content=output, tool_call_id=tool_call[\"id\"]))    return messages\n```\n\nNext let's define our examples and then convert them into message format.\n\n```\nexamples = [    (        \"The ocean is vast and blue. It's more than 20,000 feet deep. There are many fish in it.\",        Data(people=[]),    ),    (        \"Fiona traveled far from France to Spain.\",        Data(people=[Person(name=\"Fiona\", height_in_meters=None, hair_color=None)]),    ),]messages = []for text, tool_call in examples:    messages.extend(        tool_example_to_messages({\"input\": text, \"tool_calls\": [tool_call]})    )\n```\n\nLet's test out the prompt\n\n```\nexample_prompt = prompt.invoke({\"text\": \"this is some text\", \"examples\": messages})for message in example_prompt.messages:    print(f\"{message.type}: {message}\")\n```\n\n```\nsystem: content=\"You are an expert extraction algorithm. Only extract relevant information from the text. If you do not know the value of an attribute asked to extract, return null for the attribute's value.\" additional_kwargs={} response_metadata={}human: content=\"The ocean is vast and blue. It's more than 20,000 feet deep. There are many fish in it.\" additional_kwargs={} response_metadata={}ai: content='' additional_kwargs={} response_metadata={} tool_calls=[{'name': 'Data', 'args': {'people': []}, 'id': '240159b1-1405-4107-a07c-3c6b91b3d5b7', 'type': 'tool_call'}]tool: content='You have correctly called this tool.' tool_call_id='240159b1-1405-4107-a07c-3c6b91b3d5b7'human: content='Fiona traveled far from France to Spain.' additional_kwargs={} response_metadata={}ai: content='' additional_kwargs={} response_metadata={} tool_calls=[{'name': 'Data', 'args': {'people': [{'name': 'Fiona', 'hair_color': None, 'height_in_meters': None}]}, 'id': '3fc521e4-d1d2-4c20-bf40-e3d72f1068da', 'type': 'tool_call'}]tool: content='You have correctly called this tool.' tool_call_id='3fc521e4-d1d2-4c20-bf40-e3d72f1068da'human: content='this is some text' additional_kwargs={} response_metadata={}\n```\n\nLet's select an LLM. Because we are using tool-calling, we will need a model that supports a tool-calling feature. See [this table](https://python.langchain.com/docs/integrations/chat/) for available LLMs.\n\n```\npip install -qU langchain-openai\n```\n\n```\nimport getpassimport osif not os.environ.get(\"OPENAI_API_KEY\"):  os.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"Enter API key for OpenAI: \")from langchain_openai import ChatOpenAIllm = ChatOpenAI(model=\"gpt-4-0125-preview\", temperature=0)\n```\n\nFollowing the [extraction tutorial](https://python.langchain.com/docs/tutorials/extraction/), we use the `.with_structured_output` method to structure model outputs according to the desired schema:\n\n```\nrunnable = prompt | llm.with_structured_output(    schema=Data,    method=\"function_calling\",    include_raw=False,)\n```\n\n## Without examples 😿[​](#without-examples- \"Direct link to Without examples 😿\")\n\nNotice that even capable models can fail with a **very simple** test case!\n\n```\nfor _ in range(5):    text = \"The solar system is large, but earth has only 1 moon.\"    print(runnable.invoke({\"text\": text, \"examples\": []}))\n```\n\n```\npeople=[Person(name='earth', hair_color='null', height_in_meters='null')]``````outputpeople=[Person(name='earth', hair_color='null', height_in_meters='null')]``````outputpeople=[]``````outputpeople=[Person(name='earth', hair_color='null', height_in_meters='null')]``````outputpeople=[]\n```\n\n## With examples 😻[​](#with-examples- \"Direct link to With examples 😻\")\n\nReference examples helps to fix the failure!\n\n```\nfor _ in range(5):    text = \"The solar system is large, but earth has only 1 moon.\"    print(runnable.invoke({\"text\": text, \"examples\": messages}))\n```\n\n```\npeople=[]``````outputpeople=[]``````outputpeople=[]``````outputpeople=[]``````outputpeople=[]\n```\n\nNote that we can see the few-shot examples as tool-calls in the [Langsmith trace](https://smith.langchain.com/public/4c436bc2-a1ce-440b-82f5-093947542e40/r).\n\nAnd we retain performance on a positive sample:\n\n```\nrunnable.invoke(    {        \"text\": \"My name is Harrison. My hair is black.\",        \"examples\": messages,    })\n```\n\n```\nData(people=[Person(name='Harrison', hair_color='black', height_in_meters=None)])\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/passthrough/",
  "markdown": "# giscus\n\n## How to pass through arguments from one step to the next\n\nWhen composing chains with several steps, sometimes you will want to pass data from previous steps unchanged for use as input to a later step. The [`RunnablePassthrough`](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.passthrough.RunnablePassthrough.html) class allows you to do just this, and is typically is used in conjunction with a [RunnableParallel](https://python.langchain.com/docs/how_to/parallel/) to pass data through to a later step in your constructed chains.\n\nSee the example below:\n\n```\n%pip install -qU langchain langchain-openaiimport osfrom getpass import getpassif \"OPENAI_API_KEY\" not in os.environ:    os.environ[\"OPENAI_API_KEY\"] = getpass()\n```\n\n```\nfrom langchain_core.runnables import RunnableParallel, RunnablePassthroughrunnable = RunnableParallel(    passed=RunnablePassthrough(),    modified=lambda x: x[\"num\"] + 1,)runnable.invoke({\"num\": 1})\n```\n\n```\n{'passed': {'num': 1}, 'modified': 2}\n```\n\nAs seen above, `passed` key was called with `RunnablePassthrough()` and so it simply passed on `{'num': 1}`.\n\nWe also set a second key in the map with `modified`. This uses a lambda to set a single value adding 1 to the num, which resulted in `modified` key with the value of `2`.\n\n## Retrieval Example[​](#retrieval-example \"Direct link to Retrieval Example\")\n\nIn the example below, we see a more real-world use case where we use `RunnablePassthrough` along with `RunnableParallel` in a chain to properly format inputs to a prompt:\n\n```\nfrom langchain_community.vectorstores import FAISSfrom langchain_core.output_parsers import StrOutputParserfrom langchain_core.prompts import ChatPromptTemplatefrom langchain_core.runnables import RunnablePassthroughfrom langchain_openai import ChatOpenAI, OpenAIEmbeddingsvectorstore = FAISS.from_texts(    [\"harrison worked at kensho\"], embedding=OpenAIEmbeddings())retriever = vectorstore.as_retriever()template = \"\"\"Answer the question based only on the following context:{context}Question: {question}\"\"\"prompt = ChatPromptTemplate.from_template(template)model = ChatOpenAI()retrieval_chain = (    {\"context\": retriever, \"question\": RunnablePassthrough()}    | prompt    | model    | StrOutputParser())retrieval_chain.invoke(\"where did harrison work?\")\n```\n\n```\n'Harrison worked at Kensho.'\n```\n\nHere the input to prompt is expected to be a map with keys \"context\" and \"question\". The user input is just the question. So we need to get the context using our retriever and passthrough the user input under the \"question\" key. The `RunnablePassthrough` allows us to pass on the user's question to the prompt and model.\n\n## Next steps[​](#next-steps \"Direct link to Next steps\")\n\nNow you've learned how to pass data through your chains to help format the data flowing through your chains.\n\nTo learn more, see the other how-to guides on runnables in this section."
},
{
  "url": "https://python.langchain.com/docs/how_to/vectorstore_retriever/",
  "markdown": "# giscus\n\n## How to use a vectorstore as a retriever\n\nA vector store retriever is a [retriever](https://python.langchain.com/docs/concepts/retrievers/) that uses a [vector store](https://python.langchain.com/docs/concepts/vectorstores/) to retrieve documents. It is a lightweight wrapper around the vector store class to make it conform to the retriever [interface](https://python.langchain.com/docs/concepts/runnables/). It uses the search methods implemented by a vector store, like similarity search and MMR, to query the texts in the vector store.\n\nIn this guide we will cover:\n\n1.  How to instantiate a retriever from a vectorstore;\n2.  How to specify the search type for the retriever;\n3.  How to specify additional search parameters, such as threshold scores and top-k.\n\n## Creating a retriever from a vectorstore[​](#creating-a-retriever-from-a-vectorstore \"Direct link to Creating a retriever from a vectorstore\")\n\nYou can build a retriever from a vectorstore using its [.as\\_retriever](https://python.langchain.com/api_reference/core/vectorstores/langchain_core.vectorstores.base.VectorStore.html#langchain_core.vectorstores.base.VectorStore.as_retriever) method. Let's walk through an example.\n\nFirst we instantiate a vectorstore. We will use an in-memory [FAISS](https://python.langchain.com/api_reference/community/vectorstores/langchain_community.vectorstores.faiss.FAISS.html) vectorstore:\n\n```\nfrom langchain_community.document_loaders import TextLoaderfrom langchain_community.vectorstores import FAISSfrom langchain_openai import OpenAIEmbeddingsfrom langchain_text_splitters import CharacterTextSplitterloader = TextLoader(\"state_of_the_union.txt\")documents = loader.load()text_splitter = CharacterTextSplitter(chunk_size=1000, chunk_overlap=0)texts = text_splitter.split_documents(documents)embeddings = OpenAIEmbeddings()vectorstore = FAISS.from_documents(texts, embeddings)\n```\n\nWe can then instantiate a retriever:\n\n```\nretriever = vectorstore.as_retriever()\n```\n\nThis creates a retriever (specifically a [VectorStoreRetriever](https://python.langchain.com/api_reference/core/vectorstores/langchain_core.vectorstores.base.VectorStoreRetriever.html)), which we can use in the usual way:\n\n```\ndocs = retriever.invoke(\"what did the president say about ketanji brown jackson?\")\n```\n\n## Maximum marginal relevance retrieval[​](#maximum-marginal-relevance-retrieval \"Direct link to Maximum marginal relevance retrieval\")\n\nBy default, the vector store retriever uses similarity search. If the underlying vector store supports maximum marginal relevance search, you can specify that as the search type.\n\nThis effectively specifies what method on the underlying vectorstore is used (e.g., `similarity_search`, `max_marginal_relevance_search`, etc.).\n\n```\nretriever = vectorstore.as_retriever(search_type=\"mmr\")\n```\n\n```\ndocs = retriever.invoke(\"what did the president say about ketanji brown jackson?\")\n```\n\n## Passing search parameters[​](#passing-search-parameters \"Direct link to Passing search parameters\")\n\nWe can pass parameters to the underlying vectorstore's search methods using `search_kwargs`.\n\n### Similarity score threshold retrieval[​](#similarity-score-threshold-retrieval \"Direct link to Similarity score threshold retrieval\")\n\nFor example, we can set a similarity score threshold and only return documents with a score above that threshold.\n\n```\nretriever = vectorstore.as_retriever(    search_type=\"similarity_score_threshold\", search_kwargs={\"score_threshold\": 0.5})\n```\n\n```\ndocs = retriever.invoke(\"what did the president say about ketanji brown jackson?\")\n```\n\n### Specifying top k[​](#specifying-top-k \"Direct link to Specifying top k\")\n\nWe can also limit the number of documents `k` returned by the retriever.\n\n```\nretriever = vectorstore.as_retriever(search_kwargs={\"k\": 1})\n```\n\n```\ndocs = retriever.invoke(\"what did the president say about ketanji brown jackson?\")len(docs)\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/prompts_composition/",
  "markdown": "# giscus\n\n## How to compose prompts together\n\nPrerequisites\n\nThis guide assumes familiarity with the following concepts:\n\n*   [Prompt templates](https://python.langchain.com/docs/concepts/prompt_templates/)\n\nLangChain provides a user friendly interface for composing different parts of [prompts](https://python.langchain.com/docs/concepts/prompt_templates/) together. You can do this with either string prompts or chat prompts. Constructing prompts this way allows for easy reuse of components.\n\n## String prompt composition[​](#string-prompt-composition \"Direct link to String prompt composition\")\n\nWhen working with string prompts, each template is joined together. You can work with either prompts directly or strings (the first element in the list needs to be a prompt).\n\n```\nfrom langchain_core.prompts import PromptTemplateprompt = (    PromptTemplate.from_template(\"Tell me a joke about {topic}\")    + \", make it funny\"    + \"\\n\\nand in {language}\")prompt\n```\n\n```\nPromptTemplate(input_variables=['language', 'topic'], template='Tell me a joke about {topic}, make it funny\\n\\nand in {language}')\n```\n\n```\nprompt.format(topic=\"sports\", language=\"spanish\")\n```\n\n```\n'Tell me a joke about sports, make it funny\\n\\nand in spanish'\n```\n\n## Chat prompt composition[​](#chat-prompt-composition \"Direct link to Chat prompt composition\")\n\nA chat prompt is made up a of a list of messages. Similarly to the above example, we can concatenate chat prompt templates. Each new element is a new message in the final prompt.\n\nFirst, let's initialize the a [`ChatPromptTemplate`](https://python.langchain.com/api_reference/core/prompts/langchain_core.prompts.chat.ChatPromptTemplate.html) with a [`SystemMessage`](https://python.langchain.com/api_reference/core/messages/langchain_core.messages.system.SystemMessage.html).\n\n```\nfrom langchain_core.messages import AIMessage, HumanMessage, SystemMessageprompt = SystemMessage(content=\"You are a nice pirate\")\n```\n\nYou can then easily create a pipeline combining it with other messages _or_ message templates. Use a `Message` when there is no variables to be formatted, use a `MessageTemplate` when there are variables to be formatted. You can also use just a string (note: this will automatically get inferred as a [`HumanMessagePromptTemplate`](https://python.langchain.com/api_reference/core/prompts/langchain_core.prompts.chat.HumanMessagePromptTemplate.html).)\n\n```\nnew_prompt = (    prompt + HumanMessage(content=\"hi\") + AIMessage(content=\"what?\") + \"{input}\")\n```\n\nUnder the hood, this creates an instance of the ChatPromptTemplate class, so you can use it just as you did before!\n\n```\nnew_prompt.format_messages(input=\"i said hi\")\n```\n\n```\n[SystemMessage(content='You are a nice pirate'), HumanMessage(content='hi'), AIMessage(content='what?'), HumanMessage(content='i said hi')]\n```\n\n## Using PipelinePrompt[​](#using-pipelineprompt \"Direct link to Using PipelinePrompt\")\n\nLangChain includes a class called [`PipelinePromptTemplate`](https://python.langchain.com/api_reference/core/prompts/langchain_core.prompts.pipeline.PipelinePromptTemplate.html), which can be useful when you want to reuse parts of prompts. A PipelinePrompt consists of two main parts:\n\n*   Final prompt: The final prompt that is returned\n*   Pipeline prompts: A list of tuples, consisting of a string name and a prompt template. Each prompt template will be formatted and then passed to future prompt templates as a variable with the same name.\n\n```\nfrom langchain_core.prompts import PipelinePromptTemplate, PromptTemplatefull_template = \"\"\"{introduction}{example}{start}\"\"\"full_prompt = PromptTemplate.from_template(full_template)introduction_template = \"\"\"You are impersonating {person}.\"\"\"introduction_prompt = PromptTemplate.from_template(introduction_template)example_template = \"\"\"Here's an example of an interaction:Q: {example_q}A: {example_a}\"\"\"example_prompt = PromptTemplate.from_template(example_template)start_template = \"\"\"Now, do this for real!Q: {input}A:\"\"\"start_prompt = PromptTemplate.from_template(start_template)input_prompts = [    (\"introduction\", introduction_prompt),    (\"example\", example_prompt),    (\"start\", start_prompt),]pipeline_prompt = PipelinePromptTemplate(    final_prompt=full_prompt, pipeline_prompts=input_prompts)pipeline_prompt.input_variables\n```\n\n```\n['person', 'example_a', 'example_q', 'input']\n```\n\n```\nprint(    pipeline_prompt.format(        person=\"Elon Musk\",        example_q=\"What's your favorite car?\",        example_a=\"Tesla\",        input=\"What's your favorite social media site?\",    ))\n```\n\n```\nYou are impersonating Elon Musk.Here's an example of an interaction:Q: What's your favorite car?A: TeslaNow, do this for real!Q: What's your favorite social media site?A:\n```\n\n## Next steps[​](#next-steps \"Direct link to Next steps\")\n\nYou've now learned how to compose prompts together.\n\nNext, check out the other how-to guides on prompt templates in this section, like [adding few-shot examples to your prompt templates](https://python.langchain.com/docs/how_to/few_shot_examples_chat/)."
},
{
  "url": "https://python.langchain.com/docs/how_to/custom_tools/",
  "markdown": "# giscus\n\n## How to create tools\n\nWhen constructing an [agent](https://python.langchain.com/docs/concepts/agents/), you will need to provide it with a list of [Tools](https://python.langchain.com/docs/concepts/tools/) that it can use. Besides the actual function that is called, the Tool consists of several components:\n\n| Attribute | Type | Description |\n| --- | --- | --- |\n| name | str | Must be unique within a set of tools provided to an LLM or agent. |\n| description | str | Describes what the tool does. Used as context by the LLM or agent. |\n| args\\_schema | pydantic.BaseModel | Optional but recommended, and required if using callback handlers. It can be used to provide more information (e.g., few-shot examples) or validation for expected parameters. |\n| return\\_direct | boolean | Only relevant for agents. When True, after invoking the given tool, the agent will stop and return the result direcly to the user. |\n\nLangChain supports the creation of tools from:\n\n1.  Functions;\n2.  LangChain [Runnables](https://python.langchain.com/docs/concepts/runnables/);\n3.  By sub-classing from [BaseTool](https://python.langchain.com/api_reference/core/tools/langchain_core.tools.base.BaseTool.html) -- This is the most flexible method, it provides the largest degree of control, at the expense of more effort and code.\n\nCreating tools from functions may be sufficient for most use cases, and can be done via a simple [@tool decorator](https://python.langchain.com/api_reference/core/tools/langchain_core.tools.tool.html#langchain_core.tools.tool). If more configuration is needed-- e.g., specification of both sync and async implementations-- one can also use the [StructuredTool.from\\_function](https://python.langchain.com/api_reference/core/tools/langchain_core.tools.structured.StructuredTool.html#langchain_core.tools.structured.StructuredTool.from_function) class method.\n\nIn this guide we provide an overview of these methods.\n\ntip\n\nModels will perform better if the tools have well chosen names, descriptions and JSON schemas.\n\n### @tool decorator[​](#tool-decorator \"Direct link to @tool decorator\")\n\nThis `@tool` decorator is the simplest way to define a custom tool. The decorator uses the function name as the tool name by default, but this can be overridden by passing a string as the first argument. Additionally, the decorator will use the function's docstring as the tool's description - so a docstring MUST be provided.\n\n```\nfrom langchain_core.tools import tool@tooldef multiply(a: int, b: int) -> int:    \"\"\"Multiply two numbers.\"\"\"    return a * b# Let's inspect some of the attributes associated with the tool.print(multiply.name)print(multiply.description)print(multiply.args)\n```\n\n**API Reference:**[tool](https://python.langchain.com/api_reference/core/tools/langchain_core.tools.convert.tool.html)\n\n```\nmultiplyMultiply two numbers.{'a': {'title': 'A', 'type': 'integer'}, 'b': {'title': 'B', 'type': 'integer'}}\n```\n\nOr create an **async** implementation, like this:\n\n```\nfrom langchain_core.tools import tool@toolasync def amultiply(a: int, b: int) -> int:    \"\"\"Multiply two numbers.\"\"\"    return a * b\n```\n\n**API Reference:**[tool](https://python.langchain.com/api_reference/core/tools/langchain_core.tools.convert.tool.html)\n\nNote that `@tool` supports parsing of annotations, nested schemas, and other features:\n\n```\nfrom typing import Annotated, List@tooldef multiply_by_max(    a: Annotated[int, \"scale factor\"],    b: Annotated[List[int], \"list of ints over which to take maximum\"],) -> int:    \"\"\"Multiply a by the maximum of b.\"\"\"    return a * max(b)multiply_by_max.args_schema.schema()\n```\n\n```\n{'description': 'Multiply a by the maximum of b.', 'properties': {'a': {'description': 'scale factor',   'title': 'A',   'type': 'string'},  'b': {'description': 'list of ints over which to take maximum',   'items': {'type': 'integer'},   'title': 'B',   'type': 'array'}}, 'required': ['a', 'b'], 'title': 'multiply_by_maxSchema', 'type': 'object'}\n```\n\nYou can also customize the tool name and JSON args by passing them into the tool decorator.\n\n```\nfrom pydantic import BaseModel, Fieldclass CalculatorInput(BaseModel):    a: int = Field(description=\"first number\")    b: int = Field(description=\"second number\")@tool(\"multiplication-tool\", args_schema=CalculatorInput, return_direct=True)def multiply(a: int, b: int) -> int:    \"\"\"Multiply two numbers.\"\"\"    return a * b# Let's inspect some of the attributes associated with the tool.print(multiply.name)print(multiply.description)print(multiply.args)print(multiply.return_direct)\n```\n\n```\nmultiplication-toolMultiply two numbers.{'a': {'description': 'first number', 'title': 'A', 'type': 'integer'}, 'b': {'description': 'second number', 'title': 'B', 'type': 'integer'}}True\n```\n\n#### Docstring parsing[​](#docstring-parsing \"Direct link to Docstring parsing\")\n\n`@tool` can optionally parse [Google Style docstrings](https://google.github.io/styleguide/pyguide.html#383-functions-and-methods) and associate the docstring components (such as arg descriptions) to the relevant parts of the tool schema. To toggle this behavior, specify `parse_docstring`:\n\n```\n@tool(parse_docstring=True)def foo(bar: str, baz: int) -> str:    \"\"\"The foo.    Args:        bar: The bar.        baz: The baz.    \"\"\"    return barfoo.args_schema.schema()\n```\n\n```\n{'description': 'The foo.', 'properties': {'bar': {'description': 'The bar.',   'title': 'Bar',   'type': 'string'},  'baz': {'description': 'The baz.', 'title': 'Baz', 'type': 'integer'}}, 'required': ['bar', 'baz'], 'title': 'fooSchema', 'type': 'object'}\n```\n\ncaution\n\nBy default, `@tool(parse_docstring=True)` will raise `ValueError` if the docstring does not parse correctly. See [API Reference](https://python.langchain.com/api_reference/core/tools/langchain_core.tools.convert.tool.html) for detail and examples.\n\n### StructuredTool[​](#structuredtool \"Direct link to StructuredTool\")\n\nThe `StructuredTool.from_function` class method provides a bit more configurability than the `@tool` decorator, without requiring much additional code.\n\n```\nfrom langchain_core.tools import StructuredTooldef multiply(a: int, b: int) -> int:    \"\"\"Multiply two numbers.\"\"\"    return a * basync def amultiply(a: int, b: int) -> int:    \"\"\"Multiply two numbers.\"\"\"    return a * bcalculator = StructuredTool.from_function(func=multiply, coroutine=amultiply)print(calculator.invoke({\"a\": 2, \"b\": 3}))print(await calculator.ainvoke({\"a\": 2, \"b\": 5}))\n```\n\nTo configure it:\n\n```\nclass CalculatorInput(BaseModel):    a: int = Field(description=\"first number\")    b: int = Field(description=\"second number\")def multiply(a: int, b: int) -> int:    \"\"\"Multiply two numbers.\"\"\"    return a * bcalculator = StructuredTool.from_function(    func=multiply,    name=\"Calculator\",    description=\"multiply numbers\",    args_schema=CalculatorInput,    return_direct=True,    # coroutine= ... <- you can specify an async method if desired as well)print(calculator.invoke({\"a\": 2, \"b\": 3}))print(calculator.name)print(calculator.description)print(calculator.args)\n```\n\n```\n6Calculatormultiply numbers{'a': {'description': 'first number', 'title': 'A', 'type': 'integer'}, 'b': {'description': 'second number', 'title': 'B', 'type': 'integer'}}\n```\n\nLangChain [Runnables](https://python.langchain.com/docs/concepts/runnables/) that accept string or `dict` input can be converted to tools using the [as\\_tool](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.as_tool) method, which allows for the specification of names, descriptions, and additional schema information for arguments.\n\nExample usage:\n\n```\nfrom langchain_core.language_models import GenericFakeChatModelfrom langchain_core.output_parsers import StrOutputParserfrom langchain_core.prompts import ChatPromptTemplateprompt = ChatPromptTemplate.from_messages(    [(\"human\", \"Hello. Please respond in the style of {answer_style}.\")])# Placeholder LLMllm = GenericFakeChatModel(messages=iter([\"hello matey\"]))chain = prompt | llm | StrOutputParser()as_tool = chain.as_tool(    name=\"Style responder\", description=\"Description of when to use tool.\")as_tool.args\n```\n\n```\n/var/folders/4j/2rz3865x6qg07tx43146py8h0000gn/T/ipykernel_95770/2548361071.py:14: LangChainBetaWarning: This API is in beta and may change in the future.  as_tool = chain.as_tool(\n```\n\n```\n{'answer_style': {'title': 'Answer Style', 'type': 'string'}}\n```\n\nSee [this guide](https://python.langchain.com/docs/how_to/convert_runnable_to_tool/) for more detail.\n\nYou can define a custom tool by sub-classing from `BaseTool`. This provides maximal control over the tool definition, but requires writing more code.\n\n```\nfrom typing import Optional, Typefrom langchain_core.callbacks import (    AsyncCallbackManagerForToolRun,    CallbackManagerForToolRun,)from langchain_core.tools import BaseToolfrom pydantic import BaseModel, Fieldclass CalculatorInput(BaseModel):    a: int = Field(description=\"first number\")    b: int = Field(description=\"second number\")# Note: It's important that every field has type hints. BaseTool is a# Pydantic class and not having type hints can lead to unexpected behavior.class CustomCalculatorTool(BaseTool):    name: str = \"Calculator\"    description: str = \"useful for when you need to answer questions about math\"    args_schema: Type[BaseModel] = CalculatorInput    return_direct: bool = True    def _run(        self, a: int, b: int, run_manager: Optional[CallbackManagerForToolRun] = None    ) -> str:        \"\"\"Use the tool.\"\"\"        return a * b    async def _arun(        self,        a: int,        b: int,        run_manager: Optional[AsyncCallbackManagerForToolRun] = None,    ) -> str:        \"\"\"Use the tool asynchronously.\"\"\"        # If the calculation is cheap, you can just delegate to the sync implementation        # as shown below.        # If the sync calculation is expensive, you should delete the entire _arun method.        # LangChain will automatically provide a better implementation that will        # kick off the task in a thread to make sure it doesn't block other async code.        return self._run(a, b, run_manager=run_manager.get_sync())\n```\n\n```\nmultiply = CustomCalculatorTool()print(multiply.name)print(multiply.description)print(multiply.args)print(multiply.return_direct)print(multiply.invoke({\"a\": 2, \"b\": 3}))print(await multiply.ainvoke({\"a\": 2, \"b\": 3}))\n```\n\n```\nCalculatoruseful for when you need to answer questions about math{'a': {'description': 'first number', 'title': 'A', 'type': 'integer'}, 'b': {'description': 'second number', 'title': 'B', 'type': 'integer'}}True66\n```\n\nLangChain Tools implement the [Runnable interface 🏃](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html).\n\nAll Runnables expose the `invoke` and `ainvoke` methods (as well as other methods like `batch`, `abatch`, `astream` etc).\n\nSo even if you only provide an `sync` implementation of a tool, you could still use the `ainvoke` interface, but there are some important things to know:\n\n*   LangChain's by default provides an async implementation that assumes that the function is expensive to compute, so it'll delegate execution to another thread.\n*   If you're working in an async codebase, you should create async tools rather than sync tools, to avoid incuring a small overhead due to that thread.\n*   If you need both sync and async implementations, use `StructuredTool.from_function` or sub-class from `BaseTool`.\n*   If implementing both sync and async, and the sync code is fast to run, override the default LangChain async implementation and simply call the sync code.\n*   You CANNOT and SHOULD NOT use the sync `invoke` with an `async` tool.\n\n```\nfrom langchain_core.tools import StructuredTooldef multiply(a: int, b: int) -> int:    \"\"\"Multiply two numbers.\"\"\"    return a * bcalculator = StructuredTool.from_function(func=multiply)print(calculator.invoke({\"a\": 2, \"b\": 3}))print(    await calculator.ainvoke({\"a\": 2, \"b\": 5}))  # Uses default LangChain async implementation incurs small overhead\n```\n\n```\nfrom langchain_core.tools import StructuredTooldef multiply(a: int, b: int) -> int:    \"\"\"Multiply two numbers.\"\"\"    return a * basync def amultiply(a: int, b: int) -> int:    \"\"\"Multiply two numbers.\"\"\"    return a * bcalculator = StructuredTool.from_function(func=multiply, coroutine=amultiply)print(calculator.invoke({\"a\": 2, \"b\": 3}))print(    await calculator.ainvoke({\"a\": 2, \"b\": 5}))  # Uses use provided amultiply without additional overhead\n```\n\nYou should not and cannot use `.invoke` when providing only an async definition.\n\n```\n@toolasync def multiply(a: int, b: int) -> int:    \"\"\"Multiply two numbers.\"\"\"    return a * btry:    multiply.invoke({\"a\": 2, \"b\": 3})except NotImplementedError:    print(\"Raised not implemented error. You should not be doing this.\")\n```\n\n```\nRaised not implemented error. You should not be doing this.\n```\n\nIf you're using tools with agents, you will likely need an error handling strategy, so the agent can recover from the error and continue execution.\n\nA simple strategy is to throw a `ToolException` from inside the tool and specify an error handler using `handle_tool_error`.\n\nWhen the error handler is specified, the exception will be caught and the error handler will decide which output to return from the tool.\n\nYou can set `handle_tool_error` to `True`, a string value, or a function. If it's a function, the function should take a `ToolException` as a parameter and return a value.\n\nPlease note that only raising a `ToolException` won't be effective. You need to first set the `handle_tool_error` of the tool because its default value is `False`.\n\n```\nfrom langchain_core.tools import ToolExceptiondef get_weather(city: str) -> int:    \"\"\"Get weather for the given city.\"\"\"    raise ToolException(f\"Error: There is no city by the name of {city}.\")\n```\n\nHere's an example with the default `handle_tool_error=True` behavior.\n\n```\nget_weather_tool = StructuredTool.from_function(    func=get_weather,    handle_tool_error=True,)get_weather_tool.invoke({\"city\": \"foobar\"})\n```\n\n```\n'Error: There is no city by the name of foobar.'\n```\n\nWe can set `handle_tool_error` to a string that will always be returned.\n\n```\nget_weather_tool = StructuredTool.from_function(    func=get_weather,    handle_tool_error=\"There is no such city, but it's probably above 0K there!\",)get_weather_tool.invoke({\"city\": \"foobar\"})\n```\n\n```\n\"There is no such city, but it's probably above 0K there!\"\n```\n\nHandling the error using a function:\n\n```\ndef _handle_error(error: ToolException) -> str:    return f\"The following errors occurred during tool execution: `{error.args[0]}`\"get_weather_tool = StructuredTool.from_function(    func=get_weather,    handle_tool_error=_handle_error,)get_weather_tool.invoke({\"city\": \"foobar\"})\n```\n\n```\n'The following errors occurred during tool execution: `Error: There is no city by the name of foobar.`'\n```\n\nSometimes there are artifacts of a tool's execution that we want to make accessible to downstream components in our chain or agent, but that we don't want to expose to the model itself. For example if a tool returns custom objects like Documents, we may want to pass some view or metadata about this output to the model without passing the raw output to the model. At the same time, we may want to be able to access this full output elsewhere, for example in downstream tools.\n\nThe Tool and [ToolMessage](https://python.langchain.com/api_reference/core/messages/langchain_core.messages.tool.ToolMessage.html) interfaces make it possible to distinguish between the parts of the tool output meant for the model (this is the ToolMessage.content) and those parts which are meant for use outside the model (ToolMessage.artifact).\n\nRequires `langchain-core >= 0.2.19`\n\nThis functionality was added in `langchain-core == 0.2.19`. Please make sure your package is up to date.\n\nIf we want our tool to distinguish between message content and other artifacts, we need to specify `response_format=\"content_and_artifact\"` when defining our tool and make sure that we return a tuple of (content, artifact):\n\n```\nimport randomfrom typing import List, Tuplefrom langchain_core.tools import tool@tool(response_format=\"content_and_artifact\")def generate_random_ints(min: int, max: int, size: int) -> Tuple[str, List[int]]:    \"\"\"Generate size random ints in the range [min, max].\"\"\"    array = [random.randint(min, max) for _ in range(size)]    content = f\"Successfully generated array of {size} random ints in [{min}, {max}].\"    return content, array\n```\n\n**API Reference:**[tool](https://python.langchain.com/api_reference/core/tools/langchain_core.tools.convert.tool.html)\n\nIf we invoke our tool directly with the tool arguments, we'll get back just the content part of the output:\n\n```\ngenerate_random_ints.invoke({\"min\": 0, \"max\": 9, \"size\": 10})\n```\n\n```\n'Successfully generated array of 10 random ints in [0, 9].'\n```\n\nIf we invoke our tool with a ToolCall (like the ones generated by tool-calling models), we'll get back a ToolMessage that contains both the content and artifact generated by the Tool:\n\n```\ngenerate_random_ints.invoke(    {        \"name\": \"generate_random_ints\",        \"args\": {\"min\": 0, \"max\": 9, \"size\": 10},        \"id\": \"123\",  # required        \"type\": \"tool_call\",  # required    })\n```\n\n```\nToolMessage(content='Successfully generated array of 10 random ints in [0, 9].', name='generate_random_ints', tool_call_id='123', artifact=[4, 8, 2, 4, 1, 0, 9, 5, 8, 1])\n```\n\nWe can do the same when subclassing BaseTool:\n\n```\nfrom langchain_core.tools import BaseToolclass GenerateRandomFloats(BaseTool):    name: str = \"generate_random_floats\"    description: str = \"Generate size random floats in the range [min, max].\"    response_format: str = \"content_and_artifact\"    ndigits: int = 2    def _run(self, min: float, max: float, size: int) -> Tuple[str, List[float]]:        range_ = max - min        array = [            round(min + (range_ * random.random()), ndigits=self.ndigits)            for _ in range(size)        ]        content = f\"Generated {size} floats in [{min}, {max}], rounded to {self.ndigits} decimals.\"        return content, array    # Optionally define an equivalent async method    # async def _arun(self, min: float, max: float, size: int) -> Tuple[str, List[float]]:    #     ...\n```\n\n```\nrand_gen = GenerateRandomFloats(ndigits=4)rand_gen.invoke(    {        \"name\": \"generate_random_floats\",        \"args\": {\"min\": 0.1, \"max\": 3.3333, \"size\": 3},        \"id\": \"123\",        \"type\": \"tool_call\",    })\n```\n\n```\nToolMessage(content='Generated 3 floats in [0.1, 3.3333], rounded to 4 decimals.', name='generate_random_floats', tool_call_id='123', artifact=[1.5566, 0.5134, 2.7914])\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/chatbots_memory/",
  "markdown": "# giscus\n\n## How to add memory to chatbots\n\nA key feature of chatbots is their ability to use the content of previous conversational turns as context. This state management can take several forms, including:\n\n*   Simply stuffing previous messages into a chat model prompt.\n*   The above, but trimming old messages to reduce the amount of distracting information the model has to deal with.\n*   More complex modifications like synthesizing summaries for long running conversations.\n\nWe'll go into more detail on a few techniques below!\n\nnote\n\nThis how-to guide previously built a chatbot using [RunnableWithMessageHistory](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.history.RunnableWithMessageHistory.html). You can access this version of the guide in the [v0.2 docs](https://python.langchain.com/v0.2/docs/how_to/chatbots_memory/).\n\nAs of the v0.3 release of LangChain, we recommend that LangChain users take advantage of [LangGraph persistence](https://langchain-ai.github.io/langgraph/concepts/persistence/) to incorporate `memory` into new LangChain applications.\n\nIf your code is already relying on `RunnableWithMessageHistory` or `BaseChatMessageHistory`, you do **not** need to make any changes. We do not plan on deprecating this functionality in the near future as it works for simple chat applications and any code that uses `RunnableWithMessageHistory` will continue to work as expected.\n\nPlease see [How to migrate to LangGraph Memory](https://python.langchain.com/docs/versions/migrating_memory/) for more details.\n\n## Setup[​](#setup \"Direct link to Setup\")\n\nYou'll need to install a few packages, and have your OpenAI API key set as an environment variable named `OPENAI_API_KEY`:\n\n```\n%pip install --upgrade --quiet langchain langchain-openai langgraphimport getpassimport osif not os.environ.get(\"OPENAI_API_KEY\"):    os.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"OpenAI API Key:\")\n```\n\nLet's also set up a chat model that we'll use for the below examples.\n\n```\nfrom langchain_openai import ChatOpenAImodel = ChatOpenAI(model=\"gpt-4o-mini\")\n```\n\n## Message passing[​](#message-passing \"Direct link to Message passing\")\n\nThe simplest form of memory is simply passing chat history messages into a chain. Here's an example:\n\n```\nfrom langchain_core.messages import AIMessage, HumanMessage, SystemMessagefrom langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholderprompt = ChatPromptTemplate.from_messages(    [        SystemMessage(            content=\"You are a helpful assistant. Answer all questions to the best of your ability.\"        ),        MessagesPlaceholder(variable_name=\"messages\"),    ])chain = prompt | modelai_msg = chain.invoke(    {        \"messages\": [            HumanMessage(                content=\"Translate from English to French: I love programming.\"            ),            AIMessage(content=\"J'adore la programmation.\"),            HumanMessage(content=\"What did you just say?\"),        ],    })print(ai_msg.content)\n```\n\n```\nI said, \"I love programming\" in French: \"J'adore la programmation.\"\n```\n\nWe can see that by passing the previous conversation into a chain, it can use it as context to answer questions. This is the basic concept underpinning chatbot memory - the rest of the guide will demonstrate convenient techniques for passing or reformatting messages.\n\n## Automatic history management[​](#automatic-history-management \"Direct link to Automatic history management\")\n\nThe previous examples pass messages to the chain (and model) explicitly. This is a completely acceptable approach, but it does require external management of new messages. LangChain also provides a way to build applications that have memory using LangGraph's [persistence](https://langchain-ai.github.io/langgraph/concepts/persistence/). You can [enable persistence](https://langchain-ai.github.io/langgraph/how-tos/persistence/) in LangGraph applications by providing a `checkpointer` when compiling the graph.\n\n```\nfrom langgraph.checkpoint.memory import MemorySaverfrom langgraph.graph import START, MessagesState, StateGraphworkflow = StateGraph(state_schema=MessagesState)# Define the function that calls the modeldef call_model(state: MessagesState):    system_prompt = (        \"You are a helpful assistant. \"        \"Answer all questions to the best of your ability.\"    )    messages = [SystemMessage(content=system_prompt)] + state[\"messages\"]    response = model.invoke(messages)    return {\"messages\": response}# Define the node and edgeworkflow.add_node(\"model\", call_model)workflow.add_edge(START, \"model\")# Add simple in-memory checkpointermemory = MemorySaver()app = workflow.compile(checkpointer=memory)\n```\n\nWe'll pass the latest input to the conversation here and let LangGraph keep track of the conversation history using the checkpointer:\n\n```\napp.invoke(    {\"messages\": [HumanMessage(content=\"Translate to French: I love programming.\")]},    config={\"configurable\": {\"thread_id\": \"1\"}},)\n```\n\n```\n{'messages': [HumanMessage(content='Translate to French: I love programming.', additional_kwargs={}, response_metadata={}, id='be5e7099-3149-4293-af49-6b36c8ccd71b'),  AIMessage(content=\"J'aime programmer.\", additional_kwargs={'refusal': None}, response_metadata={'token_usage': {'completion_tokens': 4, 'prompt_tokens': 35, 'total_tokens': 39, 'completion_tokens_details': {'reasoning_tokens': 0}}, 'model_name': 'gpt-4o-mini-2024-07-18', 'system_fingerprint': 'fp_e9627b5346', 'finish_reason': 'stop', 'logprobs': None}, id='run-8a753d7a-b97b-4d01-a661-626be6f41b38-0', usage_metadata={'input_tokens': 35, 'output_tokens': 4, 'total_tokens': 39})]}\n```\n\n```\napp.invoke(    {\"messages\": [HumanMessage(content=\"What did I just ask you?\")]},    config={\"configurable\": {\"thread_id\": \"1\"}},)\n```\n\n```\n{'messages': [HumanMessage(content='Translate to French: I love programming.', additional_kwargs={}, response_metadata={}, id='be5e7099-3149-4293-af49-6b36c8ccd71b'),  AIMessage(content=\"J'aime programmer.\", additional_kwargs={'refusal': None}, response_metadata={'token_usage': {'completion_tokens': 4, 'prompt_tokens': 35, 'total_tokens': 39, 'completion_tokens_details': {'reasoning_tokens': 0}}, 'model_name': 'gpt-4o-mini-2024-07-18', 'system_fingerprint': 'fp_e9627b5346', 'finish_reason': 'stop', 'logprobs': None}, id='run-8a753d7a-b97b-4d01-a661-626be6f41b38-0', usage_metadata={'input_tokens': 35, 'output_tokens': 4, 'total_tokens': 39}),  HumanMessage(content='What did I just ask you?', additional_kwargs={}, response_metadata={}, id='c667529b-7c41-4cc0-9326-0af47328b816'),  AIMessage(content='You asked me to translate \"I love programming\" into French.', additional_kwargs={'refusal': None}, response_metadata={'token_usage': {'completion_tokens': 13, 'prompt_tokens': 54, 'total_tokens': 67, 'completion_tokens_details': {'reasoning_tokens': 0}}, 'model_name': 'gpt-4o-mini-2024-07-18', 'system_fingerprint': 'fp_1bb46167f9', 'finish_reason': 'stop', 'logprobs': None}, id='run-134a7ea0-d3a4-4923-bd58-25e5a43f6a1f-0', usage_metadata={'input_tokens': 54, 'output_tokens': 13, 'total_tokens': 67})]}\n```\n\n## Modifying chat history[​](#modifying-chat-history \"Direct link to Modifying chat history\")\n\nModifying stored chat messages can help your chatbot handle a variety of situations. Here are some examples:\n\n### Trimming messages[​](#trimming-messages \"Direct link to Trimming messages\")\n\nLLMs and chat models have limited context windows, and even if you're not directly hitting limits, you may want to limit the amount of distraction the model has to deal with. One solution is trim the history messages before passing them to the model. Let's use an example history with the `app` we declared above:\n\n```\ndemo_ephemeral_chat_history = [    HumanMessage(content=\"Hey there! I'm Nemo.\"),    AIMessage(content=\"Hello!\"),    HumanMessage(content=\"How are you today?\"),    AIMessage(content=\"Fine thanks!\"),]app.invoke(    {        \"messages\": demo_ephemeral_chat_history        + [HumanMessage(content=\"What's my name?\")]    },    config={\"configurable\": {\"thread_id\": \"2\"}},)\n```\n\n```\n{'messages': [HumanMessage(content=\"Hey there! I'm Nemo.\", additional_kwargs={}, response_metadata={}, id='6b4cab70-ce18-49b0-bb06-267bde44e037'),  AIMessage(content='Hello!', additional_kwargs={}, response_metadata={}, id='ba3714f4-8876-440b-a651-efdcab2fcb4c'),  HumanMessage(content='How are you today?', additional_kwargs={}, response_metadata={}, id='08d032c0-1577-4862-a3f2-5c1b90687e21'),  AIMessage(content='Fine thanks!', additional_kwargs={}, response_metadata={}, id='21790e16-db05-4537-9a6b-ecad0fcec436'),  HumanMessage(content=\"What's my name?\", additional_kwargs={}, response_metadata={}, id='c933eca3-5fd8-4651-af16-20fe2d49c216'),  AIMessage(content='Your name is Nemo.', additional_kwargs={'refusal': None}, response_metadata={'token_usage': {'completion_tokens': 5, 'prompt_tokens': 63, 'total_tokens': 68, 'completion_tokens_details': {'reasoning_tokens': 0}}, 'model_name': 'gpt-4o-mini-2024-07-18', 'system_fingerprint': 'fp_1bb46167f9', 'finish_reason': 'stop', 'logprobs': None}, id='run-a0b21acc-9dbb-4fb6-a953-392020f37d88-0', usage_metadata={'input_tokens': 63, 'output_tokens': 5, 'total_tokens': 68})]}\n```\n\nWe can see the app remembers the preloaded name.\n\nBut let's say we have a very small context window, and we want to trim the number of messages passed to the model to only the 2 most recent ones. We can use the built in [trim\\_messages](https://python.langchain.com/docs/how_to/trim_messages/) util to trim messages based on their token count before they reach our prompt. In this case we'll count each message as 1 \"token\" and keep only the last two messages:\n\n```\nfrom langchain_core.messages import trim_messagesfrom langgraph.checkpoint.memory import MemorySaverfrom langgraph.graph import START, MessagesState, StateGraph# Define trimmer# count each message as 1 \"token\" (token_counter=len) and keep only the last two messagestrimmer = trim_messages(strategy=\"last\", max_tokens=2, token_counter=len)workflow = StateGraph(state_schema=MessagesState)# Define the function that calls the modeldef call_model(state: MessagesState):    trimmed_messages = trimmer.invoke(state[\"messages\"])    system_prompt = (        \"You are a helpful assistant. \"        \"Answer all questions to the best of your ability.\"    )    messages = [SystemMessage(content=system_prompt)] + trimmed_messages    response = model.invoke(messages)    return {\"messages\": response}# Define the node and edgeworkflow.add_node(\"model\", call_model)workflow.add_edge(START, \"model\")# Add simple in-memory checkpointermemory = MemorySaver()app = workflow.compile(checkpointer=memory)\n```\n\nLet's call this new app and check the response\n\n```\napp.invoke(    {        \"messages\": demo_ephemeral_chat_history        + [HumanMessage(content=\"What is my name?\")]    },    config={\"configurable\": {\"thread_id\": \"3\"}},)\n```\n\n```\n{'messages': [HumanMessage(content=\"Hey there! I'm Nemo.\", additional_kwargs={}, response_metadata={}, id='6b4cab70-ce18-49b0-bb06-267bde44e037'),  AIMessage(content='Hello!', additional_kwargs={}, response_metadata={}, id='ba3714f4-8876-440b-a651-efdcab2fcb4c'),  HumanMessage(content='How are you today?', additional_kwargs={}, response_metadata={}, id='08d032c0-1577-4862-a3f2-5c1b90687e21'),  AIMessage(content='Fine thanks!', additional_kwargs={}, response_metadata={}, id='21790e16-db05-4537-9a6b-ecad0fcec436'),  HumanMessage(content='What is my name?', additional_kwargs={}, response_metadata={}, id='a22ab7c5-8617-4821-b3e9-a9e7dca1ff78'),  AIMessage(content=\"I'm sorry, but I don't have access to personal information about you unless you share it with me. How can I assist you today?\", additional_kwargs={'refusal': None}, response_metadata={'token_usage': {'completion_tokens': 27, 'prompt_tokens': 39, 'total_tokens': 66, 'completion_tokens_details': {'reasoning_tokens': 0}}, 'model_name': 'gpt-4o-mini-2024-07-18', 'system_fingerprint': 'fp_1bb46167f9', 'finish_reason': 'stop', 'logprobs': None}, id='run-f7b32d72-9f57-4705-be7e-43bf1c3d293b-0', usage_metadata={'input_tokens': 39, 'output_tokens': 27, 'total_tokens': 66})]}\n```\n\nWe can see that `trim_messages` was called and only the two most recent messages will be passed to the model. In this case, this means that the model forgot the name we gave it.\n\nCheck out our [how to guide on trimming messages](https://python.langchain.com/docs/how_to/trim_messages/) for more.\n\n### Summary memory[​](#summary-memory \"Direct link to Summary memory\")\n\nWe can use this same pattern in other ways too. For example, we could use an additional LLM call to generate a summary of the conversation before calling our app. Let's recreate our chat history:\n\n```\ndemo_ephemeral_chat_history = [    HumanMessage(content=\"Hey there! I'm Nemo.\"),    AIMessage(content=\"Hello!\"),    HumanMessage(content=\"How are you today?\"),    AIMessage(content=\"Fine thanks!\"),]\n```\n\nAnd now, let's update the model-calling function to distill previous interactions into a summary:\n\n```\nfrom langchain_core.messages import HumanMessage, RemoveMessagefrom langgraph.checkpoint.memory import MemorySaverfrom langgraph.graph import START, MessagesState, StateGraphworkflow = StateGraph(state_schema=MessagesState)# Define the function that calls the modeldef call_model(state: MessagesState):    system_prompt = (        \"You are a helpful assistant. \"        \"Answer all questions to the best of your ability. \"        \"The provided chat history includes a summary of the earlier conversation.\"    )    system_message = SystemMessage(content=system_prompt)    message_history = state[\"messages\"][:-1]  # exclude the most recent user input    # Summarize the messages if the chat history reaches a certain size    if len(message_history) >= 4:        last_human_message = state[\"messages\"][-1]        # Invoke the model to generate conversation summary        summary_prompt = (            \"Distill the above chat messages into a single summary message. \"            \"Include as many specific details as you can.\"        )        summary_message = model.invoke(            message_history + [HumanMessage(content=summary_prompt)]        )        # Delete messages that we no longer want to show up        delete_messages = [RemoveMessage(id=m.id) for m in state[\"messages\"]]        # Re-add user message        human_message = HumanMessage(content=last_human_message.content)        # Call the model with summary & response        response = model.invoke([system_message, summary_message, human_message])        message_updates = [summary_message, human_message, response] + delete_messages    else:        message_updates = model.invoke([system_message] + state[\"messages\"])    return {\"messages\": message_updates}# Define the node and edgeworkflow.add_node(\"model\", call_model)workflow.add_edge(START, \"model\")# Add simple in-memory checkpointermemory = MemorySaver()app = workflow.compile(checkpointer=memory)\n```\n\nLet's see if it remembers the name we gave it:\n\n```\napp.invoke(    {        \"messages\": demo_ephemeral_chat_history        + [HumanMessage(\"What did I say my name was?\")]    },    config={\"configurable\": {\"thread_id\": \"4\"}},)\n```\n\n```\n{'messages': [AIMessage(content=\"Nemo greeted me, and I responded positively, indicating that I'm doing well.\", additional_kwargs={'refusal': None}, response_metadata={'token_usage': {'completion_tokens': 16, 'prompt_tokens': 60, 'total_tokens': 76, 'completion_tokens_details': {'reasoning_tokens': 0}}, 'model_name': 'gpt-4o-mini-2024-07-18', 'system_fingerprint': 'fp_1bb46167f9', 'finish_reason': 'stop', 'logprobs': None}, id='run-ee42f98d-907d-4bad-8f16-af2db789701d-0', usage_metadata={'input_tokens': 60, 'output_tokens': 16, 'total_tokens': 76}),  HumanMessage(content='What did I say my name was?', additional_kwargs={}, response_metadata={}, id='788555ea-5b1f-4c29-a2f2-a92f15d147be'),  AIMessage(content='You mentioned that your name is Nemo.', additional_kwargs={'refusal': None}, response_metadata={'token_usage': {'completion_tokens': 8, 'prompt_tokens': 67, 'total_tokens': 75, 'completion_tokens_details': {'reasoning_tokens': 0}}, 'model_name': 'gpt-4o-mini-2024-07-18', 'system_fingerprint': 'fp_1bb46167f9', 'finish_reason': 'stop', 'logprobs': None}, id='run-099a43bd-a284-4969-bb6f-0be486614cd8-0', usage_metadata={'input_tokens': 67, 'output_tokens': 8, 'total_tokens': 75})]}\n```\n\nNote that invoking the app again will keep accumulating the history until it reaches the specified number of messages (four in our case). At that point we will generate another summary generated from the initial summary plus new messages and so on."
},
{
  "url": "https://python.langchain.com/docs/how_to/extraction_long_text/",
  "markdown": "# giscus\n\n## How to handle long text when doing extraction\n\nWhen working with files, like PDFs, you're likely to encounter text that exceeds your language model's context window. To process this text, consider these strategies:\n\n1.  **Change LLM** Choose a different LLM that supports a larger context window.\n2.  **Brute Force** Chunk the document, and extract content from each chunk.\n3.  **RAG** Chunk the document, index the chunks, and only extract content from a subset of chunks that look \"relevant\".\n\nKeep in mind that these strategies have different trade off and the best strategy likely depends on the application that you're designing!\n\nThis guide demonstrates how to implement strategies 2 and 3.\n\n## Setup[​](#setup \"Direct link to Setup\")\n\nFirst we'll install the dependencies needed for this guide:\n\n```\n%pip install -qU langchain-community lxml faiss-cpu langchain-openai\n```\n\n```\nNote: you may need to restart the kernel to use updated packages.\n```\n\nNow we need some example data! Let's download an article about [cars from wikipedia](https://en.wikipedia.org/wiki/Car) and load it as a LangChain [Document](https://python.langchain.com/api_reference/core/documents/langchain_core.documents.base.Document.html).\n\n```\nimport reimport requestsfrom langchain_community.document_loaders import BSHTMLLoader# Download the contentresponse = requests.get(\"https://en.wikipedia.org/wiki/Car\")# Write it to a filewith open(\"car.html\", \"w\", encoding=\"utf-8\") as f:    f.write(response.text)# Load it with an HTML parserloader = BSHTMLLoader(\"car.html\")document = loader.load()[0]# Clean up code# Replace consecutive new lines with a single new linedocument.page_content = re.sub(\"\\n\\n+\", \"\\n\", document.page_content)\n```\n\n```\nprint(len(document.page_content))\n```\n\n## Define the schema[​](#define-the-schema \"Direct link to Define the schema\")\n\nFollowing the [extraction tutorial](https://python.langchain.com/docs/tutorials/extraction/), we will use Pydantic to define the schema of information we wish to extract. In this case, we will extract a list of \"key developments\" (e.g., important historical events) that include a year and description.\n\nNote that we also include an `evidence` key and instruct the model to provide in verbatim the relevant sentences of text from the article. This allows us to compare the extraction results to (the model's reconstruction of) text from the original document.\n\n```\nfrom typing import List, Optionalfrom langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholderfrom pydantic import BaseModel, Fieldclass KeyDevelopment(BaseModel):    \"\"\"Information about a development in the history of cars.\"\"\"    year: int = Field(        ..., description=\"The year when there was an important historic development.\"    )    description: str = Field(        ..., description=\"What happened in this year? What was the development?\"    )    evidence: str = Field(        ...,        description=\"Repeat in verbatim the sentence(s) from which the year and description information were extracted\",    )class ExtractionData(BaseModel):    \"\"\"Extracted information about key developments in the history of cars.\"\"\"    key_developments: List[KeyDevelopment]# Define a custom prompt to provide instructions and any additional context.# 1) You can add examples into the prompt template to improve extraction quality# 2) Introduce additional parameters to take context into account (e.g., include metadata#    about the document from which the text was extracted.)prompt = ChatPromptTemplate.from_messages(    [        (            \"system\",            \"You are an expert at identifying key historic development in text. \"            \"Only extract important historic developments. Extract nothing if no important information can be found in the text.\",        ),        (\"human\", \"{text}\"),    ])\n```\n\nLet's select an LLM. Because we are using tool-calling, we will need a model that supports a tool-calling feature. See [this table](https://python.langchain.com/docs/integrations/chat/) for available LLMs.\n\n```\npip install -qU langchain-openai\n```\n\n```\nimport getpassimport osif not os.environ.get(\"OPENAI_API_KEY\"):  os.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"Enter API key for OpenAI: \")from langchain_openai import ChatOpenAIllm = ChatOpenAI(model=\"gpt-4-0125-preview\", temperature=0)\n```\n\n```\nextractor = prompt | llm.with_structured_output(    schema=ExtractionData,    include_raw=False,)\n```\n\n## Brute force approach[​](#brute-force-approach \"Direct link to Brute force approach\")\n\nSplit the documents into chunks such that each chunk fits into the context window of the LLMs.\n\n```\nfrom langchain_text_splitters import TokenTextSplittertext_splitter = TokenTextSplitter(    # Controls the size of each chunk    chunk_size=2000,    # Controls overlap between chunks    chunk_overlap=20,)texts = text_splitter.split_text(document.page_content)\n```\n\nUse [batch](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html) functionality to run the extraction in **parallel** across each chunk!\n\ntip\n\nYou can often use .batch() to parallelize the extractions! `.batch` uses a threadpool under the hood to help you parallelize workloads.\n\nIf your model is exposed via an API, this will likely speed up your extraction flow!\n\n```\n# Limit just to the first 3 chunks# so the code can be re-run quicklyfirst_few = texts[:3]extractions = extractor.batch(    [{\"text\": text} for text in first_few],    {\"max_concurrency\": 5},  # limit the concurrency by passing max concurrency!)\n```\n\n### Merge results[​](#merge-results \"Direct link to Merge results\")\n\nAfter extracting data from across the chunks, we'll want to merge the extractions together.\n\n```\nkey_developments = []for extraction in extractions:    key_developments.extend(extraction.key_developments)key_developments[:10]\n```\n\n```\n[KeyDevelopment(year=1769, description='Nicolas-Joseph Cugnot built the first full-scale, self-propelled mechanical vehicle, a steam-powered tricycle.', evidence='Nicolas-Joseph Cugnot is widely credited with building the first full-scale, self-propelled mechanical vehicle in about 1769; he created a steam-powered tricycle.'), KeyDevelopment(year=1807, description=\"Nicéphore Niépce and his brother Claude created what was probably the world's first internal combustion engine.\", evidence=\"In 1807, Nicéphore Niépce and his brother Claude created what was probably the world's first internal combustion engine (which they called a Pyréolophore), but installed it in a boat on the river Saone in France.\"), KeyDevelopment(year=1886, description='Carl Benz patented the Benz Patent-Motorwagen, marking the birth of the modern car.', evidence='In November 1881, French inventor Gustave Trouvé demonstrated a three-wheeled car powered by electricity at the International Exposition of Electricity. Although several other German engineers (including Gottlieb Daimler, Wilhelm Maybach, and Siegfried Marcus) were working on cars at about the same time, the year 1886 is regarded as the birth year of the modern car—a practical, marketable automobile for everyday use—when the German Carl Benz patented his Benz Patent-Motorwagen; he is generally acknowledged as the inventor of the car.'), KeyDevelopment(year=1886, description='Carl Benz began promotion of his vehicle, marking the introduction of the first commercially available automobile.', evidence='Benz began promotion of the vehicle on 3 July 1886.'), KeyDevelopment(year=1888, description=\"Bertha Benz undertook the first road trip by car to prove the road-worthiness of her husband's invention.\", evidence=\"In August 1888, Bertha Benz, the wife and business partner of Carl Benz, undertook the first road trip by car, to prove the road-worthiness of her husband's invention.\"), KeyDevelopment(year=1896, description='Benz designed and patented the first internal-combustion flat engine, called boxermotor.', evidence='In 1896, Benz designed and patented the first internal-combustion flat engine, called boxermotor.'), KeyDevelopment(year=1897, description='The first motor car in central Europe and one of the first factory-made cars in the world, the Präsident automobil, was produced by Nesselsdorfer Wagenbau.', evidence='The first motor car in central Europe and one of the first factory-made cars in the world, was produced by Czech company Nesselsdorfer Wagenbau (later renamed to Tatra) in 1897, the Präsident automobil.'), KeyDevelopment(year=1901, description='Ransom Olds started large-scale, production-line manufacturing of affordable cars at his Oldsmobile factory in Lansing, Michigan.', evidence='Large-scale, production-line manufacturing of affordable cars was started by Ransom Olds in 1901 at his Oldsmobile factory in Lansing, Michigan.'), KeyDevelopment(year=1913, description=\"Henry Ford introduced the world's first moving assembly line for cars at the Highland Park Ford Plant.\", evidence=\"This concept was greatly expanded by Henry Ford, beginning in 1913 with the world's first moving assembly line for cars at the Highland Park Ford Plant.\")]\n```\n\n## RAG based approach[​](#rag-based-approach \"Direct link to RAG based approach\")\n\nAnother simple idea is to chunk up the text, but instead of extracting information from every chunk, just focus on the the most relevant chunks.\n\ncaution\n\nIt can be difficult to identify which chunks are relevant.\n\nFor example, in the `car` article we're using here, most of the article contains key development information. So by using **RAG**, we'll likely be throwing out a lot of relevant information.\n\nWe suggest experimenting with your use case and determining whether this approach works or not.\n\nTo implement the RAG based approach:\n\n1.  Chunk up your document(s) and index them (e.g., in a vectorstore);\n2.  Prepend the `extractor` chain with a retrieval step using the vectorstore.\n\nHere's a simple example that relies on the `FAISS` vectorstore.\n\n```\nfrom langchain_community.vectorstores import FAISSfrom langchain_core.documents import Documentfrom langchain_core.runnables import RunnableLambdafrom langchain_openai import OpenAIEmbeddingsfrom langchain_text_splitters import CharacterTextSplittertexts = text_splitter.split_text(document.page_content)vectorstore = FAISS.from_texts(texts, embedding=OpenAIEmbeddings())retriever = vectorstore.as_retriever(    search_kwargs={\"k\": 1})  # Only extract from first document\n```\n\nIn this case the RAG extractor is only looking at the top document.\n\n```\nrag_extractor = {    \"text\": retriever | (lambda docs: docs[0].page_content)  # fetch content of top doc} | extractor\n```\n\n```\nresults = rag_extractor.invoke(\"Key developments associated with cars\")\n```\n\n```\nfor key_development in results.key_developments:    print(key_development)\n```\n\n```\nyear=2006 description='Car-sharing services in the US experienced double-digit growth in revenue and membership.' evidence='in the US, some car-sharing services have experienced double-digit growth in revenue and membership growth between 2006 and 2007.'year=2020 description='56 million cars were manufactured worldwide, with China producing the most.' evidence='In 2020, there were 56 million cars manufactured worldwide, down from 67 million the previous year. The automotive industry in China produces by far the most (20 million in 2020).'\n```\n\n## Common issues[​](#common-issues \"Direct link to Common issues\")\n\nDifferent methods have their own pros and cons related to cost, speed, and accuracy.\n\nWatch out for these issues:\n\n*   Chunking content means that the LLM can fail to extract information if the information is spread across multiple chunks.\n*   Large chunk overlap may cause the same information to be extracted twice, so be prepared to de-duplicate!\n*   LLMs can make up data. If looking for a single fact across a large text and using a brute force approach, you may end up getting more made up data."
},
{
  "url": "https://python.langchain.com/docs/how_to/qa_per_user/",
  "markdown": "# giscus\n\n## How to do per-user retrieval\n\nThis guide demonstrates how to configure runtime properties of a retrieval chain. An example application is to limit the documents available to a [retriever](https://python.langchain.com/docs/concepts/retrievers/) based on the user.\n\nWhen building a [retrieval app](https://python.langchain.com/docs/concepts/rag/), you often have to build it with multiple users in mind. This means that you may be storing data not just for one user, but for many different users, and they should not be able to see eachother's data. This means that you need to be able to configure your retrieval chain to only retrieve certain information. This generally involves two steps.\n\n**Step 1: Make sure the retriever you are using supports multiple users**\n\nAt the moment, there is no unified flag or filter for this in LangChain. Rather, each vectorstore and retriever may have their own, and may be called different things (namespaces, multi-tenancy, etc). For vectorstores, this is generally exposed as a keyword argument that is passed in during `similarity_search`. By reading the documentation or source code, figure out whether the retriever you are using supports multiple users, and, if so, how to use it.\n\nNote: adding documentation and/or support for multiple users for retrievers that do not support it (or document it) is a GREAT way to contribute to LangChain\n\n**Step 2: Add that parameter as a configurable field for the chain**\n\nThis will let you easily call the chain and configure any relevant flags at runtime. See [this documentation](https://python.langchain.com/docs/how_to/configure/) for more information on configuration.\n\nNow, at runtime you can call this chain with configurable field.\n\n## Code Example[​](#code-example \"Direct link to Code Example\")\n\nLet's see a concrete example of what this looks like in code. We will use Pinecone for this example.\n\nTo configure Pinecone, set the following environment variable:\n\n*   `PINECONE_API_KEY`: Your Pinecone API key\n\n```\nfrom langchain_openai import OpenAIEmbeddingsfrom langchain_pinecone import PineconeVectorStoreembeddings = OpenAIEmbeddings()vectorstore = PineconeVectorStore(index_name=\"test-example\", embedding=embeddings)vectorstore.add_texts([\"I worked at Kensho\"], namespace=\"harrison\")vectorstore.add_texts([\"I worked at Facebook\"], namespace=\"ankush\")\n```\n\n```\n['f907aab7-77c7-4347-acc2-6859f8142f92']\n```\n\nThe pinecone kwarg for `namespace` can be used to separate documents\n\n```\n# This will only get documents for Ankushvectorstore.as_retriever(search_kwargs={\"namespace\": \"ankush\"}).invoke(    \"where did i work?\")\n```\n\n```\n[Document(id='f907aab7-77c7-4347-acc2-6859f8142f92', metadata={}, page_content='I worked at Facebook')]\n```\n\n```\n# This will only get documents for Harrisonvectorstore.as_retriever(search_kwargs={\"namespace\": \"harrison\"}).invoke(    \"where did i work?\")\n```\n\n```\n[Document(id='16061fc5-c6fc-4f45-a3b3-23469d7996af', metadata={}, page_content='I worked at Kensho')]\n```\n\nWe can now create the chain that we will use to do question-answering over.\n\nLet's first select a LLM.\n\n```\npip install -qU langchain-openai\n```\n\n```\nimport getpassimport osif not os.environ.get(\"OPENAI_API_KEY\"):  os.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"Enter API key for OpenAI: \")from langchain_openai import ChatOpenAIllm = ChatOpenAI(model=\"gpt-4o-mini\")\n```\n\nThis will follow the basic implementation from the [RAG tutorial](https://python.langchain.com/docs/tutorials/rag/), but we will allow the retrieval step to be configurable.\n\n```\nfrom langchain_core.prompts import ChatPromptTemplatefrom langchain_core.runnables import ConfigurableFieldtemplate = \"\"\"Answer the question based only on the following context:{context}Question: {question}\"\"\"prompt = ChatPromptTemplate.from_template(template)retriever = vectorstore.as_retriever()\n```\n\nHere we mark the retriever as having a configurable field. All vectorstore retrievers have `search_kwargs` as a field. This is just a dictionary, with vectorstore specific fields.\n\nThis will let us pass in a value for `search_kwargs` when invoking the chain.\n\n```\nconfigurable_retriever = retriever.configurable_fields(    search_kwargs=ConfigurableField(        id=\"search_kwargs\",        name=\"Search Kwargs\",        description=\"The search kwargs to use\",    ))\n```\n\nWe can now create the chain using our configurable retriever.\n\n```\nfrom langchain_core.documents import Documentfrom langchain_core.runnables import RunnableConfigfrom langgraph.graph import START, StateGraphfrom typing_extensions import List, TypedDictclass State(TypedDict):    question: str    context: List[Document]    answer: strdef retrieve(state: State, config: RunnableConfig):    retrieved_docs = configurable_retriever.invoke(state[\"question\"])    return {\"context\": retrieved_docs}def generate(state: State):    docs_content = \"\\n\\n\".join(doc.page_content for doc in state[\"context\"])    messages = prompt.invoke({\"question\": state[\"question\"], \"context\": docs_content})    response = llm.invoke(messages)    return {\"answer\": response.content}graph_builder = StateGraph(State).add_sequence([retrieve, generate])graph_builder.add_edge(START, \"retrieve\")graph = graph_builder.compile()\n```\n\n```\nfrom IPython.display import Image, displaydisplay(Image(graph.get_graph().draw_mermaid_png()))\n```\n\n![](data:image/png;base64,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)\n\nWe can now invoke the chain with configurable options. `search_kwargs` is the id of the configurable field. The value is the search kwargs to use for Pinecone.\n\n```\nresult = graph.invoke(    {\"question\": \"Where did the user work?\"},    config={\"configurable\": {\"search_kwargs\": {\"namespace\": \"harrison\"}}},)result\n```\n\n```\n{'question': 'Where did the user work?', 'context': [Document(id='16061fc5-c6fc-4f45-a3b3-23469d7996af', metadata={}, page_content='I worked at Kensho')], 'answer': 'The user worked at Kensho.'}\n```\n\n```\nresult = graph.invoke(    {\"question\": \"Where did the user work?\"},    config={\"configurable\": {\"search_kwargs\": {\"namespace\": \"ankush\"}}},)result\n```\n\n```\n{'question': 'Where did the user work?', 'context': [Document(id='f907aab7-77c7-4347-acc2-6859f8142f92', metadata={}, page_content='I worked at Facebook')], 'answer': 'The user worked at Facebook.'}\n```\n\nFor details operating your specific vector store, see the [integration pages](https://python.langchain.com/docs/integrations/vectorstores/)."
},
{
  "url": "https://python.langchain.com/docs/how_to/example_selectors/",
  "markdown": "# giscus\n\n[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/langchain-ai/langchain/blob/master/docs/docs/how_to/example_selectors.ipynb)[![Open on GitHub](https://img.shields.io/badge/Open%20on%20GitHub-grey?logo=github&logoColor=white)](https://github.com/langchain-ai/langchain/blob/master/docs/docs/how_to/example_selectors.ipynb)\n\n## How to use example selectors\n\nIf you have a large number of examples, you may need to select which ones to include in the prompt. The [Example Selector](https://python.langchain.com/docs/concepts/example_selectors/) is the class responsible for doing so.\n\nThe base interface is defined as below:\n\n```\nclass BaseExampleSelector(ABC):    \"\"\"Interface for selecting examples to include in prompts.\"\"\"    @abstractmethod    def select_examples(self, input_variables: Dict[str, str]) -> List[dict]:        \"\"\"Select which examples to use based on the inputs.\"\"\"            @abstractmethod    def add_example(self, example: Dict[str, str]) -> Any:        \"\"\"Add new example to store.\"\"\"\n```\n\nThe only method it needs to define is a `select_examples` method. This takes in the input variables and then returns a list of examples. It is up to each specific implementation as to how those examples are selected.\n\nLangChain has a few different types of example selectors. For an overview of all these types, see the [below table](#example-selector-types).\n\nIn this guide, we will walk through creating a custom example selector.\n\n## Examples[​](#examples \"Direct link to Examples\")\n\nIn order to use an example selector, we need to create a list of examples. These should generally be example inputs and outputs. For this demo purpose, let's imagine we are selecting examples of how to translate English to Italian.\n\n```\nexamples = [    {\"input\": \"hi\", \"output\": \"ciao\"},    {\"input\": \"bye\", \"output\": \"arrivederci\"},    {\"input\": \"soccer\", \"output\": \"calcio\"},]\n```\n\n## Custom Example Selector[​](#custom-example-selector \"Direct link to Custom Example Selector\")\n\nLet's write an example selector that chooses what example to pick based on the length of the word.\n\n```\nfrom langchain_core.example_selectors.base import BaseExampleSelectorclass CustomExampleSelector(BaseExampleSelector):    def __init__(self, examples):        self.examples = examples    def add_example(self, example):        self.examples.append(example)    def select_examples(self, input_variables):        # This assumes knowledge that part of the input will be a 'text' key        new_word = input_variables[\"input\"]        new_word_length = len(new_word)        # Initialize variables to store the best match and its length difference        best_match = None        smallest_diff = float(\"inf\")        # Iterate through each example        for example in self.examples:            # Calculate the length difference with the first word of the example            current_diff = abs(len(example[\"input\"]) - new_word_length)            # Update the best match if the current one is closer in length            if current_diff < smallest_diff:                smallest_diff = current_diff                best_match = example        return [best_match]\n```\n\n```\nexample_selector = CustomExampleSelector(examples)\n```\n\n```\nexample_selector.select_examples({\"input\": \"okay\"})\n```\n\n```\n[{'input': 'bye', 'output': 'arrivederci'}]\n```\n\n```\nexample_selector.add_example({\"input\": \"hand\", \"output\": \"mano\"})\n```\n\n```\nexample_selector.select_examples({\"input\": \"okay\"})\n```\n\n```\n[{'input': 'hand', 'output': 'mano'}]\n```\n\n## Use in a Prompt[​](#use-in-a-prompt \"Direct link to Use in a Prompt\")\n\nWe can now use this example selector in a prompt\n\n```\nfrom langchain_core.prompts.few_shot import FewShotPromptTemplatefrom langchain_core.prompts.prompt import PromptTemplateexample_prompt = PromptTemplate.from_template(\"Input: {input} -> Output: {output}\")\n```\n\n```\nprompt = FewShotPromptTemplate(    example_selector=example_selector,    example_prompt=example_prompt,    suffix=\"Input: {input} -> Output:\",    prefix=\"Translate the following words from English to Italian:\",    input_variables=[\"input\"],)print(prompt.format(input=\"word\"))\n```\n\n```\nTranslate the following words from English to Italian:Input: hand -> Output: manoInput: word -> Output:\n```\n\n## Example Selector Types[​](#example-selector-types \"Direct link to Example Selector Types\")\n\n| Name | Description |\n| --- | --- |\n| Similarity | Uses semantic similarity between inputs and examples to decide which examples to choose. |\n| MMR | Uses Max Marginal Relevance between inputs and examples to decide which examples to choose. |\n| Length | Selects examples based on how many can fit within a certain length |\n| Ngram | Uses ngram overlap between inputs and examples to decide which examples to choose. |"
},
{
  "url": "https://python.langchain.com/docs/how_to/qa_sources/",
  "markdown": "# giscus\n\n## How to get your RAG application to return sources\n\nOften in [Q&A](https://python.langchain.com/docs/concepts/rag/) applications it's important to show users the sources that were used to generate the answer. The simplest way to do this is for the chain to return the Documents that were retrieved in each generation.\n\nWe'll work off of the Q&A app we built over the [LLM Powered Autonomous Agents](https://lilianweng.github.io/posts/2023-06-23-agent/) blog post by Lilian Weng in the [RAG tutorial](https://python.langchain.com/docs/tutorials/rag/).\n\nWe will cover two approaches:\n\n1.  Using the basic RAG chain covered in [Part 1](https://python.langchain.com/docs/tutorials/rag/) of the RAG tutorial;\n2.  Using a conversational RAG chain as convered in [Part 2](https://python.langchain.com/docs/tutorials/qa_chat_history/) of the tutorial.\n\nWe will also show how to structure sources into the model response, such that a model can report what specific sources it used in generating its answer.\n\n## Setup[​](#setup \"Direct link to Setup\")\n\n### Dependencies[​](#dependencies \"Direct link to Dependencies\")\n\nWe'll use the following packages:\n\n```\n%pip install --upgrade --quiet langchain langchain-community langchainhub beautifulsoup4\n```\n\n### LangSmith[​](#langsmith \"Direct link to LangSmith\")\n\nMany of the applications you build with LangChain will contain multiple steps with multiple invocations of LLM calls. As these applications get more and more complex, it becomes crucial to be able to inspect what exactly is going on inside your chain or agent. The best way to do this is with [LangSmith](https://smith.langchain.com/).\n\nNote that LangSmith is not needed, but it is helpful. If you do want to use LangSmith, after you sign up at the link above, make sure to set your environment variables to start logging traces:\n\n```\nos.environ[\"LANGCHAIN_TRACING_V2\"] = \"true\"os.environ[\"LANGCHAIN_API_KEY\"] = getpass.getpass()\n```\n\n### Components[​](#components \"Direct link to Components\")\n\nWe will need to select three components from LangChain's suite of integrations.\n\nA [chat model](https://python.langchain.com/docs/integrations/chat/):\n\n```\npip install -qU langchain-openai\n```\n\n```\nimport getpassimport osif not os.environ.get(\"OPENAI_API_KEY\"):  os.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"Enter API key for OpenAI: \")from langchain_openai import ChatOpenAIllm = ChatOpenAI(model=\"gpt-4o-mini\")\n```\n\nAn [embedding model](https://python.langchain.com/docs/integrations/text_embedding/):\n\n```\npip install -qU langchain-openai\n```\n\n```\nimport getpassimport osif not os.environ.get(\"OPENAI_API_KEY\"):  os.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"Enter API key for OpenAI: \")from langchain_openai import OpenAIEmbeddingsembeddings = OpenAIEmbeddings(model=\"text-embedding-3-large\")\n```\n\nAnd a [vector store](https://python.langchain.com/docs/integrations/vectorstores/):\n\n```\npip install -qU langchain-core\n```\n\n```\nfrom langchain_core.vectorstores import InMemoryVectorStorevector_store = InMemoryVectorStore(embeddings)\n```\n\n## RAG application[​](#rag-application \"Direct link to RAG application\")\n\nLet's reconstruct the Q&A app with sources we built over the [LLM Powered Autonomous Agents](https://lilianweng.github.io/posts/2023-06-23-agent/) blog post by Lilian Weng in the [RAG tutorial](https://python.langchain.com/docs/tutorials/rag/).\n\nFirst we index our documents:\n\n```\nimport bs4from langchain import hubfrom langchain_community.document_loaders import WebBaseLoaderfrom langchain_core.documents import Documentfrom langchain_text_splitters import RecursiveCharacterTextSplitterfrom typing_extensions import List, TypedDict# Load and chunk contents of the blogloader = WebBaseLoader(    web_paths=(\"https://lilianweng.github.io/posts/2023-06-23-agent/\",),    bs_kwargs=dict(        parse_only=bs4.SoupStrainer(            class_=(\"post-content\", \"post-title\", \"post-header\")        )    ),)docs = loader.load()text_splitter = RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=200)all_splits = text_splitter.split_documents(docs)\n```\n\n```\n# Index chunks_ = vector_store.add_documents(documents=all_splits)\n```\n\nNext we build the application:\n\n```\nfrom langchain import hubfrom langchain_core.documents import Documentfrom langgraph.graph import START, StateGraphfrom typing_extensions import List, TypedDict# Define prompt for question-answeringprompt = hub.pull(\"rlm/rag-prompt\")# Define state for applicationclass State(TypedDict):    question: str    context: List[Document]    answer: str# Define application stepsdef retrieve(state: State):    retrieved_docs = vector_store.similarity_search(state[\"question\"])    return {\"context\": retrieved_docs}def generate(state: State):    docs_content = \"\\n\\n\".join(doc.page_content for doc in state[\"context\"])    messages = prompt.invoke({\"question\": state[\"question\"], \"context\": docs_content})    response = llm.invoke(messages)    return {\"answer\": response.content}# Compile application and testgraph_builder = StateGraph(State).add_sequence([retrieve, generate])graph_builder.add_edge(START, \"retrieve\")graph = graph_builder.compile()\n```\n\n```\nfrom IPython.display import Image, displaydisplay(Image(graph.get_graph().draw_mermaid_png()))\n```\n\n![](data:image/png;base64,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)\n\nBecause we're tracking the retrieved context in our application's state, it is accessible after invoking the application:\n\n```\nresult = graph.invoke({\"question\": \"What is Task Decomposition?\"})print(f'Context: {result[\"context\"]}\\n\\n')print(f'Answer: {result[\"answer\"]}')\n```\n\n```\nContext: [Document(id='c8471b37-07d8-4d51-856e-4b2c22bca88d', metadata={'source': 'https://lilianweng.github.io/posts/2023-06-23-agent/'}, page_content='Fig. 1. Overview of a LLM-powered autonomous agent system.\\nComponent One: Planning#\\nA complicated task usually involves many steps. An agent needs to know what they are and plan ahead.\\nTask Decomposition#\\nChain of thought (CoT; Wei et al. 2022) has become a standard prompting technique for enhancing model performance on complex tasks. The model is instructed to “think step by step” to utilize more test-time computation to decompose hard tasks into smaller and simpler steps. CoT transforms big tasks into multiple manageable tasks and shed lights into an interpretation of the model’s thinking process.'), Document(id='acb7eb6f-f252-4353-aec2-f459135354ba', metadata={'source': 'https://lilianweng.github.io/posts/2023-06-23-agent/'}, page_content='Tree of Thoughts (Yao et al. 2023) extends CoT by exploring multiple reasoning possibilities at each step. It first decomposes the problem into multiple thought steps and generates multiple thoughts per step, creating a tree structure. The search process can be BFS (breadth-first search) or DFS (depth-first search) with each state evaluated by a classifier (via a prompt) or majority vote.\\nTask decomposition can be done (1) by LLM with simple prompting like \"Steps for XYZ.\\\\n1.\", \"What are the subgoals for achieving XYZ?\", (2) by using task-specific instructions; e.g. \"Write a story outline.\" for writing a novel, or (3) with human inputs.'), Document(id='4fae6668-7fec-4237-9b2d-78132f4f3f3f', metadata={'source': 'https://lilianweng.github.io/posts/2023-06-23-agent/'}, page_content='Resources:\\n1. Internet access for searches and information gathering.\\n2. Long Term memory management.\\n3. GPT-3.5 powered Agents for delegation of simple tasks.\\n4. File output.\\n\\nPerformance Evaluation:\\n1. Continuously review and analyze your actions to ensure you are performing to the best of your abilities.\\n2. Constructively self-criticize your big-picture behavior constantly.\\n3. Reflect on past decisions and strategies to refine your approach.\\n4. Every command has a cost, so be smart and efficient. Aim to complete tasks in the least number of steps.'), Document(id='3c79dd86-595e-42e8-b64d-404780f9e2d9', metadata={'source': 'https://lilianweng.github.io/posts/2023-06-23-agent/'}, page_content=\"(3) Task execution: Expert models execute on the specific tasks and log results.\\nInstruction:\\n\\nWith the input and the inference results, the AI assistant needs to describe the process and results. The previous stages can be formed as - User Input: {{ User Input }}, Task Planning: {{ Tasks }}, Model Selection: {{ Model Assignment }}, Task Execution: {{ Predictions }}. You must first answer the user's request in a straightforward manner. Then describe the task process and show your analysis and model inference results to the user in the first person. If inference results contain a file path, must tell the user the complete file path.\")]Answer: Task Decomposition is the process of breaking down a complex task into smaller, manageable steps to facilitate execution. This can be achieved through techniques like Chain of Thought, which encourages step-by-step reasoning, or Tree of Thoughts, which explores multiple reasoning paths for each step. It can be implemented using simple prompts, specific instructions, or human input to effectively tackle the original task.\n```\n\nHere, `\"context\"` contains the sources that the LLM used in generating the response in `\"answer\"`.\n\n## Structure sources in model response[​](#structure-sources-in-model-response \"Direct link to Structure sources in model response\")\n\nUp to this point, we've simply propagated the documents returned from the retrieval step through to the final response. But this may not illustrate what subset of information the model relied on when generating its answer. Below, we show how to structure sources into the model response, allowing the model to report what specific context it relied on for its answer.\n\nIt is straightforward to extend the above LangGraph implementation. Below, we make a simple change: we use the model's tool-calling features to generate [structured output](https://python.langchain.com/docs/how_to/structured_output/), consisting of an answer and list of sources. The schema for the response is represented in the `AnswerWithSources` TypedDict, below.\n\n```\nfrom typing import Listfrom typing_extensions import Annotated, TypedDict# Desired schema for responseclass AnswerWithSources(TypedDict):    \"\"\"An answer to the question, with sources.\"\"\"    answer: str    sources: Annotated[        List[str],        ...,        \"List of sources (author + year) used to answer the question\",    ]class State(TypedDict):    question: str    context: List[Document]    answer: AnswerWithSourcesdef generate(state: State):    docs_content = \"\\n\\n\".join(doc.page_content for doc in state[\"context\"])    messages = prompt.invoke({\"question\": state[\"question\"], \"context\": docs_content})    structured_llm = llm.with_structured_output(AnswerWithSources)    response = structured_llm.invoke(messages)    return {\"answer\": response}graph_builder = StateGraph(State).add_sequence([retrieve, generate])graph_builder.add_edge(START, \"retrieve\")graph = graph_builder.compile()\n```\n\n```\nimport jsonresult = graph.invoke({\"question\": \"What is Chain of Thought?\"})print(json.dumps(result[\"answer\"], indent=2))\n```\n\n```\n{  \"answer\": \"Chain of Thought (CoT) is a prompting technique that enhances model performance by instructing it to think step by step, allowing the decomposition of complex tasks into smaller, manageable steps. This method not only aids in task execution but also provides insights into the model's reasoning process. CoT has become a standard approach in improving how language models handle intricate problem-solving tasks.\",  \"sources\": [    \"Wei et al. 2022\"  ]}\n```\n\n## Conversational RAG[​](#conversational-rag \"Direct link to Conversational RAG\")\n\n[Part 2](https://python.langchain.com/docs/tutorials/qa_chat_history/) of the RAG tutorial implements a different architecture, in which steps in the RAG flow are represented via successive [message](https://python.langchain.com/docs/concepts/messages/) objects. This leverages additional [tool-calling](https://python.langchain.com/docs/concepts/tool_calling/) features of chat models, and more naturally accommodates a \"back-and-forth\" conversational user experience.\n\nIn that tutorial (and below), we propagate the retrieved documents as [artifacts](https://python.langchain.com/docs/how_to/tool_artifacts/) on the tool messages. That makes it easy to pluck out the retrieved documents. Below, we add them as an additional key in the state, for convenience.\n\nNote that we define the response format of the tool as `\"content_and_artifact\"`:\n\n```\nfrom langchain_core.tools import tool@tool(response_format=\"content_and_artifact\")def retrieve(query: str):    \"\"\"Retrieve information related to a query.\"\"\"    retrieved_docs = vector_store.similarity_search(query, k=2)    serialized = \"\\n\\n\".join(        (f\"Source: {doc.metadata}\\n\" f\"Content: {doc.page_content}\")        for doc in retrieved_docs    )    return serialized, retrieved_docs\n```\n\n**API Reference:**[tool](https://python.langchain.com/api_reference/core/tools/langchain_core.tools.convert.tool.html)\n\nWe can now build and compile the exact same application as in [Part 2](https://python.langchain.com/docs/tutorials/qa_chat_history/) of the RAG tutorial, with two changes:\n\n1.  We add a `context` key of the state to store retrieved documents;\n2.  In the `generate` step, we pluck out the retrieved documents and populate them in the state.\n\nThese changes are highlighted below.\n\n```\nfrom langchain_core.messages import SystemMessagefrom langgraph.graph import END, MessagesState, StateGraphfrom langgraph.prebuilt import ToolNode, tools_conditionclass State(MessagesState):    context: List[Document]# Step 1: Generate an AIMessage that may include a tool-call to be sent.def query_or_respond(state: State):    \"\"\"Generate tool call for retrieval or respond.\"\"\"    llm_with_tools = llm.bind_tools([retrieve])    response = llm_with_tools.invoke(state[\"messages\"])    # MessagesState appends messages to state instead of overwriting    return {\"messages\": [response]}# Step 2: Execute the retrieval.tools = ToolNode([retrieve])# Step 3: Generate a response using the retrieved content.def generate(state: MessagesState):    \"\"\"Generate answer.\"\"\"    # Get generated ToolMessages    recent_tool_messages = []    for message in reversed(state[\"messages\"]):        if message.type == \"tool\":            recent_tool_messages.append(message)        else:            break    tool_messages = recent_tool_messages[::-1]    # Format into prompt    docs_content = \"\\n\\n\".join(doc.content for doc in tool_messages)    system_message_content = (        \"You are an assistant for question-answering tasks. \"        \"Use the following pieces of retrieved context to answer \"        \"the question. If you don't know the answer, say that you \"        \"don't know. Use three sentences maximum and keep the \"        \"answer concise.\"        \"\\n\\n\"        f\"{docs_content}\"    )    conversation_messages = [        message        for message in state[\"messages\"]        if message.type in (\"human\", \"system\")        or (message.type == \"ai\" and not message.tool_calls)    ]    prompt = [SystemMessage(system_message_content)] + conversation_messages    # Run    response = llm.invoke(prompt)    context = []    for tool_message in tool_messages:        context.extend(tool_message.artifact)    return {\"messages\": [response], \"context\": context}\n```\n\nWe can compile the application as before:\n\n```\ngraph_builder = StateGraph(MessagesState)graph_builder.add_node(query_or_respond)graph_builder.add_node(tools)graph_builder.add_node(generate)graph_builder.set_entry_point(\"query_or_respond\")graph_builder.add_conditional_edges(    \"query_or_respond\",    tools_condition,    {END: END, \"tools\": \"tools\"},)graph_builder.add_edge(\"tools\", \"generate\")graph_builder.add_edge(\"generate\", END)graph = graph_builder.compile()\n```\n\n```\ndisplay(Image(graph.get_graph().draw_mermaid_png()))\n```\n\n![](data:image/png;base64,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)\n\nInvoking our application, we see that the retrieved [Document](https://python.langchain.com/api_reference/core/documents/langchain_core.documents.base.Document.html) objects are accessible from the application state.\n\n```\ninput_message = \"What is Task Decomposition?\"for step in graph.stream(    {\"messages\": [{\"role\": \"user\", \"content\": input_message}]},    stream_mode=\"values\",):    step[\"messages\"][-1].pretty_print()\n```\n\n```\n================================\u001b[1m Human Message \u001b[0m=================================What is Task Decomposition?==================================\u001b[1m Ai Message \u001b[0m==================================Tool Calls:  retrieve (call_oA0XZ5hF70X0oW4ccNUFCFxX) Call ID: call_oA0XZ5hF70X0oW4ccNUFCFxX  Args:    query: Task Decomposition=================================\u001b[1m Tool Message \u001b[0m=================================Name: retrieveSource: {'source': 'https://lilianweng.github.io/posts/2023-06-23-agent/'}Content: Fig. 1. Overview of a LLM-powered autonomous agent system.Component One: Planning#A complicated task usually involves many steps. An agent needs to know what they are and plan ahead.Task Decomposition#Chain of thought (CoT; Wei et al. 2022) has become a standard prompting technique for enhancing model performance on complex tasks. The model is instructed to “think step by step” to utilize more test-time computation to decompose hard tasks into smaller and simpler steps. CoT transforms big tasks into multiple manageable tasks and shed lights into an interpretation of the model’s thinking process.Source: {'source': 'https://lilianweng.github.io/posts/2023-06-23-agent/'}Content: Tree of Thoughts (Yao et al. 2023) extends CoT by exploring multiple reasoning possibilities at each step. It first decomposes the problem into multiple thought steps and generates multiple thoughts per step, creating a tree structure. The search process can be BFS (breadth-first search) or DFS (depth-first search) with each state evaluated by a classifier (via a prompt) or majority vote.Task decomposition can be done (1) by LLM with simple prompting like \"Steps for XYZ.\\n1.\", \"What are the subgoals for achieving XYZ?\", (2) by using task-specific instructions; e.g. \"Write a story outline.\" for writing a novel, or (3) with human inputs.==================================\u001b[1m Ai Message \u001b[0m==================================Task Decomposition is the process of breaking down a complicated task into smaller, manageable steps. It often utilizes techniques like Chain of Thought (CoT) prompting, which encourages models to think step by step, enhancing performance on complex tasks. This approach helps clarify the model's reasoning and makes it easier to tackle difficult problems.\n```\n\n```\n[Document(id='c8471b37-07d8-4d51-856e-4b2c22bca88d', metadata={'source': 'https://lilianweng.github.io/posts/2023-06-23-agent/'}, page_content='Fig. 1. Overview of a LLM-powered autonomous agent system.\\nComponent One: Planning#\\nA complicated task usually involves many steps. An agent needs to know what they are and plan ahead.\\nTask Decomposition#\\nChain of thought (CoT; Wei et al. 2022) has become a standard prompting technique for enhancing model performance on complex tasks. The model is instructed to “think step by step” to utilize more test-time computation to decompose hard tasks into smaller and simpler steps. CoT transforms big tasks into multiple manageable tasks and shed lights into an interpretation of the model’s thinking process.'), Document(id='acb7eb6f-f252-4353-aec2-f459135354ba', metadata={'source': 'https://lilianweng.github.io/posts/2023-06-23-agent/'}, page_content='Tree of Thoughts (Yao et al. 2023) extends CoT by exploring multiple reasoning possibilities at each step. It first decomposes the problem into multiple thought steps and generates multiple thoughts per step, creating a tree structure. The search process can be BFS (breadth-first search) or DFS (depth-first search) with each state evaluated by a classifier (via a prompt) or majority vote.\\nTask decomposition can be done (1) by LLM with simple prompting like \"Steps for XYZ.\\\\n1.\", \"What are the subgoals for achieving XYZ?\", (2) by using task-specific instructions; e.g. \"Write a story outline.\" for writing a novel, or (3) with human inputs.')]\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/debugging/",
  "markdown": "# giscus\n\n## How to debug your LLM apps\n\nLike building any type of software, at some point you'll need to debug when building with LLMs. A model call will fail, or model output will be misformatted, or there will be some nested model calls and it won't be clear where along the way an incorrect output was created.\n\nThere are three main methods for debugging:\n\n*   Verbose Mode: This adds print statements for \"important\" events in your chain.\n*   Debug Mode: This add logging statements for ALL events in your chain.\n*   LangSmith Tracing: This logs events to [LangSmith](https://docs.smith.langchain.com/) to allow for visualization there.\n\n|     | Verbose Mode | Debug Mode | LangSmith Tracing |\n| --- | --- | --- | --- |\n| Free | ✅   | ✅   | ✅   |\n| UI  | ❌   | ❌   | ✅   |\n| Persisted | ❌   | ❌   | ✅   |\n| See all events | ❌   | ✅   | ✅   |\n| See \"important\" events | ✅   | ❌   | ✅   |\n| Runs Locally | ✅   | ✅   | ❌   |\n\n## Tracing[​](#tracing \"Direct link to Tracing\")\n\nMany of the applications you build with LangChain will contain multiple steps with multiple invocations of LLM calls. As these applications get more and more complex, it becomes crucial to be able to inspect what exactly is going on inside your chain or agent. The best way to do this is with [LangSmith](https://smith.langchain.com/).\n\nAfter you sign up at the link above, make sure to set your environment variables to start logging traces:\n\n```\nexport LANGCHAIN_TRACING_V2=\"true\"export LANGCHAIN_API_KEY=\"...\"\n```\n\nOr, if in a notebook, you can set them with:\n\n```\nimport getpassimport osos.environ[\"LANGCHAIN_TRACING_V2\"] = \"true\"os.environ[\"LANGCHAIN_API_KEY\"] = getpass.getpass()\n```\n\nLet's suppose we have an agent, and want to visualize the actions it takes and tool outputs it receives. Without any debugging, here's what we see:\n\n```\npip install -qU langchain-openai\n```\n\n```\nimport getpassimport osif not os.environ.get(\"OPENAI_API_KEY\"):  os.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"Enter API key for OpenAI: \")from langchain_openai import ChatOpenAIllm = ChatOpenAI(model=\"gpt-4o-mini\")\n```\n\n```\nfrom langchain.agents import AgentExecutor, create_tool_calling_agentfrom langchain_community.tools.tavily_search import TavilySearchResultsfrom langchain_core.prompts import ChatPromptTemplatetools = [TavilySearchResults(max_results=1)]prompt = ChatPromptTemplate.from_messages(    [        (            \"system\",            \"You are a helpful assistant.\",        ),        (\"placeholder\", \"{chat_history}\"),        (\"human\", \"{input}\"),        (\"placeholder\", \"{agent_scratchpad}\"),    ])# Construct the Tools agentagent = create_tool_calling_agent(llm, tools, prompt)# Create an agent executor by passing in the agent and toolsagent_executor = AgentExecutor(agent=agent, tools=tools)agent_executor.invoke(    {\"input\": \"Who directed the 2023 film Oppenheimer and what is their age in days?\"})\n```\n\n```\n{'input': 'Who directed the 2023 film Oppenheimer and what is their age in days?', 'output': 'The 2023 film \"Oppenheimer\" was directed by Christopher Nolan.\\n\\nTo calculate Christopher Nolan\\'s age in days, we first need his birthdate, which is July 30, 1970. Let\\'s calculate his age in days from his birthdate to today\\'s date, December 7, 2023.\\n\\n1. Calculate the total number of days from July 30, 1970, to December 7, 2023.\\n2. Nolan was born on July 30, 1970. From July 30, 1970, to July 30, 2023, is 53 years.\\n3. From July 30, 2023, to December 7, 2023, is 130 days.\\n\\nNow, calculate the total days:\\n- 53 years = 53 x 365 = 19,345 days\\n- Adding leap years from 1970 to 2023: There are 13 leap years (1972, 1976, 1980, 1984, 1988, 1992, 1996, 2000, 2004, 2008, 2012, 2016, 2020). So, add 13 days.\\n- Total days from years and leap years = 19,345 + 13 = 19,358 days\\n- Add the days from July 30, 2023, to December 7, 2023 = 130 days\\n\\nTotal age in days = 19,358 + 130 = 19,488 days\\n\\nChristopher Nolan is 19,488 days old as of December 7, 2023.'}\n```\n\nWe don't get much output, but since we set up LangSmith we can easily see what happened under the hood:\n\n[https://smith.langchain.com/public/a89ff88f-9ddc-4757-a395-3a1b365655bf/r](https://smith.langchain.com/public/a89ff88f-9ddc-4757-a395-3a1b365655bf/r)\n\n## `set_debug` and `set_verbose`[​](#set_debug-and-set_verbose \"Direct link to set_debug-and-set_verbose\")\n\nIf you're prototyping in Jupyter Notebooks or running Python scripts, it can be helpful to print out the intermediate steps of a chain run.\n\nThere are a number of ways to enable printing at varying degrees of verbosity.\n\nNote: These still work even with LangSmith enabled, so you can have both turned on and running at the same time\n\n### `set_verbose(True)`[​](#set_verbosetrue \"Direct link to set_verbosetrue\")\n\nSetting the `verbose` flag will print out inputs and outputs in a slightly more readable format and will skip logging certain raw outputs (like the token usage stats for an LLM call) so that you can focus on application logic.\n\n```\nfrom langchain.globals import set_verboseset_verbose(True)agent_executor = AgentExecutor(agent=agent, tools=tools)agent_executor.invoke(    {\"input\": \"Who directed the 2023 film Oppenheimer and what is their age in days?\"})\n```\n\n```\n\u001b[1m> Entering new AgentExecutor chain...\u001b[0m\u001b[32;1m\u001b[1;3mInvoking: `tavily_search_results_json` with `{'query': 'director of the 2023 film Oppenheimer'}`\u001b[0m\u001b[36;1m\u001b[1;3m[{'url': 'https://m.imdb.com/title/tt15398776/', 'content': 'Oppenheimer: Directed by Christopher Nolan. With Cillian Murphy, Emily Blunt, Robert Downey Jr., Alden Ehrenreich. The story of American scientist J. Robert Oppenheimer and his role in the development of the atomic bomb.'}]\u001b[0m\u001b[32;1m\u001b[1;3mInvoking: `tavily_search_results_json` with `{'query': 'birth date of Christopher Nolan'}`\u001b[0m\u001b[36;1m\u001b[1;3m[{'url': 'https://m.imdb.com/name/nm0634240/bio/', 'content': 'Christopher Nolan. Writer: Tenet. Best known for his cerebral, often nonlinear, storytelling, acclaimed Academy Award winner writer/director/producer Sir Christopher Nolan CBE was born in London, England. Over the course of more than 25 years of filmmaking, Nolan has gone from low-budget independent films to working on some of the biggest blockbusters ever made and became one of the most ...'}]\u001b[0m\u001b[32;1m\u001b[1;3mInvoking: `tavily_search_results_json` with `{'query': 'Christopher Nolan birth date'}`responded: The 2023 film **Oppenheimer** was directed by **Christopher Nolan**.To calculate Christopher Nolan's age in days, I need his exact birth date. Let me find that information for you.\u001b[0m\u001b[36;1m\u001b[1;3m[{'url': 'https://m.imdb.com/name/nm0634240/bio/', 'content': 'Christopher Nolan. Writer: Tenet. Best known for his cerebral, often nonlinear, storytelling, acclaimed Academy Award winner writer/director/producer Sir Christopher Nolan CBE was born in London, England. Over the course of more than 25 years of filmmaking, Nolan has gone from low-budget independent films to working on some of the biggest blockbusters ever made and became one of the most ...'}]\u001b[0m\u001b[32;1m\u001b[1;3mInvoking: `tavily_search_results_json` with `{'query': 'Christopher Nolan date of birth'}`responded: It appears that I need to refine my search to get the exact birth date of Christopher Nolan. Let me try again to find that specific information.\u001b[0m\u001b[36;1m\u001b[1;3m[{'url': 'https://m.imdb.com/name/nm0634240/bio/', 'content': 'Christopher Nolan. Writer: Tenet. Best known for his cerebral, often nonlinear, storytelling, acclaimed Academy Award winner writer/director/producer Sir Christopher Nolan CBE was born in London, England. Over the course of more than 25 years of filmmaking, Nolan has gone from low-budget independent films to working on some of the biggest blockbusters ever made and became one of the most ...'}]\u001b[0m\u001b[32;1m\u001b[1;3mI am currently unable to retrieve the exact birth date of Christopher Nolan from the sources available. However, it is widely known that he was born on July 30, 1970. Using this date, I can calculate his age in days as of today.Let's calculate:- Christopher Nolan's birth date: July 30, 1970.- Today's date: December 7, 2023.The number of days between these two dates can be calculated as follows:1. From July 30, 1970, to July 30, 2023, is 53 years.2. From July 30, 2023, to December 7, 2023, is 130 days.Calculating the total days for 53 years (considering leap years):- 53 years × 365 days/year = 19,345 days- Adding leap years (1972, 1976, ..., 2020, 2024 - 13 leap years): 13 daysTotal days from birth until July 30, 2023: 19,345 + 13 = 19,358 daysAdding the days from July 30, 2023, to December 7, 2023: 130 daysTotal age in days as of December 7, 2023: 19,358 + 130 = 19,488 days.Therefore, Christopher Nolan is 19,488 days old as of December 7, 2023.\u001b[0m\u001b[1m> Finished chain.\u001b[0m\n```\n\n```\n{'input': 'Who directed the 2023 film Oppenheimer and what is their age in days?', 'output': \"I am currently unable to retrieve the exact birth date of Christopher Nolan from the sources available. However, it is widely known that he was born on July 30, 1970. Using this date, I can calculate his age in days as of today.\\n\\nLet's calculate:\\n\\n- Christopher Nolan's birth date: July 30, 1970.\\n- Today's date: December 7, 2023.\\n\\nThe number of days between these two dates can be calculated as follows:\\n\\n1. From July 30, 1970, to July 30, 2023, is 53 years.\\n2. From July 30, 2023, to December 7, 2023, is 130 days.\\n\\nCalculating the total days for 53 years (considering leap years):\\n- 53 years × 365 days/year = 19,345 days\\n- Adding leap years (1972, 1976, ..., 2020, 2024 - 13 leap years): 13 days\\n\\nTotal days from birth until July 30, 2023: 19,345 + 13 = 19,358 days\\nAdding the days from July 30, 2023, to December 7, 2023: 130 days\\n\\nTotal age in days as of December 7, 2023: 19,358 + 130 = 19,488 days.\\n\\nTherefore, Christopher Nolan is 19,488 days old as of December 7, 2023.\"}\n```\n\n### `set_debug(True)`[​](#set_debugtrue \"Direct link to set_debugtrue\")\n\nSetting the global `debug` flag will cause all LangChain components with callback support (chains, models, agents, tools, retrievers) to print the inputs they receive and outputs they generate. This is the most verbose setting and will fully log raw inputs and outputs.\n\n```\nfrom langchain.globals import set_debugset_debug(True)set_verbose(False)agent_executor = AgentExecutor(agent=agent, tools=tools)agent_executor.invoke(    {\"input\": \"Who directed the 2023 film Oppenheimer and what is their age in days?\"})\n```\n\n```\n\u001b[32;1m\u001b[1;3m[chain/start]\u001b[0m \u001b[1m[1:chain:AgentExecutor] Entering Chain run with input:\u001b[0m{  \"input\": \"Who directed the 2023 film Oppenheimer and what is their age in days?\"}\u001b[32;1m\u001b[1;3m[chain/start]\u001b[0m \u001b[1m[1:chain:AgentExecutor > 2:chain:RunnableSequence] Entering Chain run with input:\u001b[0m{  \"input\": \"\"}\u001b[32;1m\u001b[1;3m[chain/start]\u001b[0m \u001b[1m[1:chain:AgentExecutor > 2:chain:RunnableSequence > 3:chain:RunnableAssign<agent_scratchpad>] Entering Chain run with input:\u001b[0m{  \"input\": \"\"}\u001b[32;1m\u001b[1;3m[chain/start]\u001b[0m \u001b[1m[1:chain:AgentExecutor > 2:chain:RunnableSequence > 3:chain:RunnableAssign<agent_scratchpad> > 4:chain:RunnableParallel<agent_scratchpad>] Entering Chain run with input:\u001b[0m{  \"input\": \"\"}\u001b[32;1m\u001b[1;3m[chain/start]\u001b[0m \u001b[1m[1:chain:AgentExecutor > 2:chain:RunnableSequence > 3:chain:RunnableAssign<agent_scratchpad> > 4:chain:RunnableParallel<agent_scratchpad> > 5:chain:RunnableLambda] Entering Chain run with input:\u001b[0m{  \"input\": \"\"}\u001b[36;1m\u001b[1;3m[chain/end]\u001b[0m \u001b[1m[1:chain:AgentExecutor > 2:chain:RunnableSequence > 3:chain:RunnableAssign<agent_scratchpad> > 4:chain:RunnableParallel<agent_scratchpad> > 5:chain:RunnableLambda] [1ms] Exiting Chain run with output:\u001b[0m{  \"output\": []}\u001b[36;1m\u001b[1;3m[chain/end]\u001b[0m \u001b[1m[1:chain:AgentExecutor > 2:chain:RunnableSequence > 3:chain:RunnableAssign<agent_scratchpad> > 4:chain:RunnableParallel<agent_scratchpad>] [2ms] Exiting Chain run with output:\u001b[0m{  \"agent_scratchpad\": []}\u001b[36;1m\u001b[1;3m[chain/end]\u001b[0m \u001b[1m[1:chain:AgentExecutor > 2:chain:RunnableSequence > 3:chain:RunnableAssign<agent_scratchpad>] [5ms] Exiting Chain run with output:\u001b[0m{  \"input\": \"Who directed the 2023 film Oppenheimer and what is their age in days?\",  \"intermediate_steps\": [],  \"agent_scratchpad\": []}\u001b[32;1m\u001b[1;3m[chain/start]\u001b[0m \u001b[1m[1:chain:AgentExecutor > 2:chain:RunnableSequence > 6:prompt:ChatPromptTemplate] Entering Prompt run with input:\u001b[0m{  \"input\": \"Who directed the 2023 film Oppenheimer and what is their age in days?\",  \"intermediate_steps\": [],  \"agent_scratchpad\": []}\u001b[36;1m\u001b[1;3m[chain/end]\u001b[0m \u001b[1m[1:chain:AgentExecutor > 2:chain:RunnableSequence > 6:prompt:ChatPromptTemplate] [1ms] Exiting Prompt run with output:\u001b[0m[outputs]\u001b[32;1m\u001b[1;3m[llm/start]\u001b[0m \u001b[1m[1:chain:AgentExecutor > 2:chain:RunnableSequence > 7:llm:ChatOpenAI] Entering LLM run with input:\u001b[0m{  \"prompts\": [    \"System: You are a helpful assistant.\\nHuman: Who directed the 2023 film Oppenheimer and what is their age in days?\"  ]}\u001b[36;1m\u001b[1;3m[llm/end]\u001b[0m \u001b[1m[1:chain:AgentExecutor > 2:chain:RunnableSequence > 7:llm:ChatOpenAI] [3.17s] Exiting LLM run with output:\u001b[0m{  \"generations\": [    [      {        \"text\": \"\",        \"generation_info\": {          \"finish_reason\": \"tool_calls\"        },        \"type\": \"ChatGenerationChunk\",        \"message\": {          \"lc\": 1,          \"type\": \"constructor\",          \"id\": [            \"langchain\",            \"schema\",            \"messages\",            \"AIMessageChunk\"          ],          \"kwargs\": {            \"content\": \"\",            \"example\": false,            \"additional_kwargs\": {              \"tool_calls\": [                {                  \"index\": 0,                  \"id\": \"call_fnfq6GjSQED4iF6lo4rxkUup\",                  \"function\": {                    \"arguments\": \"{\\\"query\\\": \\\"director of the 2023 film Oppenheimer\\\"}\",                    \"name\": \"tavily_search_results_json\"                  },                  \"type\": \"function\"                },                {                  \"index\": 1,                  \"id\": \"call_mwhVi6pk49f4OIo5rOWrr4TD\",                  \"function\": {                    \"arguments\": \"{\\\"query\\\": \\\"birth date of Christopher Nolan\\\"}\",                    \"name\": \"tavily_search_results_json\"                  },                  \"type\": \"function\"                }              ]            },            \"tool_call_chunks\": [              {                \"name\": \"tavily_search_results_json\",                \"args\": \"{\\\"query\\\": \\\"director of the 2023 film Oppenheimer\\\"}\",                \"id\": \"call_fnfq6GjSQED4iF6lo4rxkUup\",                \"index\": 0              },              {                \"name\": \"tavily_search_results_json\",                \"args\": \"{\\\"query\\\": \\\"birth date of Christopher Nolan\\\"}\",                \"id\": \"call_mwhVi6pk49f4OIo5rOWrr4TD\",                \"index\": 1              }            ],            \"response_metadata\": {              \"finish_reason\": \"tool_calls\"            },            \"id\": \"run-6e160323-15f9-491d-aadf-b5d337e9e2a1\",            \"tool_calls\": [              {                \"name\": \"tavily_search_results_json\",                \"args\": {                  \"query\": \"director of the 2023 film Oppenheimer\"                },                \"id\": \"call_fnfq6GjSQED4iF6lo4rxkUup\"              },              {                \"name\": \"tavily_search_results_json\",                \"args\": {                  \"query\": \"birth date of Christopher Nolan\"                },                \"id\": \"call_mwhVi6pk49f4OIo5rOWrr4TD\"              }            ],            \"invalid_tool_calls\": []          }        }      }    ]  ],  \"llm_output\": null,  \"run\": null}\u001b[32;1m\u001b[1;3m[chain/start]\u001b[0m \u001b[1m[1:chain:AgentExecutor > 2:chain:RunnableSequence > 8:parser:ToolsAgentOutputParser] Entering Parser run with input:\u001b[0m[inputs]\u001b[36;1m\u001b[1;3m[chain/end]\u001b[0m \u001b[1m[1:chain:AgentExecutor > 2:chain:RunnableSequence > 8:parser:ToolsAgentOutputParser] [1ms] Exiting Parser run with output:\u001b[0m[outputs]\u001b[36;1m\u001b[1;3m[chain/end]\u001b[0m \u001b[1m[1:chain:AgentExecutor > 2:chain:RunnableSequence] [3.18s] Exiting Chain run with output:\u001b[0m[outputs]\u001b[32;1m\u001b[1;3m[tool/start]\u001b[0m \u001b[1m[1:chain:AgentExecutor > 9:tool:tavily_search_results_json] Entering Tool run with input:\u001b[0m\"{'query': 'director of the 2023 film Oppenheimer'}\"``````outputError in ConsoleCallbackHandler.on_tool_end callback: AttributeError(\"'list' object has no attribute 'strip'\")``````output\u001b[32;1m\u001b[1;3m[tool/start]\u001b[0m \u001b[1m[1:chain:AgentExecutor > 10:tool:tavily_search_results_json] Entering Tool run with input:\u001b[0m\"{'query': 'birth date of Christopher Nolan'}\"``````outputError in ConsoleCallbackHandler.on_tool_end callback: AttributeError(\"'list' object has no attribute 'strip'\")``````output\u001b[32;1m\u001b[1;3m[chain/start]\u001b[0m \u001b[1m[1:chain:AgentExecutor > 11:chain:RunnableSequence] Entering Chain run with input:\u001b[0m{  \"input\": \"\"}\u001b[32;1m\u001b[1;3m[chain/start]\u001b[0m \u001b[1m[1:chain:AgentExecutor > 11:chain:RunnableSequence > 12:chain:RunnableAssign<agent_scratchpad>] Entering Chain run with input:\u001b[0m{  \"input\": \"\"}\u001b[32;1m\u001b[1;3m[chain/start]\u001b[0m \u001b[1m[1:chain:AgentExecutor > 11:chain:RunnableSequence > 12:chain:RunnableAssign<agent_scratchpad> > 13:chain:RunnableParallel<agent_scratchpad>] Entering Chain run with input:\u001b[0m{  \"input\": \"\"}\u001b[32;1m\u001b[1;3m[chain/start]\u001b[0m \u001b[1m[1:chain:AgentExecutor > 11:chain:RunnableSequence > 12:chain:RunnableAssign<agent_scratchpad> > 13:chain:RunnableParallel<agent_scratchpad> > 14:chain:RunnableLambda] Entering Chain run with input:\u001b[0m{  \"input\": \"\"}\u001b[36;1m\u001b[1;3m[chain/end]\u001b[0m \u001b[1m[1:chain:AgentExecutor > 11:chain:RunnableSequence > 12:chain:RunnableAssign<agent_scratchpad> > 13:chain:RunnableParallel<agent_scratchpad> > 14:chain:RunnableLambda] [1ms] Exiting Chain run with output:\u001b[0m[outputs]\u001b[36;1m\u001b[1;3m[chain/end]\u001b[0m \u001b[1m[1:chain:AgentExecutor > 11:chain:RunnableSequence > 12:chain:RunnableAssign<agent_scratchpad> > 13:chain:RunnableParallel<agent_scratchpad>] [4ms] Exiting Chain run with output:\u001b[0m[outputs]\u001b[36;1m\u001b[1;3m[chain/end]\u001b[0m \u001b[1m[1:chain:AgentExecutor > 11:chain:RunnableSequence > 12:chain:RunnableAssign<agent_scratchpad>] [8ms] Exiting Chain run with output:\u001b[0m[outputs]\u001b[32;1m\u001b[1;3m[chain/start]\u001b[0m \u001b[1m[1:chain:AgentExecutor > 11:chain:RunnableSequence > 15:prompt:ChatPromptTemplate] Entering Prompt run with input:\u001b[0m[inputs]\u001b[36;1m\u001b[1;3m[chain/end]\u001b[0m \u001b[1m[1:chain:AgentExecutor > 11:chain:RunnableSequence > 15:prompt:ChatPromptTemplate] [1ms] Exiting Prompt run with output:\u001b[0m[outputs]\u001b[32;1m\u001b[1;3m[llm/start]\u001b[0m \u001b[1m[1:chain:AgentExecutor > 11:chain:RunnableSequence > 16:llm:ChatOpenAI] Entering LLM run with input:\u001b[0m{  \"prompts\": [    \"System: You are a helpful assistant.\\nHuman: Who directed the 2023 film Oppenheimer and what is their age in days?\\nAI: \\nTool: [{\\\"url\\\": \\\"https://m.imdb.com/title/tt15398776/fullcredits/\\\", \\\"content\\\": \\\"Oppenheimer (2023) cast and crew credits, including actors, actresses, directors, writers and more. Menu. ... director of photography: behind-the-scenes Jason Gary ... best boy grip ... film loader Luc Poullain ... aerial coordinator\\\"}]\\nTool: [{\\\"url\\\": \\\"https://en.wikipedia.org/wiki/Christopher_Nolan\\\", \\\"content\\\": \\\"In early 2003, Nolan approached Warner Bros. with the idea of making a new Batman film, based on the character's origin story.[58] Nolan was fascinated by the notion of grounding it in a more realistic world than a comic-book fantasy.[59] He relied heavily on traditional stunts and miniature effects during filming, with minimal use of computer-generated imagery (CGI).[60] Batman Begins (2005), the biggest project Nolan had undertaken to that point,[61] was released to critical acclaim and commercial success.[62][63] Starring Christian Bale as Bruce Wayne / Batman—along with Michael Caine, Gary Oldman, Morgan Freeman and Liam Neeson—Batman Begins revived the franchise.[64][65] Batman Begins was 2005's ninth-highest-grossing film and was praised for its psychological depth and contemporary relevance;[63][66] it is cited as one of the most influential films of the 2000s.[67] Film author Ian Nathan wrote that within five years of his career, Nolan \\\\\\\"[went] from unknown to indie darling to gaining creative control over one of the biggest properties in Hollywood, and (perhaps unwittingly) fomenting the genre that would redefine the entire industry\\\\\\\".[68]\\\\nNolan directed, co-wrote and produced The Prestige (2006), an adaptation of the Christopher Priest novel about two rival 19th-century magicians.[69] He directed, wrote and edited the short film Larceny (1996),[19] which was filmed over a weekend in black and white with limited equipment and a small cast and crew.[12][20] Funded by Nolan and shot with the UCL Union Film society's equipment, it appeared at the Cambridge Film Festival in 1996 and is considered one of UCL's best shorts.[21] For unknown reasons, the film has since been removed from public view.[19] Nolan filmed a third short, Doodlebug (1997), about a man seemingly chasing an insect with his shoe, only to discover that it is a miniature of himself.[14][22] Nolan and Thomas first attempted to make a feature in the mid-1990s with Larry Mahoney, which they scrapped.[23] During this period in his career, Nolan had little to no success getting his projects off the ground, facing several rejections; he added, \\\\\\\"[T]here's a very limited pool of finance in the UK. Philosophy professor David Kyle Johnson wrote that \\\\\\\"Inception became a classic almost as soon as it was projected on silver screens\\\\\\\", praising its exploration of philosophical ideas, including leap of faith and allegory of the cave.[97] The film grossed over $836 million worldwide.[98] Nominated for eight Academy Awards—including Best Picture and Best Original Screenplay—it won Best Cinematography, Best Sound Mixing, Best Sound Editing and Best Visual Effects.[99] Nolan was nominated for a BAFTA Award and a Golden Globe Award for Best Director, among other accolades.[40]\\\\nAround the release of The Dark Knight Rises (2012), Nolan's third and final Batman film, Joseph Bevan of the British Film Institute wrote a profile on him: \\\\\\\"In the space of just over a decade, Christopher Nolan has shot from promising British indie director to undisputed master of a new brand of intelligent escapism. He further wrote that Nolan's body of work reflect \\\\\\\"a heterogeneity of conditions of products\\\\\\\" extending from low-budget films to lucrative blockbusters, \\\\\\\"a wide range of genres and settings\\\\\\\" and \\\\\\\"a diversity of styles that trumpet his versatility\\\\\\\".[193]\\\\nDavid Bordwell, a film theorist, wrote that Nolan has been able to blend his \\\\\\\"experimental impulses\\\\\\\" with the demands of mainstream entertainment, describing his oeuvre as \\\\\\\"experiments with cinematic time by means of techniques of subjective viewpoint and crosscutting\\\\\\\".[194] Nolan's use of practical, in-camera effects, miniatures and models, as well as shooting on celluloid film, has been highly influential in early 21st century cinema.[195][196] IndieWire wrote in 2019 that, Nolan \\\\\\\"kept a viable alternate model of big-budget filmmaking alive\\\\\\\", in an era where blockbuster filmmaking has become \\\\\\\"a largely computer-generated art form\\\\\\\".[196] Initially reluctant to make a sequel, he agreed after Warner Bros. repeatedly insisted.[78] Nolan wanted to expand on the noir quality of the first film by broadening the canvas and taking on \\\\\\\"the dynamic of a story of the city, a large crime story ... where you're looking at the police, the justice system, the vigilante, the poor people, the rich people, the criminals\\\\\\\".[79] Continuing to minimalise the use of CGI, Nolan employed high-resolution IMAX cameras, making it the first major motion picture to use this technology.[80][81]\\\"}]\"  ]}\u001b[36;1m\u001b[1;3m[llm/end]\u001b[0m \u001b[1m[1:chain:AgentExecutor > 11:chain:RunnableSequence > 16:llm:ChatOpenAI] [20.22s] Exiting LLM run with output:\u001b[0m{  \"generations\": [    [      {        \"text\": \"The 2023 film \\\"Oppenheimer\\\" was directed by Christopher Nolan.\\n\\nTo calculate Christopher Nolan's age in days, we first need his birth date, which is July 30, 1970. Let's calculate his age in days from his birth date to today's date, December 7, 2023.\\n\\n1. Calculate the total number of days from July 30, 1970, to December 7, 2023.\\n2. Christopher Nolan was born on July 30, 1970. From July 30, 1970, to July 30, 2023, is 53 years.\\n3. From July 30, 2023, to December 7, 2023, is 130 days.\\n\\nNow, calculate the total days for 53 years:\\n- Each year has 365 days, so 53 years × 365 days/year = 19,345 days.\\n- Adding the leap years from 1970 to 2023: 1972, 1976, 1980, 1984, 1988, 1992, 1996, 2000, 2004, 2008, 2012, 2016, 2020, and 2024 (up to February). This gives us 14 leap years.\\n- Total days from leap years: 14 days.\\n\\nAdding all together:\\n- Total days = 19,345 days (from years) + 14 days (from leap years) + 130 days (from July 30, 2023, to December 7, 2023) = 19,489 days.\\n\\nTherefore, as of December 7, 2023, Christopher Nolan is 19,489 days old.\",        \"generation_info\": {          \"finish_reason\": \"stop\"        },        \"type\": \"ChatGenerationChunk\",        \"message\": {          \"lc\": 1,          \"type\": \"constructor\",          \"id\": [            \"langchain\",            \"schema\",            \"messages\",            \"AIMessageChunk\"          ],          \"kwargs\": {            \"content\": \"The 2023 film \\\"Oppenheimer\\\" was directed by Christopher Nolan.\\n\\nTo calculate Christopher Nolan's age in days, we first need his birth date, which is July 30, 1970. Let's calculate his age in days from his birth date to today's date, December 7, 2023.\\n\\n1. Calculate the total number of days from July 30, 1970, to December 7, 2023.\\n2. Christopher Nolan was born on July 30, 1970. From July 30, 1970, to July 30, 2023, is 53 years.\\n3. From July 30, 2023, to December 7, 2023, is 130 days.\\n\\nNow, calculate the total days for 53 years:\\n- Each year has 365 days, so 53 years × 365 days/year = 19,345 days.\\n- Adding the leap years from 1970 to 2023: 1972, 1976, 1980, 1984, 1988, 1992, 1996, 2000, 2004, 2008, 2012, 2016, 2020, and 2024 (up to February). This gives us 14 leap years.\\n- Total days from leap years: 14 days.\\n\\nAdding all together:\\n- Total days = 19,345 days (from years) + 14 days (from leap years) + 130 days (from July 30, 2023, to December 7, 2023) = 19,489 days.\\n\\nTherefore, as of December 7, 2023, Christopher Nolan is 19,489 days old.\",            \"example\": false,            \"additional_kwargs\": {},            \"tool_call_chunks\": [],            \"response_metadata\": {              \"finish_reason\": \"stop\"            },            \"id\": \"run-1c08a44f-db70-4836-935b-417caaf422a5\",            \"tool_calls\": [],            \"invalid_tool_calls\": []          }        }      }    ]  ],  \"llm_output\": null,  \"run\": null}\u001b[32;1m\u001b[1;3m[chain/start]\u001b[0m \u001b[1m[1:chain:AgentExecutor > 11:chain:RunnableSequence > 17:parser:ToolsAgentOutputParser] Entering Parser run with input:\u001b[0m[inputs]\u001b[36;1m\u001b[1;3m[chain/end]\u001b[0m \u001b[1m[1:chain:AgentExecutor > 11:chain:RunnableSequence > 17:parser:ToolsAgentOutputParser] [2ms] Exiting Parser run with output:\u001b[0m[outputs]\u001b[36;1m\u001b[1;3m[chain/end]\u001b[0m \u001b[1m[1:chain:AgentExecutor > 11:chain:RunnableSequence] [20.27s] Exiting Chain run with output:\u001b[0m[outputs]\u001b[36;1m\u001b[1;3m[chain/end]\u001b[0m \u001b[1m[1:chain:AgentExecutor] [26.37s] Exiting Chain run with output:\u001b[0m{  \"output\": \"The 2023 film \\\"Oppenheimer\\\" was directed by Christopher Nolan.\\n\\nTo calculate Christopher Nolan's age in days, we first need his birth date, which is July 30, 1970. Let's calculate his age in days from his birth date to today's date, December 7, 2023.\\n\\n1. Calculate the total number of days from July 30, 1970, to December 7, 2023.\\n2. Christopher Nolan was born on July 30, 1970. From July 30, 1970, to July 30, 2023, is 53 years.\\n3. From July 30, 2023, to December 7, 2023, is 130 days.\\n\\nNow, calculate the total days for 53 years:\\n- Each year has 365 days, so 53 years × 365 days/year = 19,345 days.\\n- Adding the leap years from 1970 to 2023: 1972, 1976, 1980, 1984, 1988, 1992, 1996, 2000, 2004, 2008, 2012, 2016, 2020, and 2024 (up to February). This gives us 14 leap years.\\n- Total days from leap years: 14 days.\\n\\nAdding all together:\\n- Total days = 19,345 days (from years) + 14 days (from leap years) + 130 days (from July 30, 2023, to December 7, 2023) = 19,489 days.\\n\\nTherefore, as of December 7, 2023, Christopher Nolan is 19,489 days old.\"}\n```\n\n```\n{'input': 'Who directed the 2023 film Oppenheimer and what is their age in days?', 'output': 'The 2023 film \"Oppenheimer\" was directed by Christopher Nolan.\\n\\nTo calculate Christopher Nolan\\'s age in days, we first need his birth date, which is July 30, 1970. Let\\'s calculate his age in days from his birth date to today\\'s date, December 7, 2023.\\n\\n1. Calculate the total number of days from July 30, 1970, to December 7, 2023.\\n2. Christopher Nolan was born on July 30, 1970. From July 30, 1970, to July 30, 2023, is 53 years.\\n3. From July 30, 2023, to December 7, 2023, is 130 days.\\n\\nNow, calculate the total days for 53 years:\\n- Each year has 365 days, so 53 years × 365 days/year = 19,345 days.\\n- Adding the leap years from 1970 to 2023: 1972, 1976, 1980, 1984, 1988, 1992, 1996, 2000, 2004, 2008, 2012, 2016, 2020, and 2024 (up to February). This gives us 14 leap years.\\n- Total days from leap years: 14 days.\\n\\nAdding all together:\\n- Total days = 19,345 days (from years) + 14 days (from leap years) + 130 days (from July 30, 2023, to December 7, 2023) = 19,489 days.\\n\\nTherefore, as of December 7, 2023, Christopher Nolan is 19,489 days old.'}\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/query_multiple_retrievers/",
  "markdown": "# giscus\n\n## How to handle multiple retrievers when doing query analysis\n\nSometimes, a query analysis technique may allow for selection of which [retriever](https://python.langchain.com/docs/concepts/retrievers/) to use. To use this, you will need to add some logic to select the retriever to do. We will show a simple example (using mock data) of how to do that.\n\n## Setup[​](#setup \"Direct link to Setup\")\n\n#### Install dependencies[​](#install-dependencies \"Direct link to Install dependencies\")\n\n```\n%pip install -qU langchain langchain-community langchain-openai langchain-chroma\n```\n\n```\nNote: you may need to restart the kernel to use updated packages.\n```\n\n#### Set environment variables[​](#set-environment-variables \"Direct link to Set environment variables\")\n\nWe'll use OpenAI in this example:\n\n```\nimport getpassimport osif \"OPENAI_API_KEY\" not in os.environ:    os.environ[\"OPENAI_API_KEY\"] = getpass.getpass()# Optional, uncomment to trace runs with LangSmith. Sign up here: https://smith.langchain.com.# os.environ[\"LANGCHAIN_TRACING_V2\"] = \"true\"# os.environ[\"LANGCHAIN_API_KEY\"] = getpass.getpass()\n```\n\n### Create Index[​](#create-index \"Direct link to Create Index\")\n\nWe will create a vectorstore over fake information.\n\n```\nfrom langchain_chroma import Chromafrom langchain_openai import OpenAIEmbeddingsfrom langchain_text_splitters import RecursiveCharacterTextSplittertexts = [\"Harrison worked at Kensho\"]embeddings = OpenAIEmbeddings(model=\"text-embedding-3-small\")vectorstore = Chroma.from_texts(texts, embeddings, collection_name=\"harrison\")retriever_harrison = vectorstore.as_retriever(search_kwargs={\"k\": 1})texts = [\"Ankush worked at Facebook\"]embeddings = OpenAIEmbeddings(model=\"text-embedding-3-small\")vectorstore = Chroma.from_texts(texts, embeddings, collection_name=\"ankush\")retriever_ankush = vectorstore.as_retriever(search_kwargs={\"k\": 1})\n```\n\n## Query analysis[​](#query-analysis \"Direct link to Query analysis\")\n\nWe will use function calling to structure the output. We will let it return multiple queries.\n\n```\nfrom typing import List, Optionalfrom pydantic import BaseModel, Fieldclass Search(BaseModel):    \"\"\"Search for information about a person.\"\"\"    query: str = Field(        ...,        description=\"Query to look up\",    )    person: str = Field(        ...,        description=\"Person to look things up for. Should be `HARRISON` or `ANKUSH`.\",    )\n```\n\n```\nfrom langchain_core.output_parsers.openai_tools import PydanticToolsParserfrom langchain_core.prompts import ChatPromptTemplatefrom langchain_core.runnables import RunnablePassthroughfrom langchain_openai import ChatOpenAIoutput_parser = PydanticToolsParser(tools=[Search])system = \"\"\"You have the ability to issue search queries to get information to help answer user information.\"\"\"prompt = ChatPromptTemplate.from_messages(    [        (\"system\", system),        (\"human\", \"{question}\"),    ])llm = ChatOpenAI(model=\"gpt-4o-mini\", temperature=0)structured_llm = llm.with_structured_output(Search)query_analyzer = {\"question\": RunnablePassthrough()} | prompt | structured_llm\n```\n\nWe can see that this allows for routing between retrievers\n\n```\nquery_analyzer.invoke(\"where did Harrison Work\")\n```\n\n```\nSearch(query='work history', person='HARRISON')\n```\n\n```\nquery_analyzer.invoke(\"where did ankush Work\")\n```\n\n```\nSearch(query='work history', person='ANKUSH')\n```\n\n## Retrieval with query analysis[​](#retrieval-with-query-analysis \"Direct link to Retrieval with query analysis\")\n\nSo how would we include this in a chain? We just need some simple logic to select the retriever and pass in the search query\n\n```\nfrom langchain_core.runnables import chain\n```\n\n```\nretrievers = {    \"HARRISON\": retriever_harrison,    \"ANKUSH\": retriever_ankush,}\n```\n\n```\n@chaindef custom_chain(question):    response = query_analyzer.invoke(question)    retriever = retrievers[response.person]    return retriever.invoke(response.query)\n```\n\n```\ncustom_chain.invoke(\"where did Harrison Work\")\n```\n\n```\n[Document(page_content='Harrison worked at Kensho')]\n```\n\n```\ncustom_chain.invoke(\"where did ankush Work\")\n```\n\n```\n[Document(page_content='Ankush worked at Facebook')]\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/extraction_parse/",
  "markdown": "# giscus\n\n## How to use prompting alone (no tool calling) to do extraction\n\n[Tool calling](https://python.langchain.com/docs/concepts/tool_calling/) features are not required for generating structured output from LLMs. LLMs that are able to follow prompt instructions well can be tasked with outputting information in a given format.\n\nThis approach relies on designing good prompts and then parsing the output of the LLMs to make them extract information well.\n\nTo extract data without tool-calling features:\n\n1.  Instruct the LLM to generate text following an expected format (e.g., JSON with a certain schema);\n2.  Use [output parsers](https://python.langchain.com/docs/concepts/output_parsers/) to structure the model response into a desired Python object.\n\nFirst we select a LLM:\n\n```\npip install -qU langchain-openai\n```\n\n```\nimport getpassimport osif not os.environ.get(\"OPENAI_API_KEY\"):  os.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"Enter API key for OpenAI: \")from langchain_openai import ChatOpenAImodel = ChatOpenAI(model=\"gpt-4o-mini\")\n```\n\ntip\n\nThis tutorial is meant to be simple, but generally should really include reference examples to squeeze out performance!\n\n## Using PydanticOutputParser[​](#using-pydanticoutputparser \"Direct link to Using PydanticOutputParser\")\n\nThe following example uses the built-in `PydanticOutputParser` to parse the output of a chat model.\n\n```\nfrom typing import List, Optionalfrom langchain_core.output_parsers import PydanticOutputParserfrom langchain_core.prompts import ChatPromptTemplatefrom pydantic import BaseModel, Field, validatorclass Person(BaseModel):    \"\"\"Information about a person.\"\"\"    name: str = Field(..., description=\"The name of the person\")    height_in_meters: float = Field(        ..., description=\"The height of the person expressed in meters.\"    )class People(BaseModel):    \"\"\"Identifying information about all people in a text.\"\"\"    people: List[Person]# Set up a parserparser = PydanticOutputParser(pydantic_object=People)# Promptprompt = ChatPromptTemplate.from_messages(    [        (            \"system\",            \"Answer the user query. Wrap the output in `json` tags\\n{format_instructions}\",        ),        (\"human\", \"{query}\"),    ]).partial(format_instructions=parser.get_format_instructions())\n```\n\nLet's take a look at what information is sent to the model\n\n```\nquery = \"Anna is 23 years old and she is 6 feet tall\"\n```\n\n```\nprint(prompt.format_prompt(query=query).to_string())\n```\n\n```\nSystem: Answer the user query. Wrap the output in `json` tagsThe output should be formatted as a JSON instance that conforms to the JSON schema below.As an example, for the schema {\"properties\": {\"foo\": {\"title\": \"Foo\", \"description\": \"a list of strings\", \"type\": \"array\", \"items\": {\"type\": \"string\"}}}, \"required\": [\"foo\"]}the object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted instance of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"]}} is not well-formatted.Here is the output schema:\\`\\`\\`{\"$defs\": {\"Person\": {\"description\": \"Information about a person.\", \"properties\": {\"name\": {\"description\": \"The name of the person\", \"title\": \"Name\", \"type\": \"string\"}, \"height_in_meters\": {\"description\": \"The height of the person expressed in meters.\", \"title\": \"Height In Meters\", \"type\": \"number\"}}, \"required\": [\"name\", \"height_in_meters\"], \"title\": \"Person\", \"type\": \"object\"}}, \"description\": \"Identifying information about all people in a text.\", \"properties\": {\"people\": {\"items\": {\"$ref\": \"#/$defs/Person\"}, \"title\": \"People\", \"type\": \"array\"}}, \"required\": [\"people\"]}\\`\\`\\`Human: Anna is 23 years old and she is 6 feet tall\n```\n\nHaving defined our prompt, we simply chain together the prompt, model and output parser:\n\n```\nchain = prompt | model | parserchain.invoke({\"query\": query})\n```\n\n```\nPeople(people=[Person(name='Anna', height_in_meters=1.83)])\n```\n\nCheck out the associated [Langsmith trace](https://smith.langchain.com/public/92ed52a3-92b9-45af-a663-0a9c00e5e396/r).\n\nNote that the schema shows up in two places:\n\n1.  In the prompt, via `parser.get_format_instructions()`;\n2.  In the chain, to receive the formatted output and structure it into a Python object (in this case, the Pydantic object `People`).\n\n## Custom Parsing[​](#custom-parsing \"Direct link to Custom Parsing\")\n\nIf desired, it's easy to create a custom prompt and parser with `LangChain` and `LCEL`.\n\nTo create a custom parser, define a function to parse the output from the model (typically an [AIMessage](https://python.langchain.com/api_reference/core/messages/langchain_core.messages.ai.AIMessage.html)) into an object of your choice.\n\nSee below for a simple implementation of a JSON parser.\n\n```\nimport jsonimport refrom typing import List, Optionalfrom langchain_anthropic.chat_models import ChatAnthropicfrom langchain_core.messages import AIMessagefrom langchain_core.prompts import ChatPromptTemplatefrom pydantic import BaseModel, Field, validatorclass Person(BaseModel):    \"\"\"Information about a person.\"\"\"    name: str = Field(..., description=\"The name of the person\")    height_in_meters: float = Field(        ..., description=\"The height of the person expressed in meters.\"    )class People(BaseModel):    \"\"\"Identifying information about all people in a text.\"\"\"    people: List[Person]# Promptprompt = ChatPromptTemplate.from_messages(    [        (            \"system\",            \"Answer the user query. Output your answer as JSON that  \"            \"matches the given schema: \\`\\`\\`json\\n{schema}\\n\\`\\`\\`. \"            \"Make sure to wrap the answer in \\`\\`\\`json and \\`\\`\\` tags\",        ),        (\"human\", \"{query}\"),    ]).partial(schema=People.schema())# Custom parserdef extract_json(message: AIMessage) -> List[dict]:    \"\"\"Extracts JSON content from a string where JSON is embedded between \\`\\`\\`json and \\`\\`\\` tags.    Parameters:        text (str): The text containing the JSON content.    Returns:        list: A list of extracted JSON strings.    \"\"\"    text = message.content    # Define the regular expression pattern to match JSON blocks    pattern = r\"\\`\\`\\`json(.*?)\\`\\`\\`\"    # Find all non-overlapping matches of the pattern in the string    matches = re.findall(pattern, text, re.DOTALL)    # Return the list of matched JSON strings, stripping any leading or trailing whitespace    try:        return [json.loads(match.strip()) for match in matches]    except Exception:        raise ValueError(f\"Failed to parse: {message}\")\n```\n\n```\nquery = \"Anna is 23 years old and she is 6 feet tall\"print(prompt.format_prompt(query=query).to_string())\n```\n\n```\nSystem: Answer the user query. Output your answer as JSON that  matches the given schema: \\`\\`\\`json{'$defs': {'Person': {'description': 'Information about a person.', 'properties': {'name': {'description': 'The name of the person', 'title': 'Name', 'type': 'string'}, 'height_in_meters': {'description': 'The height of the person expressed in meters.', 'title': 'Height In Meters', 'type': 'number'}}, 'required': ['name', 'height_in_meters'], 'title': 'Person', 'type': 'object'}}, 'description': 'Identifying information about all people in a text.', 'properties': {'people': {'items': {'$ref': '#/$defs/Person'}, 'title': 'People', 'type': 'array'}}, 'required': ['people'], 'title': 'People', 'type': 'object'}\\`\\`\\`. Make sure to wrap the answer in \\`\\`\\`json and \\`\\`\\` tagsHuman: Anna is 23 years old and she is 6 feet tall\n```\n\n```\nchain = prompt | model | extract_jsonchain.invoke({\"query\": query})\n```\n\n```\n/Users/bagatur/langchain/.venv/lib/python3.11/site-packages/pydantic/_internal/_fields.py:201: UserWarning: Field name \"schema\" in \"PromptInput\" shadows an attribute in parent \"BaseModel\"  warnings.warn(\n```\n\n```\n[{'people': [{'name': 'Anna', 'height_in_meters': 1.83}]}]\n```\n\n## Other Libraries[​](#other-libraries \"Direct link to Other Libraries\")\n\nIf you're looking at extracting using a parsing approach, check out the [Kor](https://eyurtsev.github.io/kor/) library. It's written by one of the `LangChain` maintainers and it helps to craft a prompt that takes examples into account, allows controlling formats (e.g., JSON or CSV) and expresses the schema in TypeScript. It seems to work pretty!"
},
{
  "url": "https://python.langchain.com/docs/how_to/qa_streaming/",
  "markdown": "# giscus\n\n## How to stream results from your RAG application\n\nThis guide explains how to stream results from a [RAG](https://python.langchain.com/docs/concepts/rag/) application. It covers streaming tokens from the final output as well as intermediate steps of a chain (e.g., from query re-writing).\n\nWe'll work off of the Q&A app with sources we built over the [LLM Powered Autonomous Agents](https://lilianweng.github.io/posts/2023-06-23-agent/) blog post by Lilian Weng in the [RAG tutorial](https://python.langchain.com/docs/tutorials/rag/).\n\n## Setup[​](#setup \"Direct link to Setup\")\n\n### Dependencies[​](#dependencies \"Direct link to Dependencies\")\n\nWe'll use the following packages:\n\n```\n%pip install --upgrade --quiet  langchain langchain-community langchainhub beautifulsoup4\n```\n\n### LangSmith[​](#langsmith \"Direct link to LangSmith\")\n\nMany of the applications you build with LangChain will contain multiple steps with multiple invocations of LLM calls. As these applications get more and more complex, it becomes crucial to be able to inspect what exactly is going on inside your chain or agent. The best way to do this is with [LangSmith](https://smith.langchain.com/).\n\nNote that LangSmith is not needed, but it is helpful. If you do want to use LangSmith, after you sign up at the link above, make sure to set your environment variables to start logging traces:\n\n```\nos.environ[\"LANGCHAIN_TRACING_V2\"] = \"true\"os.environ[\"LANGCHAIN_API_KEY\"] = getpass.getpass()\n```\n\n### Components[​](#components \"Direct link to Components\")\n\nWe will need to select three components from LangChain's suite of integrations.\n\nA [chat model](https://python.langchain.com/docs/integrations/chat/):\n\n```\npip install -qU langchain-openai\n```\n\n```\nimport getpassimport osif not os.environ.get(\"OPENAI_API_KEY\"):  os.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"Enter API key for OpenAI: \")from langchain_openai import ChatOpenAIllm = ChatOpenAI(model=\"gpt-4o-mini\")\n```\n\nAn [embedding model](https://python.langchain.com/docs/integrations/text_embedding/):\n\n```\npip install -qU langchain-openai\n```\n\n```\nimport getpassimport osif not os.environ.get(\"OPENAI_API_KEY\"):  os.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"Enter API key for OpenAI: \")from langchain_openai import OpenAIEmbeddingsembeddings = OpenAIEmbeddings(model=\"text-embedding-3-large\")\n```\n\nAnd a [vector store](https://python.langchain.com/docs/integrations/vectorstores/):\n\n```\npip install -qU langchain-core\n```\n\n```\nfrom langchain_core.vectorstores import InMemoryVectorStorevector_store = InMemoryVectorStore(embeddings)\n```\n\n## RAG application[​](#rag-application \"Direct link to RAG application\")\n\nLet's reconstruct the Q&A app with sources we built over the [LLM Powered Autonomous Agents](https://lilianweng.github.io/posts/2023-06-23-agent/) blog post by Lilian Weng in the [RAG tutorial](https://python.langchain.com/docs/tutorials/rag/).\n\nFirst we index our documents:\n\n```\nimport bs4from langchain import hubfrom langchain_community.document_loaders import WebBaseLoaderfrom langchain_core.documents import Documentfrom langchain_text_splitters import RecursiveCharacterTextSplitterfrom typing_extensions import List, TypedDict# Load and chunk contents of the blogloader = WebBaseLoader(    web_paths=(\"https://lilianweng.github.io/posts/2023-06-23-agent/\",),    bs_kwargs=dict(        parse_only=bs4.SoupStrainer(            class_=(\"post-content\", \"post-title\", \"post-header\")        )    ),)docs = loader.load()text_splitter = RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=200)all_splits = text_splitter.split_documents(docs)\n```\n\n```\n# Index chunks_ = vector_store.add_documents(documents=all_splits)\n```\n\nNext we build the application:\n\n```\nfrom langchain import hubfrom langchain_core.documents import Documentfrom langgraph.graph import START, StateGraphfrom typing_extensions import List, TypedDict# Define prompt for question-answeringprompt = hub.pull(\"rlm/rag-prompt\")# Define state for applicationclass State(TypedDict):    question: str    context: List[Document]    answer: str# Define application stepsdef retrieve(state: State):    retrieved_docs = vector_store.similarity_search(state[\"question\"])    return {\"context\": retrieved_docs}def generate(state: State):    docs_content = \"\\n\\n\".join(doc.page_content for doc in state[\"context\"])    messages = prompt.invoke({\"question\": state[\"question\"], \"context\": docs_content})    response = llm.invoke(messages)    return {\"answer\": response.content}# Compile application and testgraph_builder = StateGraph(State).add_sequence([retrieve, generate])graph_builder.add_edge(START, \"retrieve\")graph = graph_builder.compile()\n```\n\n```\nfrom IPython.display import Image, displaydisplay(Image(graph.get_graph().draw_mermaid_png()))\n```\n\n![](data:image/png;base64,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)\n\n## Streaming final outputs[​](#streaming-final-outputs \"Direct link to Streaming final outputs\")\n\nLangGraph supports several [streaming modes](https://langchain-ai.github.io/langgraph/how-tos/#streaming), which can be controlled by specifying the `stream_mode` parameter. Setting `stream_mode=\"messages\"` allows us to stream tokens from chat model invocations.\n\nIn general there can be multiple chat model invocations in an application (although here there is just one). Below, we filter to only the last step using the name of the corresponding node:\n\n```\ninput_message = \"What is Task Decomposition?\"for message, metadata in graph.stream(    {\"question\": \"What is Task Decomposition?\"},    stream_mode=\"messages\",):    if metadata[\"langgraph_node\"] == \"generate\":        print(message.content, end=\"|\")\n```\n\n```\n|Task| De|composition| is| a| technique| used| to| break| down| complex| tasks| into| smaller|,| more| manageable| steps|.| It| often| involves| prompting| models| to| \"|think| step| by| step|,\"| allowing| for| clearer| reasoning| and| better| performance| on| intricate| problems|.| This| can| be| achieved| through| various| methods|,| including| simple| prompts|,| task|-specific| instructions|,| or| human| input|.||\n```\n\nOther streaming modes will generally stream steps from our invocation-- i.e., state updates from individual nodes. In this case, each node is just appending a new key to the state:\n\n```\nfor step in graph.stream(    {\"question\": \"What is Task Decomposition?\"},    stream_mode=\"updates\",):    print(f\"{step}\\n\\n----------------\\n\")\n```\n\n```\n{'retrieve': {'context': [Document(id='5bf5e308-6ccb-4f09-94d2-d0c36b8c9980', metadata={'source': 'https://lilianweng.github.io/posts/2023-06-23-agent/'}, page_content='Fig. 1. Overview of a LLM-powered autonomous agent system.\\nComponent One: Planning#\\nA complicated task usually involves many steps. An agent needs to know what they are and plan ahead.\\nTask Decomposition#\\nChain of thought (CoT; Wei et al. 2022) has become a standard prompting technique for enhancing model performance on complex tasks. The model is instructed to “think step by step” to utilize more test-time computation to decompose hard tasks into smaller and simpler steps. CoT transforms big tasks into multiple manageable tasks and shed lights into an interpretation of the model’s thinking process.'), Document(id='d8aed221-7943-414d-8ed7-63c2b0e7523b', metadata={'source': 'https://lilianweng.github.io/posts/2023-06-23-agent/'}, page_content='Tree of Thoughts (Yao et al. 2023) extends CoT by exploring multiple reasoning possibilities at each step. It first decomposes the problem into multiple thought steps and generates multiple thoughts per step, creating a tree structure. The search process can be BFS (breadth-first search) or DFS (depth-first search) with each state evaluated by a classifier (via a prompt) or majority vote.\\nTask decomposition can be done (1) by LLM with simple prompting like \"Steps for XYZ.\\\\n1.\", \"What are the subgoals for achieving XYZ?\", (2) by using task-specific instructions; e.g. \"Write a story outline.\" for writing a novel, or (3) with human inputs.'), Document(id='bfa87007-02ef-4f81-a008-4522ecea1025', metadata={'source': 'https://lilianweng.github.io/posts/2023-06-23-agent/'}, page_content='Resources:\\n1. Internet access for searches and information gathering.\\n2. Long Term memory management.\\n3. GPT-3.5 powered Agents for delegation of simple tasks.\\n4. File output.\\n\\nPerformance Evaluation:\\n1. Continuously review and analyze your actions to ensure you are performing to the best of your abilities.\\n2. Constructively self-criticize your big-picture behavior constantly.\\n3. Reflect on past decisions and strategies to refine your approach.\\n4. Every command has a cost, so be smart and efficient. Aim to complete tasks in the least number of steps.'), Document(id='6aff7fc0-5c21-4986-9f1e-91e89715d934', metadata={'source': 'https://lilianweng.github.io/posts/2023-06-23-agent/'}, page_content=\"(3) Task execution: Expert models execute on the specific tasks and log results.\\nInstruction:\\n\\nWith the input and the inference results, the AI assistant needs to describe the process and results. The previous stages can be formed as - User Input: {{ User Input }}, Task Planning: {{ Tasks }}, Model Selection: {{ Model Assignment }}, Task Execution: {{ Predictions }}. You must first answer the user's request in a straightforward manner. Then describe the task process and show your analysis and model inference results to the user in the first person. If inference results contain a file path, must tell the user the complete file path.\")]}}----------------{'generate': {'answer': 'Task Decomposition is the process of breaking down a complex task into smaller, manageable steps to enhance understanding and execution. Techniques like Chain of Thought (CoT) and Tree of Thoughts (ToT) guide models to think through steps systematically, allowing for better problem-solving. It can be achieved through simple prompting, task-specific instructions, or human input.'}}----------------\n```\n\nFor more on streaming with LangGraph, check out its [streaming documentation](https://langchain-ai.github.io/langgraph/how-tos/#streaming). For more information on streaming individual LangChain [Runnables](https://python.langchain.com/docs/concepts/runnables/), refer to [this guide](https://python.langchain.com/docs/how_to/streaming/)."
},
{
  "url": "https://python.langchain.com/docs/how_to/document_loader_csv/",
  "markdown": "# giscus\n\n## How to load CSVs\n\nA [comma-separated values (CSV)](https://en.wikipedia.org/wiki/Comma-separated_values) file is a delimited text file that uses a comma to separate values. Each line of the file is a data record. Each record consists of one or more fields, separated by commas.\n\nLangChain implements a [CSV Loader](https://python.langchain.com/api_reference/community/document_loaders/langchain_community.document_loaders.csv_loader.CSVLoader.html) that will load CSV files into a sequence of [Document](https://python.langchain.com/api_reference/core/documents/langchain_core.documents.base.Document.html#langchain_core.documents.base.Document) objects. Each row of the CSV file is translated to one document.\n\n```\nfrom langchain_community.document_loaders.csv_loader import CSVLoaderfile_path = \"../integrations/document_loaders/example_data/mlb_teams_2012.csv\"loader = CSVLoader(file_path=file_path)data = loader.load()for record in data[:2]:    print(record)\n```\n\n```\npage_content='Team: Nationals\\n\"Payroll (millions)\": 81.34\\n\"Wins\": 98' metadata={'source': '../../../docs/integrations/document_loaders/example_data/mlb_teams_2012.csv', 'row': 0}page_content='Team: Reds\\n\"Payroll (millions)\": 82.20\\n\"Wins\": 97' metadata={'source': '../../../docs/integrations/document_loaders/example_data/mlb_teams_2012.csv', 'row': 1}\n```\n\n## Customizing the CSV parsing and loading[​](#customizing-the-csv-parsing-and-loading \"Direct link to Customizing the CSV parsing and loading\")\n\n`CSVLoader` will accept a `csv_args` kwarg that supports customization of arguments passed to Python's `csv.DictReader`. See the [csv module](https://docs.python.org/3/library/csv.html) documentation for more information of what csv args are supported.\n\n```\nloader = CSVLoader(    file_path=file_path,    csv_args={        \"delimiter\": \",\",        \"quotechar\": '\"',        \"fieldnames\": [\"MLB Team\", \"Payroll in millions\", \"Wins\"],    },)data = loader.load()for record in data[:2]:    print(record)\n```\n\n```\npage_content='MLB Team: Team\\nPayroll in millions: \"Payroll (millions)\"\\nWins: \"Wins\"' metadata={'source': '../../../docs/integrations/document_loaders/example_data/mlb_teams_2012.csv', 'row': 0}page_content='MLB Team: Nationals\\nPayroll in millions: 81.34\\nWins: 98' metadata={'source': '../../../docs/integrations/document_loaders/example_data/mlb_teams_2012.csv', 'row': 1}\n```\n\n## Specify a column to identify the document source[​](#specify-a-column-to-identify-the-document-source \"Direct link to Specify a column to identify the document source\")\n\nThe `\"source\"` key on [Document](https://python.langchain.com/api_reference/core/documents/langchain_core.documents.base.Document.html#langchain_core.documents.base.Document) metadata can be set using a column of the CSV. Use the `source_column` argument to specify a source for the document created from each row. Otherwise `file_path` will be used as the source for all documents created from the CSV file.\n\nThis is useful when using documents loaded from CSV files for chains that answer questions using sources.\n\n```\nloader = CSVLoader(file_path=file_path, source_column=\"Team\")data = loader.load()for record in data[:2]:    print(record)\n```\n\n```\npage_content='Team: Nationals\\n\"Payroll (millions)\": 81.34\\n\"Wins\": 98' metadata={'source': 'Nationals', 'row': 0}page_content='Team: Reds\\n\"Payroll (millions)\": 82.20\\n\"Wins\": 97' metadata={'source': 'Reds', 'row': 1}\n```\n\n## Load from a string[​](#load-from-a-string \"Direct link to Load from a string\")\n\nPython's `tempfile` can be used when working with CSV strings directly.\n\n```\nimport tempfilefrom io import StringIOstring_data = \"\"\"\"Team\", \"Payroll (millions)\", \"Wins\"\"Nationals\",     81.34, 98\"Reds\",          82.20, 97\"Yankees\",      197.96, 95\"Giants\",       117.62, 94\"\"\".strip()with tempfile.NamedTemporaryFile(delete=False, mode=\"w+\") as temp_file:    temp_file.write(string_data)    temp_file_path = temp_file.nameloader = CSVLoader(file_path=temp_file_path)data = loader.load()for record in data[:2]:    print(record)\n```\n\n```\npage_content='Team: Nationals\\n\"Payroll (millions)\": 81.34\\n\"Wins\": 98' metadata={'source': 'Nationals', 'row': 0}page_content='Team: Reds\\n\"Payroll (millions)\": 82.20\\n\"Wins\": 97' metadata={'source': 'Reds', 'row': 1}\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/graph_semantic/",
  "markdown": "# giscus\n\n## How to add a semantic layer over graph database\n\nYou can use database queries to retrieve information from a graph database like Neo4j. One option is to use LLMs to generate Cypher statements. While that option provides excellent flexibility, the solution could be brittle and not consistently generating precise Cypher statements. Instead of generating Cypher statements, we can implement Cypher templates as tools in a semantic layer that an LLM agent can interact with.\n\n![graph_semantic.png](https://python.langchain.com/assets/images/graph_semantic-365248d76b7862193c33f44eaa6ecaeb.png)\n\n## Setup[​](#setup \"Direct link to Setup\")\n\nFirst, get required packages and set environment variables:\n\n```\n%pip install --upgrade --quiet  langchain langchain-neo4j langchain-openai\n```\n\nWe default to OpenAI models in this guide, but you can swap them out for the model provider of your choice.\n\n```\nimport getpassimport osos.environ[\"OPENAI_API_KEY\"] = getpass.getpass()# Uncomment the below to use LangSmith. Not required.# os.environ[\"LANGCHAIN_API_KEY\"] = getpass.getpass()# os.environ[\"LANGCHAIN_TRACING_V2\"] = \"true\"\n```\n\nNext, we need to define Neo4j credentials. Follow [these installation steps](https://neo4j.com/docs/operations-manual/current/installation/) to set up a Neo4j database.\n\n```\nos.environ[\"NEO4J_URI\"] = \"bolt://localhost:7687\"os.environ[\"NEO4J_USERNAME\"] = \"neo4j\"os.environ[\"NEO4J_PASSWORD\"] = \"password\"\n```\n\nThe below example will create a connection with a Neo4j database and will populate it with example data about movies and their actors.\n\n```\nfrom langchain_neo4j import Neo4jGraphgraph = Neo4jGraph(refresh_schema=False)# Import movie informationmovies_query = \"\"\"LOAD CSV WITH HEADERS FROM 'https://raw.githubusercontent.com/tomasonjo/blog-datasets/main/movies/movies_small.csv'AS rowMERGE (m:Movie {id:row.movieId})SET m.released = date(row.released),    m.title = row.title,    m.imdbRating = toFloat(row.imdbRating)FOREACH (director in split(row.director, '|') |     MERGE (p:Person {name:trim(director)})    MERGE (p)-[:DIRECTED]->(m))FOREACH (actor in split(row.actors, '|') |     MERGE (p:Person {name:trim(actor)})    MERGE (p)-[:ACTED_IN]->(m))FOREACH (genre in split(row.genres, '|') |     MERGE (g:Genre {name:trim(genre)})    MERGE (m)-[:IN_GENRE]->(g))\"\"\"graph.query(movies_query)\n```\n\nA semantic layer consists of various tools exposed to an LLM that it can use to interact with a knowledge graph. They can be of various complexity. You can think of each tool in a semantic layer as a function.\n\nThe function we will implement is to retrieve information about movies or their cast.\n\n```\ndescription_query = \"\"\"MATCH (m:Movie|Person)WHERE m.title CONTAINS $candidate OR m.name CONTAINS $candidateMATCH (m)-[r:ACTED_IN|IN_GENRE]-(t)WITH m, type(r) as type, collect(coalesce(t.name, t.title)) as namesWITH m, type+\": \"+reduce(s=\"\", n IN names | s + n + \", \") as typesWITH m, collect(types) as contextsWITH m, \"type:\" + labels(m)[0] + \"\\ntitle: \"+ coalesce(m.title, m.name)        + \"\\nyear: \"+coalesce(m.released,\"\") +\"\\n\" +       reduce(s=\"\", c in contexts | s + substring(c, 0, size(c)-2) +\"\\n\") as contextRETURN context LIMIT 1\"\"\"def get_information(entity: str) -> str:    try:        data = graph.query(description_query, params={\"candidate\": entity})        return data[0][\"context\"]    except IndexError:        return \"No information was found\"\n```\n\nYou can observe that we have defined the Cypher statement used to retrieve information. Therefore, we can avoid generating Cypher statements and use the LLM agent to only populate the input parameters. To provide additional information to an LLM agent about when to use the tool and their input parameters, we wrap the function as a tool.\n\n```\nfrom typing import Optional, Typefrom langchain_core.tools import BaseToolfrom pydantic import BaseModel, Fieldclass InformationInput(BaseModel):    entity: str = Field(description=\"movie or a person mentioned in the question\")class InformationTool(BaseTool):    name: str = \"Information\"    description: str = (        \"useful for when you need to answer questions about various actors or movies\"    )    args_schema: Type[BaseModel] = InformationInput    def _run(        self,        entity: str,    ) -> str:        \"\"\"Use the tool.\"\"\"        return get_information(entity)    async def _arun(        self,        entity: str,    ) -> str:        \"\"\"Use the tool asynchronously.\"\"\"        return get_information(entity)\n```\n\n## LangGraph Agent[​](#langgraph-agent \"Direct link to LangGraph Agent\")\n\nWe will implement a straightforward ReAct agent using LangGraph.\n\nThe agent consists of an LLM and tools step. As we interact with the agent, we will first call the LLM to decide if we should use tools. Then we will run a loop:\n\nIf the agent said to take an action (i.e. call tool), we’ll run the tools and pass the results back to the agent. If the agent did not ask to run tools, we will finish (respond to the user).\n\nThe code implementation is as straightforward as it gets. First we bind the tools to the LLM and define the assistant step.\n\n```\nfrom langchain_core.messages import HumanMessage, SystemMessagefrom langchain_openai import ChatOpenAIfrom langgraph.graph import MessagesStatellm = ChatOpenAI(model=\"gpt-4o\")tools = [InformationTool()]llm_with_tools = llm.bind_tools(tools)# System messagesys_msg = SystemMessage(    content=\"You are a helpful assistant tasked with finding and explaining relevant information about movies.\")# Nodedef assistant(state: MessagesState):    return {\"messages\": [llm_with_tools.invoke([sys_msg] + state[\"messages\"])]}\n```\n\nNext we define the LangGraph flow.\n\n```\nfrom IPython.display import Image, displayfrom langgraph.graph import END, START, StateGraphfrom langgraph.prebuilt import ToolNode, tools_condition# Graphbuilder = StateGraph(MessagesState)# Define nodes: these do the workbuilder.add_node(\"assistant\", assistant)builder.add_node(\"tools\", ToolNode(tools))# Define edges: these determine how the control flow movesbuilder.add_edge(START, \"assistant\")builder.add_conditional_edges(    \"assistant\",    # If the latest message (result) from assistant is a tool call -> tools_condition routes to tools    # If the latest message (result) from assistant is a not a tool call -> tools_condition routes to END    tools_condition,)builder.add_edge(\"tools\", \"assistant\")react_graph = builder.compile()# Showdisplay(Image(react_graph.get_graph(xray=True).draw_mermaid_png()))\n```\n\n![](data:image/png;base64,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)\n\nLet's test the workflow now with an example question.\n\n```\ninput_messages = [HumanMessage(content=\"Who played in the Casino?\")]messages = react_graph.invoke({\"messages\": input_messages})for m in messages[\"messages\"]:    m.pretty_print()\n```\n\n```\n================================\u001b[1m Human Message \u001b[0m=================================Who played in the Casino?==================================\u001b[1m Ai Message \u001b[0m==================================Tool Calls:  Information (call_j4usgFStGtBM16fuguRaeoGc) Call ID: call_j4usgFStGtBM16fuguRaeoGc  Args:    entity: Casino=================================\u001b[1m Tool Message \u001b[0m=================================Name: Informationtype:Movietitle: Casinoyear: 1995-11-22ACTED_IN: Robert De Niro, Joe Pesci, Sharon Stone, James WoodsIN_GENRE: Drama, Crime==================================\u001b[1m Ai Message \u001b[0m==================================The movie \"Casino,\" released in 1995, features the following actors:- Robert De Niro- Joe Pesci- Sharon Stone- James WoodsThe film is in the Drama and Crime genres.\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/fallbacks/",
  "markdown": "# giscus\n\n## How to add fallbacks to a runnable\n\nWhen working with language models, you may often encounter issues from the underlying APIs, whether these be rate limiting or downtime. Therefore, as you go to move your LLM applications into production it becomes more and more important to safeguard against these. That's why we've introduced the concept of fallbacks.\n\nA **fallback** is an alternative plan that may be used in an emergency.\n\nCrucially, fallbacks can be applied not only on the LLM level but on the whole runnable level. This is important because often times different models require different prompts. So if your call to OpenAI fails, you don't just want to send the same prompt to Anthropic - you probably want to use a different prompt template and send a different version there.\n\n## Fallback for LLM API Errors[​](#fallback-for-llm-api-errors \"Direct link to Fallback for LLM API Errors\")\n\nThis is maybe the most common use case for fallbacks. A request to an LLM API can fail for a variety of reasons - the API could be down, you could have hit rate limits, any number of things. Therefore, using fallbacks can help protect against these types of things.\n\nIMPORTANT: By default, a lot of the LLM wrappers catch errors and retry. You will most likely want to turn those off when working with fallbacks. Otherwise the first wrapper will keep on retrying and not failing.\n\n```\n%pip install --upgrade --quiet  langchain langchain-openai\n```\n\n```\nfrom langchain_anthropic import ChatAnthropicfrom langchain_openai import ChatOpenAI\n```\n\nFirst, let's mock out what happens if we hit a RateLimitError from OpenAI\n\n```\nfrom unittest.mock import patchimport httpxfrom openai import RateLimitErrorrequest = httpx.Request(\"GET\", \"/\")response = httpx.Response(200, request=request)error = RateLimitError(\"rate limit\", response=response, body=\"\")\n```\n\n```\n# Note that we set max_retries = 0 to avoid retrying on RateLimits, etcopenai_llm = ChatOpenAI(model=\"gpt-4o-mini\", max_retries=0)anthropic_llm = ChatAnthropic(model=\"claude-3-haiku-20240307\")llm = openai_llm.with_fallbacks([anthropic_llm])\n```\n\n```\n# Let's use just the OpenAI LLm first, to show that we run into an errorwith patch(\"openai.resources.chat.completions.Completions.create\", side_effect=error):    try:        print(openai_llm.invoke(\"Why did the chicken cross the road?\"))    except RateLimitError:        print(\"Hit error\")\n```\n\n```\n# Now let's try with fallbacks to Anthropicwith patch(\"openai.resources.chat.completions.Completions.create\", side_effect=error):    try:        print(llm.invoke(\"Why did the chicken cross the road?\"))    except RateLimitError:        print(\"Hit error\")\n```\n\n```\ncontent=' I don\\'t actually know why the chicken crossed the road, but here are some possible humorous answers:\\n\\n- To get to the other side!\\n\\n- It was too chicken to just stand there. \\n\\n- It wanted a change of scenery.\\n\\n- It wanted to show the possum it could be done.\\n\\n- It was on its way to a poultry farmers\\' convention.\\n\\nThe joke plays on the double meaning of \"the other side\" - literally crossing the road to the other side, or the \"other side\" meaning the afterlife. So it\\'s an anti-joke, with a silly or unexpected pun as the answer.' additional_kwargs={} example=False\n```\n\nWe can use our \"LLM with Fallbacks\" as we would a normal LLM.\n\n```\nfrom langchain_core.prompts import ChatPromptTemplateprompt = ChatPromptTemplate.from_messages(    [        (            \"system\",            \"You're a nice assistant who always includes a compliment in your response\",        ),        (\"human\", \"Why did the {animal} cross the road\"),    ])chain = prompt | llmwith patch(\"openai.resources.chat.completions.Completions.create\", side_effect=error):    try:        print(chain.invoke({\"animal\": \"kangaroo\"}))    except RateLimitError:        print(\"Hit error\")\n```\n\n```\ncontent=\" I don't actually know why the kangaroo crossed the road, but I can take a guess! Here are some possible reasons:\\n\\n- To get to the other side (the classic joke answer!)\\n\\n- It was trying to find some food or water \\n\\n- It was trying to find a mate during mating season\\n\\n- It was fleeing from a predator or perceived threat\\n\\n- It was disoriented and crossed accidentally \\n\\n- It was following a herd of other kangaroos who were crossing\\n\\n- It wanted a change of scenery or environment \\n\\n- It was trying to reach a new habitat or territory\\n\\nThe real reason is unknown without more context, but hopefully one of those potential explanations does the joke justice! Let me know if you have any other animal jokes I can try to decipher.\" additional_kwargs={} example=False\n```\n\n## Fallback for Sequences[​](#fallback-for-sequences \"Direct link to Fallback for Sequences\")\n\nWe can also create fallbacks for sequences, that are sequences themselves. Here we do that with two different models: ChatOpenAI and then normal OpenAI (which does not use a chat model). Because OpenAI is NOT a chat model, you likely want a different prompt.\n\n```\n# First let's create a chain with a ChatModel# We add in a string output parser here so the outputs between the two are the same typefrom langchain_core.output_parsers import StrOutputParserchat_prompt = ChatPromptTemplate.from_messages(    [        (            \"system\",            \"You're a nice assistant who always includes a compliment in your response\",        ),        (\"human\", \"Why did the {animal} cross the road\"),    ])# Here we're going to use a bad model name to easily create a chain that will errorchat_model = ChatOpenAI(model=\"gpt-fake\")bad_chain = chat_prompt | chat_model | StrOutputParser()\n```\n\n```\n# Now lets create a chain with the normal OpenAI modelfrom langchain_core.prompts import PromptTemplatefrom langchain_openai import OpenAIprompt_template = \"\"\"Instructions: You should always include a compliment in your response.Question: Why did the {animal} cross the road?\"\"\"prompt = PromptTemplate.from_template(prompt_template)llm = OpenAI()good_chain = prompt | llm\n```\n\n```\n# We can now create a final chain which combines the twochain = bad_chain.with_fallbacks([good_chain])chain.invoke({\"animal\": \"turtle\"})\n```\n\n```\n'\\n\\nAnswer: The turtle crossed the road to get to the other side, and I have to say he had some impressive determination.'\n```\n\n## Fallback for Long Inputs[​](#fallback-for-long-inputs \"Direct link to Fallback for Long Inputs\")\n\nOne of the big limiting factors of LLMs is their context window. Usually, you can count and track the length of prompts before sending them to an LLM, but in situations where that is hard/complicated, you can fallback to a model with a longer context length.\n\n```\nshort_llm = ChatOpenAI()long_llm = ChatOpenAI(model=\"gpt-3.5-turbo-16k\")llm = short_llm.with_fallbacks([long_llm])\n```\n\n```\ninputs = \"What is the next number: \" + \", \".join([\"one\", \"two\"] * 3000)\n```\n\n```\ntry:    print(short_llm.invoke(inputs))except Exception as e:    print(e)\n```\n\n```\nThis model's maximum context length is 4097 tokens. However, your messages resulted in 12012 tokens. Please reduce the length of the messages.\n```\n\n```\ntry:    print(llm.invoke(inputs))except Exception as e:    print(e)\n```\n\n```\ncontent='The next number in the sequence is two.' additional_kwargs={} example=False\n```\n\n## Fallback to Better Model[​](#fallback-to-better-model \"Direct link to Fallback to Better Model\")\n\nOften times we ask models to output format in a specific format (like JSON). Models like GPT-3.5 can do this okay, but sometimes struggle. This naturally points to fallbacks - we can try with GPT-3.5 (faster, cheaper), but then if parsing fails we can use GPT-4.\n\n```\nfrom langchain.output_parsers import DatetimeOutputParser\n```\n\n```\nprompt = ChatPromptTemplate.from_template(    \"what time was {event} (in %Y-%m-%dT%H:%M:%S.%fZ format - only return this value)\")\n```\n\n```\n# In this case we are going to do the fallbacks on the LLM + output parser level# Because the error will get raised in the OutputParseropenai_35 = ChatOpenAI() | DatetimeOutputParser()openai_4 = ChatOpenAI(model=\"gpt-4\") | DatetimeOutputParser()\n```\n\n```\nonly_35 = prompt | openai_35fallback_4 = prompt | openai_35.with_fallbacks([openai_4])\n```\n\n```\ntry:    print(only_35.invoke({\"event\": \"the superbowl in 1994\"}))except Exception as e:    print(f\"Error: {e}\")\n```\n\n```\nError: Could not parse datetime string: The Super Bowl in 1994 took place on January 30th at 3:30 PM local time. Converting this to the specified format (%Y-%m-%dT%H:%M:%S.%fZ) results in: 1994-01-30T15:30:00.000Z\n```\n\n```\ntry:    print(fallback_4.invoke({\"event\": \"the superbowl in 1994\"}))except Exception as e:    print(f\"Error: {e}\")\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/query_constructing_filters/",
  "markdown": "# giscus\n\n## How to construct filters for query analysis\n\nWe may want to do query analysis to extract filters to pass into retrievers. One way we ask the LLM to represent these filters is as a Pydantic model. There is then the issue of converting that Pydantic model into a filter that can be passed into a retriever.\n\nThis can be done manually, but LangChain also provides some \"Translators\" that are able to translate from a common syntax into filters specific to each retriever. Here, we will cover how to use those translators.\n\n```\nfrom typing import Optionalfrom langchain.chains.query_constructor.ir import (    Comparator,    Comparison,    Operation,    Operator,    StructuredQuery,)from langchain_community.query_constructors.chroma import ChromaTranslatorfrom langchain_community.query_constructors.elasticsearch import ElasticsearchTranslatorfrom pydantic import BaseModel\n```\n\nIn this example, `year` and `author` are both attributes to filter on.\n\n```\nclass Search(BaseModel):    query: str    start_year: Optional[int]    author: Optional[str]\n```\n\n```\nsearch_query = Search(query=\"RAG\", start_year=2022, author=\"LangChain\")\n```\n\n```\ndef construct_comparisons(query: Search):    comparisons = []    if query.start_year is not None:        comparisons.append(            Comparison(                comparator=Comparator.GT,                attribute=\"start_year\",                value=query.start_year,            )        )    if query.author is not None:        comparisons.append(            Comparison(                comparator=Comparator.EQ,                attribute=\"author\",                value=query.author,            )        )    return comparisons\n```\n\n```\ncomparisons = construct_comparisons(search_query)\n```\n\n```\n_filter = Operation(operator=Operator.AND, arguments=comparisons)\n```\n\n```\nElasticsearchTranslator().visit_operation(_filter)\n```\n\n```\n{'bool': {'must': [{'range': {'metadata.start_year': {'gt': 2022}}},   {'term': {'metadata.author.keyword': 'LangChain'}}]}}\n```\n\n```\nChromaTranslator().visit_operation(_filter)\n```\n\n```\n{'$and': [{'start_year': {'$gt': 2022}}, {'author': {'$eq': 'LangChain'}}]}\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/assign/",
  "markdown": "# giscus\n\n## How to add values to a chain's state\n\nAn alternate way of [passing data through](https://python.langchain.com/docs/how_to/passthrough/) steps of a chain is to leave the current values of the chain state unchanged while assigning a new value under a given key. The [`RunnablePassthrough.assign()`](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.passthrough.RunnablePassthrough.html#langchain_core.runnables.passthrough.RunnablePassthrough.assign) static method takes an input value and adds the extra arguments passed to the assign function.\n\nThis is useful in the common [LangChain Expression Language](https://python.langchain.com/docs/concepts/lcel/) pattern of additively creating a dictionary to use as input to a later step.\n\nHere's an example:\n\n```\n%pip install --upgrade --quiet langchain langchain-openaiimport osfrom getpass import getpassif \"OPENAI_API_KEY\" not in os.environ:    os.environ[\"OPENAI_API_KEY\"] = getpass()\n```\n\n```\nfrom langchain_core.runnables import RunnableParallel, RunnablePassthroughrunnable = RunnableParallel(    extra=RunnablePassthrough.assign(mult=lambda x: x[\"num\"] * 3),    modified=lambda x: x[\"num\"] + 1,)runnable.invoke({\"num\": 1})\n```\n\n```\n{'extra': {'num': 1, 'mult': 3}, 'modified': 2}\n```\n\nLet's break down what's happening here.\n\n*   The input to the chain is `{\"num\": 1}`. This is passed into a `RunnableParallel`, which invokes the runnables it is passed in parallel with that input.\n*   The value under the `extra` key is invoked. `RunnablePassthrough.assign()` keeps the original keys in the input dict (`{\"num\": 1}`), and assigns a new key called `mult`. The value is `lambda x: x[\"num\"] * 3)`, which is `3`. Thus, the result is `{\"num\": 1, \"mult\": 3}`.\n*   `{\"num\": 1, \"mult\": 3}` is returned to the `RunnableParallel` call, and is set as the value to the key `extra`.\n*   At the same time, the `modified` key is called. The result is `2`, since the lambda extracts a key called `\"num\"` from its input and adds one.\n\nThus, the result is `{'extra': {'num': 1, 'mult': 3}, 'modified': 2}`.\n\n## Streaming[​](#streaming \"Direct link to Streaming\")\n\nOne convenient feature of this method is that it allows values to pass through as soon as they are available. To show this off, we'll use `RunnablePassthrough.assign()` to immediately return source docs in a retrieval chain:\n\n```\nfrom langchain_community.vectorstores import FAISSfrom langchain_core.output_parsers import StrOutputParserfrom langchain_core.prompts import ChatPromptTemplatefrom langchain_core.runnables import RunnablePassthroughfrom langchain_openai import ChatOpenAI, OpenAIEmbeddingsvectorstore = FAISS.from_texts(    [\"harrison worked at kensho\"], embedding=OpenAIEmbeddings())retriever = vectorstore.as_retriever()template = \"\"\"Answer the question based only on the following context:{context}Question: {question}\"\"\"prompt = ChatPromptTemplate.from_template(template)model = ChatOpenAI()generation_chain = prompt | model | StrOutputParser()retrieval_chain = {    \"context\": retriever,    \"question\": RunnablePassthrough(),} | RunnablePassthrough.assign(output=generation_chain)stream = retrieval_chain.stream(\"where did harrison work?\")for chunk in stream:    print(chunk)\n```\n\n```\n{'question': 'where did harrison work?'}{'context': [Document(page_content='harrison worked at kensho')]}{'output': ''}{'output': 'H'}{'output': 'arrison'}{'output': ' worked'}{'output': ' at'}{'output': ' Kens'}{'output': 'ho'}{'output': '.'}{'output': ''}\n```\n\nWe can see that the first chunk contains the original `\"question\"` since that is immediately available. The second chunk contains `\"context\"` since the retriever finishes second. Finally, the output from the `generation_chain` streams in chunks as soon as it is available.\n\n## Next steps[​](#next-steps \"Direct link to Next steps\")\n\nNow you've learned how to pass data through your chains to help to help format the data flowing through your chains.\n\nTo learn more, see the other how-to guides on runnables in this section."
},
{
  "url": "https://python.langchain.com/docs/how_to/document_loader_directory/",
  "markdown": "# giscus\n\n## How to load documents from a directory\n\nLangChain's [DirectoryLoader](https://python.langchain.com/api_reference/community/document_loaders/langchain_community.document_loaders.directory.DirectoryLoader.html) implements functionality for reading files from disk into LangChain [Document](https://python.langchain.com/api_reference/core/documents/langchain_core.documents.base.Document.html#langchain_core.documents.base.Document) objects. Here we demonstrate:\n\n*   How to load from a filesystem, including use of wildcard patterns;\n*   How to use multithreading for file I/O;\n*   How to use custom loader classes to parse specific file types (e.g., code);\n*   How to handle errors, such as those due to decoding.\n\n```\nfrom langchain_community.document_loaders import DirectoryLoader\n```\n\n`DirectoryLoader` accepts a `loader_cls` kwarg, which defaults to [UnstructuredLoader](https://python.langchain.com/docs/integrations/document_loaders/unstructured_file/). [Unstructured](https://unstructured-io.github.io/unstructured/) supports parsing for a number of formats, such as PDF and HTML. Here we use it to read in a markdown (.md) file.\n\nWe can use the `glob` parameter to control which files to load. Note that here it doesn't load the `.rst` file or the `.html` files.\n\n```\nloader = DirectoryLoader(\"../\", glob=\"**/*.md\")docs = loader.load()len(docs)\n```\n\n```\nprint(docs[0].page_content[:100])\n```\n\n```\nSecurityLangChain has a large ecosystem of integrations with various external resources like local\n```\n\n## Show a progress bar[​](#show-a-progress-bar \"Direct link to Show a progress bar\")\n\nBy default a progress bar will not be shown. To show a progress bar, install the `tqdm` library (e.g. `pip install tqdm`), and set the `show_progress` parameter to `True`.\n\n```\nloader = DirectoryLoader(\"../\", glob=\"**/*.md\", show_progress=True)docs = loader.load()\n```\n\n```\n100%|█████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 20/20 [00:00<00:00, 54.56it/s]\n```\n\n## Use multithreading[​](#use-multithreading \"Direct link to Use multithreading\")\n\nBy default the loading happens in one thread. In order to utilize several threads set the `use_multithreading` flag to true.\n\n```\nloader = DirectoryLoader(\"../\", glob=\"**/*.md\", use_multithreading=True)docs = loader.load()\n```\n\n## Change loader class[​](#change-loader-class \"Direct link to Change loader class\")\n\nBy default this uses the `UnstructuredLoader` class. To customize the loader, specify the loader class in the `loader_cls` kwarg. Below we show an example using [TextLoader](https://python.langchain.com/api_reference/community/document_loaders/langchain_community.document_loaders.text.TextLoader.html):\n\n```\nfrom langchain_community.document_loaders import TextLoaderloader = DirectoryLoader(\"../\", glob=\"**/*.md\", loader_cls=TextLoader)docs = loader.load()\n```\n\n```\nprint(docs[0].page_content[:100])\n```\n\n```\n# SecurityLangChain has a large ecosystem of integrations with various external resources like loc\n```\n\nNotice that while the `UnstructuredLoader` parses Markdown headers, `TextLoader` does not.\n\nIf you need to load Python source code files, use the `PythonLoader`:\n\n```\nfrom langchain_community.document_loaders import PythonLoaderloader = DirectoryLoader(\"../../../../../\", glob=\"**/*.py\", loader_cls=PythonLoader)\n```\n\n## Auto-detect file encodings with TextLoader[​](#auto-detect-file-encodings-with-textloader \"Direct link to Auto-detect file encodings with TextLoader\")\n\n`DirectoryLoader` can help manage errors due to variations in file encodings. Below we will attempt to load in a collection of files, one of which includes non-UTF8 encodings.\n\n```\npath = \"../../../libs/langchain/tests/unit_tests/examples/\"loader = DirectoryLoader(path, glob=\"**/*.txt\", loader_cls=TextLoader)\n```\n\n### A. Default Behavior[​](#a-default-behavior \"Direct link to A. Default Behavior\")\n\nBy default we raise an error:\n\n```\nError loading file ../../../../libs/langchain/tests/unit_tests/examples/example-non-utf8.txt\n```\n\n```\n---------------------------------------------------------------------------``````outputUnicodeDecodeError                        Traceback (most recent call last)``````outputFile ~/repos/langchain/libs/community/langchain_community/document_loaders/text.py:43, in TextLoader.lazy_load(self)     42     with open(self.file_path, encoding=self.encoding) as f:---> 43         text = f.read()     44 except UnicodeDecodeError as e:``````outputFile ~/.pyenv/versions/3.10.4/lib/python3.10/codecs.py:322, in BufferedIncrementalDecoder.decode(self, input, final)    321 data = self.buffer + input--> 322 (result, consumed) = self._buffer_decode(data, self.errors, final)    323 # keep undecoded input until the next call``````outputUnicodeDecodeError: 'utf-8' codec can't decode byte 0xca in position 0: invalid continuation byte``````outputThe above exception was the direct cause of the following exception:``````outputRuntimeError                              Traceback (most recent call last)``````outputCell In[10], line 1----> 1 loader.load()``````outputFile ~/repos/langchain/libs/community/langchain_community/document_loaders/directory.py:117, in DirectoryLoader.load(self)    115 def load(self) -> List[Document]:    116     \"\"\"Load documents.\"\"\"--> 117     return list(self.lazy_load())``````outputFile ~/repos/langchain/libs/community/langchain_community/document_loaders/directory.py:182, in DirectoryLoader.lazy_load(self)    180 else:    181     for i in items:--> 182         yield from self._lazy_load_file(i, p, pbar)    184 if pbar:    185     pbar.close()``````outputFile ~/repos/langchain/libs/community/langchain_community/document_loaders/directory.py:220, in DirectoryLoader._lazy_load_file(self, item, path, pbar)    218     else:    219         logger.error(f\"Error loading file {str(item)}\")--> 220         raise e    221 finally:    222     if pbar:``````outputFile ~/repos/langchain/libs/community/langchain_community/document_loaders/directory.py:210, in DirectoryLoader._lazy_load_file(self, item, path, pbar)    208 loader = self.loader_cls(str(item), **self.loader_kwargs)    209 try:--> 210     for subdoc in loader.lazy_load():    211         yield subdoc    212 except NotImplementedError:``````outputFile ~/repos/langchain/libs/community/langchain_community/document_loaders/text.py:56, in TextLoader.lazy_load(self)     54                 continue     55     else:---> 56         raise RuntimeError(f\"Error loading {self.file_path}\") from e     57 except Exception as e:     58     raise RuntimeError(f\"Error loading {self.file_path}\") from e``````outputRuntimeError: Error loading ../../../../libs/langchain/tests/unit_tests/examples/example-non-utf8.txt\n```\n\nThe file `example-non-utf8.txt` uses a different encoding, so the `load()` function fails with a helpful message indicating which file failed decoding.\n\nWith the default behavior of `TextLoader` any failure to load any of the documents will fail the whole loading process and no documents are loaded.\n\n### B. Silent fail[​](#b-silent-fail \"Direct link to B. Silent fail\")\n\nWe can pass the parameter `silent_errors` to the `DirectoryLoader` to skip the files which could not be loaded and continue the load process.\n\n```\nloader = DirectoryLoader(    path, glob=\"**/*.txt\", loader_cls=TextLoader, silent_errors=True)docs = loader.load()\n```\n\n```\nError loading file ../../../../libs/langchain/tests/unit_tests/examples/example-non-utf8.txt: Error loading ../../../../libs/langchain/tests/unit_tests/examples/example-non-utf8.txt\n```\n\n```\ndoc_sources = [doc.metadata[\"source\"] for doc in docs]doc_sources\n```\n\n```\n['../../../../libs/langchain/tests/unit_tests/examples/example-utf8.txt']\n```\n\n### C. Auto detect encodings[​](#c-auto-detect-encodings \"Direct link to C. Auto detect encodings\")\n\nWe can also ask `TextLoader` to auto detect the file encoding before failing, by passing the `autodetect_encoding` to the loader class.\n\n```\ntext_loader_kwargs = {\"autodetect_encoding\": True}loader = DirectoryLoader(    path, glob=\"**/*.txt\", loader_cls=TextLoader, loader_kwargs=text_loader_kwargs)docs = loader.load()\n```\n\n```\ndoc_sources = [doc.metadata[\"source\"] for doc in docs]doc_sources\n```\n\n```\n['../../../../libs/langchain/tests/unit_tests/examples/example-utf8.txt', '../../../../libs/langchain/tests/unit_tests/examples/example-non-utf8.txt']\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/filter_messages/",
  "markdown": "# giscus\n\n[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/langchain-ai/langchain/blob/master/docs/docs/how_to/filter_messages.ipynb)[![Open on GitHub](https://img.shields.io/badge/Open%20on%20GitHub-grey?logo=github&logoColor=white)](https://github.com/langchain-ai/langchain/blob/master/docs/docs/how_to/filter_messages.ipynb)\n\n## How to filter messages\n\nIn more complex chains and agents we might track state with a list of [messages](https://python.langchain.com/docs/concepts/messages/). This list can start to accumulate messages from multiple different models, speakers, sub-chains, etc., and we may only want to pass subsets of this full list of messages to each model call in the chain/agent.\n\nThe `filter_messages` utility makes it easy to filter messages by type, id, or name.\n\n## Basic usage[​](#basic-usage \"Direct link to Basic usage\")\n\n```\nfrom langchain_core.messages import (    AIMessage,    HumanMessage,    SystemMessage,    filter_messages,)messages = [    SystemMessage(\"you are a good assistant\", id=\"1\"),    HumanMessage(\"example input\", id=\"2\", name=\"example_user\"),    AIMessage(\"example output\", id=\"3\", name=\"example_assistant\"),    HumanMessage(\"real input\", id=\"4\", name=\"bob\"),    AIMessage(\"real output\", id=\"5\", name=\"alice\"),]filter_messages(messages, include_types=\"human\")\n```\n\n```\n[HumanMessage(content='example input', name='example_user', id='2'), HumanMessage(content='real input', name='bob', id='4')]\n```\n\n```\nfilter_messages(messages, exclude_names=[\"example_user\", \"example_assistant\"])\n```\n\n```\n[SystemMessage(content='you are a good assistant', id='1'), HumanMessage(content='real input', name='bob', id='4'), AIMessage(content='real output', name='alice', id='5')]\n```\n\n```\nfilter_messages(messages, include_types=[HumanMessage, AIMessage], exclude_ids=[\"3\"])\n```\n\n```\n[HumanMessage(content='example input', name='example_user', id='2'), HumanMessage(content='real input', name='bob', id='4'), AIMessage(content='real output', name='alice', id='5')]\n```\n\n## Chaining[​](#chaining \"Direct link to Chaining\")\n\n`filter_messages` can be used in an imperatively (like above) or declaratively, making it easy to compose with other components in a chain:\n\n```\n%pip install -qU langchain-anthropic\n```\n\n```\nfrom langchain_anthropic import ChatAnthropicllm = ChatAnthropic(model=\"claude-3-sonnet-20240229\", temperature=0)# Notice we don't pass in messages. This creates# a RunnableLambda that takes messages as inputfilter_ = filter_messages(exclude_names=[\"example_user\", \"example_assistant\"])chain = filter_ | llmchain.invoke(messages)\n```\n\n```\nAIMessage(content=[], response_metadata={'id': 'msg_01Wz7gBHahAwkZ1KCBNtXmwA', 'model': 'claude-3-sonnet-20240229', 'stop_reason': 'end_turn', 'stop_sequence': None, 'usage': {'input_tokens': 16, 'output_tokens': 3}}, id='run-b5d8a3fe-004f-4502-a071-a6c025031827-0', usage_metadata={'input_tokens': 16, 'output_tokens': 3, 'total_tokens': 19})\n```\n\nLooking at the LangSmith trace we can see that before the messages are passed to the model they are filtered: [https://smith.langchain.com/public/f808a724-e072-438e-9991-657cc9e7e253/r](https://smith.langchain.com/public/f808a724-e072-438e-9991-657cc9e7e253/r)\n\nLooking at just the filter\\_, we can see that it's a Runnable object that can be invoked like all Runnables:\n\n```\n[HumanMessage(content='real input', name='bob', id='4'), AIMessage(content='real output', name='alice', id='5')]\n```\n\n## API reference[​](#api-reference \"Direct link to API reference\")\n\nFor a complete description of all arguments head to the API reference: [https://python.langchain.com/api\\_reference/core/messages/langchain\\_core.messages.utils.filter\\_messages.html](https://python.langchain.com/api_reference/core/messages/langchain_core.messages.utils.filter_messages.html)"
},
{
  "url": "https://python.langchain.com/docs/how_to/recursive_json_splitter/",
  "markdown": "# giscus\n\n## How to split JSON data\n\nThis json splitter [splits](https://python.langchain.com/docs/concepts/text_splitters/) json data while allowing control over chunk sizes. It traverses json data depth first and builds smaller json chunks. It attempts to keep nested json objects whole but will split them if needed to keep chunks between a min\\_chunk\\_size and the max\\_chunk\\_size.\n\nIf the value is not a nested json, but rather a very large string the string will not be split. If you need a hard cap on the chunk size consider composing this with a Recursive Text splitter on those chunks. There is an optional pre-processing step to split lists, by first converting them to json (dict) and then splitting them as such.\n\n1.  How the text is split: json value.\n2.  How the chunk size is measured: by number of characters.\n\n```\n%pip install -qU langchain-text-splitters\n```\n\nFirst we load some json data:\n\n```\nimport jsonimport requests# This is a large nested json object and will be loaded as a python dictjson_data = requests.get(\"https://api.smith.langchain.com/openapi.json\").json()\n```\n\n## Basic usage[​](#basic-usage \"Direct link to Basic usage\")\n\nSpecify `max_chunk_size` to constrain chunk sizes:\n\n```\nfrom langchain_text_splitters import RecursiveJsonSplittersplitter = RecursiveJsonSplitter(max_chunk_size=300)\n```\n\nTo obtain json chunks, use the `.split_json` method:\n\n```\n# Recursively split json data - If you need to access/manipulate the smaller json chunksjson_chunks = splitter.split_json(json_data=json_data)for chunk in json_chunks[:3]:    print(chunk)\n```\n\n```\n{'openapi': '3.1.0', 'info': {'title': 'LangSmith', 'version': '0.1.0'}, 'servers': [{'url': 'https://api.smith.langchain.com', 'description': 'LangSmith API endpoint.'}]}{'paths': {'/api/v1/sessions/{session_id}': {'get': {'tags': ['tracer-sessions'], 'summary': 'Read Tracer Session', 'description': 'Get a specific session.', 'operationId': 'read_tracer_session_api_v1_sessions__session_id__get'}}}}{'paths': {'/api/v1/sessions/{session_id}': {'get': {'security': [{'API Key': []}, {'Tenant ID': []}, {'Bearer Auth': []}]}}}}\n```\n\nTo obtain LangChain [Document](https://python.langchain.com/api_reference/core/documents/langchain_core.documents.base.Document.html) objects, use the `.create_documents` method:\n\n```\n# The splitter can also output documentsdocs = splitter.create_documents(texts=[json_data])for doc in docs[:3]:    print(doc)\n```\n\n```\npage_content='{\"openapi\": \"3.1.0\", \"info\": {\"title\": \"LangSmith\", \"version\": \"0.1.0\"}, \"servers\": [{\"url\": \"https://api.smith.langchain.com\", \"description\": \"LangSmith API endpoint.\"}]}'page_content='{\"paths\": {\"/api/v1/sessions/{session_id}\": {\"get\": {\"tags\": [\"tracer-sessions\"], \"summary\": \"Read Tracer Session\", \"description\": \"Get a specific session.\", \"operationId\": \"read_tracer_session_api_v1_sessions__session_id__get\"}}}}'page_content='{\"paths\": {\"/api/v1/sessions/{session_id}\": {\"get\": {\"security\": [{\"API Key\": []}, {\"Tenant ID\": []}, {\"Bearer Auth\": []}]}}}}'\n```\n\nOr use `.split_text` to obtain string content directly:\n\n```\ntexts = splitter.split_text(json_data=json_data)print(texts[0])print(texts[1])\n```\n\n```\n{\"openapi\": \"3.1.0\", \"info\": {\"title\": \"LangSmith\", \"version\": \"0.1.0\"}, \"servers\": [{\"url\": \"https://api.smith.langchain.com\", \"description\": \"LangSmith API endpoint.\"}]}{\"paths\": {\"/api/v1/sessions/{session_id}\": {\"get\": {\"tags\": [\"tracer-sessions\"], \"summary\": \"Read Tracer Session\", \"description\": \"Get a specific session.\", \"operationId\": \"read_tracer_session_api_v1_sessions__session_id__get\"}}}}\n```\n\n## How to manage chunk sizes from list content[​](#how-to-manage-chunk-sizes-from-list-content \"Direct link to How to manage chunk sizes from list content\")\n\nNote that one of the chunks in this example is larger than the specified `max_chunk_size` of 300. Reviewing one of these chunks that was bigger we see there is a list object there:\n\n```\nprint([len(text) for text in texts][:10])print()print(texts[3])\n```\n\n```\n[171, 231, 126, 469, 210, 213, 237, 271, 191, 232]{\"paths\": {\"/api/v1/sessions/{session_id}\": {\"get\": {\"parameters\": [{\"name\": \"session_id\", \"in\": \"path\", \"required\": true, \"schema\": {\"type\": \"string\", \"format\": \"uuid\", \"title\": \"Session Id\"}}, {\"name\": \"include_stats\", \"in\": \"query\", \"required\": false, \"schema\": {\"type\": \"boolean\", \"default\": false, \"title\": \"Include Stats\"}}, {\"name\": \"accept\", \"in\": \"header\", \"required\": false, \"schema\": {\"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}], \"title\": \"Accept\"}}]}}}}\n```\n\nThe json splitter by default does not split lists.\n\nSpecify `convert_lists=True` to preprocess the json, converting list content to dicts with `index:item` as `key:val` pairs:\n\n```\ntexts = splitter.split_text(json_data=json_data, convert_lists=True)\n```\n\nLet's look at the size of the chunks. Now they are all under the max\n\n```\nprint([len(text) for text in texts][:10])\n```\n\n```\n[176, 236, 141, 203, 212, 221, 210, 213, 242, 291]\n```\n\nThe list has been converted to a dict, but retains all the needed contextual information even if split into many chunks:\n\n```\n{\"paths\": {\"/api/v1/sessions/{session_id}\": {\"get\": {\"tags\": {\"0\": \"tracer-sessions\"}, \"summary\": \"Read Tracer Session\", \"description\": \"Get a specific session.\", \"operationId\": \"read_tracer_session_api_v1_sessions__session_id__get\"}}}}\n```\n\n```\n# We can also look at the documentsdocs[1]\n```\n\n```\nDocument(page_content='{\"paths\": {\"/api/v1/sessions/{session_id}\": {\"get\": {\"tags\": [\"tracer-sessions\"], \"summary\": \"Read Tracer Session\", \"description\": \"Get a specific session.\", \"operationId\": \"read_tracer_session_api_v1_sessions__session_id__get\"}}}}')\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/parallel/",
  "markdown": "# giscus\n\n## How to invoke runnables in parallel\n\nThe [`RunnableParallel`](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.RunnableParallel.html) primitive is essentially a dict whose values are runnables (or things that can be coerced to runnables, like functions). It runs all of its values in parallel, and each value is called with the overall input of the `RunnableParallel`. The final return value is a dict with the results of each value under its appropriate key.\n\n## Formatting with `RunnableParallels`[​](#formatting-with-runnableparallels \"Direct link to formatting-with-runnableparallels\")\n\n`RunnableParallels` are useful for parallelizing operations, but can also be useful for manipulating the output of one Runnable to match the input format of the next Runnable in a sequence. You can use them to split or fork the chain so that multiple components can process the input in parallel. Later, other components can join or merge the results to synthesize a final response. This type of chain creates a computation graph that looks like the following:\n\n```\n     Input      / \\     /   \\ Branch1 Branch2     \\   /      \\ /      Combine\n```\n\nBelow, the input to prompt is expected to be a map with keys `\"context\"` and `\"question\"`. The user input is just the question. So we need to get the context using our retriever and passthrough the user input under the `\"question\"` key.\n\n```\nfrom langchain_community.vectorstores import FAISSfrom langchain_core.output_parsers import StrOutputParserfrom langchain_core.prompts import ChatPromptTemplatefrom langchain_core.runnables import RunnablePassthroughfrom langchain_openai import ChatOpenAI, OpenAIEmbeddingsvectorstore = FAISS.from_texts(    [\"harrison worked at kensho\"], embedding=OpenAIEmbeddings())retriever = vectorstore.as_retriever()template = \"\"\"Answer the question based only on the following context:{context}Question: {question}\"\"\"# The prompt expects input with keys for \"context\" and \"question\"prompt = ChatPromptTemplate.from_template(template)model = ChatOpenAI()retrieval_chain = (    {\"context\": retriever, \"question\": RunnablePassthrough()}    | prompt    | model    | StrOutputParser())retrieval_chain.invoke(\"where did harrison work?\")\n```\n\n```\n'Harrison worked at Kensho.'\n```\n\ntip\n\nNote that when composing a RunnableParallel with another Runnable we don't even need to wrap our dictionary in the RunnableParallel class — the type conversion is handled for us. In the context of a chain, these are equivalent:\n\n```\n{\"context\": retriever, \"question\": RunnablePassthrough()}\n```\n\n```\nRunnableParallel({\"context\": retriever, \"question\": RunnablePassthrough()})\n```\n\n```\nRunnableParallel(context=retriever, question=RunnablePassthrough())\n```\n\nSee the section on [coercion for more](https://python.langchain.com/docs/how_to/sequence/#coercion).\n\n## Using itemgetter as shorthand[​](#using-itemgetter-as-shorthand \"Direct link to Using itemgetter as shorthand\")\n\nNote that you can use Python's `itemgetter` as shorthand to extract data from the map when combining with `RunnableParallel`. You can find more information about itemgetter in the [Python Documentation](https://docs.python.org/3/library/operator.html#operator.itemgetter).\n\nIn the example below, we use itemgetter to extract specific keys from the map:\n\n```\nfrom operator import itemgetterfrom langchain_community.vectorstores import FAISSfrom langchain_core.output_parsers import StrOutputParserfrom langchain_core.prompts import ChatPromptTemplatefrom langchain_core.runnables import RunnablePassthroughfrom langchain_openai import ChatOpenAI, OpenAIEmbeddingsvectorstore = FAISS.from_texts(    [\"harrison worked at kensho\"], embedding=OpenAIEmbeddings())retriever = vectorstore.as_retriever()template = \"\"\"Answer the question based only on the following context:{context}Question: {question}Answer in the following language: {language}\"\"\"prompt = ChatPromptTemplate.from_template(template)chain = (    {        \"context\": itemgetter(\"question\") | retriever,        \"question\": itemgetter(\"question\"),        \"language\": itemgetter(\"language\"),    }    | prompt    | model    | StrOutputParser())chain.invoke({\"question\": \"where did harrison work\", \"language\": \"italian\"})\n```\n\n```\n'Harrison ha lavorato a Kensho.'\n```\n\n## Parallelize steps[​](#parallelize-steps \"Direct link to Parallelize steps\")\n\nRunnableParallels make it easy to execute multiple Runnables in parallel, and to return the output of these Runnables as a map.\n\n```\nfrom langchain_core.prompts import ChatPromptTemplatefrom langchain_core.runnables import RunnableParallelfrom langchain_openai import ChatOpenAImodel = ChatOpenAI()joke_chain = ChatPromptTemplate.from_template(\"tell me a joke about {topic}\") | modelpoem_chain = (    ChatPromptTemplate.from_template(\"write a 2-line poem about {topic}\") | model)map_chain = RunnableParallel(joke=joke_chain, poem=poem_chain)map_chain.invoke({\"topic\": \"bear\"})\n```\n\n```\n{'joke': AIMessage(content=\"Why don't bears like fast food? Because they can't catch it!\", response_metadata={'token_usage': {'completion_tokens': 15, 'prompt_tokens': 13, 'total_tokens': 28}, 'model_name': 'gpt-3.5-turbo', 'system_fingerprint': 'fp_d9767fc5b9', 'finish_reason': 'stop', 'logprobs': None}, id='run-fe024170-c251-4b7a-bfd4-64a3737c67f2-0'), 'poem': AIMessage(content='In the quiet of the forest, the bear roams free\\nMajestic and wild, a sight to see.', response_metadata={'token_usage': {'completion_tokens': 24, 'prompt_tokens': 15, 'total_tokens': 39}, 'model_name': 'gpt-3.5-turbo', 'system_fingerprint': 'fp_c2295e73ad', 'finish_reason': 'stop', 'logprobs': None}, id='run-2707913e-a743-4101-b6ec-840df4568a76-0')}\n```\n\n## Parallelism[​](#parallelism \"Direct link to Parallelism\")\n\nRunnableParallel are also useful for running independent processes in parallel, since each Runnable in the map is executed in parallel. For example, we can see our earlier `joke_chain`, `poem_chain` and `map_chain` all have about the same runtime, even though `map_chain` executes both of the other two.\n\n```\n%%timeitjoke_chain.invoke({\"topic\": \"bear\"})\n```\n\n```\n610 ms ± 64 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\n```\n\n```\n%%timeitpoem_chain.invoke({\"topic\": \"bear\"})\n```\n\n```\n599 ms ± 73.3 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\n```\n\n```\n%%timeitmap_chain.invoke({\"topic\": \"bear\"})\n```\n\n```\n643 ms ± 77.8 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\n```\n\n## Next steps[​](#next-steps \"Direct link to Next steps\")\n\nYou now know some ways to format and parallelize chain steps with `RunnableParallel`.\n\nTo learn more, see the other how-to guides on runnables in this section."
},
{
  "url": "https://python.langchain.com/docs/how_to/document_loader_html/",
  "markdown": "# giscus\n\n## How to load HTML\n\nThe HyperText Markup Language or [HTML](https://en.wikipedia.org/wiki/HTML) is the standard markup language for documents designed to be displayed in a web browser.\n\nThis covers how to load `HTML` documents into a LangChain [Document](https://python.langchain.com/api_reference/core/documents/langchain_core.documents.base.Document.html#langchain_core.documents.base.Document) objects that we can use downstream.\n\nParsing HTML files often requires specialized tools. Here we demonstrate parsing via [Unstructured](https://unstructured-io.github.io/unstructured/) and [BeautifulSoup4](https://beautiful-soup-4.readthedocs.io/en/latest/), which can be installed via pip. Head over to the integrations page to find integrations with additional services, such as [Azure AI Document Intelligence](https://python.langchain.com/docs/integrations/document_loaders/azure_document_intelligence/) or [FireCrawl](https://python.langchain.com/docs/integrations/document_loaders/firecrawl/).\n\n## Loading HTML with Unstructured[​](#loading-html-with-unstructured \"Direct link to Loading HTML with Unstructured\")\n\n```\n%pip install unstructured\n```\n\n```\nfrom langchain_community.document_loaders import UnstructuredHTMLLoaderfile_path = \"../../docs/integrations/document_loaders/example_data/fake-content.html\"loader = UnstructuredHTMLLoader(file_path)data = loader.load()print(data)\n```\n\n```\n[Document(page_content='My First Heading\\n\\nMy first paragraph.', metadata={'source': '../../docs/integrations/document_loaders/example_data/fake-content.html'})]\n```\n\n## Loading HTML with BeautifulSoup4[​](#loading-html-with-beautifulsoup4 \"Direct link to Loading HTML with BeautifulSoup4\")\n\nWe can also use `BeautifulSoup4` to load HTML documents using the `BSHTMLLoader`. This will extract the text from the HTML into `page_content`, and the page title as `title` into `metadata`.\n\n```\nfrom langchain_community.document_loaders import BSHTMLLoaderloader = BSHTMLLoader(file_path)data = loader.load()print(data)\n```\n\n```\n[Document(page_content='\\nTest Title\\n\\n\\nMy First Heading\\nMy first paragraph.\\n\\n\\n', metadata={'source': '../../docs/integrations/document_loaders/example_data/fake-content.html', 'title': 'Test Title'})]\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/hybrid/",
  "markdown": "# giscus\n\n## Hybrid Search\n\nThe standard search in LangChain is done by vector similarity. However, a number of [vector store](https://python.langchain.com/docs/integrations/vectorstores/) implementations (Astra DB, ElasticSearch, Neo4J, AzureSearch, Qdrant...) also support more advanced search combining vector similarity search and other search techniques (full-text, BM25, and so on). This is generally referred to as \"Hybrid\" search.\n\n**Step 1: Make sure the vectorstore you are using supports hybrid search**\n\nAt the moment, there is no unified way to perform hybrid search in LangChain. Each vectorstore may have their own way to do it. This is generally exposed as a keyword argument that is passed in during `similarity_search`.\n\nBy reading the documentation or source code, figure out whether the vectorstore you are using supports hybrid search, and, if so, how to use it.\n\n**Step 2: Add that parameter as a configurable field for the chain**\n\nThis will let you easily call the chain and configure any relevant flags at runtime. See [this documentation](https://python.langchain.com/docs/how_to/configure/) for more information on configuration.\n\n**Step 3: Call the chain with that configurable field**\n\nNow, at runtime you can call this chain with configurable field.\n\n## Code Example[​](#code-example \"Direct link to Code Example\")\n\nLet's see a concrete example of what this looks like in code. We will use the Cassandra/CQL interface of Astra DB for this example.\n\nInstall the following Python package:\n\n```\n!pip install \"cassio>=0.1.7\"\n```\n\nGet the [connection secrets](https://docs.datastax.com/en/astra/astra-db-vector/get-started/quickstart.html).\n\nInitialize cassio:\n\n```\nimport cassiocassio.init(    database_id=\"Your database ID\",    token=\"Your application token\",    keyspace=\"Your key space\",)\n```\n\nCreate the Cassandra VectorStore with a standard [index analyzer](https://docs.datastax.com/en/astra/astra-db-vector/cql/use-analyzers-with-cql.html). The index analyzer is needed to enable term matching.\n\n```\nfrom cassio.table.cql import STANDARD_ANALYZERfrom langchain_community.vectorstores import Cassandrafrom langchain_openai import OpenAIEmbeddingsembeddings = OpenAIEmbeddings()vectorstore = Cassandra(    embedding=embeddings,    table_name=\"test_hybrid\",    body_index_options=[STANDARD_ANALYZER],    session=None,    keyspace=None,)vectorstore.add_texts(    [        \"In 2023, I visited Paris\",        \"In 2022, I visited New York\",        \"In 2021, I visited New Orleans\",    ])\n```\n\nIf we do a standard similarity search, we get all the documents:\n\n```\nvectorstore.as_retriever().invoke(\"What city did I visit last?\")\n```\n\n```\n[Document(page_content='In 2022, I visited New York'),Document(page_content='In 2023, I visited Paris'),Document(page_content='In 2021, I visited New Orleans')]\n```\n\nThe Astra DB vectorstore `body_search` argument can be used to filter the search on the term `new`.\n\n```\nvectorstore.as_retriever(search_kwargs={\"body_search\": \"new\"}).invoke(    \"What city did I visit last?\")\n```\n\n```\n[Document(page_content='In 2022, I visited New York'),Document(page_content='In 2021, I visited New Orleans')]\n```\n\nWe can now create the chain that we will use to do question-answering over\n\n```\nfrom langchain_core.output_parsers import StrOutputParserfrom langchain_core.prompts import ChatPromptTemplatefrom langchain_core.runnables import (    ConfigurableField,    RunnablePassthrough,)from langchain_openai import ChatOpenAI\n```\n\nThis is basic question-answering chain set up.\n\n```\ntemplate = \"\"\"Answer the question based only on the following context:{context}Question: {question}\"\"\"prompt = ChatPromptTemplate.from_template(template)model = ChatOpenAI()retriever = vectorstore.as_retriever()\n```\n\nHere we mark the retriever as having a configurable field. All vectorstore retrievers have `search_kwargs` as a field. This is just a dictionary, with vectorstore specific fields\n\n```\nconfigurable_retriever = retriever.configurable_fields(    search_kwargs=ConfigurableField(        id=\"search_kwargs\",        name=\"Search Kwargs\",        description=\"The search kwargs to use\",    ))\n```\n\nWe can now create the chain using our configurable retriever\n\n```\nchain = (    {\"context\": configurable_retriever, \"question\": RunnablePassthrough()}    | prompt    | model    | StrOutputParser())\n```\n\n```\nchain.invoke(\"What city did I visit last?\")\n```\n\nWe can now invoke the chain with configurable options. `search_kwargs` is the id of the configurable field. The value is the search kwargs to use for Astra DB.\n\n```\nchain.invoke(    \"What city did I visit last?\",    config={\"configurable\": {\"search_kwargs\": {\"body_search\": \"new\"}}},)\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/chat_streaming/",
  "markdown": "# giscus\n\nAll [chat models](https://python.langchain.com/api_reference/core/language_models/langchain_core.language_models.chat_models.BaseChatModel.html) implement the [Runnable interface](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable), which comes with a **default** implementations of standard runnable methods (i.e. `ainvoke`, `batch`, `abatch`, `stream`, `astream`, `astream_events`).\n\nThe **default** streaming implementation provides an`Iterator` (or `AsyncIterator` for asynchronous streaming) that yields a single value: the final output from the underlying chat model provider.\n\nThe ability to stream the output token-by-token depends on whether the provider has implemented proper streaming support.\n\nBelow we use a `|` to help visualize the delimiter between tokens.\n\n```\nHere| is| a| |1| |verse| song| about| gol|dfish| on| the| moon|:|Floating| up| in| the| star|ry| night|,|Fins| a|-|gl|im|mer| in| the| pale| moon|light|.|Gol|dfish| swimming|,| peaceful| an|d free|,|Se|ren|ely| |drif|ting| across| the| lunar| sea|.|\n```\n\n```\nHere| is| a| |1| |verse| song| about| gol|dfish| on| the| moon|:|Floating| up| above| the| Earth|,|Gol|dfish| swim| in| alien| m|irth|.|In| their| bowl| of| lunar| dust|,|Gl|it|tering| scales| reflect| the| trust|Of| swimming| free| in| this| new| worl|d,|Where| their| aqu|atic| dream|'s| unf|ur|le|d.|\n```\n\nThis method is useful if you're streaming output from a larger LLM application that contains multiple steps (e.g., an LLM chain composed of a prompt, llm and parser).\n\n```\n{'event': 'on_chat_model_start', 'run_id': '08da631a-12a0-4f07-baee-fc9a175ad4ba', 'name': 'ChatAnthropic', 'tags': [], 'metadata': {}, 'data': {'input': 'Write me a 1 verse song about goldfish on the moon'}}{'event': 'on_chat_model_stream', 'run_id': '08da631a-12a0-4f07-baee-fc9a175ad4ba', 'tags': [], 'metadata': {}, 'name': 'ChatAnthropic', 'data': {'chunk': AIMessageChunk(content='Here', id='run-08da631a-12a0-4f07-baee-fc9a175ad4ba')}}{'event': 'on_chat_model_stream', 'run_id': '08da631a-12a0-4f07-baee-fc9a175ad4ba', 'tags': [], 'metadata': {}, 'name': 'ChatAnthropic', 'data': {'chunk': AIMessageChunk(content=\"'s\", id='run-08da631a-12a0-4f07-baee-fc9a175ad4ba')}}{'event': 'on_chat_model_stream', 'run_id': '08da631a-12a0-4f07-baee-fc9a175ad4ba', 'tags': [], 'metadata': {}, 'name': 'ChatAnthropic', 'data': {'chunk': AIMessageChunk(content=' a', id='run-08da631a-12a0-4f07-baee-fc9a175ad4ba')}}...Truncated\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/configure/",
  "markdown": "# giscus\n\n## How to configure runtime chain internals\n\nSometimes you may want to experiment with, or even expose to the end user, multiple different ways of doing things within your chains. This can include tweaking parameters such as temperature or even swapping out one model for another. In order to make this experience as easy as possible, we have defined two methods.\n\n*   A `configurable_fields` method. This lets you configure particular fields of a runnable.\n    *   This is related to the [`.bind`](https://python.langchain.com/docs/how_to/binding/) method on runnables, but allows you to specify parameters for a given step in a chain at runtime rather than specifying them beforehand.\n*   A `configurable_alternatives` method. With this method, you can list out alternatives for any particular runnable that can be set during runtime, and swap them for those specified alternatives.\n\n## Configurable Fields[​](#configurable-fields \"Direct link to Configurable Fields\")\n\nLet's walk through an example that configures chat model fields like temperature at runtime:\n\n```\n%pip install --upgrade --quiet langchain langchain-openaiimport osfrom getpass import getpassif \"OPENAI_API_KEY\" not in os.environ:    os.environ[\"OPENAI_API_KEY\"] = getpass()\n```\n\n```\nfrom langchain_core.prompts import PromptTemplatefrom langchain_core.runnables import ConfigurableFieldfrom langchain_openai import ChatOpenAImodel = ChatOpenAI(temperature=0).configurable_fields(    temperature=ConfigurableField(        id=\"llm_temperature\",        name=\"LLM Temperature\",        description=\"The temperature of the LLM\",    ))model.invoke(\"pick a random number\")\n```\n\n```\nAIMessage(content='17', response_metadata={'token_usage': {'completion_tokens': 1, 'prompt_tokens': 11, 'total_tokens': 12}, 'model_name': 'gpt-3.5-turbo', 'system_fingerprint': 'fp_c2295e73ad', 'finish_reason': 'stop', 'logprobs': None}, id='run-ba26a0da-0a69-4533-ab7f-21178a73d303-0')\n```\n\nAbove, we defined `temperature` as a [`ConfigurableField`](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.utils.ConfigurableField.html#langchain_core.runnables.utils.ConfigurableField) that we can set at runtime. To do so, we use the [`with_config`](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.with_config) method like this:\n\n```\nmodel.with_config(configurable={\"llm_temperature\": 0.9}).invoke(\"pick a random number\")\n```\n\n```\nAIMessage(content='12', response_metadata={'token_usage': {'completion_tokens': 1, 'prompt_tokens': 11, 'total_tokens': 12}, 'model_name': 'gpt-3.5-turbo', 'system_fingerprint': 'fp_c2295e73ad', 'finish_reason': 'stop', 'logprobs': None}, id='run-ba8422ad-be77-4cb1-ac45-ad0aae74e3d9-0')\n```\n\nNote that the passed `llm_temperature` entry in the dict has the same key as the `id` of the `ConfigurableField`.\n\nWe can also do this to affect just one step that's part of a chain:\n\n```\nprompt = PromptTemplate.from_template(\"Pick a random number above {x}\")chain = prompt | modelchain.invoke({\"x\": 0})\n```\n\n```\nAIMessage(content='27', response_metadata={'token_usage': {'completion_tokens': 1, 'prompt_tokens': 14, 'total_tokens': 15}, 'model_name': 'gpt-3.5-turbo', 'system_fingerprint': 'fp_c2295e73ad', 'finish_reason': 'stop', 'logprobs': None}, id='run-ecd4cadd-1b72-4f92-b9a0-15e08091f537-0')\n```\n\n```\nchain.with_config(configurable={\"llm_temperature\": 0.9}).invoke({\"x\": 0})\n```\n\n```\nAIMessage(content='35', response_metadata={'token_usage': {'completion_tokens': 1, 'prompt_tokens': 14, 'total_tokens': 15}, 'model_name': 'gpt-3.5-turbo', 'system_fingerprint': 'fp_c2295e73ad', 'finish_reason': 'stop', 'logprobs': None}, id='run-a916602b-3460-46d3-a4a8-7c926ec747c0-0')\n```\n\n### With HubRunnables[​](#with-hubrunnables \"Direct link to With HubRunnables\")\n\nThis is useful to allow for switching of prompts\n\n```\nfrom langchain.runnables.hub import HubRunnableprompt = HubRunnable(\"rlm/rag-prompt\").configurable_fields(    owner_repo_commit=ConfigurableField(        id=\"hub_commit\",        name=\"Hub Commit\",        description=\"The Hub commit to pull from\",    ))prompt.invoke({\"question\": \"foo\", \"context\": \"bar\"})\n```\n\n```\nChatPromptValue(messages=[HumanMessage(content=\"You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don't know the answer, just say that you don't know. Use three sentences maximum and keep the answer concise.\\nQuestion: foo \\nContext: bar \\nAnswer:\")])\n```\n\n```\nprompt.with_config(configurable={\"hub_commit\": \"rlm/rag-prompt-llama\"}).invoke(    {\"question\": \"foo\", \"context\": \"bar\"})\n```\n\n```\nChatPromptValue(messages=[HumanMessage(content=\"[INST]<<SYS>> You are an assistant for question-answering tasks. Use the following pieces of retrieved context to answer the question. If you don't know the answer, just say that you don't know. Use three sentences maximum and keep the answer concise.<</SYS>> \\nQuestion: foo \\nContext: bar \\nAnswer: [/INST]\")])\n```\n\n## Configurable Alternatives[​](#configurable-alternatives \"Direct link to Configurable Alternatives\")\n\nThe `configurable_alternatives()` method allows us to swap out steps in a chain with an alternative. Below, we swap out one chat model for another:\n\n```\n%pip install --upgrade --quiet langchain-anthropicimport osfrom getpass import getpassif \"ANTHROPIC_API_KEY\" not in os.environ:    os.environ[\"ANTHROPIC_API_KEY\"] = getpass()\n```\n\n```\n\u001b[33mWARNING: You are using pip version 22.0.4; however, version 24.0 is available.You should consider upgrading via the '/Users/jacoblee/.pyenv/versions/3.10.5/bin/python -m pip install --upgrade pip' command.\u001b[0m\u001b[33m\u001b[0mNote: you may need to restart the kernel to use updated packages.\n```\n\n```\nfrom langchain_anthropic import ChatAnthropicfrom langchain_core.prompts import PromptTemplatefrom langchain_core.runnables import ConfigurableFieldfrom langchain_openai import ChatOpenAIllm = ChatAnthropic(    model=\"claude-3-haiku-20240307\", temperature=0).configurable_alternatives(    # This gives this field an id    # When configuring the end runnable, we can then use this id to configure this field    ConfigurableField(id=\"llm\"),    # This sets a default_key.    # If we specify this key, the default LLM (ChatAnthropic initialized above) will be used    default_key=\"anthropic\",    # This adds a new option, with name `openai` that is equal to `ChatOpenAI()`    openai=ChatOpenAI(),    # This adds a new option, with name `gpt4` that is equal to `ChatOpenAI(model=\"gpt-4\")`    gpt4=ChatOpenAI(model=\"gpt-4\"),    # You can add more configuration options here)prompt = PromptTemplate.from_template(\"Tell me a joke about {topic}\")chain = prompt | llm# By default it will call Anthropicchain.invoke({\"topic\": \"bears\"})\n```\n\n```\nAIMessage(content=\"Here's a bear joke for you:\\n\\nWhy don't bears wear socks? \\nBecause they have bear feet!\\n\\nHow's that? I tried to come up with a simple, silly pun-based joke about bears. Puns and wordplay are a common way to create humorous bear jokes. Let me know if you'd like to hear another one!\", response_metadata={'id': 'msg_018edUHh5fUbWdiimhrC3dZD', 'model': 'claude-3-haiku-20240307', 'stop_reason': 'end_turn', 'stop_sequence': None, 'usage': {'input_tokens': 13, 'output_tokens': 80}}, id='run-775bc58c-28d7-4e6b-a268-48fa6661f02f-0')\n```\n\n```\n# We can use `.with_config(configurable={\"llm\": \"openai\"})` to specify an llm to usechain.with_config(configurable={\"llm\": \"openai\"}).invoke({\"topic\": \"bears\"})\n```\n\n```\nAIMessage(content=\"Why don't bears like fast food?\\n\\nBecause they can't catch it!\", response_metadata={'token_usage': {'completion_tokens': 15, 'prompt_tokens': 13, 'total_tokens': 28}, 'model_name': 'gpt-3.5-turbo', 'system_fingerprint': 'fp_c2295e73ad', 'finish_reason': 'stop', 'logprobs': None}, id='run-7bdaa992-19c9-4f0d-9a0c-1f326bc992d4-0')\n```\n\n```\n# If we use the `default_key` then it uses the defaultchain.with_config(configurable={\"llm\": \"anthropic\"}).invoke({\"topic\": \"bears\"})\n```\n\n```\nAIMessage(content=\"Here's a bear joke for you:\\n\\nWhy don't bears wear socks? \\nBecause they have bear feet!\\n\\nHow's that? I tried to come up with a simple, silly pun-based joke about bears. Puns and wordplay are a common way to create humorous bear jokes. Let me know if you'd like to hear another one!\", response_metadata={'id': 'msg_01BZvbmnEPGBtcxRWETCHkct', 'model': 'claude-3-haiku-20240307', 'stop_reason': 'end_turn', 'stop_sequence': None, 'usage': {'input_tokens': 13, 'output_tokens': 80}}, id='run-59b6ee44-a1cd-41b8-a026-28ee67cdd718-0')\n```\n\n### With Prompts[​](#with-prompts \"Direct link to With Prompts\")\n\nWe can do a similar thing, but alternate between prompts\n\n```\nllm = ChatAnthropic(model=\"claude-3-haiku-20240307\", temperature=0)prompt = PromptTemplate.from_template(    \"Tell me a joke about {topic}\").configurable_alternatives(    # This gives this field an id    # When configuring the end runnable, we can then use this id to configure this field    ConfigurableField(id=\"prompt\"),    # This sets a default_key.    # If we specify this key, the default prompt (asking for a joke, as initialized above) will be used    default_key=\"joke\",    # This adds a new option, with name `poem`    poem=PromptTemplate.from_template(\"Write a short poem about {topic}\"),    # You can add more configuration options here)chain = prompt | llm# By default it will write a jokechain.invoke({\"topic\": \"bears\"})\n```\n\n```\nAIMessage(content=\"Here's a bear joke for you:\\n\\nWhy don't bears wear socks? \\nBecause they have bear feet!\", response_metadata={'id': 'msg_01DtM1cssjNFZYgeS3gMZ49H', 'model': 'claude-3-haiku-20240307', 'stop_reason': 'end_turn', 'stop_sequence': None, 'usage': {'input_tokens': 13, 'output_tokens': 28}}, id='run-8199af7d-ea31-443d-b064-483693f2e0a1-0')\n```\n\n```\n# We can configure it write a poemchain.with_config(configurable={\"prompt\": \"poem\"}).invoke({\"topic\": \"bears\"})\n```\n\n```\nAIMessage(content=\"Here is a short poem about bears:\\n\\nMajestic bears, strong and true,\\nRoaming the forests, wild and free.\\nPowerful paws, fur soft and brown,\\nCommanding respect, nature's crown.\\n\\nForaging for berries, fishing streams,\\nProtecting their young, fierce and keen.\\nMighty bears, a sight to behold,\\nGuardians of the wilderness, untold.\\n\\nIn the wild they reign supreme,\\nEmbodying nature's grand theme.\\nBears, a symbol of strength and grace,\\nCaptivating all who see their face.\", response_metadata={'id': 'msg_01Wck3qPxrjURtutvtodaJFn', 'model': 'claude-3-haiku-20240307', 'stop_reason': 'end_turn', 'stop_sequence': None, 'usage': {'input_tokens': 13, 'output_tokens': 134}}, id='run-69414a1e-51d7-4bec-a307-b34b7d61025e-0')\n```\n\n### With Prompts and LLMs[​](#with-prompts-and-llms \"Direct link to With Prompts and LLMs\")\n\nWe can also have multiple things configurable! Here's an example doing that with both prompts and LLMs.\n\n```\nllm = ChatAnthropic(    model=\"claude-3-haiku-20240307\", temperature=0).configurable_alternatives(    # This gives this field an id    # When configuring the end runnable, we can then use this id to configure this field    ConfigurableField(id=\"llm\"),    # This sets a default_key.    # If we specify this key, the default LLM (ChatAnthropic initialized above) will be used    default_key=\"anthropic\",    # This adds a new option, with name `openai` that is equal to `ChatOpenAI()`    openai=ChatOpenAI(),    # This adds a new option, with name `gpt4` that is equal to `ChatOpenAI(model=\"gpt-4\")`    gpt4=ChatOpenAI(model=\"gpt-4\"),    # You can add more configuration options here)prompt = PromptTemplate.from_template(    \"Tell me a joke about {topic}\").configurable_alternatives(    # This gives this field an id    # When configuring the end runnable, we can then use this id to configure this field    ConfigurableField(id=\"prompt\"),    # This sets a default_key.    # If we specify this key, the default prompt (asking for a joke, as initialized above) will be used    default_key=\"joke\",    # This adds a new option, with name `poem`    poem=PromptTemplate.from_template(\"Write a short poem about {topic}\"),    # You can add more configuration options here)chain = prompt | llm# We can configure it write a poem with OpenAIchain.with_config(configurable={\"prompt\": \"poem\", \"llm\": \"openai\"}).invoke(    {\"topic\": \"bears\"})\n```\n\n```\nAIMessage(content=\"In the forest deep and wide,\\nBears roam with grace and pride.\\nWith fur as dark as night,\\nThey rule the land with all their might.\\n\\nIn winter's chill, they hibernate,\\nIn spring they emerge, hungry and great.\\nWith claws sharp and eyes so keen,\\nThey hunt for food, fierce and lean.\\n\\nBut beneath their tough exterior,\\nLies a gentle heart, warm and superior.\\nThey love their cubs with all their might,\\nProtecting them through day and night.\\n\\nSo let us admire these majestic creatures,\\nIn awe of their strength and features.\\nFor in the wild, they reign supreme,\\nThe mighty bears, a timeless dream.\", response_metadata={'token_usage': {'completion_tokens': 133, 'prompt_tokens': 13, 'total_tokens': 146}, 'model_name': 'gpt-3.5-turbo', 'system_fingerprint': 'fp_c2295e73ad', 'finish_reason': 'stop', 'logprobs': None}, id='run-5eec0b96-d580-49fd-ac4e-e32a0803b49b-0')\n```\n\n```\n# We can always just configure only one if we wantchain.with_config(configurable={\"llm\": \"openai\"}).invoke({\"topic\": \"bears\"})\n```\n\n```\nAIMessage(content=\"Why don't bears wear shoes?\\n\\nBecause they have bear feet!\", response_metadata={'token_usage': {'completion_tokens': 13, 'prompt_tokens': 13, 'total_tokens': 26}, 'model_name': 'gpt-3.5-turbo', 'system_fingerprint': 'fp_c2295e73ad', 'finish_reason': 'stop', 'logprobs': None}, id='run-c1b14c9c-4988-49b8-9363-15bfd479973a-0')\n```\n\n### Saving configurations[​](#saving-configurations \"Direct link to Saving configurations\")\n\nWe can also easily save configured chains as their own objects\n\n```\nopenai_joke = chain.with_config(configurable={\"llm\": \"openai\"})openai_joke.invoke({\"topic\": \"bears\"})\n```\n\n```\nAIMessage(content=\"Why did the bear break up with his girlfriend? \\nBecause he couldn't bear the relationship anymore!\", response_metadata={'token_usage': {'completion_tokens': 20, 'prompt_tokens': 13, 'total_tokens': 33}, 'model_name': 'gpt-3.5-turbo', 'system_fingerprint': 'fp_c2295e73ad', 'finish_reason': 'stop', 'logprobs': None}, id='run-391ebd55-9137-458b-9a11-97acaff6a892-0')\n```\n\n## Next steps[​](#next-steps \"Direct link to Next steps\")\n\nYou now know how to configure a chain's internal steps at runtime.\n\nTo learn more, see the other how-to guides on runnables in this section, including:\n\n*   Using [.bind()](https://python.langchain.com/docs/how_to/binding/) as a simpler way to set a runnable's runtime parameters"
},
{
  "url": "https://python.langchain.com/docs/how_to/recursive_text_splitter/",
  "markdown": "# giscus\n\n## How to recursively split text by characters\n\nThis [text splitter](https://python.langchain.com/docs/concepts/text_splitters/) is the recommended one for generic text. It is parameterized by a list of characters. It tries to split on them in order until the chunks are small enough. The default list is `[\"\\n\\n\", \"\\n\", \" \", \"\"]`. This has the effect of trying to keep all paragraphs (and then sentences, and then words) together as long as possible, as those would generically seem to be the strongest semantically related pieces of text.\n\n1.  How the text is split: by list of characters.\n2.  How the chunk size is measured: by number of characters.\n\nBelow we show example usage.\n\nTo obtain the string content directly, use `.split_text`.\n\nTo create LangChain [Document](https://python.langchain.com/api_reference/core/documents/langchain_core.documents.base.Document.html) objects (e.g., for use in downstream tasks), use `.create_documents`.\n\n```\n%pip install -qU langchain-text-splitters\n```\n\n```\nfrom langchain_text_splitters import RecursiveCharacterTextSplitter# Load example documentwith open(\"state_of_the_union.txt\") as f:    state_of_the_union = f.read()text_splitter = RecursiveCharacterTextSplitter(    # Set a really small chunk size, just to show.    chunk_size=100,    chunk_overlap=20,    length_function=len,    is_separator_regex=False,)texts = text_splitter.create_documents([state_of_the_union])print(texts[0])print(texts[1])\n```\n\n```\npage_content='Madam Speaker, Madam Vice President, our First Lady and Second Gentleman. Members of Congress and'page_content='of Congress and the Cabinet. Justices of the Supreme Court. My fellow Americans.'\n```\n\n```\ntext_splitter.split_text(state_of_the_union)[:2]\n```\n\n```\n['Madam Speaker, Madam Vice President, our First Lady and Second Gentleman. Members of Congress and', 'of Congress and the Cabinet. Justices of the Supreme Court. My fellow Americans.']\n```\n\nLet's go through the parameters set above for `RecursiveCharacterTextSplitter`:\n\n*   `chunk_size`: The maximum size of a chunk, where size is determined by the `length_function`.\n*   `chunk_overlap`: Target overlap between chunks. Overlapping chunks helps to mitigate loss of information when context is divided between chunks.\n*   `length_function`: Function determining the chunk size.\n*   `is_separator_regex`: Whether the separator list (defaulting to `[\"\\n\\n\", \"\\n\", \" \", \"\"]`) should be interpreted as regex.\n\n## Splitting text from languages without word boundaries[​](#splitting-text-from-languages-without-word-boundaries \"Direct link to Splitting text from languages without word boundaries\")\n\nSome writing systems do not have [word boundaries](https://en.wikipedia.org/wiki/Category:Writing_systems_without_word_boundaries), for example Chinese, Japanese, and Thai. Splitting text with the default separator list of `[\"\\n\\n\", \"\\n\", \" \", \"\"]` can cause words to be split between chunks. To keep words together, you can override the list of separators to include additional punctuation:\n\n*   Add ASCII full-stop \"`.`\", [Unicode fullwidth](https://en.wikipedia.org/wiki/Halfwidth_and_Fullwidth_Forms_\\(Unicode_block\\)) full stop \"`．`\" (used in Chinese text), and [ideographic full stop](https://en.wikipedia.org/wiki/CJK_Symbols_and_Punctuation) \"`。`\" (used in Japanese and Chinese)\n*   Add [Zero-width space](https://en.wikipedia.org/wiki/Zero-width_space) used in Thai, Myanmar, Kmer, and Japanese.\n*   Add ASCII comma \"`,`\", Unicode fullwidth comma \"`，`\", and Unicode ideographic comma \"`、`\"\n\n```\ntext_splitter = RecursiveCharacterTextSplitter(    separators=[        \"\\n\\n\",        \"\\n\",        \" \",        \".\",        \",\",        \"\\u200b\",  # Zero-width space        \"\\uff0c\",  # Fullwidth comma        \"\\u3001\",  # Ideographic comma        \"\\uff0e\",  # Fullwidth full stop        \"\\u3002\",  # Ideographic full stop        \"\",    ],    # Existing args)\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/response_metadata/",
  "markdown": "# giscus\n\n## Response metadata\n\nMany model providers include some metadata in their chat generation [responses](https://python.langchain.com/docs/concepts/messages/#aimessage). This metadata can be accessed via the `AIMessage.response_metadata: Dict` attribute. Depending on the model provider and model configuration, this can contain information like [token counts](https://python.langchain.com/docs/how_to/chat_token_usage_tracking/), [logprobs](https://python.langchain.com/docs/how_to/logprobs/), and more.\n\nHere's what the response metadata looks like for a few different providers:\n\n## OpenAI[​](#openai \"Direct link to OpenAI\")\n\n```\nfrom langchain_openai import ChatOpenAIllm = ChatOpenAI(model=\"gpt-4-turbo\")msg = llm.invoke([(\"human\", \"What's the oldest known example of cuneiform\")])msg.response_metadata\n```\n\n```\n{'token_usage': {'completion_tokens': 164,  'prompt_tokens': 17,  'total_tokens': 181}, 'model_name': 'gpt-4-turbo', 'system_fingerprint': 'fp_76f018034d', 'finish_reason': 'stop', 'logprobs': None}\n```\n\n## Anthropic[​](#anthropic \"Direct link to Anthropic\")\n\n```\nfrom langchain_anthropic import ChatAnthropicllm = ChatAnthropic(model=\"claude-3-sonnet-20240229\")msg = llm.invoke([(\"human\", \"What's the oldest known example of cuneiform\")])msg.response_metadata\n```\n\n```\n{'id': 'msg_01CzQyD7BX8nkhDNfT1QqvEp', 'model': 'claude-3-sonnet-20240229', 'stop_reason': 'end_turn', 'stop_sequence': None, 'usage': {'input_tokens': 17, 'output_tokens': 296}}\n```\n\n## Google VertexAI[​](#google-vertexai \"Direct link to Google VertexAI\")\n\n```\nfrom langchain_google_vertexai import ChatVertexAIllm = ChatVertexAI(model=\"gemini-pro\")msg = llm.invoke([(\"human\", \"What's the oldest known example of cuneiform\")])msg.response_metadata\n```\n\n```\n{'is_blocked': False, 'safety_ratings': [{'category': 'HARM_CATEGORY_HATE_SPEECH',   'probability_label': 'NEGLIGIBLE',   'blocked': False},  {'category': 'HARM_CATEGORY_DANGEROUS_CONTENT',   'probability_label': 'NEGLIGIBLE',   'blocked': False},  {'category': 'HARM_CATEGORY_HARASSMENT',   'probability_label': 'NEGLIGIBLE',   'blocked': False},  {'category': 'HARM_CATEGORY_SEXUALLY_EXPLICIT',   'probability_label': 'NEGLIGIBLE',   'blocked': False}], 'citation_metadata': None, 'usage_metadata': {'prompt_token_count': 10,  'candidates_token_count': 30,  'total_token_count': 40}}\n```\n\n## Bedrock (Anthropic)[​](#bedrock-anthropic \"Direct link to Bedrock (Anthropic)\")\n\n```\nfrom langchain_aws import ChatBedrockllm = ChatBedrock(model_id=\"anthropic.claude-v2\")msg = llm.invoke([(\"human\", \"What's the oldest known example of cuneiform\")])msg.response_metadata\n```\n\n```\n{'model_id': 'anthropic.claude-v2', 'usage': {'prompt_tokens': 19, 'completion_tokens': 371, 'total_tokens': 390}}\n```\n\n## MistralAI[​](#mistralai \"Direct link to MistralAI\")\n\n```\nfrom langchain_mistralai import ChatMistralAIllm = ChatMistralAI()msg = llm.invoke([(\"human\", \"What's the oldest known example of cuneiform\")])msg.response_metadata\n```\n\n```\n{'token_usage': {'prompt_tokens': 19,  'total_tokens': 141,  'completion_tokens': 122}, 'model': 'mistral-small', 'finish_reason': 'stop'}\n```\n\n## Groq[​](#groq \"Direct link to Groq\")\n\n```\nfrom langchain_groq import ChatGroqllm = ChatGroq()msg = llm.invoke([(\"human\", \"What's the oldest known example of cuneiform\")])msg.response_metadata\n```\n\n```\n{'token_usage': {'completion_time': 0.243,  'completion_tokens': 132,  'prompt_time': 0.022,  'prompt_tokens': 22,  'queue_time': None,  'total_time': 0.265,  'total_tokens': 154}, 'model_name': 'mixtral-8x7b-32768', 'system_fingerprint': 'fp_7b44c65f25', 'finish_reason': 'stop', 'logprobs': None}\n```\n\n## TogetherAI[​](#togetherai \"Direct link to TogetherAI\")\n\n```\nimport osfrom langchain_openai import ChatOpenAIllm = ChatOpenAI(    base_url=\"https://api.together.xyz/v1\",    api_key=os.environ[\"TOGETHER_API_KEY\"],    model=\"mistralai/Mixtral-8x7B-Instruct-v0.1\",)msg = llm.invoke([(\"human\", \"What's the oldest known example of cuneiform\")])msg.response_metadata\n```\n\n```\n{'token_usage': {'completion_tokens': 208,  'prompt_tokens': 20,  'total_tokens': 228}, 'model_name': 'mistralai/Mixtral-8x7B-Instruct-v0.1', 'system_fingerprint': None, 'finish_reason': 'eos', 'logprobs': None}\n```\n\n## FireworksAI[​](#fireworksai \"Direct link to FireworksAI\")\n\n```\nfrom langchain_fireworks import ChatFireworksllm = ChatFireworks(model=\"accounts/fireworks/models/mixtral-8x7b-instruct\")msg = llm.invoke([(\"human\", \"What's the oldest known example of cuneiform\")])msg.response_metadata\n```\n\n```\n{'token_usage': {'prompt_tokens': 19,  'total_tokens': 219,  'completion_tokens': 200}, 'model_name': 'accounts/fireworks/models/mixtral-8x7b-instruct', 'system_fingerprint': '', 'finish_reason': 'length', 'logprobs': None}\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/indexing/",
  "markdown": "# giscus\n\n## How to use the LangChain indexing API\n\nHere, we will look at a basic indexing workflow using the LangChain indexing API.\n\nThe indexing API lets you load and keep in sync documents from any source into a [vector store](https://python.langchain.com/docs/concepts/vectorstores/). Specifically, it helps:\n\n*   Avoid writing duplicated content into the vector store\n*   Avoid re-writing unchanged content\n*   Avoid re-computing embeddings over unchanged content\n\nAll of which should save you time and money, as well as improve your vector search results.\n\nCrucially, the indexing API will work even with documents that have gone through several transformation steps (e.g., via text chunking) with respect to the original source documents.\n\n## How it works[​](#how-it-works \"Direct link to How it works\")\n\nLangChain indexing makes use of a record manager (`RecordManager`) that keeps track of document writes into the vector store.\n\nWhen indexing content, hashes are computed for each document, and the following information is stored in the record manager:\n\n*   the document hash (hash of both page content and metadata)\n*   write time\n*   the source id -- each document should include information in its metadata to allow us to determine the ultimate source of this document\n\n## Deletion modes[​](#deletion-modes \"Direct link to Deletion modes\")\n\nWhen indexing documents into a vector store, it's possible that some existing documents in the vector store should be deleted. In certain situations you may want to remove any existing documents that are derived from the same sources as the new documents being indexed. In others you may want to delete all existing documents wholesale. The indexing API deletion modes let you pick the behavior you want:\n\n| Cleanup Mode | De-Duplicates Content | Parallelizable | Cleans Up Deleted Source Docs | Cleans Up Mutations of Source Docs and/or Derived Docs | Clean Up Timing |\n| --- | --- | --- | --- | --- | --- |\n| None | ✅   | ✅   | ❌   | ❌   | \\-  |\n| Incremental | ✅   | ✅   | ❌   | ✅   | Continuously |\n| Full | ✅   | ❌   | ✅   | ✅   | At end of indexing |\n| Scoped\\_Full | ✅   | ✅   | ❌   | ✅   | At end of indexing |\n\n`None` does not do any automatic clean up, allowing the user to manually do clean up of old content.\n\n`incremental`, `full` and `scoped_full` offer the following automated clean up:\n\n*   If the content of the source document or derived documents has **changed**, all 3 modes will clean up (delete) previous versions of the content.\n*   If the source document has been **deleted** (meaning it is not included in the documents currently being indexed), the `full` cleanup mode will delete it from the vector store correctly, but the `incremental` and `scoped_full` mode will not.\n\nWhen content is mutated (e.g., the source PDF file was revised) there will be a period of time during indexing when both the new and old versions may be returned to the user. This happens after the new content was written, but before the old version was deleted.\n\n*   `incremental` indexing minimizes this period of time as it is able to do clean up continuously, as it writes.\n*   `full` and `scoped_full` mode does the clean up after all batches have been written.\n\n## Requirements[​](#requirements \"Direct link to Requirements\")\n\n1.  Do not use with a store that has been pre-populated with content independently of the indexing API, as the record manager will not know that records have been inserted previously.\n2.  Only works with LangChain `vectorstore`'s that support:\n    *   document addition by id (`add_documents` method with `ids` argument)\n    *   delete by id (`delete` method with `ids` argument)\n\nCompatible Vectorstores: `Aerospike`, `AnalyticDB`, `AstraDB`, `AwaDB`, `AzureCosmosDBNoSqlVectorSearch`, `AzureCosmosDBVectorSearch`, `Bagel`, `Cassandra`, `Chroma`, `CouchbaseVectorStore`, `DashVector`, `DatabricksVectorSearch`, `DeepLake`, `Dingo`, `ElasticVectorSearch`, `ElasticsearchStore`, `FAISS`, `HanaDB`, `Milvus`, `MongoDBAtlasVectorSearch`, `MyScale`, `OpenSearchVectorSearch`, `PGVector`, `Pinecone`, `Qdrant`, `Redis`, `Rockset`, `ScaNN`, `SingleStoreDB`, `SupabaseVectorStore`, `SurrealDBStore`, `TimescaleVector`, `Vald`, `VDMS`, `Vearch`, `VespaStore`, `Weaviate`, `Yellowbrick`, `ZepVectorStore`, `TencentVectorDB`, `OpenSearchVectorSearch`.\n\n## Caution[​](#caution \"Direct link to Caution\")\n\nThe record manager relies on a time-based mechanism to determine what content can be cleaned up (when using `full` or `incremental` or `scoped_full` cleanup modes).\n\nIf two tasks run back-to-back, and the first task finishes before the clock time changes, then the second task may not be able to clean up content.\n\nThis is unlikely to be an issue in actual settings for the following reasons:\n\n1.  The RecordManager uses higher resolution timestamps.\n2.  The data would need to change between the first and the second tasks runs, which becomes unlikely if the time interval between the tasks is small.\n3.  Indexing tasks typically take more than a few ms.\n\n## Quickstart[​](#quickstart \"Direct link to Quickstart\")\n\n```\nfrom langchain.indexes import SQLRecordManager, indexfrom langchain_core.documents import Documentfrom langchain_elasticsearch import ElasticsearchStorefrom langchain_openai import OpenAIEmbeddings\n```\n\nInitialize a vector store and set up the embeddings:\n\n```\ncollection_name = \"test_index\"embedding = OpenAIEmbeddings()vectorstore = ElasticsearchStore(    es_url=\"http://localhost:9200\", index_name=\"test_index\", embedding=embedding)\n```\n\nInitialize a record manager with an appropriate namespace.\n\n**Suggestion:** Use a namespace that takes into account both the vector store and the collection name in the vector store; e.g., 'redis/my\\_docs', 'chromadb/my\\_docs' or 'postgres/my\\_docs'.\n\n```\nnamespace = f\"elasticsearch/{collection_name}\"record_manager = SQLRecordManager(    namespace, db_url=\"sqlite:///record_manager_cache.sql\")\n```\n\nCreate a schema before using the record manager.\n\n```\nrecord_manager.create_schema()\n```\n\nLet's index some test documents:\n\n```\ndoc1 = Document(page_content=\"kitty\", metadata={\"source\": \"kitty.txt\"})doc2 = Document(page_content=\"doggy\", metadata={\"source\": \"doggy.txt\"})\n```\n\nIndexing into an empty vector store:\n\n```\ndef _clear():    \"\"\"Hacky helper method to clear content. See the `full` mode section to to understand why it works.\"\"\"    index([], record_manager, vectorstore, cleanup=\"full\", source_id_key=\"source\")\n```\n\n### `None` deletion mode[​](#none-deletion-mode \"Direct link to none-deletion-mode\")\n\nThis mode does not do automatic clean up of old versions of content; however, it still takes care of content de-duplication.\n\n```\nindex(    [doc1, doc1, doc1, doc1, doc1],    record_manager,    vectorstore,    cleanup=None,    source_id_key=\"source\",)\n```\n\n```\n{'num_added': 1, 'num_updated': 0, 'num_skipped': 0, 'num_deleted': 0}\n```\n\n```\nindex([doc1, doc2], record_manager, vectorstore, cleanup=None, source_id_key=\"source\")\n```\n\n```\n{'num_added': 2, 'num_updated': 0, 'num_skipped': 0, 'num_deleted': 0}\n```\n\nSecond time around all content will be skipped:\n\n```\nindex([doc1, doc2], record_manager, vectorstore, cleanup=None, source_id_key=\"source\")\n```\n\n```\n{'num_added': 0, 'num_updated': 0, 'num_skipped': 2, 'num_deleted': 0}\n```\n\n### `\"incremental\"` deletion mode[​](#incremental-deletion-mode \"Direct link to incremental-deletion-mode\")\n\n```\nindex(    [doc1, doc2],    record_manager,    vectorstore,    cleanup=\"incremental\",    source_id_key=\"source\",)\n```\n\n```\n{'num_added': 2, 'num_updated': 0, 'num_skipped': 0, 'num_deleted': 0}\n```\n\nIndexing again should result in both documents getting **skipped** -- also skipping the embedding operation!\n\n```\nindex(    [doc1, doc2],    record_manager,    vectorstore,    cleanup=\"incremental\",    source_id_key=\"source\",)\n```\n\n```\n{'num_added': 0, 'num_updated': 0, 'num_skipped': 2, 'num_deleted': 0}\n```\n\nIf we provide no documents with incremental indexing mode, nothing will change.\n\n```\nindex([], record_manager, vectorstore, cleanup=\"incremental\", source_id_key=\"source\")\n```\n\n```\n{'num_added': 0, 'num_updated': 0, 'num_skipped': 0, 'num_deleted': 0}\n```\n\nIf we mutate a document, the new version will be written and all old versions sharing the same source will be deleted.\n\n```\nchanged_doc_2 = Document(page_content=\"puppy\", metadata={\"source\": \"doggy.txt\"})\n```\n\n```\nindex(    [changed_doc_2],    record_manager,    vectorstore,    cleanup=\"incremental\",    source_id_key=\"source\",)\n```\n\n```\n{'num_added': 1, 'num_updated': 0, 'num_skipped': 0, 'num_deleted': 1}\n```\n\n### `\"full\"` deletion mode[​](#full-deletion-mode \"Direct link to full-deletion-mode\")\n\nIn `full` mode the user should pass the `full` universe of content that should be indexed into the indexing function.\n\nAny documents that are not passed into the indexing function and are present in the vectorstore will be deleted!\n\nThis behavior is useful to handle deletions of source documents.\n\n```\nindex(all_docs, record_manager, vectorstore, cleanup=\"full\", source_id_key=\"source\")\n```\n\n```\n{'num_added': 2, 'num_updated': 0, 'num_skipped': 0, 'num_deleted': 0}\n```\n\nSay someone deleted the first doc:\n\n```\n[Document(page_content='doggy', metadata={'source': 'doggy.txt'})]\n```\n\nUsing full mode will clean up the deleted content as well.\n\n```\nindex(all_docs, record_manager, vectorstore, cleanup=\"full\", source_id_key=\"source\")\n```\n\n```\n{'num_added': 0, 'num_updated': 0, 'num_skipped': 1, 'num_deleted': 1}\n```\n\n## Source[​](#source \"Direct link to Source\")\n\nThe metadata attribute contains a field called `source`. This source should be pointing at the _ultimate_ provenance associated with the given document.\n\nFor example, if these documents are representing chunks of some parent document, the `source` for both documents should be the same and reference the parent document.\n\nIn general, `source` should always be specified. Only use a `None`, if you **never** intend to use `incremental` mode, and for some reason can't specify the `source` field correctly.\n\n```\nfrom langchain_text_splitters import CharacterTextSplitter\n```\n\n```\ndoc1 = Document(    page_content=\"kitty kitty kitty kitty kitty\", metadata={\"source\": \"kitty.txt\"})doc2 = Document(page_content=\"doggy doggy the doggy\", metadata={\"source\": \"doggy.txt\"})\n```\n\n```\nnew_docs = CharacterTextSplitter(    separator=\"t\", keep_separator=True, chunk_size=12, chunk_overlap=2).split_documents([doc1, doc2])new_docs\n```\n\n```\n[Document(page_content='kitty kit', metadata={'source': 'kitty.txt'}), Document(page_content='tty kitty ki', metadata={'source': 'kitty.txt'}), Document(page_content='tty kitty', metadata={'source': 'kitty.txt'}), Document(page_content='doggy doggy', metadata={'source': 'doggy.txt'}), Document(page_content='the doggy', metadata={'source': 'doggy.txt'})]\n```\n\n```\nindex(    new_docs,    record_manager,    vectorstore,    cleanup=\"incremental\",    source_id_key=\"source\",)\n```\n\n```\n{'num_added': 5, 'num_updated': 0, 'num_skipped': 0, 'num_deleted': 0}\n```\n\n```\nchanged_doggy_docs = [    Document(page_content=\"woof woof\", metadata={\"source\": \"doggy.txt\"}),    Document(page_content=\"woof woof woof\", metadata={\"source\": \"doggy.txt\"}),]\n```\n\nThis should delete the old versions of documents associated with `doggy.txt` source and replace them with the new versions.\n\n```\nindex(    changed_doggy_docs,    record_manager,    vectorstore,    cleanup=\"incremental\",    source_id_key=\"source\",)\n```\n\n```\n{'num_added': 2, 'num_updated': 0, 'num_skipped': 0, 'num_deleted': 2}\n```\n\n```\nvectorstore.similarity_search(\"dog\", k=30)\n```\n\n```\n[Document(page_content='woof woof', metadata={'source': 'doggy.txt'}), Document(page_content='woof woof woof', metadata={'source': 'doggy.txt'}), Document(page_content='tty kitty', metadata={'source': 'kitty.txt'}), Document(page_content='tty kitty ki', metadata={'source': 'kitty.txt'}), Document(page_content='kitty kit', metadata={'source': 'kitty.txt'})]\n```\n\n## Using with loaders[​](#using-with-loaders \"Direct link to Using with loaders\")\n\nIndexing can accept either an iterable of documents or else any loader.\n\n**Attention:** The loader **must** set source keys correctly.\n\n```\nfrom langchain_core.document_loaders import BaseLoaderclass MyCustomLoader(BaseLoader):    def lazy_load(self):        text_splitter = CharacterTextSplitter(            separator=\"t\", keep_separator=True, chunk_size=12, chunk_overlap=2        )        docs = [            Document(page_content=\"woof woof\", metadata={\"source\": \"doggy.txt\"}),            Document(page_content=\"woof woof woof\", metadata={\"source\": \"doggy.txt\"}),        ]        yield from text_splitter.split_documents(docs)    def load(self):        return list(self.lazy_load())\n```\n\n```\nloader = MyCustomLoader()\n```\n\n```\n[Document(page_content='woof woof', metadata={'source': 'doggy.txt'}), Document(page_content='woof woof woof', metadata={'source': 'doggy.txt'})]\n```\n\n```\nindex(loader, record_manager, vectorstore, cleanup=\"full\", source_id_key=\"source\")\n```\n\n```\n{'num_added': 2, 'num_updated': 0, 'num_skipped': 0, 'num_deleted': 0}\n```\n\n```\nvectorstore.similarity_search(\"dog\", k=30)\n```\n\n```\n[Document(page_content='woof woof', metadata={'source': 'doggy.txt'}), Document(page_content='woof woof woof', metadata={'source': 'doggy.txt'})]\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/document_loader_json/",
  "markdown": "# giscus\n\n## How to load JSON\n\n[JSON (JavaScript Object Notation)](https://en.wikipedia.org/wiki/JSON) is an open standard file format and data interchange format that uses human-readable text to store and transmit data objects consisting of attribute–value pairs and arrays (or other serializable values).\n\n[JSON Lines](https://jsonlines.org/) is a file format where each line is a valid JSON value.\n\nLangChain implements a [JSONLoader](https://python.langchain.com/api_reference/community/document_loaders/langchain_community.document_loaders.json_loader.JSONLoader.html) to convert JSON and JSONL data into LangChain [Document](https://python.langchain.com/api_reference/core/documents/langchain_core.documents.base.Document.html#langchain_core.documents.base.Document) objects. It uses a specified [jq schema](https://en.wikipedia.org/wiki/Jq_\\(programming_language\\)) to parse the JSON files, allowing for the extraction of specific fields into the content and metadata of the LangChain Document.\n\nIt uses the `jq` python package. Check out this [manual](https://stedolan.github.io/jq/manual/#Basicfilters) for a detailed documentation of the `jq` syntax.\n\nHere we will demonstrate:\n\n*   How to load JSON and JSONL data into the content of a LangChain `Document`;\n*   How to load JSON and JSONL data into metadata associated with a `Document`.\n\n```\nfrom langchain_community.document_loaders import JSONLoader\n```\n\n```\nimport jsonfrom pathlib import Pathfrom pprint import pprintfile_path='./example_data/facebook_chat.json'data = json.loads(Path(file_path).read_text())\n```\n\n```\n    {'image': {'creation_timestamp': 1675549016, 'uri': 'image_of_the_chat.jpg'},     'is_still_participant': True,     'joinable_mode': {'link': '', 'mode': 1},     'magic_words': [],     'messages': [{'content': 'Bye!',                   'sender_name': 'User 2',                   'timestamp_ms': 1675597571851},                  {'content': 'Oh no worries! Bye',                   'sender_name': 'User 1',                   'timestamp_ms': 1675597435669},                  {'content': 'No Im sorry it was my mistake, the blue one is not '                              'for sale',                   'sender_name': 'User 2',                   'timestamp_ms': 1675596277579},                  {'content': 'I thought you were selling the blue one!',                   'sender_name': 'User 1',                   'timestamp_ms': 1675595140251},                  {'content': 'Im not interested in this bag. Im interested in the '                              'blue one!',                   'sender_name': 'User 1',                   'timestamp_ms': 1675595109305},                  {'content': 'Here is $129',                   'sender_name': 'User 2',                   'timestamp_ms': 1675595068468},                  {'photos': [{'creation_timestamp': 1675595059,                               'uri': 'url_of_some_picture.jpg'}],                   'sender_name': 'User 2',                   'timestamp_ms': 1675595060730},                  {'content': 'Online is at least $100',                   'sender_name': 'User 2',                   'timestamp_ms': 1675595045152},                  {'content': 'How much do you want?',                   'sender_name': 'User 1',                   'timestamp_ms': 1675594799696},                  {'content': 'Goodmorning! $50 is too low.',                   'sender_name': 'User 2',                   'timestamp_ms': 1675577876645},                  {'content': 'Hi! Im interested in your bag. Im offering $50. Let '                              'me know if you are interested. Thanks!',                   'sender_name': 'User 1',                   'timestamp_ms': 1675549022673}],     'participants': [{'name': 'User 1'}, {'name': 'User 2'}],     'thread_path': 'inbox/User 1 and User 2 chat',     'title': 'User 1 and User 2 chat'}\n```\n\n## Using `JSONLoader`[​](#using-jsonloader \"Direct link to using-jsonloader\")\n\nSuppose we are interested in extracting the values under the `content` field within the `messages` key of the JSON data. This can easily be done through the `JSONLoader` as shown below.\n\n### JSON file[​](#json-file \"Direct link to JSON file\")\n\n```\nloader = JSONLoader(    file_path='./example_data/facebook_chat.json',    jq_schema='.messages[].content',    text_content=False)data = loader.load()\n```\n\n```\n    [Document(page_content='Bye!', metadata={'source': '/Users/avsolatorio/WBG/langchain/docs/modules/indexes/document_loaders/examples/example_data/facebook_chat.json', 'seq_num': 1}),     Document(page_content='Oh no worries! Bye', metadata={'source': '/Users/avsolatorio/WBG/langchain/docs/modules/indexes/document_loaders/examples/example_data/facebook_chat.json', 'seq_num': 2}),     Document(page_content='No Im sorry it was my mistake, the blue one is not for sale', metadata={'source': '/Users/avsolatorio/WBG/langchain/docs/modules/indexes/document_loaders/examples/example_data/facebook_chat.json', 'seq_num': 3}),     Document(page_content='I thought you were selling the blue one!', metadata={'source': '/Users/avsolatorio/WBG/langchain/docs/modules/indexes/document_loaders/examples/example_data/facebook_chat.json', 'seq_num': 4}),     Document(page_content='Im not interested in this bag. Im interested in the blue one!', metadata={'source': '/Users/avsolatorio/WBG/langchain/docs/modules/indexes/document_loaders/examples/example_data/facebook_chat.json', 'seq_num': 5}),     Document(page_content='Here is $129', metadata={'source': '/Users/avsolatorio/WBG/langchain/docs/modules/indexes/document_loaders/examples/example_data/facebook_chat.json', 'seq_num': 6}),     Document(page_content='', metadata={'source': '/Users/avsolatorio/WBG/langchain/docs/modules/indexes/document_loaders/examples/example_data/facebook_chat.json', 'seq_num': 7}),     Document(page_content='Online is at least $100', metadata={'source': '/Users/avsolatorio/WBG/langchain/docs/modules/indexes/document_loaders/examples/example_data/facebook_chat.json', 'seq_num': 8}),     Document(page_content='How much do you want?', metadata={'source': '/Users/avsolatorio/WBG/langchain/docs/modules/indexes/document_loaders/examples/example_data/facebook_chat.json', 'seq_num': 9}),     Document(page_content='Goodmorning! $50 is too low.', metadata={'source': '/Users/avsolatorio/WBG/langchain/docs/modules/indexes/document_loaders/examples/example_data/facebook_chat.json', 'seq_num': 10}),     Document(page_content='Hi! Im interested in your bag. Im offering $50. Let me know if you are interested. Thanks!', metadata={'source': '/Users/avsolatorio/WBG/langchain/docs/modules/indexes/document_loaders/examples/example_data/facebook_chat.json', 'seq_num': 11})]\n```\n\n### JSON Lines file[​](#json-lines-file \"Direct link to JSON Lines file\")\n\nIf you want to load documents from a JSON Lines file, you pass `json_lines=True` and specify `jq_schema` to extract `page_content` from a single JSON object.\n\n```\nfile_path = './example_data/facebook_chat_messages.jsonl'pprint(Path(file_path).read_text())\n```\n\n```\n    ('{\"sender_name\": \"User 2\", \"timestamp_ms\": 1675597571851, \"content\": \"Bye!\"}\\n'     '{\"sender_name\": \"User 1\", \"timestamp_ms\": 1675597435669, \"content\": \"Oh no '     'worries! Bye\"}\\n'     '{\"sender_name\": \"User 2\", \"timestamp_ms\": 1675596277579, \"content\": \"No Im '     'sorry it was my mistake, the blue one is not for sale\"}\\n')\n```\n\n```\nloader = JSONLoader(    file_path='./example_data/facebook_chat_messages.jsonl',    jq_schema='.content',    text_content=False,    json_lines=True)data = loader.load()\n```\n\n```\n    [Document(page_content='Bye!', metadata={'source': 'langchain/docs/modules/indexes/document_loaders/examples/example_data/facebook_chat_messages.jsonl', 'seq_num': 1}),     Document(page_content='Oh no worries! Bye', metadata={'source': 'langchain/docs/modules/indexes/document_loaders/examples/example_data/facebook_chat_messages.jsonl', 'seq_num': 2}),     Document(page_content='No Im sorry it was my mistake, the blue one is not for sale', metadata={'source': 'langchain/docs/modules/indexes/document_loaders/examples/example_data/facebook_chat_messages.jsonl', 'seq_num': 3})]\n```\n\nAnother option is to set `jq_schema='.'` and provide `content_key`:\n\n```\nloader = JSONLoader(    file_path='./example_data/facebook_chat_messages.jsonl',    jq_schema='.',    content_key='sender_name',    json_lines=True)data = loader.load()\n```\n\n```\n    [Document(page_content='User 2', metadata={'source': 'langchain/docs/modules/indexes/document_loaders/examples/example_data/facebook_chat_messages.jsonl', 'seq_num': 1}),     Document(page_content='User 1', metadata={'source': 'langchain/docs/modules/indexes/document_loaders/examples/example_data/facebook_chat_messages.jsonl', 'seq_num': 2}),     Document(page_content='User 2', metadata={'source': 'langchain/docs/modules/indexes/document_loaders/examples/example_data/facebook_chat_messages.jsonl', 'seq_num': 3})]\n```\n\n### JSON file with jq schema `content_key`[​](#json-file-with-jq-schema-content_key \"Direct link to json-file-with-jq-schema-content_key\")\n\nTo load documents from a JSON file using the content\\_key within the jq schema, set is\\_content\\_key\\_jq\\_parsable=True. Ensure that content\\_key is compatible and can be parsed using the jq schema.\n\n```\nfile_path = './sample.json'pprint(Path(file_path).read_text())\n```\n\n```\n    {\"data\": [        {\"attributes\": {            \"message\": \"message1\",            \"tags\": [            \"tag1\"]},        \"id\": \"1\"},        {\"attributes\": {            \"message\": \"message2\",            \"tags\": [            \"tag2\"]},        \"id\": \"2\"}]}\n```\n\n```\nloader = JSONLoader(    file_path=file_path,    jq_schema=\".data[]\",    content_key=\".attributes.message\",    is_content_key_jq_parsable=True,)data = loader.load()\n```\n\n```\n    [Document(page_content='message1', metadata={'source': '/path/to/sample.json', 'seq_num': 1}),     Document(page_content='message2', metadata={'source': '/path/to/sample.json', 'seq_num': 2})]\n```\n\nGenerally, we want to include metadata available in the JSON file into the documents that we create from the content.\n\nThe following demonstrates how metadata can be extracted using the `JSONLoader`.\n\nThere are some key changes to be noted. In the previous example where we didn't collect the metadata, we managed to directly specify in the schema where the value for the `page_content` can be extracted from.\n\nIn the current example, we have to tell the loader to iterate over the records in the `messages` field. The jq\\_schema then has to be:\n\nThis allows us to pass the records (dict) into the `metadata_func` that has to be implemented. The `metadata_func` is responsible for identifying which pieces of information in the record should be included in the metadata stored in the final `Document` object.\n\nAdditionally, we now have to explicitly specify in the loader, via the `content_key` argument, the key from the record where the value for the `page_content` needs to be extracted from.\n\n```\n# Define the metadata extraction function.def metadata_func(record: dict, metadata: dict) -> dict:    metadata[\"sender_name\"] = record.get(\"sender_name\")    metadata[\"timestamp_ms\"] = record.get(\"timestamp_ms\")    return metadataloader = JSONLoader(    file_path='./example_data/facebook_chat.json',    jq_schema='.messages[]',    content_key=\"content\",    metadata_func=metadata_func)data = loader.load()\n```\n\n```\n    [Document(page_content='Bye!', metadata={'source': '/Users/avsolatorio/WBG/langchain/docs/modules/indexes/document_loaders/examples/example_data/facebook_chat.json', 'seq_num': 1, 'sender_name': 'User 2', 'timestamp_ms': 1675597571851}),     Document(page_content='Oh no worries! Bye', metadata={'source': '/Users/avsolatorio/WBG/langchain/docs/modules/indexes/document_loaders/examples/example_data/facebook_chat.json', 'seq_num': 2, 'sender_name': 'User 1', 'timestamp_ms': 1675597435669}),     Document(page_content='No Im sorry it was my mistake, the blue one is not for sale', metadata={'source': '/Users/avsolatorio/WBG/langchain/docs/modules/indexes/document_loaders/examples/example_data/facebook_chat.json', 'seq_num': 3, 'sender_name': 'User 2', 'timestamp_ms': 1675596277579}),     Document(page_content='I thought you were selling the blue one!', metadata={'source': '/Users/avsolatorio/WBG/langchain/docs/modules/indexes/document_loaders/examples/example_data/facebook_chat.json', 'seq_num': 4, 'sender_name': 'User 1', 'timestamp_ms': 1675595140251}),     Document(page_content='Im not interested in this bag. Im interested in the blue one!', metadata={'source': '/Users/avsolatorio/WBG/langchain/docs/modules/indexes/document_loaders/examples/example_data/facebook_chat.json', 'seq_num': 5, 'sender_name': 'User 1', 'timestamp_ms': 1675595109305}),     Document(page_content='Here is $129', metadata={'source': '/Users/avsolatorio/WBG/langchain/docs/modules/indexes/document_loaders/examples/example_data/facebook_chat.json', 'seq_num': 6, 'sender_name': 'User 2', 'timestamp_ms': 1675595068468}),     Document(page_content='', metadata={'source': '/Users/avsolatorio/WBG/langchain/docs/modules/indexes/document_loaders/examples/example_data/facebook_chat.json', 'seq_num': 7, 'sender_name': 'User 2', 'timestamp_ms': 1675595060730}),     Document(page_content='Online is at least $100', metadata={'source': '/Users/avsolatorio/WBG/langchain/docs/modules/indexes/document_loaders/examples/example_data/facebook_chat.json', 'seq_num': 8, 'sender_name': 'User 2', 'timestamp_ms': 1675595045152}),     Document(page_content='How much do you want?', metadata={'source': '/Users/avsolatorio/WBG/langchain/docs/modules/indexes/document_loaders/examples/example_data/facebook_chat.json', 'seq_num': 9, 'sender_name': 'User 1', 'timestamp_ms': 1675594799696}),     Document(page_content='Goodmorning! $50 is too low.', metadata={'source': '/Users/avsolatorio/WBG/langchain/docs/modules/indexes/document_loaders/examples/example_data/facebook_chat.json', 'seq_num': 10, 'sender_name': 'User 2', 'timestamp_ms': 1675577876645}),     Document(page_content='Hi! Im interested in your bag. Im offering $50. Let me know if you are interested. Thanks!', metadata={'source': '/Users/avsolatorio/WBG/langchain/docs/modules/indexes/document_loaders/examples/example_data/facebook_chat.json', 'seq_num': 11, 'sender_name': 'User 1', 'timestamp_ms': 1675549022673})]\n```\n\nNow, you will see that the documents contain the metadata associated with the content we extracted.\n\nAs shown above, the `metadata_func` accepts the default metadata generated by the `JSONLoader`. This allows full control to the user with respect to how the metadata is formatted.\n\nFor example, the default metadata contains the `source` and the `seq_num` keys. However, it is possible that the JSON data contain these keys as well. The user can then exploit the `metadata_func` to rename the default keys and use the ones from the JSON data.\n\nThe example below shows how we can modify the `source` to only contain information of the file source relative to the `langchain` directory.\n\n```\n# Define the metadata extraction function.def metadata_func(record: dict, metadata: dict) -> dict:    metadata[\"sender_name\"] = record.get(\"sender_name\")    metadata[\"timestamp_ms\"] = record.get(\"timestamp_ms\")    if \"source\" in metadata:        source = metadata[\"source\"].split(\"/\")        source = source[source.index(\"langchain\"):]        metadata[\"source\"] = \"/\".join(source)    return metadataloader = JSONLoader(    file_path='./example_data/facebook_chat.json',    jq_schema='.messages[]',    content_key=\"content\",    metadata_func=metadata_func)data = loader.load()\n```\n\n```\n    [Document(page_content='Bye!', metadata={'source': 'langchain/docs/modules/indexes/document_loaders/examples/example_data/facebook_chat.json', 'seq_num': 1, 'sender_name': 'User 2', 'timestamp_ms': 1675597571851}),     Document(page_content='Oh no worries! Bye', metadata={'source': 'langchain/docs/modules/indexes/document_loaders/examples/example_data/facebook_chat.json', 'seq_num': 2, 'sender_name': 'User 1', 'timestamp_ms': 1675597435669}),     Document(page_content='No Im sorry it was my mistake, the blue one is not for sale', metadata={'source': 'langchain/docs/modules/indexes/document_loaders/examples/example_data/facebook_chat.json', 'seq_num': 3, 'sender_name': 'User 2', 'timestamp_ms': 1675596277579}),     Document(page_content='I thought you were selling the blue one!', metadata={'source': 'langchain/docs/modules/indexes/document_loaders/examples/example_data/facebook_chat.json', 'seq_num': 4, 'sender_name': 'User 1', 'timestamp_ms': 1675595140251}),     Document(page_content='Im not interested in this bag. Im interested in the blue one!', metadata={'source': 'langchain/docs/modules/indexes/document_loaders/examples/example_data/facebook_chat.json', 'seq_num': 5, 'sender_name': 'User 1', 'timestamp_ms': 1675595109305}),     Document(page_content='Here is $129', metadata={'source': 'langchain/docs/modules/indexes/document_loaders/examples/example_data/facebook_chat.json', 'seq_num': 6, 'sender_name': 'User 2', 'timestamp_ms': 1675595068468}),     Document(page_content='', metadata={'source': 'langchain/docs/modules/indexes/document_loaders/examples/example_data/facebook_chat.json', 'seq_num': 7, 'sender_name': 'User 2', 'timestamp_ms': 1675595060730}),     Document(page_content='Online is at least $100', metadata={'source': 'langchain/docs/modules/indexes/document_loaders/examples/example_data/facebook_chat.json', 'seq_num': 8, 'sender_name': 'User 2', 'timestamp_ms': 1675595045152}),     Document(page_content='How much do you want?', metadata={'source': 'langchain/docs/modules/indexes/document_loaders/examples/example_data/facebook_chat.json', 'seq_num': 9, 'sender_name': 'User 1', 'timestamp_ms': 1675594799696}),     Document(page_content='Goodmorning! $50 is too low.', metadata={'source': 'langchain/docs/modules/indexes/document_loaders/examples/example_data/facebook_chat.json', 'seq_num': 10, 'sender_name': 'User 2', 'timestamp_ms': 1675577876645}),     Document(page_content='Hi! Im interested in your bag. Im offering $50. Let me know if you are interested. Thanks!', metadata={'source': 'langchain/docs/modules/indexes/document_loaders/examples/example_data/facebook_chat.json', 'seq_num': 11, 'sender_name': 'User 1', 'timestamp_ms': 1675549022673})]\n```\n\n## Common JSON structures with jq schema[​](#common-json-structures-with-jq-schema \"Direct link to Common JSON structures with jq schema\")\n\nThe list below provides a reference to the possible `jq_schema` the user can use to extract content from the JSON data depending on the structure.\n\n```\nJSON        -> [{\"text\": ...}, {\"text\": ...}, {\"text\": ...}]jq_schema   -> \".[].text\"JSON        -> {\"key\": [{\"text\": ...}, {\"text\": ...}, {\"text\": ...}]}jq_schema   -> \".key[].text\"JSON        -> [\"...\", \"...\", \"...\"]jq_schema   -> \".[]\"\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/binding/",
  "markdown": "# giscus\n\n## How to add default invocation args to a Runnable\n\nSometimes we want to invoke a [`Runnable`](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html) within a [RunnableSequence](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.RunnableSequence.html) with constant arguments that are not part of the output of the preceding Runnable in the sequence, and which are not part of the user input. We can use the [`Runnable.bind()`](https://python.langchain.com/api_reference/langchain_core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.bind) method to set these arguments ahead of time.\n\n## Binding stop sequences[​](#binding-stop-sequences \"Direct link to Binding stop sequences\")\n\nSuppose we have a simple prompt + model chain:\n\n```\nfrom langchain_core.output_parsers import StrOutputParserfrom langchain_core.prompts import ChatPromptTemplatefrom langchain_core.runnables import RunnablePassthroughfrom langchain_openai import ChatOpenAIprompt = ChatPromptTemplate.from_messages(    [        (            \"system\",            \"Write out the following equation using algebraic symbols then solve it. Use the format\\n\\nEQUATION:...\\nSOLUTION:...\\n\\n\",        ),        (\"human\", \"{equation_statement}\"),    ])model = ChatOpenAI(temperature=0)runnable = (    {\"equation_statement\": RunnablePassthrough()} | prompt | model | StrOutputParser())print(runnable.invoke(\"x raised to the third plus seven equals 12\"))\n```\n\n```\nEQUATION: x^3 + 7 = 12SOLUTION: Subtract 7 from both sides:x^3 = 5Take the cube root of both sides:x = ∛5\n```\n\nand want to call the model with certain `stop` words so that we shorten the output as is useful in certain types of prompting techniques. While we can pass some arguments into the constructor, other runtime args use the `.bind()` method as follows:\n\n```\nrunnable = (    {\"equation_statement\": RunnablePassthrough()}    | prompt    | model.bind(stop=\"SOLUTION\")    | StrOutputParser())print(runnable.invoke(\"x raised to the third plus seven equals 12\"))\n```\n\nWhat you can bind to a Runnable will depend on the extra parameters you can pass when invoking it.\n\nAnother common use-case is tool calling. While you should generally use the [`.bind_tools()`](https://python.langchain.com/docs/how_to/tool_calling/) method for tool-calling models, you can also bind provider-specific args directly if you want lower level control:\n\n```\ntools = [    {        \"type\": \"function\",        \"function\": {            \"name\": \"get_current_weather\",            \"description\": \"Get the current weather in a given location\",            \"parameters\": {                \"type\": \"object\",                \"properties\": {                    \"location\": {                        \"type\": \"string\",                        \"description\": \"The city and state, e.g. San Francisco, CA\",                    },                    \"unit\": {\"type\": \"string\", \"enum\": [\"celsius\", \"fahrenheit\"]},                },                \"required\": [\"location\"],            },        },    }]\n```\n\n```\nmodel = ChatOpenAI(model=\"gpt-4o-mini\").bind(tools=tools)model.invoke(\"What's the weather in SF, NYC and LA?\")\n```\n\n```\nAIMessage(content='', additional_kwargs={'tool_calls': [{'id': 'call_z0OU2CytqENVrRTI6T8DkI3u', 'function': {'arguments': '{\"location\": \"San Francisco, CA\", \"unit\": \"celsius\"}', 'name': 'get_current_weather'}, 'type': 'function'}, {'id': 'call_ft96IJBh0cMKkQWrZjNg4bsw', 'function': {'arguments': '{\"location\": \"New York, NY\", \"unit\": \"celsius\"}', 'name': 'get_current_weather'}, 'type': 'function'}, {'id': 'call_tfbtGgCLmuBuWgZLvpPwvUMH', 'function': {'arguments': '{\"location\": \"Los Angeles, CA\", \"unit\": \"celsius\"}', 'name': 'get_current_weather'}, 'type': 'function'}]}, response_metadata={'token_usage': {'completion_tokens': 84, 'prompt_tokens': 85, 'total_tokens': 169}, 'model_name': 'gpt-4o-mini', 'system_fingerprint': 'fp_77a673219d', 'finish_reason': 'tool_calls', 'logprobs': None}, id='run-d57ad5fa-b52a-4822-bc3e-74f838697e18-0', tool_calls=[{'name': 'get_current_weather', 'args': {'location': 'San Francisco, CA', 'unit': 'celsius'}, 'id': 'call_z0OU2CytqENVrRTI6T8DkI3u'}, {'name': 'get_current_weather', 'args': {'location': 'New York, NY', 'unit': 'celsius'}, 'id': 'call_ft96IJBh0cMKkQWrZjNg4bsw'}, {'name': 'get_current_weather', 'args': {'location': 'Los Angeles, CA', 'unit': 'celsius'}, 'id': 'call_tfbtGgCLmuBuWgZLvpPwvUMH'}])\n```\n\n## Next steps[​](#next-steps \"Direct link to Next steps\")\n\nYou now know how to bind runtime arguments to a Runnable.\n\nTo learn more, see the other how-to guides on runnables in this section, including:\n\n*   [Using configurable fields and alternatives](https://python.langchain.com/docs/how_to/configure/) to change parameters of a step in a chain, or even swap out entire steps, at runtime"
},
{
  "url": "https://python.langchain.com/docs/how_to/query_high_cardinality/",
  "markdown": "# giscus\n\n## How deal with high cardinality categoricals when doing query analysis\n\nYou may want to do query analysis to create a filter on a categorical column. One of the difficulties here is that you usually need to specify the EXACT categorical value. The issue is you need to make sure the LLM generates that categorical value exactly. This can be done relatively easy with prompting when there are only a few values that are valid. When there are a high number of valid values then it becomes more difficult, as those values may not fit in the LLM context, or (if they do) there may be too many for the LLM to properly attend to.\n\nIn this notebook we take a look at how to approach this.\n\n## Setup[​](#setup \"Direct link to Setup\")\n\n#### Install dependencies[​](#install-dependencies \"Direct link to Install dependencies\")\n\n```\n%pip install -qU langchain langchain-community langchain-openai faker langchain-chroma\n```\n\n```\nNote: you may need to restart the kernel to use updated packages.\n```\n\n#### Set environment variables[​](#set-environment-variables \"Direct link to Set environment variables\")\n\nWe'll use OpenAI in this example:\n\n```\nimport getpassimport osif \"OPENAI_API_KEY\" not in os.environ:    os.environ[\"OPENAI_API_KEY\"] = getpass.getpass()# Optional, uncomment to trace runs with LangSmith. Sign up here: https://smith.langchain.com.# os.environ[\"LANGCHAIN_TRACING_V2\"] = \"true\"# os.environ[\"LANGCHAIN_API_KEY\"] = getpass.getpass()\n```\n\n#### Set up data[​](#set-up-data \"Direct link to Set up data\")\n\nWe will generate a bunch of fake names\n\n```\nfrom faker import Fakerfake = Faker()names = [fake.name() for _ in range(10000)]\n```\n\nLet's look at some of the names\n\n## Query Analysis[​](#query-analysis \"Direct link to Query Analysis\")\n\nWe can now set up a baseline query analysis\n\n```\nfrom pydantic import BaseModel, Field, model_validator\n```\n\n```\nclass Search(BaseModel):    query: str    author: str\n```\n\n```\nfrom langchain_core.prompts import ChatPromptTemplatefrom langchain_core.runnables import RunnablePassthroughfrom langchain_openai import ChatOpenAIsystem = \"\"\"Generate a relevant search query for a library system\"\"\"prompt = ChatPromptTemplate.from_messages(    [        (\"system\", system),        (\"human\", \"{question}\"),    ])llm = ChatOpenAI(model=\"gpt-4o-mini\", temperature=0)structured_llm = llm.with_structured_output(Search)query_analyzer = {\"question\": RunnablePassthrough()} | prompt | structured_llm\n```\n\nWe can see that if we spell the name exactly correctly, it knows how to handle it\n\n```\nquery_analyzer.invoke(\"what are books about aliens by Jesse Knight\")\n```\n\n```\nSearch(query='aliens', author='Jesse Knight')\n```\n\nThe issue is that the values you want to filter on may NOT be spelled exactly correctly\n\n```\nquery_analyzer.invoke(\"what are books about aliens by jess knight\")\n```\n\n```\nSearch(query='aliens', author='Jess Knight')\n```\n\n### Add in all values[​](#add-in-all-values \"Direct link to Add in all values\")\n\nOne way around this is to add ALL possible values to the prompt. That will generally guide the query in the right direction\n\n```\nsystem = \"\"\"Generate a relevant search query for a library system.`author` attribute MUST be one of:{authors}Do NOT hallucinate author name!\"\"\"base_prompt = ChatPromptTemplate.from_messages(    [        (\"system\", system),        (\"human\", \"{question}\"),    ])prompt = base_prompt.partial(authors=\", \".join(names))\n```\n\n```\nquery_analyzer_all = {\"question\": RunnablePassthrough()} | prompt | structured_llm\n```\n\nHowever... if the list of categoricals is long enough, it may error!\n\n```\ntry:    res = query_analyzer_all.invoke(\"what are books about aliens by jess knight\")except Exception as e:    print(e)\n```\n\nWe can try to use a longer context window... but with so much information in there, it is not garunteed to pick it up reliably\n\n```\nllm_long = ChatOpenAI(model=\"gpt-4-turbo-preview\", temperature=0)structured_llm_long = llm_long.with_structured_output(Search)query_analyzer_all = {\"question\": RunnablePassthrough()} | prompt | structured_llm_long\n```\n\n```\nquery_analyzer_all.invoke(\"what are books about aliens by jess knight\")\n```\n\n```\nSearch(query='aliens', author='jess knight')\n```\n\n### Find and all relevant values[​](#find-and-all-relevant-values \"Direct link to Find and all relevant values\")\n\nInstead, what we can do is create an index over the relevant values and then query that for the N most relevant values,\n\n```\nfrom langchain_chroma import Chromafrom langchain_openai import OpenAIEmbeddingsembeddings = OpenAIEmbeddings(model=\"text-embedding-3-small\")vectorstore = Chroma.from_texts(names, embeddings, collection_name=\"author_names\")\n```\n\n```\ndef select_names(question):    _docs = vectorstore.similarity_search(question, k=10)    _names = [d.page_content for d in _docs]    return \", \".join(_names)\n```\n\n```\ncreate_prompt = {    \"question\": RunnablePassthrough(),    \"authors\": select_names,} | base_prompt\n```\n\n```\nquery_analyzer_select = create_prompt | structured_llm\n```\n\n```\ncreate_prompt.invoke(\"what are books by jess knight\")\n```\n\n```\nChatPromptValue(messages=[SystemMessage(content='Generate a relevant search query for a library system.\\n\\n`author` attribute MUST be one of:\\n\\nJennifer Knight, Jill Knight, John Knight, Dr. Jeffrey Knight, Christopher Knight, Andrea Knight, Brandy Knight, Jennifer Keller, Becky Chambers, Sarah Knapp\\n\\nDo NOT hallucinate author name!'), HumanMessage(content='what are books by jess knight')])\n```\n\n```\nquery_analyzer_select.invoke(\"what are books about aliens by jess knight\")\n```\n\n```\nSearch(query='books about aliens', author='Jennifer Knight')\n```\n\n### Replace after selection[​](#replace-after-selection \"Direct link to Replace after selection\")\n\nAnother method is to let the LLM fill in whatever value, but then convert that value to a valid value. This can actually be done with the Pydantic class itself!\n\n```\nclass Search(BaseModel):    query: str    author: str    @model_validator(mode=\"before\")    @classmethod    def double(cls, values: dict) -> dict:        author = values[\"author\"]        closest_valid_author = vectorstore.similarity_search(author, k=1)[            0        ].page_content        values[\"author\"] = closest_valid_author        return values\n```\n\n```\nsystem = \"\"\"Generate a relevant search query for a library system\"\"\"prompt = ChatPromptTemplate.from_messages(    [        (\"system\", system),        (\"human\", \"{question}\"),    ])corrective_structure_llm = llm.with_structured_output(Search)corrective_query_analyzer = (    {\"question\": RunnablePassthrough()} | prompt | corrective_structure_llm)\n```\n\n```\ncorrective_query_analyzer.invoke(\"what are books about aliens by jes knight\")\n```\n\n```\nSearch(query='aliens', author='John Knight')\n```\n\n```\n# TODO: show trigram similarity\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/document_loader_markdown/",
  "markdown": "# giscus\n\n[Markdown](https://en.wikipedia.org/wiki/Markdown) is a lightweight markup language for creating formatted text using a plain-text editor.\n\nHere we cover how to load `Markdown` documents into LangChain [Document](https://python.langchain.com/api_reference/core/documents/langchain_core.documents.base.Document.html#langchain_core.documents.base.Document) objects that we can use downstream.\n\nBasic usage will ingest a Markdown file to a single document. Here we demonstrate on LangChain's readme:\n\n```\n🦜️🔗 LangChain⚡ Build context-aware reasoning applications ⚡Looking for the JS/TS library? Check out LangChain.js.To help you ship LangChain apps to production faster, check out LangSmith. LangSmith is a unified developer platform for building,\n```\n\nUnder the hood, Unstructured creates different \"elements\" for different chunks of text. By default we combine those together, but you can easily keep that separation by specifying `mode=\"elements\"`.\n\n```\nNumber of documents: 66page_content='🦜️🔗 LangChain' metadata={'source': '../../../README.md', 'category_depth': 0, 'last_modified': '2024-06-28T15:20:01', 'languages': ['eng'], 'filetype': 'text/markdown', 'file_directory': '../../..', 'filename': 'README.md', 'category': 'Title'}page_content='⚡ Build context-aware reasoning applications ⚡' metadata={'source': '../../../README.md', 'last_modified': '2024-06-28T15:20:01', 'languages': ['eng'], 'parent_id': '200b8a7d0dd03f66e4f13456566d2b3a', 'filetype': 'text/markdown', 'file_directory': '../../..', 'filename': 'README.md', 'category': 'NarrativeText'}\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/runnable_runtime_secrets/",
  "markdown": "# giscus\n\nWe can pass in secrets to our [runnables](https://python.langchain.com/docs/concepts/runnables/) at runtime using the `RunnableConfig`. Specifically we can pass in secrets with a `__` prefix to the `configurable` field. This will ensure that these secrets aren't traced as part of the invocation:\n\n```\nfrom langchain_core.runnables import RunnableConfigfrom langchain_core.tools import tool@tooldef foo(x: int, config: RunnableConfig) -> int:    \"\"\"Sum x and a secret int\"\"\"    return x + config[\"configurable\"][\"__top_secret_int\"]foo.invoke({\"x\": 5}, {\"configurable\": {\"__top_secret_int\": 2, \"traced_key\": \"bar\"}})\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/chatbots_retrieval/",
  "markdown": "# giscus\n\n## How to add retrieval to chatbots\n\n[Retrieval](https://python.langchain.com/docs/concepts/retrieval/) is a common technique chatbots use to augment their responses with data outside a chat model's training data. This section will cover how to implement retrieval in the context of chatbots, but it's worth noting that retrieval is a very subtle and deep topic - we encourage you to explore [other parts of the documentation](https://python.langchain.com/docs/how_to/#qa-with-rag) that go into greater depth!\n\n## Setup[​](#setup \"Direct link to Setup\")\n\nYou'll need to install a few packages, and have your OpenAI API key set as an environment variable named `OPENAI_API_KEY`:\n\n```\n%pip install -qU langchain langchain-openai langchain-chroma beautifulsoup4# Set env var OPENAI_API_KEY or load from a .env file:import dotenvdotenv.load_dotenv()\n```\n\n```\n\u001b[33mWARNING: You are using pip version 22.0.4; however, version 23.3.2 is available.You should consider upgrading via the '/Users/jacoblee/.pyenv/versions/3.10.5/bin/python -m pip install --upgrade pip' command.\u001b[0m\u001b[33m\u001b[0mNote: you may need to restart the kernel to use updated packages.\n```\n\nLet's also set up a chat model that we'll use for the below examples.\n\n```\nfrom langchain_openai import ChatOpenAIchat = ChatOpenAI(model=\"gpt-4o-mini\", temperature=0.2)\n```\n\n## Creating a retriever[​](#creating-a-retriever \"Direct link to Creating a retriever\")\n\nWe'll use [the LangSmith documentation](https://docs.smith.langchain.com/overview) as source material and store the content in a [vector store](https://python.langchain.com/docs/concepts/vectorstores/) for later retrieval. Note that this example will gloss over some of the specifics around parsing and storing a data source - you can see more [in-depth documentation on creating retrieval systems here](https://python.langchain.com/docs/how_to/#qa-with-rag).\n\nLet's use a document loader to pull text from the docs:\n\n```\nfrom langchain_community.document_loaders import WebBaseLoaderloader = WebBaseLoader(\"https://docs.smith.langchain.com/overview\")data = loader.load()\n```\n\nNext, we split it into smaller chunks that the LLM's context window can handle and store it in a vector database:\n\n```\nfrom langchain_text_splitters import RecursiveCharacterTextSplittertext_splitter = RecursiveCharacterTextSplitter(chunk_size=500, chunk_overlap=0)all_splits = text_splitter.split_documents(data)\n```\n\nThen we embed and store those chunks in a vector database:\n\n```\nfrom langchain_chroma import Chromafrom langchain_openai import OpenAIEmbeddingsvectorstore = Chroma.from_documents(documents=all_splits, embedding=OpenAIEmbeddings())\n```\n\nAnd finally, let's create a retriever from our initialized vectorstore:\n\n```\n# k is the number of chunks to retrieveretriever = vectorstore.as_retriever(k=4)docs = retriever.invoke(\"Can LangSmith help test my LLM applications?\")docs\n```\n\n```\n[Document(page_content='Skip to main content🦜️🛠️ LangSmith DocsPython DocsJS/TS DocsSearchGo to AppLangSmithOverviewTracingTesting & EvaluationOrganizationsHubLangSmith CookbookOverviewOn this pageLangSmith Overview and User GuideBuilding reliable LLM applications can be challenging. LangChain simplifies the initial setup, but there is still work needed to bring the performance of prompts, chains and agents up the level where they are reliable enough to be used in production.Over the past two months, we at LangChain', metadata={'description': 'Building reliable LLM applications can be challenging. LangChain simplifies the initial setup, but there is still work needed to bring the performance of prompts, chains and agents up the level where they are reliable enough to be used in production.', 'language': 'en', 'source': 'https://docs.smith.langchain.com/overview', 'title': 'LangSmith Overview and User Guide | 🦜️🛠️ LangSmith'}), Document(page_content='LangSmith Overview and User Guide | 🦜️🛠️ LangSmith', metadata={'description': 'Building reliable LLM applications can be challenging. LangChain simplifies the initial setup, but there is still work needed to bring the performance of prompts, chains and agents up the level where they are reliable enough to be used in production.', 'language': 'en', 'source': 'https://docs.smith.langchain.com/overview', 'title': 'LangSmith Overview and User Guide | 🦜️🛠️ LangSmith'}), Document(page_content='You can also quickly edit examples and add them to datasets to expand the surface area of your evaluation sets or to fine-tune a model for improved quality or reduced costs.Monitoring\\u200bAfter all this, your app might finally ready to go in production. LangSmith can also be used to monitor your application in much the same way that you used for debugging. You can log all traces, visualize latency and token usage statistics, and troubleshoot specific issues as they arise. Each run can also be', metadata={'description': 'Building reliable LLM applications can be challenging. LangChain simplifies the initial setup, but there is still work needed to bring the performance of prompts, chains and agents up the level where they are reliable enough to be used in production.', 'language': 'en', 'source': 'https://docs.smith.langchain.com/overview', 'title': 'LangSmith Overview and User Guide | 🦜️🛠️ LangSmith'}), Document(page_content=\"does that affect the output?\\u200bSo you notice a bad output, and you go into LangSmith to see what's going on. You find the faulty LLM call and are now looking at the exact input. You want to try changing a word or a phrase to see what happens -- what do you do?We constantly ran into this issue. Initially, we copied the prompt to a playground of sorts. But this got annoying, so we built a playground of our own! When examining an LLM call, you can click the Open in Playground button to access this\", metadata={'description': 'Building reliable LLM applications can be challenging. LangChain simplifies the initial setup, but there is still work needed to bring the performance of prompts, chains and agents up the level where they are reliable enough to be used in production.', 'language': 'en', 'source': 'https://docs.smith.langchain.com/overview', 'title': 'LangSmith Overview and User Guide | 🦜️🛠️ LangSmith'})]\n```\n\nWe can see that invoking the retriever above results in some parts of the LangSmith docs that contain information about testing that our chatbot can use as context when answering questions. And now we've got a retriever that can return related data from the LangSmith docs!\n\n## Document chains[​](#document-chains \"Direct link to Document chains\")\n\nNow that we have a retriever that can return LangChain docs, let's create a chain that can use them as context to answer questions. We'll use a `create_stuff_documents_chain` helper function to \"stuff\" all of the input documents into the prompt. It will also handle formatting the docs as strings.\n\nIn addition to a chat model, the function also expects a prompt that has a `context` variables, as well as a placeholder for chat history messages named `messages`. We'll create an appropriate prompt and pass it as shown below:\n\n```\nfrom langchain.chains.combine_documents import create_stuff_documents_chainfrom langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholderSYSTEM_TEMPLATE = \"\"\"Answer the user's questions based on the below context. If the context doesn't contain any relevant information to the question, don't make something up and just say \"I don't know\":<context>{context}</context>\"\"\"question_answering_prompt = ChatPromptTemplate.from_messages(    [        (            \"system\",            SYSTEM_TEMPLATE,        ),        MessagesPlaceholder(variable_name=\"messages\"),    ])document_chain = create_stuff_documents_chain(chat, question_answering_prompt)\n```\n\nWe can invoke this `document_chain` by itself to answer questions. Let's use the docs we retrieved above and the same question, `how can langsmith help with testing?`:\n\n```\nfrom langchain_core.messages import HumanMessagedocument_chain.invoke(    {        \"context\": docs,        \"messages\": [            HumanMessage(content=\"Can LangSmith help test my LLM applications?\")        ],    })\n```\n\n```\n'Yes, LangSmith can help test and evaluate your LLM applications. It simplifies the initial setup, and you can use it to monitor your application, log all traces, visualize latency and token usage statistics, and troubleshoot specific issues as they arise.'\n```\n\nLooks good! For comparison, we can try it with no context docs and compare the result:\n\n```\ndocument_chain.invoke(    {        \"context\": [],        \"messages\": [            HumanMessage(content=\"Can LangSmith help test my LLM applications?\")        ],    })\n```\n\n```\n\"I don't know about LangSmith's specific capabilities for testing LLM applications. It's best to reach out to LangSmith directly to inquire about their services and how they can assist with testing your LLM applications.\"\n```\n\nWe can see that the LLM does not return any results.\n\n## Retrieval chains[​](#retrieval-chains \"Direct link to Retrieval chains\")\n\nLet's combine this document chain with the retriever. Here's one way this can look:\n\n```\nfrom typing import Dictfrom langchain_core.runnables import RunnablePassthroughdef parse_retriever_input(params: Dict):    return params[\"messages\"][-1].contentretrieval_chain = RunnablePassthrough.assign(    context=parse_retriever_input | retriever,).assign(    answer=document_chain,)\n```\n\nGiven a list of input messages, we extract the content of the last message in the list and pass that to the retriever to fetch some documents. Then, we pass those documents as context to our document chain to generate a final response.\n\nInvoking this chain combines both steps outlined above:\n\n```\nretrieval_chain.invoke(    {        \"messages\": [            HumanMessage(content=\"Can LangSmith help test my LLM applications?\")        ],    })\n```\n\n```\n{'messages': [HumanMessage(content='Can LangSmith help test my LLM applications?')], 'context': [Document(page_content='Skip to main content🦜️🛠️ LangSmith DocsPython DocsJS/TS DocsSearchGo to AppLangSmithOverviewTracingTesting & EvaluationOrganizationsHubLangSmith CookbookOverviewOn this pageLangSmith Overview and User GuideBuilding reliable LLM applications can be challenging. LangChain simplifies the initial setup, but there is still work needed to bring the performance of prompts, chains and agents up the level where they are reliable enough to be used in production.Over the past two months, we at LangChain', metadata={'description': 'Building reliable LLM applications can be challenging. LangChain simplifies the initial setup, but there is still work needed to bring the performance of prompts, chains and agents up the level where they are reliable enough to be used in production.', 'language': 'en', 'source': 'https://docs.smith.langchain.com/overview', 'title': 'LangSmith Overview and User Guide | 🦜️🛠️ LangSmith'}),  Document(page_content='LangSmith Overview and User Guide | 🦜️🛠️ LangSmith', metadata={'description': 'Building reliable LLM applications can be challenging. LangChain simplifies the initial setup, but there is still work needed to bring the performance of prompts, chains and agents up the level where they are reliable enough to be used in production.', 'language': 'en', 'source': 'https://docs.smith.langchain.com/overview', 'title': 'LangSmith Overview and User Guide | 🦜️🛠️ LangSmith'}),  Document(page_content='You can also quickly edit examples and add them to datasets to expand the surface area of your evaluation sets or to fine-tune a model for improved quality or reduced costs.Monitoring\\u200bAfter all this, your app might finally ready to go in production. LangSmith can also be used to monitor your application in much the same way that you used for debugging. You can log all traces, visualize latency and token usage statistics, and troubleshoot specific issues as they arise. Each run can also be', metadata={'description': 'Building reliable LLM applications can be challenging. LangChain simplifies the initial setup, but there is still work needed to bring the performance of prompts, chains and agents up the level where they are reliable enough to be used in production.', 'language': 'en', 'source': 'https://docs.smith.langchain.com/overview', 'title': 'LangSmith Overview and User Guide | 🦜️🛠️ LangSmith'}),  Document(page_content=\"does that affect the output?\\u200bSo you notice a bad output, and you go into LangSmith to see what's going on. You find the faulty LLM call and are now looking at the exact input. You want to try changing a word or a phrase to see what happens -- what do you do?We constantly ran into this issue. Initially, we copied the prompt to a playground of sorts. But this got annoying, so we built a playground of our own! When examining an LLM call, you can click the Open in Playground button to access this\", metadata={'description': 'Building reliable LLM applications can be challenging. LangChain simplifies the initial setup, but there is still work needed to bring the performance of prompts, chains and agents up the level where they are reliable enough to be used in production.', 'language': 'en', 'source': 'https://docs.smith.langchain.com/overview', 'title': 'LangSmith Overview and User Guide | 🦜️🛠️ LangSmith'})], 'answer': 'Yes, LangSmith can help test and evaluate your LLM applications. It simplifies the initial setup, and you can use it to monitor your application, log all traces, visualize latency and token usage statistics, and troubleshoot specific issues as they arise.'}\n```\n\nLooks good!\n\n## Query transformation[​](#query-transformation \"Direct link to Query transformation\")\n\nOur retrieval chain is capable of answering questions about LangSmith, but there's a problem - chatbots interact with users conversationally, and therefore have to deal with followup questions.\n\nThe chain in its current form will struggle with this. Consider a followup question to our original question like `Tell me more!`. If we invoke our retriever with that query directly, we get documents irrelevant to LLM application testing:\n\n```\nretriever.invoke(\"Tell me more!\")\n```\n\n```\n[Document(page_content='You can also quickly edit examples and add them to datasets to expand the surface area of your evaluation sets or to fine-tune a model for improved quality or reduced costs.Monitoring\\u200bAfter all this, your app might finally ready to go in production. LangSmith can also be used to monitor your application in much the same way that you used for debugging. You can log all traces, visualize latency and token usage statistics, and troubleshoot specific issues as they arise. Each run can also be', metadata={'description': 'Building reliable LLM applications can be challenging. LangChain simplifies the initial setup, but there is still work needed to bring the performance of prompts, chains and agents up the level where they are reliable enough to be used in production.', 'language': 'en', 'source': 'https://docs.smith.langchain.com/overview', 'title': 'LangSmith Overview and User Guide | 🦜️🛠️ LangSmith'}), Document(page_content='playground. Here, you can modify the prompt and re-run it to observe the resulting changes to the output - as many times as needed!Currently, this feature supports only OpenAI and Anthropic models and works for LLM and Chat Model calls. We plan to extend its functionality to more LLM types, chains, agents, and retrievers in the future.What is the exact sequence of events?\\u200bIn complicated chains and agents, it can often be hard to understand what is going on under the hood. What calls are being', metadata={'description': 'Building reliable LLM applications can be challenging. LangChain simplifies the initial setup, but there is still work needed to bring the performance of prompts, chains and agents up the level where they are reliable enough to be used in production.', 'language': 'en', 'source': 'https://docs.smith.langchain.com/overview', 'title': 'LangSmith Overview and User Guide | 🦜️🛠️ LangSmith'}), Document(page_content='however, there is still no complete substitute for human review to get the utmost quality and reliability from your application.', metadata={'description': 'Building reliable LLM applications can be challenging. LangChain simplifies the initial setup, but there is still work needed to bring the performance of prompts, chains and agents up the level where they are reliable enough to be used in production.', 'language': 'en', 'source': 'https://docs.smith.langchain.com/overview', 'title': 'LangSmith Overview and User Guide | 🦜️🛠️ LangSmith'}), Document(page_content='Skip to main content🦜️🛠️ LangSmith DocsPython DocsJS/TS DocsSearchGo to AppLangSmithOverviewTracingTesting & EvaluationOrganizationsHubLangSmith CookbookOverviewOn this pageLangSmith Overview and User GuideBuilding reliable LLM applications can be challenging. LangChain simplifies the initial setup, but there is still work needed to bring the performance of prompts, chains and agents up the level where they are reliable enough to be used in production.Over the past two months, we at LangChain', metadata={'description': 'Building reliable LLM applications can be challenging. LangChain simplifies the initial setup, but there is still work needed to bring the performance of prompts, chains and agents up the level where they are reliable enough to be used in production.', 'language': 'en', 'source': 'https://docs.smith.langchain.com/overview', 'title': 'LangSmith Overview and User Guide | 🦜️🛠️ LangSmith'})]\n```\n\nThis is because the retriever has no innate concept of state, and will only pull documents most similar to the query given. To solve this, we can transform the query into a standalone query without any external references an LLM.\n\nHere's an example:\n\n```\nfrom langchain_core.messages import AIMessage, HumanMessagequery_transform_prompt = ChatPromptTemplate.from_messages(    [        MessagesPlaceholder(variable_name=\"messages\"),        (            \"user\",            \"Given the above conversation, generate a search query to look up in order to get information relevant to the conversation. Only respond with the query, nothing else.\",        ),    ])query_transformation_chain = query_transform_prompt | chatquery_transformation_chain.invoke(    {        \"messages\": [            HumanMessage(content=\"Can LangSmith help test my LLM applications?\"),            AIMessage(                content=\"Yes, LangSmith can help test and evaluate your LLM applications. It allows you to quickly edit examples and add them to datasets to expand the surface area of your evaluation sets or to fine-tune a model for improved quality or reduced costs. Additionally, LangSmith can be used to monitor your application, log all traces, visualize latency and token usage statistics, and troubleshoot specific issues as they arise.\"            ),            HumanMessage(content=\"Tell me more!\"),        ],    })\n```\n\n```\nAIMessage(content='\"LangSmith LLM application testing and evaluation\"')\n```\n\nAwesome! That transformed query would pull up context documents related to LLM application testing.\n\nLet's add this to our retrieval chain. We can wrap our retriever as follows:\n\n```\nfrom langchain_core.output_parsers import StrOutputParserfrom langchain_core.runnables import RunnableBranchquery_transforming_retriever_chain = RunnableBranch(    (        lambda x: len(x.get(\"messages\", [])) == 1,        # If only one message, then we just pass that message's content to retriever        (lambda x: x[\"messages\"][-1].content) | retriever,    ),    # If messages, then we pass inputs to LLM chain to transform the query, then pass to retriever    query_transform_prompt | chat | StrOutputParser() | retriever,).with_config(run_name=\"chat_retriever_chain\")\n```\n\nThen, we can use this query transformation chain to make our retrieval chain better able to handle such followup questions:\n\n```\nSYSTEM_TEMPLATE = \"\"\"Answer the user's questions based on the below context. If the context doesn't contain any relevant information to the question, don't make something up and just say \"I don't know\":<context>{context}</context>\"\"\"question_answering_prompt = ChatPromptTemplate.from_messages(    [        (            \"system\",            SYSTEM_TEMPLATE,        ),        MessagesPlaceholder(variable_name=\"messages\"),    ])document_chain = create_stuff_documents_chain(chat, question_answering_prompt)conversational_retrieval_chain = RunnablePassthrough.assign(    context=query_transforming_retriever_chain,).assign(    answer=document_chain,)\n```\n\nAwesome! Let's invoke this new chain with the same inputs as earlier:\n\n```\nconversational_retrieval_chain.invoke(    {        \"messages\": [            HumanMessage(content=\"Can LangSmith help test my LLM applications?\"),        ]    })\n```\n\n```\n{'messages': [HumanMessage(content='Can LangSmith help test my LLM applications?')], 'context': [Document(page_content='Skip to main content🦜️🛠️ LangSmith DocsPython DocsJS/TS DocsSearchGo to AppLangSmithOverviewTracingTesting & EvaluationOrganizationsHubLangSmith CookbookOverviewOn this pageLangSmith Overview and User GuideBuilding reliable LLM applications can be challenging. LangChain simplifies the initial setup, but there is still work needed to bring the performance of prompts, chains and agents up the level where they are reliable enough to be used in production.Over the past two months, we at LangChain', metadata={'description': 'Building reliable LLM applications can be challenging. LangChain simplifies the initial setup, but there is still work needed to bring the performance of prompts, chains and agents up the level where they are reliable enough to be used in production.', 'language': 'en', 'source': 'https://docs.smith.langchain.com/overview', 'title': 'LangSmith Overview and User Guide | 🦜️🛠️ LangSmith'}),  Document(page_content='LangSmith Overview and User Guide | 🦜️🛠️ LangSmith', metadata={'description': 'Building reliable LLM applications can be challenging. LangChain simplifies the initial setup, but there is still work needed to bring the performance of prompts, chains and agents up the level where they are reliable enough to be used in production.', 'language': 'en', 'source': 'https://docs.smith.langchain.com/overview', 'title': 'LangSmith Overview and User Guide | 🦜️🛠️ LangSmith'}),  Document(page_content='You can also quickly edit examples and add them to datasets to expand the surface area of your evaluation sets or to fine-tune a model for improved quality or reduced costs.Monitoring\\u200bAfter all this, your app might finally ready to go in production. LangSmith can also be used to monitor your application in much the same way that you used for debugging. You can log all traces, visualize latency and token usage statistics, and troubleshoot specific issues as they arise. Each run can also be', metadata={'description': 'Building reliable LLM applications can be challenging. LangChain simplifies the initial setup, but there is still work needed to bring the performance of prompts, chains and agents up the level where they are reliable enough to be used in production.', 'language': 'en', 'source': 'https://docs.smith.langchain.com/overview', 'title': 'LangSmith Overview and User Guide | 🦜️🛠️ LangSmith'}),  Document(page_content=\"does that affect the output?\\u200bSo you notice a bad output, and you go into LangSmith to see what's going on. You find the faulty LLM call and are now looking at the exact input. You want to try changing a word or a phrase to see what happens -- what do you do?We constantly ran into this issue. Initially, we copied the prompt to a playground of sorts. But this got annoying, so we built a playground of our own! When examining an LLM call, you can click the Open in Playground button to access this\", metadata={'description': 'Building reliable LLM applications can be challenging. LangChain simplifies the initial setup, but there is still work needed to bring the performance of prompts, chains and agents up the level where they are reliable enough to be used in production.', 'language': 'en', 'source': 'https://docs.smith.langchain.com/overview', 'title': 'LangSmith Overview and User Guide | 🦜️🛠️ LangSmith'})], 'answer': 'Yes, LangSmith can help test and evaluate LLM (Language Model) applications. It simplifies the initial setup, and you can use it to monitor your application, log all traces, visualize latency and token usage statistics, and troubleshoot specific issues as they arise.'}\n```\n\n```\nconversational_retrieval_chain.invoke(    {        \"messages\": [            HumanMessage(content=\"Can LangSmith help test my LLM applications?\"),            AIMessage(                content=\"Yes, LangSmith can help test and evaluate your LLM applications. It allows you to quickly edit examples and add them to datasets to expand the surface area of your evaluation sets or to fine-tune a model for improved quality or reduced costs. Additionally, LangSmith can be used to monitor your application, log all traces, visualize latency and token usage statistics, and troubleshoot specific issues as they arise.\"            ),            HumanMessage(content=\"Tell me more!\"),        ],    })\n```\n\n```\n{'messages': [HumanMessage(content='Can LangSmith help test my LLM applications?'),  AIMessage(content='Yes, LangSmith can help test and evaluate your LLM applications. It allows you to quickly edit examples and add them to datasets to expand the surface area of your evaluation sets or to fine-tune a model for improved quality or reduced costs. Additionally, LangSmith can be used to monitor your application, log all traces, visualize latency and token usage statistics, and troubleshoot specific issues as they arise.'),  HumanMessage(content='Tell me more!')], 'context': [Document(page_content='LangSmith Overview and User Guide | 🦜️🛠️ LangSmith', metadata={'description': 'Building reliable LLM applications can be challenging. LangChain simplifies the initial setup, but there is still work needed to bring the performance of prompts, chains and agents up the level where they are reliable enough to be used in production.', 'language': 'en', 'source': 'https://docs.smith.langchain.com/overview', 'title': 'LangSmith Overview and User Guide | 🦜️🛠️ LangSmith'}),  Document(page_content='You can also quickly edit examples and add them to datasets to expand the surface area of your evaluation sets or to fine-tune a model for improved quality or reduced costs.Monitoring\\u200bAfter all this, your app might finally ready to go in production. LangSmith can also be used to monitor your application in much the same way that you used for debugging. You can log all traces, visualize latency and token usage statistics, and troubleshoot specific issues as they arise. Each run can also be', metadata={'description': 'Building reliable LLM applications can be challenging. LangChain simplifies the initial setup, but there is still work needed to bring the performance of prompts, chains and agents up the level where they are reliable enough to be used in production.', 'language': 'en', 'source': 'https://docs.smith.langchain.com/overview', 'title': 'LangSmith Overview and User Guide | 🦜️🛠️ LangSmith'}),  Document(page_content='Skip to main content🦜️🛠️ LangSmith DocsPython DocsJS/TS DocsSearchGo to AppLangSmithOverviewTracingTesting & EvaluationOrganizationsHubLangSmith CookbookOverviewOn this pageLangSmith Overview and User GuideBuilding reliable LLM applications can be challenging. LangChain simplifies the initial setup, but there is still work needed to bring the performance of prompts, chains and agents up the level where they are reliable enough to be used in production.Over the past two months, we at LangChain', metadata={'description': 'Building reliable LLM applications can be challenging. LangChain simplifies the initial setup, but there is still work needed to bring the performance of prompts, chains and agents up the level where they are reliable enough to be used in production.', 'language': 'en', 'source': 'https://docs.smith.langchain.com/overview', 'title': 'LangSmith Overview and User Guide | 🦜️🛠️ LangSmith'}),  Document(page_content='LangSmith makes it easy to manually review and annotate runs through annotation queues.These queues allow you to select any runs based on criteria like model type or automatic evaluation scores, and queue them up for human review. As a reviewer, you can then quickly step through the runs, viewing the input, output, and any existing tags before adding your own feedback.We often use this for a couple of reasons:To assess subjective qualities that automatic evaluators struggle with, like', metadata={'description': 'Building reliable LLM applications can be challenging. LangChain simplifies the initial setup, but there is still work needed to bring the performance of prompts, chains and agents up the level where they are reliable enough to be used in production.', 'language': 'en', 'source': 'https://docs.smith.langchain.com/overview', 'title': 'LangSmith Overview and User Guide | 🦜️🛠️ LangSmith'})], 'answer': 'LangSmith simplifies the initial setup for building reliable LLM applications, but it acknowledges that there is still work needed to bring the performance of prompts, chains, and agents up to the level where they are reliable enough to be used in production. It also provides the capability to manually review and annotate runs through annotation queues, allowing you to select runs based on criteria like model type or automatic evaluation scores for human review. This feature is particularly useful for assessing subjective qualities that automatic evaluators struggle with.'}\n```\n\nYou can check out [this LangSmith trace](https://smith.langchain.com/public/bb329a3b-e92a-4063-ad78-43f720fbb5a2/r) to see the internal query transformation step for yourself.\n\n## Streaming[​](#streaming \"Direct link to Streaming\")\n\nBecause this chain is constructed with LCEL, you can use familiar methods like `.stream()` with it:\n\n```\nstream = conversational_retrieval_chain.stream(    {        \"messages\": [            HumanMessage(content=\"Can LangSmith help test my LLM applications?\"),            AIMessage(                content=\"Yes, LangSmith can help test and evaluate your LLM applications. It allows you to quickly edit examples and add them to datasets to expand the surface area of your evaluation sets or to fine-tune a model for improved quality or reduced costs. Additionally, LangSmith can be used to monitor your application, log all traces, visualize latency and token usage statistics, and troubleshoot specific issues as they arise.\"            ),            HumanMessage(content=\"Tell me more!\"),        ],    })for chunk in stream:    print(chunk)\n```\n\n```\n{'messages': [HumanMessage(content='Can LangSmith help test my LLM applications?'), AIMessage(content='Yes, LangSmith can help test and evaluate your LLM applications. It allows you to quickly edit examples and add them to datasets to expand the surface area of your evaluation sets or to fine-tune a model for improved quality or reduced costs. Additionally, LangSmith can be used to monitor your application, log all traces, visualize latency and token usage statistics, and troubleshoot specific issues as they arise.'), HumanMessage(content='Tell me more!')]}{'context': [Document(page_content='LangSmith Overview and User Guide | 🦜️🛠️ LangSmith', metadata={'description': 'Building reliable LLM applications can be challenging. LangChain simplifies the initial setup, but there is still work needed to bring the performance of prompts, chains and agents up the level where they are reliable enough to be used in production.', 'language': 'en', 'source': 'https://docs.smith.langchain.com/overview', 'title': 'LangSmith Overview and User Guide | 🦜️🛠️ LangSmith'}), Document(page_content='You can also quickly edit examples and add them to datasets to expand the surface area of your evaluation sets or to fine-tune a model for improved quality or reduced costs.Monitoring\\u200bAfter all this, your app might finally ready to go in production. LangSmith can also be used to monitor your application in much the same way that you used for debugging. You can log all traces, visualize latency and token usage statistics, and troubleshoot specific issues as they arise. Each run can also be', metadata={'description': 'Building reliable LLM applications can be challenging. LangChain simplifies the initial setup, but there is still work needed to bring the performance of prompts, chains and agents up the level where they are reliable enough to be used in production.', 'language': 'en', 'source': 'https://docs.smith.langchain.com/overview', 'title': 'LangSmith Overview and User Guide | 🦜️🛠️ LangSmith'}), Document(page_content='Skip to main content🦜️🛠️ LangSmith DocsPython DocsJS/TS DocsSearchGo to AppLangSmithOverviewTracingTesting & EvaluationOrganizationsHubLangSmith CookbookOverviewOn this pageLangSmith Overview and User GuideBuilding reliable LLM applications can be challenging. LangChain simplifies the initial setup, but there is still work needed to bring the performance of prompts, chains and agents up the level where they are reliable enough to be used in production.Over the past two months, we at LangChain', metadata={'description': 'Building reliable LLM applications can be challenging. LangChain simplifies the initial setup, but there is still work needed to bring the performance of prompts, chains and agents up the level where they are reliable enough to be used in production.', 'language': 'en', 'source': 'https://docs.smith.langchain.com/overview', 'title': 'LangSmith Overview and User Guide | 🦜️🛠️ LangSmith'}), Document(page_content='LangSmith makes it easy to manually review and annotate runs through annotation queues.These queues allow you to select any runs based on criteria like model type or automatic evaluation scores, and queue them up for human review. As a reviewer, you can then quickly step through the runs, viewing the input, output, and any existing tags before adding your own feedback.We often use this for a couple of reasons:To assess subjective qualities that automatic evaluators struggle with, like', metadata={'description': 'Building reliable LLM applications can be challenging. LangChain simplifies the initial setup, but there is still work needed to bring the performance of prompts, chains and agents up the level where they are reliable enough to be used in production.', 'language': 'en', 'source': 'https://docs.smith.langchain.com/overview', 'title': 'LangSmith Overview and User Guide | 🦜️🛠️ LangSmith'})]}{'answer': ''}{'answer': 'Lang'}{'answer': 'Smith'}{'answer': ' simpl'}{'answer': 'ifies'}{'answer': ' the'}{'answer': ' initial'}{'answer': ' setup'}{'answer': ' for'}{'answer': ' building'}{'answer': ' reliable'}{'answer': ' L'}{'answer': 'LM'}{'answer': ' applications'}{'answer': '.'}{'answer': ' It'}{'answer': ' provides'}{'answer': ' features'}{'answer': ' for'}{'answer': ' manually'}{'answer': ' reviewing'}{'answer': ' and'}{'answer': ' annot'}{'answer': 'ating'}{'answer': ' runs'}{'answer': ' through'}{'answer': ' annotation'}{'answer': ' queues'}{'answer': ','}{'answer': ' allowing'}{'answer': ' you'}{'answer': ' to'}{'answer': ' select'}{'answer': ' runs'}{'answer': ' based'}{'answer': ' on'}{'answer': ' criteria'}{'answer': ' like'}{'answer': ' model'}{'answer': ' type'}{'answer': ' or'}{'answer': ' automatic'}{'answer': ' evaluation'}{'answer': ' scores'}{'answer': ','}{'answer': ' and'}{'answer': ' queue'}{'answer': ' them'}{'answer': ' up'}{'answer': ' for'}{'answer': ' human'}{'answer': ' review'}{'answer': '.'}{'answer': ' As'}{'answer': ' a'}{'answer': ' reviewer'}{'answer': ','}{'answer': ' you'}{'answer': ' can'}{'answer': ' quickly'}{'answer': ' step'}{'answer': ' through'}{'answer': ' the'}{'answer': ' runs'}{'answer': ','}{'answer': ' view'}{'answer': ' the'}{'answer': ' input'}{'answer': ','}{'answer': ' output'}{'answer': ','}{'answer': ' and'}{'answer': ' any'}{'answer': ' existing'}{'answer': ' tags'}{'answer': ' before'}{'answer': ' adding'}{'answer': ' your'}{'answer': ' own'}{'answer': ' feedback'}{'answer': '.'}{'answer': ' This'}{'answer': ' can'}{'answer': ' be'}{'answer': ' particularly'}{'answer': ' useful'}{'answer': ' for'}{'answer': ' assessing'}{'answer': ' subjective'}{'answer': ' qualities'}{'answer': ' that'}{'answer': ' automatic'}{'answer': ' evalu'}{'answer': 'ators'}{'answer': ' struggle'}{'answer': ' with'}{'answer': '.'}{'answer': ''}\n```\n\n## Further reading[​](#further-reading \"Direct link to Further reading\")\n\nThis guide only scratches the surface of retrieval techniques. For more on different ways of ingesting, preparing, and retrieving the most relevant data, check out the relevant how-to guides [here](https://python.langchain.com/docs/how_to/#document-loaders)."
},
{
  "url": "https://python.langchain.com/docs/how_to/document_loader_custom/",
  "markdown": "# giscus\n\n## How to create a custom Document Loader\n\n## Overview[​](#overview \"Direct link to Overview\")\n\nApplications based on LLMs frequently entail extracting data from databases or files, like PDFs, and converting it into a format that LLMs can utilize. In LangChain, this usually involves creating Document objects, which encapsulate the extracted text (`page_content`) along with metadata—a dictionary containing details about the document, such as the author's name or the date of publication.\n\n`Document` objects are often formatted into prompts that are fed into an LLM, allowing the LLM to use the information in the `Document` to generate a desired response (e.g., summarizing the document). `Documents` can be either used immediately or indexed into a vectorstore for future retrieval and use.\n\nThe main abstractions for [Document Loading](https://python.langchain.com/docs/concepts/document_loaders/) are:\n\n| Component | Description |\n| --- | --- |\n| Document | Contains `text` and `metadata` |\n| BaseLoader | Use to convert raw data into `Documents` |\n| Blob | A representation of binary data that's located either in a file or in memory |\n| BaseBlobParser | Logic to parse a `Blob` to yield `Document` objects |\n\nThis guide will demonstrate how to write custom document loading and file parsing logic; specifically, we'll see how to:\n\n1.  Create a standard document Loader by sub-classing from `BaseLoader`.\n2.  Create a parser using `BaseBlobParser` and use it in conjunction with `Blob` and `BlobLoaders`. This is useful primarily when working with files.\n\n## Standard Document Loader[​](#standard-document-loader \"Direct link to Standard Document Loader\")\n\nA document loader can be implemented by sub-classing from a `BaseLoader` which provides a standard interface for loading documents.\n\n### Interface[​](#interface \"Direct link to Interface\")\n\n| Method Name | Explanation |\n| --- | --- |\n| lazy\\_load | Used to load documents one by one **lazily**. Use for production code. |\n| alazy\\_load | Async variant of `lazy_load` |\n| load | Used to load all the documents into memory **eagerly**. Use for prototyping or interactive work. |\n| aload | Used to load all the documents into memory **eagerly**. Use for prototyping or interactive work. **Added in 2024-04 to LangChain.** |\n\n*   The `load` methods is a convenience method meant solely for prototyping work -- it just invokes `list(self.lazy_load())`.\n*   The `alazy_load` has a default implementation that will delegate to `lazy_load`. If you're using async, we recommend overriding the default implementation and providing a native async implementation.\n\nimportant\n\nWhen implementing a document loader do **NOT** provide parameters via the `lazy_load` or `alazy_load` methods.\n\nAll configuration is expected to be passed through the initializer (**init**). This was a design choice made by LangChain to make sure that once a document loader has been instantiated it has all the information needed to load documents.\n\n### Implementation[​](#implementation \"Direct link to Implementation\")\n\nLet's create an example of a standard document loader that loads a file and creates a document from each line in the file.\n\n```\nfrom typing import AsyncIterator, Iteratorfrom langchain_core.document_loaders import BaseLoaderfrom langchain_core.documents import Documentclass CustomDocumentLoader(BaseLoader):    \"\"\"An example document loader that reads a file line by line.\"\"\"    def __init__(self, file_path: str) -> None:        \"\"\"Initialize the loader with a file path.        Args:            file_path: The path to the file to load.        \"\"\"        self.file_path = file_path    def lazy_load(self) -> Iterator[Document]:  # <-- Does not take any arguments        \"\"\"A lazy loader that reads a file line by line.        When you're implementing lazy load methods, you should use a generator        to yield documents one by one.        \"\"\"        with open(self.file_path, encoding=\"utf-8\") as f:            line_number = 0            for line in f:                yield Document(                    page_content=line,                    metadata={\"line_number\": line_number, \"source\": self.file_path},                )                line_number += 1    # alazy_load is OPTIONAL.    # If you leave out the implementation, a default implementation which delegates to lazy_load will be used!    async def alazy_load(        self,    ) -> AsyncIterator[Document]:  # <-- Does not take any arguments        \"\"\"An async lazy loader that reads a file line by line.\"\"\"        # Requires aiofiles (install with pip)        # https://github.com/Tinche/aiofiles        import aiofiles        async with aiofiles.open(self.file_path, encoding=\"utf-8\") as f:            line_number = 0            async for line in f:                yield Document(                    page_content=line,                    metadata={\"line_number\": line_number, \"source\": self.file_path},                )                line_number += 1\n```\n\n### Test 🧪[​](#test- \"Direct link to Test 🧪\")\n\nTo test out the document loader, we need a file with some quality content.\n\n```\nwith open(\"./meow.txt\", \"w\", encoding=\"utf-8\") as f:    quality_content = \"meow meow🐱 \\n meow meow🐱 \\n meow😻😻\"    f.write(quality_content)loader = CustomDocumentLoader(\"./meow.txt\")\n```\n\n```\n## Test out the lazy load interfacefor doc in loader.lazy_load():    print()    print(type(doc))    print(doc)\n```\n\n```\n<class 'langchain_core.documents.base.Document'>page_content='meow meow🐱 \\n' metadata={'line_number': 0, 'source': './meow.txt'}<class 'langchain_core.documents.base.Document'>page_content=' meow meow🐱 \\n' metadata={'line_number': 1, 'source': './meow.txt'}<class 'langchain_core.documents.base.Document'>page_content=' meow😻😻' metadata={'line_number': 2, 'source': './meow.txt'}\n```\n\n```\n## Test out the async implementationasync for doc in loader.alazy_load():    print()    print(type(doc))    print(doc)\n```\n\n```\n<class 'langchain_core.documents.base.Document'>page_content='meow meow🐱 \\n' metadata={'line_number': 0, 'source': './meow.txt'}<class 'langchain_core.documents.base.Document'>page_content=' meow meow🐱 \\n' metadata={'line_number': 1, 'source': './meow.txt'}<class 'langchain_core.documents.base.Document'>page_content=' meow😻😻' metadata={'line_number': 2, 'source': './meow.txt'}\n```\n\ntip\n\n`load()` can be helpful in an interactive environment such as a jupyter notebook.\n\nAvoid using it for production code since eager loading assumes that all the content can fit into memory, which is not always the case, especially for enterprise data.\n\n```\n[Document(page_content='meow meow🐱 \\n', metadata={'line_number': 0, 'source': './meow.txt'}), Document(page_content=' meow meow🐱 \\n', metadata={'line_number': 1, 'source': './meow.txt'}), Document(page_content=' meow😻😻', metadata={'line_number': 2, 'source': './meow.txt'})]\n```\n\n## Working with Files[​](#working-with-files \"Direct link to Working with Files\")\n\nMany document loaders involve parsing files. The difference between such loaders usually stems from how the file is parsed, rather than how the file is loaded. For example, you can use `open` to read the binary content of either a PDF or a markdown file, but you need different parsing logic to convert that binary data into text.\n\nAs a result, it can be helpful to decouple the parsing logic from the loading logic, which makes it easier to re-use a given parser regardless of how the data was loaded.\n\n### BaseBlobParser[​](#baseblobparser \"Direct link to BaseBlobParser\")\n\nA `BaseBlobParser` is an interface that accepts a `blob` and outputs a list of `Document` objects. A `blob` is a representation of data that lives either in memory or in a file. LangChain python has a `Blob` primitive which is inspired by the [Blob WebAPI spec](https://developer.mozilla.org/en-US/docs/Web/API/Blob).\n\n```\nfrom langchain_core.document_loaders import BaseBlobParser, Blobclass MyParser(BaseBlobParser):    \"\"\"A simple parser that creates a document from each line.\"\"\"    def lazy_parse(self, blob: Blob) -> Iterator[Document]:        \"\"\"Parse a blob into a document line by line.\"\"\"        line_number = 0        with blob.as_bytes_io() as f:            for line in f:                line_number += 1                yield Document(                    page_content=line,                    metadata={\"line_number\": line_number, \"source\": blob.source},                )\n```\n\n```\nblob = Blob.from_path(\"./meow.txt\")parser = MyParser()\n```\n\n```\nlist(parser.lazy_parse(blob))\n```\n\n```\n[Document(page_content='meow meow🐱 \\n', metadata={'line_number': 1, 'source': './meow.txt'}), Document(page_content=' meow meow🐱 \\n', metadata={'line_number': 2, 'source': './meow.txt'}), Document(page_content=' meow😻😻', metadata={'line_number': 3, 'source': './meow.txt'})]\n```\n\nUsing the **blob** API also allows one to load content directly from memory without having to read it from a file!\n\n```\nblob = Blob(data=b\"some data from memory\\nmeow\")list(parser.lazy_parse(blob))\n```\n\n```\n[Document(page_content='some data from memory\\n', metadata={'line_number': 1, 'source': None}), Document(page_content='meow', metadata={'line_number': 2, 'source': None})]\n```\n\n### Blob[​](#blob \"Direct link to Blob\")\n\nLet's take a quick look through some of the Blob API.\n\n```\nblob = Blob.from_path(\"./meow.txt\", metadata={\"foo\": \"bar\"})\n```\n\n```\nb'meow meow\\xf0\\x9f\\x90\\xb1 \\n meow meow\\xf0\\x9f\\x90\\xb1 \\n meow\\xf0\\x9f\\x98\\xbb\\xf0\\x9f\\x98\\xbb'\n```\n\n```\n'meow meow🐱 \\n meow meow🐱 \\n meow😻😻'\n```\n\n```\n<contextlib._GeneratorContextManager at 0x743f34324450>\n```\n\n### Blob Loaders[​](#blob-loaders \"Direct link to Blob Loaders\")\n\nWhile a parser encapsulates the logic needed to parse binary data into documents, _blob loaders_ encapsulate the logic that's necessary to load blobs from a given storage location.\n\nA the moment, `LangChain` only supports `FileSystemBlobLoader`.\n\nYou can use the `FileSystemBlobLoader` to load blobs and then use the parser to parse them.\n\n```\nfrom langchain_community.document_loaders.blob_loaders import FileSystemBlobLoaderblob_loader = FileSystemBlobLoader(path=\".\", glob=\"*.mdx\", show_progress=True)\n```\n\n```\nparser = MyParser()for blob in blob_loader.yield_blobs():    for doc in parser.lazy_parse(blob):        print(doc)        break\n```\n\n```\n  0%|          | 0/8 [00:00<?, ?it/s]\n```\n\n```\npage_content='# Microsoft Office\\n' metadata={'line_number': 1, 'source': 'office_file.mdx'}page_content='# Markdown\\n' metadata={'line_number': 1, 'source': 'markdown.mdx'}page_content='# JSON\\n' metadata={'line_number': 1, 'source': 'json.mdx'}page_content='---\\n' metadata={'line_number': 1, 'source': 'pdf.mdx'}page_content='---\\n' metadata={'line_number': 1, 'source': 'index.mdx'}page_content='# File Directory\\n' metadata={'line_number': 1, 'source': 'file_directory.mdx'}page_content='# CSV\\n' metadata={'line_number': 1, 'source': 'csv.mdx'}page_content='# HTML\\n' metadata={'line_number': 1, 'source': 'html.mdx'}\n```\n\n### Generic Loader[​](#generic-loader \"Direct link to Generic Loader\")\n\nLangChain has a `GenericLoader` abstraction which composes a `BlobLoader` with a `BaseBlobParser`.\n\n`GenericLoader` is meant to provide standardized classmethods that make it easy to use existing `BlobLoader` implementations. At the moment, only the `FileSystemBlobLoader` is supported.\n\n```\nfrom langchain_community.document_loaders.generic import GenericLoaderloader = GenericLoader.from_filesystem(    path=\".\", glob=\"*.mdx\", show_progress=True, parser=MyParser())for idx, doc in enumerate(loader.lazy_load()):    if idx < 5:        print(doc)print(\"... output truncated for demo purposes\")\n```\n\n```\n  0%|          | 0/8 [00:00<?, ?it/s]\n```\n\n```\npage_content='# Microsoft Office\\n' metadata={'line_number': 1, 'source': 'office_file.mdx'}page_content='\\n' metadata={'line_number': 2, 'source': 'office_file.mdx'}page_content='>[The Microsoft Office](https://www.office.com/) suite of productivity software includes Microsoft Word, Microsoft Excel, Microsoft PowerPoint, Microsoft Outlook, and Microsoft OneNote. It is available for Microsoft Windows and macOS operating systems. It is also available on Android and iOS.\\n' metadata={'line_number': 3, 'source': 'office_file.mdx'}page_content='\\n' metadata={'line_number': 4, 'source': 'office_file.mdx'}page_content='This covers how to load commonly used file formats including `DOCX`, `XLSX` and `PPTX` documents into a document format that we can use downstream.\\n' metadata={'line_number': 5, 'source': 'office_file.mdx'}... output truncated for demo purposes\n```\n\n#### Custom Generic Loader[​](#custom-generic-loader \"Direct link to Custom Generic Loader\")\n\nIf you really like creating classes, you can sub-class and create a class to encapsulate the logic together.\n\nYou can sub-class from this class to load content using an existing loader.\n\n```\nfrom typing import Anyclass MyCustomLoader(GenericLoader):    @staticmethod    def get_parser(**kwargs: Any) -> BaseBlobParser:        \"\"\"Override this method to associate a default parser with the class.\"\"\"        return MyParser()\n```\n\n```\nloader = MyCustomLoader.from_filesystem(path=\".\", glob=\"*.mdx\", show_progress=True)for idx, doc in enumerate(loader.lazy_load()):    if idx < 5:        print(doc)print(\"... output truncated for demo purposes\")\n```\n\n```\n  0%|          | 0/8 [00:00<?, ?it/s]\n```\n\n```\npage_content='# Microsoft Office\\n' metadata={'line_number': 1, 'source': 'office_file.mdx'}page_content='\\n' metadata={'line_number': 2, 'source': 'office_file.mdx'}page_content='>[The Microsoft Office](https://www.office.com/) suite of productivity software includes Microsoft Word, Microsoft Excel, Microsoft PowerPoint, Microsoft Outlook, and Microsoft OneNote. It is available for Microsoft Windows and macOS operating systems. It is also available on Android and iOS.\\n' metadata={'line_number': 3, 'source': 'office_file.mdx'}page_content='\\n' metadata={'line_number': 4, 'source': 'office_file.mdx'}page_content='This covers how to load commonly used file formats including `DOCX`, `XLSX` and `PPTX` documents into a document format that we can use downstream.\\n' metadata={'line_number': 5, 'source': 'office_file.mdx'}... output truncated for demo purposes\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/inspect/",
  "markdown": "# giscus\n\n## How to inspect runnables\n\nOnce you create a runnable with [LangChain Expression Language](https://python.langchain.com/docs/concepts/lcel/), you may often want to inspect it to get a better sense for what is going on. This notebook covers some methods for doing so.\n\nThis guide shows some ways you can programmatically introspect the internal steps of chains. If you are instead interested in debugging issues in your chain, see [this section](https://python.langchain.com/docs/how_to/debugging/) instead.\n\nFirst, let's create an example chain. We will create one that does retrieval:\n\n```\n%pip install -qU langchain langchain-openai faiss-cpu tiktoken\n```\n\n```\nfrom langchain_community.vectorstores import FAISSfrom langchain_core.output_parsers import StrOutputParserfrom langchain_core.prompts import ChatPromptTemplatefrom langchain_core.runnables import RunnablePassthroughfrom langchain_openai import ChatOpenAI, OpenAIEmbeddingsvectorstore = FAISS.from_texts(    [\"harrison worked at kensho\"], embedding=OpenAIEmbeddings())retriever = vectorstore.as_retriever()template = \"\"\"Answer the question based only on the following context:{context}Question: {question}\"\"\"prompt = ChatPromptTemplate.from_template(template)model = ChatOpenAI()chain = (    {\"context\": retriever, \"question\": RunnablePassthrough()}    | prompt    | model    | StrOutputParser())\n```\n\n## Get a graph[​](#get-a-graph \"Direct link to Get a graph\")\n\nYou can use the `get_graph()` method to get a graph representation of the runnable:\n\n## Print a graph[​](#print-a-graph \"Direct link to Print a graph\")\n\nWhile that is not super legible, you can use the `print_ascii()` method to show that graph in a way that's easier to understand:\n\n```\nchain.get_graph().print_ascii()\n```\n\n```\n           +---------------------------------+                    | Parallel<context,question>Input |                    +---------------------------------+                             **               **                                 ***                   ***                            **                         **           +----------------------+              +-------------+  | VectorStoreRetriever |              | Passthrough |  +----------------------+              +-------------+                      **               **                                      ***         ***                                           **     **                                +----------------------------------+                   | Parallel<context,question>Output |                   +----------------------------------+                                     *                                                      *                                                      *                                           +--------------------+                                 | ChatPromptTemplate |                                 +--------------------+                                            *                                                      *                                                      *                                               +------------+                                         | ChatOpenAI |                                         +------------+                                                *                                                      *                                                      *                                            +-----------------+                                    | StrOutputParser |                                    +-----------------+                                              *                                                      *                                                      *                                         +-----------------------+                              | StrOutputParserOutput |                              +-----------------------+\n```\n\n## Get the prompts[​](#get-the-prompts \"Direct link to Get the prompts\")\n\nYou may want to see just the prompts that are used in a chain with the `get_prompts()` method:\n\n```\n[ChatPromptTemplate(input_variables=['context', 'question'], messages=[HumanMessagePromptTemplate(prompt=PromptTemplate(input_variables=['context', 'question'], template='Answer the question based only on the following context:\\n{context}\\n\\nQuestion: {question}\\n'))])]\n```\n\n## Next steps[​](#next-steps \"Direct link to Next steps\")\n\nYou've now learned how to introspect your composed LCEL chains.\n\nNext, check out the other how-to guides on runnables in this section, or the related how-to guide on [debugging your chains](https://python.langchain.com/docs/how_to/debugging/)."
},
{
  "url": "https://python.langchain.com/docs/how_to/self_query/",
  "markdown": "# giscus\n\n## How to do \"self-querying\" retrieval\n\ninfo\n\nHead to [Integrations](https://python.langchain.com/docs/integrations/retrievers/self_query/) for documentation on vector stores with built-in support for self-querying.\n\nA self-querying [retriever](https://python.langchain.com/docs/concepts/retrievers/) is one that, as the name suggests, has the ability to query itself. Specifically, given any natural language query, the retriever uses a query-constructing LLM chain to write a structured query and then applies that structured query to its underlying [vector store](https://python.langchain.com/docs/concepts/vectorstores/). This allows the retriever to not only use the user-input query for semantic similarity comparison with the contents of stored documents but to also extract filters from the user query on the metadata of stored documents and to execute those filters.\n\n![](https://python.langchain.com/assets/images/self_querying-26ac0fc8692e85bc3cd9b8640509404f.jpg)\n\n## Get started[​](#get-started \"Direct link to Get started\")\n\nFor demonstration purposes we'll use a `Chroma` vector store. We've created a small demo set of documents that contain summaries of movies.\n\n**Note:** The self-query retriever requires you to have `lark` package installed.\n\n```\n%pip install --upgrade --quiet  lark langchain-chroma\n```\n\n```\nfrom langchain_chroma import Chromafrom langchain_core.documents import Documentfrom langchain_openai import OpenAIEmbeddingsdocs = [    Document(        page_content=\"A bunch of scientists bring back dinosaurs and mayhem breaks loose\",        metadata={\"year\": 1993, \"rating\": 7.7, \"genre\": \"science fiction\"},    ),    Document(        page_content=\"Leo DiCaprio gets lost in a dream within a dream within a dream within a ...\",        metadata={\"year\": 2010, \"director\": \"Christopher Nolan\", \"rating\": 8.2},    ),    Document(        page_content=\"A psychologist / detective gets lost in a series of dreams within dreams within dreams and Inception reused the idea\",        metadata={\"year\": 2006, \"director\": \"Satoshi Kon\", \"rating\": 8.6},    ),    Document(        page_content=\"A bunch of normal-sized women are supremely wholesome and some men pine after them\",        metadata={\"year\": 2019, \"director\": \"Greta Gerwig\", \"rating\": 8.3},    ),    Document(        page_content=\"Toys come alive and have a blast doing so\",        metadata={\"year\": 1995, \"genre\": \"animated\"},    ),    Document(        page_content=\"Three men walk into the Zone, three men walk out of the Zone\",        metadata={            \"year\": 1979,            \"director\": \"Andrei Tarkovsky\",            \"genre\": \"thriller\",            \"rating\": 9.9,        },    ),]vectorstore = Chroma.from_documents(docs, OpenAIEmbeddings())\n```\n\n### Creating our self-querying retriever[​](#creating-our-self-querying-retriever \"Direct link to Creating our self-querying retriever\")\n\nNow we can instantiate our retriever. To do this we'll need to provide some information upfront about the metadata fields that our documents support and a short description of the document contents.\n\n```\nfrom langchain.chains.query_constructor.schema import AttributeInfofrom langchain.retrievers.self_query.base import SelfQueryRetrieverfrom langchain_openai import ChatOpenAImetadata_field_info = [    AttributeInfo(        name=\"genre\",        description=\"The genre of the movie. One of ['science fiction', 'comedy', 'drama', 'thriller', 'romance', 'action', 'animated']\",        type=\"string\",    ),    AttributeInfo(        name=\"year\",        description=\"The year the movie was released\",        type=\"integer\",    ),    AttributeInfo(        name=\"director\",        description=\"The name of the movie director\",        type=\"string\",    ),    AttributeInfo(        name=\"rating\", description=\"A 1-10 rating for the movie\", type=\"float\"    ),]document_content_description = \"Brief summary of a movie\"llm = ChatOpenAI(temperature=0)retriever = SelfQueryRetriever.from_llm(    llm,    vectorstore,    document_content_description,    metadata_field_info,)\n```\n\n### Testing it out[​](#testing-it-out \"Direct link to Testing it out\")\n\nAnd now we can actually try using our retriever!\n\n```\n# This example only specifies a filterretriever.invoke(\"I want to watch a movie rated higher than 8.5\")\n```\n\n```\n[Document(page_content='Three men walk into the Zone, three men walk out of the Zone', metadata={'director': 'Andrei Tarkovsky', 'genre': 'thriller', 'rating': 9.9, 'year': 1979}), Document(page_content='A psychologist / detective gets lost in a series of dreams within dreams within dreams and Inception reused the idea', metadata={'director': 'Satoshi Kon', 'rating': 8.6, 'year': 2006})]\n```\n\n```\n# This example specifies a query and a filterretriever.invoke(\"Has Greta Gerwig directed any movies about women\")\n```\n\n```\n[Document(page_content='A bunch of normal-sized women are supremely wholesome and some men pine after them', metadata={'director': 'Greta Gerwig', 'rating': 8.3, 'year': 2019})]\n```\n\n```\n# This example specifies a composite filterretriever.invoke(\"What's a highly rated (above 8.5) science fiction film?\")\n```\n\n```\n[Document(page_content='A psychologist / detective gets lost in a series of dreams within dreams within dreams and Inception reused the idea', metadata={'director': 'Satoshi Kon', 'rating': 8.6, 'year': 2006}), Document(page_content='Three men walk into the Zone, three men walk out of the Zone', metadata={'director': 'Andrei Tarkovsky', 'genre': 'thriller', 'rating': 9.9, 'year': 1979})]\n```\n\n```\n# This example specifies a query and composite filterretriever.invoke(    \"What's a movie after 1990 but before 2005 that's all about toys, and preferably is animated\")\n```\n\n```\n[Document(page_content='Toys come alive and have a blast doing so', metadata={'genre': 'animated', 'year': 1995})]\n```\n\n### Filter k[​](#filter-k \"Direct link to Filter k\")\n\nWe can also use the self query retriever to specify `k`: the number of documents to fetch.\n\nWe can do this by passing `enable_limit=True` to the constructor.\n\n```\nretriever = SelfQueryRetriever.from_llm(    llm,    vectorstore,    document_content_description,    metadata_field_info,    enable_limit=True,)# This example only specifies a relevant queryretriever.invoke(\"What are two movies about dinosaurs\")\n```\n\n```\n[Document(page_content='A bunch of scientists bring back dinosaurs and mayhem breaks loose', metadata={'genre': 'science fiction', 'rating': 7.7, 'year': 1993}), Document(page_content='Toys come alive and have a blast doing so', metadata={'genre': 'animated', 'year': 1995})]\n```\n\n## Constructing from scratch with LCEL[​](#constructing-from-scratch-with-lcel \"Direct link to Constructing from scratch with LCEL\")\n\nTo see what's going on under the hood, and to have more custom control, we can reconstruct our retriever from scratch.\n\nFirst, we need to create a query-construction chain. This chain will take a user query and generated a `StructuredQuery` object which captures the filters specified by the user. We provide some helper functions for creating a prompt and output parser. These have a number of tunable params that we'll ignore here for simplicity.\n\n```\nfrom langchain.chains.query_constructor.base import (    StructuredQueryOutputParser,    get_query_constructor_prompt,)prompt = get_query_constructor_prompt(    document_content_description,    metadata_field_info,)output_parser = StructuredQueryOutputParser.from_components()query_constructor = prompt | llm | output_parser\n```\n\nLet's look at our prompt:\n\n```\nprint(prompt.format(query=\"dummy question\"))\n```\n\n```\nYour goal is to structure the user's query to match the request schema provided below.<< Structured Request Schema >>When responding use a markdown code snippet with a JSON object formatted in the following schema:\\`\\`\\`json{    \"query\": string \\ text string to compare to document contents    \"filter\": string \\ logical condition statement for filtering documents}\\`\\`\\`The query string should contain only text that is expected to match the contents of documents. Any conditions in the filter should not be mentioned in the query as well.A logical condition statement is composed of one or more comparison and logical operation statements.A comparison statement takes the form: `comp(attr, val)`:- `comp` (eq | ne | gt | gte | lt | lte | contain | like | in | nin): comparator- `attr` (string):  name of attribute to apply the comparison to- `val` (string): is the comparison valueA logical operation statement takes the form `op(statement1, statement2, ...)`:- `op` (and | or | not): logical operator- `statement1`, `statement2`, ... (comparison statements or logical operation statements): one or more statements to apply the operation toMake sure that you only use the comparators and logical operators listed above and no others.Make sure that filters only refer to attributes that exist in the data source.Make sure that filters only use the attributed names with its function names if there are functions applied on them.Make sure that filters only use format `YYYY-MM-DD` when handling date data typed values.Make sure that filters take into account the descriptions of attributes and only make comparisons that are feasible given the type of data being stored.Make sure that filters are only used as needed. If there are no filters that should be applied return \"NO_FILTER\" for the filter value.<< Example 1. >>Data Source:\\`\\`\\`json{    \"content\": \"Lyrics of a song\",    \"attributes\": {        \"artist\": {            \"type\": \"string\",            \"description\": \"Name of the song artist\"        },        \"length\": {            \"type\": \"integer\",            \"description\": \"Length of the song in seconds\"        },        \"genre\": {            \"type\": \"string\",            \"description\": \"The song genre, one of \"pop\", \"rock\" or \"rap\"\"        }    }}\\`\\`\\`User Query:What are songs by Taylor Swift or Katy Perry about teenage romance under 3 minutes long in the dance pop genreStructured Request:\\`\\`\\`json{    \"query\": \"teenager love\",    \"filter\": \"and(or(eq(\\\"artist\\\", \\\"Taylor Swift\\\"), eq(\\\"artist\\\", \\\"Katy Perry\\\")), lt(\\\"length\\\", 180), eq(\\\"genre\\\", \\\"pop\\\"))\"}\\`\\`\\`<< Example 2. >>Data Source:\\`\\`\\`json{    \"content\": \"Lyrics of a song\",    \"attributes\": {        \"artist\": {            \"type\": \"string\",            \"description\": \"Name of the song artist\"        },        \"length\": {            \"type\": \"integer\",            \"description\": \"Length of the song in seconds\"        },        \"genre\": {            \"type\": \"string\",            \"description\": \"The song genre, one of \"pop\", \"rock\" or \"rap\"\"        }    }}\\`\\`\\`User Query:What are songs that were not published on SpotifyStructured Request:\\`\\`\\`json{    \"query\": \"\",    \"filter\": \"NO_FILTER\"}\\`\\`\\`<< Example 3. >>Data Source:\\`\\`\\`json{    \"content\": \"Brief summary of a movie\",    \"attributes\": {    \"genre\": {        \"description\": \"The genre of the movie. One of ['science fiction', 'comedy', 'drama', 'thriller', 'romance', 'action', 'animated']\",        \"type\": \"string\"    },    \"year\": {        \"description\": \"The year the movie was released\",        \"type\": \"integer\"    },    \"director\": {        \"description\": \"The name of the movie director\",        \"type\": \"string\"    },    \"rating\": {        \"description\": \"A 1-10 rating for the movie\",        \"type\": \"float\"    }}}\\`\\`\\`User Query:dummy questionStructured Request:\n```\n\nAnd what our full chain produces:\n\n```\nquery_constructor.invoke(    {        \"query\": \"What are some sci-fi movies from the 90's directed by Luc Besson about taxi drivers\"    })\n```\n\n```\nStructuredQuery(query='taxi driver', filter=Operation(operator=<Operator.AND: 'and'>, arguments=[Comparison(comparator=<Comparator.EQ: 'eq'>, attribute='genre', value='science fiction'), Operation(operator=<Operator.AND: 'and'>, arguments=[Comparison(comparator=<Comparator.GTE: 'gte'>, attribute='year', value=1990), Comparison(comparator=<Comparator.LT: 'lt'>, attribute='year', value=2000)]), Comparison(comparator=<Comparator.EQ: 'eq'>, attribute='director', value='Luc Besson')]), limit=None)\n```\n\nThe query constructor is the key element of the self-query retriever. To make a great retrieval system you'll need to make sure your query constructor works well. Often this requires adjusting the prompt, the examples in the prompt, the attribute descriptions, etc. For an example that walks through refining a query constructor on some hotel inventory data, [check out this cookbook](https://github.com/langchain-ai/langchain/blob/master/cookbook/self_query_hotel_search.ipynb).\n\nThe next key element is the structured query translator. This is the object responsible for translating the generic `StructuredQuery` object into a metadata filter in the syntax of the vector store you're using. LangChain comes with a number of built-in translators. To see them all head to the [Integrations section](https://python.langchain.com/docs/integrations/retrievers/self_query/).\n\n```\nfrom langchain_community.query_constructors.chroma import ChromaTranslatorretriever = SelfQueryRetriever(    query_constructor=query_constructor,    vectorstore=vectorstore,    structured_query_translator=ChromaTranslator(),)\n```\n\n```\nretriever.invoke(    \"What's a movie after 1990 but before 2005 that's all about toys, and preferably is animated\")\n```\n\n```\n[Document(page_content='Toys come alive and have a blast doing so', metadata={'genre': 'animated', 'year': 1995})]\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/MultiQueryRetriever/",
  "markdown": "# giscus\n\n[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/langchain-ai/langchain/blob/master/docs/docs/how_to/MultiQueryRetriever.ipynb)[![Open on GitHub](https://img.shields.io/badge/Open%20on%20GitHub-grey?logo=github&logoColor=white)](https://github.com/langchain-ai/langchain/blob/master/docs/docs/how_to/MultiQueryRetriever.ipynb)\n\n## How to use the MultiQueryRetriever\n\nDistance-based [vector database](https://python.langchain.com/docs/concepts/vectorstores/) retrieval [embeds](https://python.langchain.com/docs/concepts/embedding_models/) (represents) queries in high-dimensional space and finds similar embedded documents based on a distance metric. But, retrieval may produce different results with subtle changes in query wording, or if the embeddings do not capture the semantics of the data well. Prompt engineering / tuning is sometimes done to manually address these problems, but can be tedious.\n\nThe [MultiQueryRetriever](https://python.langchain.com/api_reference/langchain/retrievers/langchain.retrievers.multi_query.MultiQueryRetriever.html) automates the process of prompt tuning by using an LLM to generate multiple queries from different perspectives for a given user input query. For each query, it retrieves a set of relevant documents and takes the unique union across all queries to get a larger set of potentially relevant documents. By generating multiple perspectives on the same question, the `MultiQueryRetriever` can mitigate some of the limitations of the distance-based retrieval and get a richer set of results.\n\nLet's build a vectorstore using the [LLM Powered Autonomous Agents](https://lilianweng.github.io/posts/2023-06-23-agent/) blog post by Lilian Weng from the [RAG tutorial](https://python.langchain.com/docs/tutorials/rag/):\n\n```\n# Build a sample vectorDBfrom langchain_chroma import Chromafrom langchain_community.document_loaders import WebBaseLoaderfrom langchain_openai import OpenAIEmbeddingsfrom langchain_text_splitters import RecursiveCharacterTextSplitter# Load blog postloader = WebBaseLoader(\"https://lilianweng.github.io/posts/2023-06-23-agent/\")data = loader.load()# Splittext_splitter = RecursiveCharacterTextSplitter(chunk_size=500, chunk_overlap=0)splits = text_splitter.split_documents(data)# VectorDBembedding = OpenAIEmbeddings()vectordb = Chroma.from_documents(documents=splits, embedding=embedding)\n```\n\n```\nUSER_AGENT environment variable not set, consider setting it to identify your requests.\n```\n\n#### Simple usage[​](#simple-usage \"Direct link to Simple usage\")\n\nSpecify the LLM to use for query generation, and the retriever will do the rest.\n\n```\nfrom langchain.retrievers.multi_query import MultiQueryRetrieverfrom langchain_openai import ChatOpenAIquestion = \"What are the approaches to Task Decomposition?\"llm = ChatOpenAI(temperature=0)retriever_from_llm = MultiQueryRetriever.from_llm(    retriever=vectordb.as_retriever(), llm=llm)\n```\n\n```\n# Set logging for the queriesimport logginglogging.basicConfig()logging.getLogger(\"langchain.retrievers.multi_query\").setLevel(logging.INFO)\n```\n\n```\nunique_docs = retriever_from_llm.invoke(question)len(unique_docs)\n```\n\n```\nINFO:langchain.retrievers.multi_query:Generated queries: ['1. How can Task Decomposition be achieved through different methods?', '2. What strategies are commonly used for Task Decomposition?', '3. What are the various ways to break down tasks in Task Decomposition?']\n```\n\nNote that the underlying queries generated by the [retriever](https://python.langchain.com/docs/concepts/retrievers/) are logged at the `INFO` level.\n\n#### Supplying your own prompt[​](#supplying-your-own-prompt \"Direct link to Supplying your own prompt\")\n\nUnder the hood, `MultiQueryRetriever` generates queries using a specific [prompt](https://python.langchain.com/api_reference/langchain/retrievers/langchain.retrievers.multi_query.MultiQueryRetriever.html). To customize this prompt:\n\n1.  Make a [PromptTemplate](https://python.langchain.com/api_reference/core/prompts/langchain_core.prompts.prompt.PromptTemplate.html) with an input variable for the question;\n2.  Implement an [output parser](https://python.langchain.com/docs/concepts/output_parsers/) like the one below to split the result into a list of queries.\n\nThe prompt and output parser together must support the generation of a list of queries.\n\n```\nfrom typing import Listfrom langchain_core.output_parsers import BaseOutputParserfrom langchain_core.prompts import PromptTemplatefrom pydantic import BaseModel, Field# Output parser will split the LLM result into a list of queriesclass LineListOutputParser(BaseOutputParser[List[str]]):    \"\"\"Output parser for a list of lines.\"\"\"    def parse(self, text: str) -> List[str]:        lines = text.strip().split(\"\\n\")        return list(filter(None, lines))  # Remove empty linesoutput_parser = LineListOutputParser()QUERY_PROMPT = PromptTemplate(    input_variables=[\"question\"],    template=\"\"\"You are an AI language model assistant. Your task is to generate five     different versions of the given user question to retrieve relevant documents from a vector     database. By generating multiple perspectives on the user question, your goal is to help    the user overcome some of the limitations of the distance-based similarity search.     Provide these alternative questions separated by newlines.    Original question: {question}\"\"\",)llm = ChatOpenAI(temperature=0)# Chainllm_chain = QUERY_PROMPT | llm | output_parser# Other inputsquestion = \"What are the approaches to Task Decomposition?\"\n```\n\n```\n# Runretriever = MultiQueryRetriever(    retriever=vectordb.as_retriever(), llm_chain=llm_chain, parser_key=\"lines\")  # \"lines\" is the key (attribute name) of the parsed output# Resultsunique_docs = retriever.invoke(\"What does the course say about regression?\")len(unique_docs)\n```\n\n```\nINFO:langchain.retrievers.multi_query:Generated queries: ['1. Can you provide insights on regression from the course material?', '2. How is regression discussed in the course content?', '3. What information does the course offer regarding regression?', '4. In what way is regression covered in the course?', \"5. What are the course's teachings on regression?\"]\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/few_shot_examples_chat/",
  "markdown": "# giscus\n\n## How to use few shot examples in chat models\n\nThis guide covers how to prompt a chat model with example inputs and outputs. Providing the model with a few such examples is called [few-shotting](https://python.langchain.com/docs/concepts/few_shot_prompting/), and is a simple yet powerful way to guide generation and in some cases drastically improve model performance.\n\nThere does not appear to be solid consensus on how best to do few-shot prompting, and the optimal prompt compilation will likely vary by model. Because of this, we provide few-shot prompt templates like the [FewShotChatMessagePromptTemplate](https://python.langchain.com/api_reference/core/prompts/langchain_core.prompts.few_shot.FewShotChatMessagePromptTemplate.html?highlight=fewshot#langchain_core.prompts.few_shot.FewShotChatMessagePromptTemplate) as a flexible starting point, and you can modify or replace them as you see fit.\n\nThe goal of few-shot prompt templates are to dynamically select examples based on an input, and then format the examples in a final prompt to provide for the model.\n\n**Note:** The following code examples are for chat models only, since `FewShotChatMessagePromptTemplates` are designed to output formatted [chat messages](https://python.langchain.com/docs/concepts/messages/) rather than pure strings. For similar few-shot prompt examples for pure string templates compatible with completion models (LLMs), see the [few-shot prompt templates](https://python.langchain.com/docs/how_to/few_shot_examples/) guide.\n\n## Fixed Examples[​](#fixed-examples \"Direct link to Fixed Examples\")\n\nThe most basic (and common) few-shot prompting technique is to use fixed prompt examples. This way you can select a chain, evaluate it, and avoid worrying about additional moving parts in production.\n\nThe basic components of the template are:\n\n*   `examples`: A list of dictionary examples to include in the final prompt.\n*   `example_prompt`: converts each example into 1 or more messages through its [`format_messages`](https://python.langchain.com/api_reference/core/prompts/langchain_core.prompts.chat.ChatPromptTemplate.html?highlight=format_messages#langchain_core.prompts.chat.ChatPromptTemplate.format_messages) method. A common example would be to convert each example into one human message and one AI message response, or a human message followed by a function call message.\n\nBelow is a simple demonstration. First, define the examples you'd like to include. Let's give the LLM an unfamiliar mathematical operator, denoted by the \"🦜\" emoji:\n\n```\n%pip install -qU langchain langchain-openai langchain-chromaimport osfrom getpass import getpassif \"OPENAI_API_KEY\" not in os.environ:    os.environ[\"OPENAI_API_KEY\"] = getpass()\n```\n\nIf we try to ask the model what the result of this expression is, it will fail:\n\n```\nfrom langchain_openai import ChatOpenAImodel = ChatOpenAI(model=\"gpt-4o-mini\", temperature=0.0)model.invoke(\"What is 2 🦜 9?\")\n```\n\n```\nAIMessage(content='The expression \"2 🦜 9\" is not a standard mathematical operation or equation. It appears to be a combination of the number 2 and the parrot emoji 🦜 followed by the number 9. It does not have a specific mathematical meaning.', response_metadata={'token_usage': {'completion_tokens': 54, 'prompt_tokens': 17, 'total_tokens': 71}, 'model_name': 'gpt-4o-mini', 'system_fingerprint': None, 'finish_reason': 'stop', 'logprobs': None}, id='run-aad12dda-5c47-4a1e-9949-6fe94e03242a-0', usage_metadata={'input_tokens': 17, 'output_tokens': 54, 'total_tokens': 71})\n```\n\nNow let's see what happens if we give the LLM some examples to work with. We'll define some below:\n\n```\nfrom langchain_core.prompts import ChatPromptTemplate, FewShotChatMessagePromptTemplateexamples = [    {\"input\": \"2 🦜 2\", \"output\": \"4\"},    {\"input\": \"2 🦜 3\", \"output\": \"5\"},]\n```\n\nNext, assemble them into the few-shot prompt template.\n\n```\n# This is a prompt template used to format each individual example.example_prompt = ChatPromptTemplate.from_messages(    [        (\"human\", \"{input}\"),        (\"ai\", \"{output}\"),    ])few_shot_prompt = FewShotChatMessagePromptTemplate(    example_prompt=example_prompt,    examples=examples,)print(few_shot_prompt.invoke({}).to_messages())\n```\n\n```\n[HumanMessage(content='2 🦜 2'), AIMessage(content='4'), HumanMessage(content='2 🦜 3'), AIMessage(content='5')]\n```\n\nFinally, we assemble the final prompt as shown below, passing `few_shot_prompt` directly into the `from_messages` factory method, and use it with a model:\n\n```\nfinal_prompt = ChatPromptTemplate.from_messages(    [        (\"system\", \"You are a wondrous wizard of math.\"),        few_shot_prompt,        (\"human\", \"{input}\"),    ])\n```\n\nAnd now let's ask the model the initial question and see how it does:\n\n```\nfrom langchain_openai import ChatOpenAIchain = final_prompt | modelchain.invoke({\"input\": \"What is 2 🦜 9?\"})\n```\n\n```\nAIMessage(content='11', response_metadata={'token_usage': {'completion_tokens': 1, 'prompt_tokens': 60, 'total_tokens': 61}, 'model_name': 'gpt-4o-mini', 'system_fingerprint': None, 'finish_reason': 'stop', 'logprobs': None}, id='run-5ec4e051-262f-408e-ad00-3f2ebeb561c3-0', usage_metadata={'input_tokens': 60, 'output_tokens': 1, 'total_tokens': 61})\n```\n\nAnd we can see that the model has now inferred that the parrot emoji means addition from the given few-shot examples!\n\n## Dynamic few-shot prompting[​](#dynamic-few-shot-prompting \"Direct link to Dynamic few-shot prompting\")\n\nSometimes you may want to select only a few examples from your overall set to show based on the input. For this, you can replace the `examples` passed into `FewShotChatMessagePromptTemplate` with an `example_selector`. The other components remain the same as above! Our dynamic few-shot prompt template would look like:\n\n*   `example_selector`: responsible for selecting few-shot examples (and the order in which they are returned) for a given input. These implement the [BaseExampleSelector](https://python.langchain.com/api_reference/core/example_selectors/langchain_core.example_selectors.base.BaseExampleSelector.html?highlight=baseexampleselector#langchain_core.example_selectors.base.BaseExampleSelector) interface. A common example is the vectorstore-backed [SemanticSimilarityExampleSelector](https://python.langchain.com/api_reference/core/example_selectors/langchain_core.example_selectors.semantic_similarity.SemanticSimilarityExampleSelector.html?highlight=semanticsimilarityexampleselector#langchain_core.example_selectors.semantic_similarity.SemanticSimilarityExampleSelector)\n*   `example_prompt`: convert each example into 1 or more messages through its [`format_messages`](https://python.langchain.com/api_reference/core/prompts/langchain_core.prompts.chat.ChatPromptTemplate.html?highlight=chatprompttemplate#langchain_core.prompts.chat.ChatPromptTemplate.format_messages) method. A common example would be to convert each example into one human message and one AI message response, or a human message followed by a function call message.\n\nThese once again can be composed with other messages and chat templates to assemble your final prompt.\n\nLet's walk through an example with the `SemanticSimilarityExampleSelector`. Since this implementation uses a vectorstore to select examples based on semantic similarity, we will want to first populate the store. Since the basic idea here is that we want to search for and return examples most similar to the text input, we embed the `values` of our prompt examples rather than considering the keys:\n\n```\nfrom langchain_chroma import Chromafrom langchain_core.example_selectors import SemanticSimilarityExampleSelectorfrom langchain_openai import OpenAIEmbeddingsexamples = [    {\"input\": \"2 🦜 2\", \"output\": \"4\"},    {\"input\": \"2 🦜 3\", \"output\": \"5\"},    {\"input\": \"2 🦜 4\", \"output\": \"6\"},    {\"input\": \"What did the cow say to the moon?\", \"output\": \"nothing at all\"},    {        \"input\": \"Write me a poem about the moon\",        \"output\": \"One for the moon, and one for me, who are we to talk about the moon?\",    },]to_vectorize = [\" \".join(example.values()) for example in examples]embeddings = OpenAIEmbeddings()vectorstore = Chroma.from_texts(to_vectorize, embeddings, metadatas=examples)\n```\n\n### Create the `example_selector`[​](#create-the-example_selector \"Direct link to create-the-example_selector\")\n\nWith a vectorstore created, we can create the `example_selector`. Here we will call it in isolation, and set `k` on it to only fetch the two example closest to the input.\n\n```\nexample_selector = SemanticSimilarityExampleSelector(    vectorstore=vectorstore,    k=2,)# The prompt template will load examples by passing the input do the `select_examples` methodexample_selector.select_examples({\"input\": \"horse\"})\n```\n\n```\n[{'input': 'What did the cow say to the moon?', 'output': 'nothing at all'}, {'input': '2 🦜 4', 'output': '6'}]\n```\n\n### Create prompt template[​](#create-prompt-template \"Direct link to Create prompt template\")\n\nWe now assemble the prompt template, using the `example_selector` created above.\n\n```\nfrom langchain_core.prompts import ChatPromptTemplate, FewShotChatMessagePromptTemplate# Define the few-shot prompt.few_shot_prompt = FewShotChatMessagePromptTemplate(    # The input variables select the values to pass to the example_selector    input_variables=[\"input\"],    example_selector=example_selector,    # Define how each example will be formatted.    # In this case, each example will become 2 messages:    # 1 human, and 1 AI    example_prompt=ChatPromptTemplate.from_messages(        [(\"human\", \"{input}\"), (\"ai\", \"{output}\")]    ),)print(few_shot_prompt.invoke(input=\"What's 3 🦜 3?\").to_messages())\n```\n\n```\n[HumanMessage(content='2 🦜 3'), AIMessage(content='5'), HumanMessage(content='2 🦜 4'), AIMessage(content='6')]\n```\n\nAnd we can pass this few-shot chat message prompt template into another chat prompt template:\n\n```\nfinal_prompt = ChatPromptTemplate.from_messages(    [        (\"system\", \"You are a wondrous wizard of math.\"),        few_shot_prompt,        (\"human\", \"{input}\"),    ])print(few_shot_prompt.invoke(input=\"What's 3 🦜 3?\"))\n```\n\n```\nmessages=[HumanMessage(content='2 🦜 3'), AIMessage(content='5'), HumanMessage(content='2 🦜 4'), AIMessage(content='6')]\n```\n\n### Use with an chat model[​](#use-with-an-chat-model \"Direct link to Use with an chat model\")\n\nFinally, you can connect your model to the few-shot prompt.\n\n```\nchain = final_prompt | ChatOpenAI(model=\"gpt-4o-mini\", temperature=0.0)chain.invoke({\"input\": \"What's 3 🦜 3?\"})\n```\n\n```\nAIMessage(content='6', response_metadata={'token_usage': {'completion_tokens': 1, 'prompt_tokens': 60, 'total_tokens': 61}, 'model_name': 'gpt-4o-mini', 'system_fingerprint': None, 'finish_reason': 'stop', 'logprobs': None}, id='run-d1863e5e-17cd-4e9d-bf7a-b9f118747a65-0', usage_metadata={'input_tokens': 60, 'output_tokens': 1, 'total_tokens': 61})\n```\n\n## Next steps[​](#next-steps \"Direct link to Next steps\")\n\nYou've now learned how to add few-shot examples to your chat prompts.\n\nNext, check out the other how-to guides on prompt templates in this section, the related how-to guide on [few shotting with text completion models](https://python.langchain.com/docs/how_to/few_shot_examples/), or the other [example selector how-to guides](https://python.langchain.com/docs/how_to/example_selectors/)."
},
{
  "url": "https://python.langchain.com/docs/how_to/document_loader_office_file/",
  "markdown": "# giscus\n\n## How to load Microsoft Office files\n\nThe [Microsoft Office](https://www.office.com/) suite of productivity software includes Microsoft Word, Microsoft Excel, Microsoft PowerPoint, Microsoft Outlook, and Microsoft OneNote. It is available for Microsoft Windows and macOS operating systems. It is also available on Android and iOS.\n\nThis covers how to load commonly used file formats including `DOCX`, `XLSX` and `PPTX` documents into a LangChain [Document](https://python.langchain.com/api_reference/core/documents/langchain_core.documents.base.Document.html#langchain_core.documents.base.Document) object that we can use downstream.\n\n## Loading DOCX, XLSX, PPTX with AzureAIDocumentIntelligenceLoader[​](#loading-docx-xlsx-pptx-with-azureaidocumentintelligenceloader \"Direct link to Loading DOCX, XLSX, PPTX with AzureAIDocumentIntelligenceLoader\")\n\n[Azure AI Document Intelligence](https://aka.ms/doc-intelligence) (formerly known as `Azure Form Recognizer`) is machine-learning based service that extracts texts (including handwriting), tables, document structures (e.g., titles, section headings, etc.) and key-value-pairs from digital or scanned PDFs, images, Office and HTML files. Document Intelligence supports `PDF`, `JPEG/JPG`, `PNG`, `BMP`, `TIFF`, `HEIF`, `DOCX`, `XLSX`, `PPTX` and `HTML`.\n\nThis [current implementation](https://aka.ms/di-langchain) of a loader using `Document Intelligence` can incorporate content page-wise and turn it into LangChain documents. The default output format is markdown, which can be easily chained with `MarkdownHeaderTextSplitter` for semantic document chunking. You can also use `mode=\"single\"` or `mode=\"page\"` to return pure texts in a single page or document split by page.\n\n### Prerequisite[​](#prerequisite \"Direct link to Prerequisite\")\n\nAn Azure AI Document Intelligence resource in one of the 3 preview regions: **East US**, **West US2**, **West Europe** - follow [this document](https://learn.microsoft.com/azure/ai-services/document-intelligence/create-document-intelligence-resource?view=doc-intel-4.0.0) to create one if you don't have. You will be passing `<endpoint>` and `<key>` as parameters to the loader.\n\n```\n%pip install --upgrade --quiet  langchain langchain-community azure-ai-documentintelligencefrom langchain_community.document_loaders import AzureAIDocumentIntelligenceLoaderfile_path = \"<filepath>\"endpoint = \"<endpoint>\"key = \"<key>\"loader = AzureAIDocumentIntelligenceLoader(    api_endpoint=endpoint, api_key=key, file_path=file_path, api_model=\"prebuilt-layout\")documents = loader.load()\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/lcel_cheatsheet/",
  "markdown": "# giscus\n\n## LangChain Expression Language Cheatsheet\n\nThis is a quick reference for all the most important [LCEL](https://python.langchain.com/docs/concepts/lcel/) primitives. For more advanced usage see the [LCEL how-to guides](https://python.langchain.com/docs/how_to/#langchain-expression-language-lcel) and the [full API reference](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html).\n\n### Invoke a runnable[​](#invoke-a-runnable \"Direct link to Invoke a runnable\")\n\n#### [Runnable.invoke()](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.invoke) / [Runnable.ainvoke()](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.ainvoke)[​](#runnableinvoke--runnableainvoke \"Direct link to runnableinvoke--runnableainvoke\")\n\n```\nfrom langchain_core.runnables import RunnableLambdarunnable = RunnableLambda(lambda x: str(x))runnable.invoke(5)# Async variant:# await runnable.ainvoke(5)\n```\n\n### Batch a runnable[​](#batch-a-runnable \"Direct link to Batch a runnable\")\n\n#### [Runnable.batch()](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.batch) / [Runnable.abatch()](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.abatch)[​](#runnablebatch--runnableabatch \"Direct link to runnablebatch--runnableabatch\")\n\n```\nfrom langchain_core.runnables import RunnableLambdarunnable = RunnableLambda(lambda x: str(x))runnable.batch([7, 8, 9])# Async variant:# await runnable.abatch([7, 8, 9])\n```\n\n### Stream a runnable[​](#stream-a-runnable \"Direct link to Stream a runnable\")\n\n#### [Runnable.stream()](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.stream) / [Runnable.astream()](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.astream)[​](#runnablestream--runnableastream \"Direct link to runnablestream--runnableastream\")\n\n```\nfrom langchain_core.runnables import RunnableLambdadef func(x):    for y in x:        yield str(y)runnable = RunnableLambda(func)for chunk in runnable.stream(range(5)):    print(chunk)# Async variant:# async for chunk in await runnable.astream(range(5)):#     print(chunk)\n```\n\n### Compose runnables[​](#compose-runnables \"Direct link to Compose runnables\")\n\n#### Pipe operator `|`[​](#pipe-operator- \"Direct link to pipe-operator-\")\n\n```\nfrom langchain_core.runnables import RunnableLambdarunnable1 = RunnableLambda(lambda x: {\"foo\": x})runnable2 = RunnableLambda(lambda x: [x] * 2)chain = runnable1 | runnable2chain.invoke(2)\n```\n\n### Invoke runnables in parallel[​](#invoke-runnables-in-parallel \"Direct link to Invoke runnables in parallel\")\n\n#### [RunnableParallel](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.RunnableParallel.html)[​](#runnableparallel \"Direct link to runnableparallel\")\n\n```\nfrom langchain_core.runnables import RunnableLambda, RunnableParallelrunnable1 = RunnableLambda(lambda x: {\"foo\": x})runnable2 = RunnableLambda(lambda x: [x] * 2)chain = RunnableParallel(first=runnable1, second=runnable2)chain.invoke(2)\n```\n\n```\n{'first': {'foo': 2}, 'second': [2, 2]}\n```\n\n### Turn any function into a runnable[​](#turn-any-function-into-a-runnable \"Direct link to Turn any function into a runnable\")\n\n#### [RunnableLambda](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.RunnableLambda.html)[​](#runnablelambda \"Direct link to runnablelambda\")\n\n```\nfrom langchain_core.runnables import RunnableLambdadef func(x):    return x + 5runnable = RunnableLambda(func)runnable.invoke(2)\n```\n\n### Merge input and output dicts[​](#merge-input-and-output-dicts \"Direct link to Merge input and output dicts\")\n\n#### [RunnablePassthrough.assign](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.passthrough.RunnablePassthrough.html)[​](#runnablepassthroughassign \"Direct link to runnablepassthroughassign\")\n\n```\nfrom langchain_core.runnables import RunnableLambda, RunnablePassthroughrunnable1 = RunnableLambda(lambda x: x[\"foo\"] + 7)chain = RunnablePassthrough.assign(bar=runnable1)chain.invoke({\"foo\": 10})\n```\n\n### Include input dict in output dict[​](#include-input-dict-in-output-dict \"Direct link to Include input dict in output dict\")\n\n#### [RunnablePassthrough](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.passthrough.RunnablePassthrough.html)[​](#runnablepassthrough \"Direct link to runnablepassthrough\")\n\n```\nfrom langchain_core.runnables import (    RunnableLambda,    RunnableParallel,    RunnablePassthrough,)runnable1 = RunnableLambda(lambda x: x[\"foo\"] + 7)chain = RunnableParallel(bar=runnable1, baz=RunnablePassthrough())chain.invoke({\"foo\": 10})\n```\n\n```\n{'bar': 17, 'baz': {'foo': 10}}\n```\n\n### Add default invocation args[​](#add-default-invocation-args \"Direct link to Add default invocation args\")\n\n#### [Runnable.bind](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.bind)[​](#runnablebind \"Direct link to runnablebind\")\n\n```\nfrom typing import Optionalfrom langchain_core.runnables import RunnableLambdadef func(main_arg: dict, other_arg: Optional[str] = None) -> dict:    if other_arg:        return {**main_arg, **{\"foo\": other_arg}}    return main_argrunnable1 = RunnableLambda(func)bound_runnable1 = runnable1.bind(other_arg=\"bye\")bound_runnable1.invoke({\"bar\": \"hello\"})\n```\n\n```\n{'bar': 'hello', 'foo': 'bye'}\n```\n\n### Add fallbacks[​](#add-fallbacks \"Direct link to Add fallbacks\")\n\n#### [Runnable.with\\_fallbacks](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.with_fallbacks)[​](#runnablewith_fallbacks \"Direct link to runnablewith_fallbacks\")\n\n```\nfrom langchain_core.runnables import RunnableLambdarunnable1 = RunnableLambda(lambda x: x + \"foo\")runnable2 = RunnableLambda(lambda x: str(x) + \"foo\")chain = runnable1.with_fallbacks([runnable2])chain.invoke(5)\n```\n\n### Add retries[​](#add-retries \"Direct link to Add retries\")\n\n#### [Runnable.with\\_retry](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.with_retry)[​](#runnablewith_retry \"Direct link to runnablewith_retry\")\n\n```\nfrom langchain_core.runnables import RunnableLambdacounter = -1def func(x):    global counter    counter += 1    print(f\"attempt with {counter=}\")    return x / counterchain = RunnableLambda(func).with_retry(stop_after_attempt=2)chain.invoke(2)\n```\n\n```\nattempt with counter=0attempt with counter=1\n```\n\n### Configure runnable execution[​](#configure-runnable-execution \"Direct link to Configure runnable execution\")\n\n#### [RunnableConfig](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.config.RunnableConfig.html)[​](#runnableconfig \"Direct link to runnableconfig\")\n\n```\nfrom langchain_core.runnables import RunnableLambda, RunnableParallelrunnable1 = RunnableLambda(lambda x: {\"foo\": x})runnable2 = RunnableLambda(lambda x: [x] * 2)runnable3 = RunnableLambda(lambda x: str(x))chain = RunnableParallel(first=runnable1, second=runnable2, third=runnable3)chain.invoke(7, config={\"max_concurrency\": 2})\n```\n\n```\n{'first': {'foo': 7}, 'second': [7, 7], 'third': '7'}\n```\n\n### Add default config to runnable[​](#add-default-config-to-runnable \"Direct link to Add default config to runnable\")\n\n#### [Runnable.with\\_config](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.with_config)[​](#runnablewith_config \"Direct link to runnablewith_config\")\n\n```\nfrom langchain_core.runnables import RunnableLambda, RunnableParallelrunnable1 = RunnableLambda(lambda x: {\"foo\": x})runnable2 = RunnableLambda(lambda x: [x] * 2)runnable3 = RunnableLambda(lambda x: str(x))chain = RunnableParallel(first=runnable1, second=runnable2, third=runnable3)configured_chain = chain.with_config(max_concurrency=2)chain.invoke(7)\n```\n\n```\n{'first': {'foo': 7}, 'second': [7, 7], 'third': '7'}\n```\n\n### Make runnable attributes configurable[​](#make-runnable-attributes-configurable \"Direct link to Make runnable attributes configurable\")\n\n#### [Runnable.with\\_configurable\\_fields](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.RunnableSerializable.html#langchain_core.runnables.base.RunnableSerializable.configurable_fields)[​](#runnablewith_configurable_fields \"Direct link to runnablewith_configurable_fields\")\n\n```\nfrom typing import Any, Optionalfrom langchain_core.runnables import (    ConfigurableField,    RunnableConfig,    RunnableSerializable,)class FooRunnable(RunnableSerializable[dict, dict]):    output_key: str    def invoke(        self, input: Any, config: Optional[RunnableConfig] = None, **kwargs: Any    ) -> list:        return self._call_with_config(self.subtract_seven, input, config, **kwargs)    def subtract_seven(self, input: dict) -> dict:        return {self.output_key: input[\"foo\"] - 7}runnable1 = FooRunnable(output_key=\"bar\")configurable_runnable1 = runnable1.configurable_fields(    output_key=ConfigurableField(id=\"output_key\"))configurable_runnable1.invoke(    {\"foo\": 10}, config={\"configurable\": {\"output_key\": \"not bar\"}})\n```\n\n```\nconfigurable_runnable1.invoke({\"foo\": 10})\n```\n\n### Make chain components configurable[​](#make-chain-components-configurable \"Direct link to Make chain components configurable\")\n\n#### [Runnable.with\\_configurable\\_alternatives](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.RunnableSerializable.html#langchain_core.runnables.base.RunnableSerializable.configurable_alternatives)[​](#runnablewith_configurable_alternatives \"Direct link to runnablewith_configurable_alternatives\")\n\n```\nfrom typing import Any, Optionalfrom langchain_core.runnables import RunnableConfig, RunnableLambda, RunnableParallelclass ListRunnable(RunnableSerializable[Any, list]):    def invoke(        self, input: Any, config: Optional[RunnableConfig] = None, **kwargs: Any    ) -> list:        return self._call_with_config(self.listify, input, config, **kwargs)    def listify(self, input: Any) -> list:        return [input]class StrRunnable(RunnableSerializable[Any, str]):    def invoke(        self, input: Any, config: Optional[RunnableConfig] = None, **kwargs: Any    ) -> list:        return self._call_with_config(self.strify, input, config, **kwargs)    def strify(self, input: Any) -> str:        return str(input)runnable1 = RunnableLambda(lambda x: {\"foo\": x})configurable_runnable = ListRunnable().configurable_alternatives(    ConfigurableField(id=\"second_step\"), default_key=\"list\", string=StrRunnable())chain = runnable1 | configurable_runnablechain.invoke(7, config={\"configurable\": {\"second_step\": \"string\"}})\n```\n\n### Build a chain dynamically based on input[​](#build-a-chain-dynamically-based-on-input \"Direct link to Build a chain dynamically based on input\")\n\n```\nfrom langchain_core.runnables import RunnableLambda, RunnableParallelrunnable1 = RunnableLambda(lambda x: {\"foo\": x})runnable2 = RunnableLambda(lambda x: [x] * 2)chain = RunnableLambda(lambda x: runnable1 if x > 6 else runnable2)chain.invoke(7)\n```\n\n### Generate a stream of events[​](#generate-a-stream-of-events \"Direct link to Generate a stream of events\")\n\n#### [Runnable.astream\\_events](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.astream_events)[​](#runnableastream_events \"Direct link to runnableastream_events\")\n\n```\n# | echo: falseimport nest_asyncionest_asyncio.apply()\n```\n\n```\nfrom langchain_core.runnables import RunnableLambda, RunnableParallelrunnable1 = RunnableLambda(lambda x: {\"foo\": x}, name=\"first\")async def func(x):    for _ in range(5):        yield xrunnable2 = RunnableLambda(func, name=\"second\")chain = runnable1 | runnable2async for event in chain.astream_events(\"bar\", version=\"v2\"):    print(f\"event={event['event']} | name={event['name']} | data={event['data']}\")\n```\n\n```\nevent=on_chain_start | name=RunnableSequence | data={'input': 'bar'}event=on_chain_start | name=first | data={}event=on_chain_stream | name=first | data={'chunk': {'foo': 'bar'}}event=on_chain_start | name=second | data={}event=on_chain_end | name=first | data={'output': {'foo': 'bar'}, 'input': 'bar'}event=on_chain_stream | name=second | data={'chunk': {'foo': 'bar'}}event=on_chain_stream | name=RunnableSequence | data={'chunk': {'foo': 'bar'}}event=on_chain_stream | name=second | data={'chunk': {'foo': 'bar'}}event=on_chain_stream | name=RunnableSequence | data={'chunk': {'foo': 'bar'}}event=on_chain_stream | name=second | data={'chunk': {'foo': 'bar'}}event=on_chain_stream | name=RunnableSequence | data={'chunk': {'foo': 'bar'}}event=on_chain_stream | name=second | data={'chunk': {'foo': 'bar'}}event=on_chain_stream | name=RunnableSequence | data={'chunk': {'foo': 'bar'}}event=on_chain_stream | name=second | data={'chunk': {'foo': 'bar'}}event=on_chain_stream | name=RunnableSequence | data={'chunk': {'foo': 'bar'}}event=on_chain_end | name=second | data={'output': {'foo': 'bar'}, 'input': {'foo': 'bar'}}event=on_chain_end | name=RunnableSequence | data={'output': {'foo': 'bar'}}\n```\n\n### Yield batched outputs as they complete[​](#yield-batched-outputs-as-they-complete \"Direct link to Yield batched outputs as they complete\")\n\n#### [Runnable.batch\\_as\\_completed](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.batch_as_completed) / [Runnable.abatch\\_as\\_completed](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.abatch_as_completed)[​](#runnablebatch_as_completed--runnableabatch_as_completed \"Direct link to runnablebatch_as_completed--runnableabatch_as_completed\")\n\n```\nimport timefrom langchain_core.runnables import RunnableLambda, RunnableParallelrunnable1 = RunnableLambda(lambda x: time.sleep(x) or print(f\"slept {x}\"))for idx, result in runnable1.batch_as_completed([5, 1]):    print(idx, result)# Async variant:# async for idx, result in runnable1.abatch_as_completed([5, 1]):#     print(idx, result)\n```\n\n```\nslept 11 Noneslept 50 None\n```\n\n### Return subset of output dict[​](#return-subset-of-output-dict \"Direct link to Return subset of output dict\")\n\n#### [Runnable.pick](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.pick)[​](#runnablepick \"Direct link to runnablepick\")\n\n```\nfrom langchain_core.runnables import RunnableLambda, RunnablePassthroughrunnable1 = RunnableLambda(lambda x: x[\"baz\"] + 5)chain = RunnablePassthrough.assign(foo=runnable1).pick([\"foo\", \"bar\"])chain.invoke({\"bar\": \"hi\", \"baz\": 2})\n```\n\n### Declaratively make a batched version of a runnable[​](#declaratively-make-a-batched-version-of-a-runnable \"Direct link to Declaratively make a batched version of a runnable\")\n\n#### [Runnable.map](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.map)[​](#runnablemap \"Direct link to runnablemap\")\n\n```\nfrom langchain_core.runnables import RunnableLambdarunnable1 = RunnableLambda(lambda x: list(range(x)))runnable2 = RunnableLambda(lambda x: x + 5)chain = runnable1 | runnable2.map()chain.invoke(3)\n```\n\n### Get a graph representation of a runnable[​](#get-a-graph-representation-of-a-runnable \"Direct link to Get a graph representation of a runnable\")\n\n#### [Runnable.get\\_graph](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.get_graph)[​](#runnableget_graph \"Direct link to runnableget_graph\")\n\n```\nfrom langchain_core.runnables import RunnableLambda, RunnableParallelrunnable1 = RunnableLambda(lambda x: {\"foo\": x})runnable2 = RunnableLambda(lambda x: [x] * 2)runnable3 = RunnableLambda(lambda x: str(x))chain = runnable1 | RunnableParallel(second=runnable2, third=runnable3)chain.get_graph().print_ascii()\n```\n\n```\n                             +-------------+                                                           | LambdaInput |                                                           +-------------+                                                                  *                                                                         *                                                                         *                                                         +------------------------------+                                          | Lambda(lambda x: {'foo': x}) |                                          +------------------------------+                                                          *                                                                         *                                                                         *                                                          +-----------------------------+                                           | Parallel<second,third>Input |                                           +-----------------------------+                                              ****                  ***                                             ****                         ****                                       **                                 **                   +---------------------------+               +--------------------------+  | Lambda(lambda x: [x] * 2) |               | Lambda(lambda x: str(x)) |  +---------------------------+               +--------------------------+                          ****                  ***                                                     ****          ****                                                            **      **                                                    +------------------------------+                                          | Parallel<second,third>Output |                                          +------------------------------+\n```\n\n### Get all prompts in a chain[​](#get-all-prompts-in-a-chain \"Direct link to Get all prompts in a chain\")\n\n#### [Runnable.get\\_prompts](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.get_prompts)[​](#runnableget_prompts \"Direct link to runnableget_prompts\")\n\n```\nfrom langchain_core.prompts import ChatPromptTemplatefrom langchain_core.runnables import RunnableLambdaprompt1 = ChatPromptTemplate.from_messages(    [(\"system\", \"good ai\"), (\"human\", \"{input}\")])prompt2 = ChatPromptTemplate.from_messages(    [        (\"system\", \"really good ai\"),        (\"human\", \"{input}\"),        (\"ai\", \"{ai_output}\"),        (\"human\", \"{input2}\"),    ])fake_llm = RunnableLambda(lambda prompt: \"i am good ai\")chain = prompt1.assign(ai_output=fake_llm) | prompt2 | fake_llmfor i, prompt in enumerate(chain.get_prompts()):    print(f\"**prompt {i=}**\\n\")    print(prompt.pretty_repr())    print(\"\\n\" * 3)\n```\n\n```\n**prompt i=0**================================ System Message ================================good ai================================ Human Message ================================={input}**prompt i=1**================================ System Message ================================really good ai================================ Human Message ================================={input}================================== AI Message =================================={ai_output}================================ Human Message ================================={input2}\n```\n\n### Add lifecycle listeners[​](#add-lifecycle-listeners \"Direct link to Add lifecycle listeners\")\n\n#### [Runnable.with\\_listeners](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.with_listeners)[​](#runnablewith_listeners \"Direct link to runnablewith_listeners\")\n\n```\nimport timefrom langchain_core.runnables import RunnableLambdafrom langchain_core.tracers.schemas import Rundef on_start(run_obj: Run):    print(\"start_time:\", run_obj.start_time)def on_end(run_obj: Run):    print(\"end_time:\", run_obj.end_time)runnable1 = RunnableLambda(lambda x: time.sleep(x))chain = runnable1.with_listeners(on_start=on_start, on_end=on_end)chain.invoke(2)\n```\n\n```\nstart_time: 2024-05-17 23:04:00.951065+00:00end_time: 2024-05-17 23:04:02.958765+00:00\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/function_calling/",
  "markdown": "# giscus\n\n## How to do tool/function calling\n\ninfo\n\nWe use the term tool calling interchangeably with function calling. Although function calling is sometimes meant to refer to invocations of a single function, we treat all models as though they can return multiple tool or function calls in each message.\n\nTool calling allows a model to respond to a given prompt by generating output that matches a user-defined schema. While the name implies that the model is performing some action, this is actually not the case! The model is coming up with the arguments to a tool, and actually running the tool (or not) is up to the user - for example, if you want to [extract output matching some schema](https://python.langchain.com/docs/tutorials/extraction/) from unstructured text, you could give the model an \"extraction\" tool that takes parameters matching the desired schema, then treat the generated output as your final result.\n\nA tool call includes a name, arguments dict, and an optional identifier. The arguments dict is structured `{argument_name: argument_value}`.\n\nMany LLM providers, including [Anthropic](https://www.anthropic.com/), [Cohere](https://cohere.com/), [Google](https://cloud.google.com/vertex-ai), [Mistral](https://mistral.ai/), [OpenAI](https://openai.com/), and others, support variants of a tool calling feature. These features typically allow requests to the LLM to include available tools and their schemas, and for responses to include calls to these tools. For instance, given a search engine tool, an LLM might handle a query by first issuing a call to the search engine. The system calling the LLM can receive the tool call, execute it, and return the output to the LLM to inform its response. LangChain includes a suite of [built-in tools](https://python.langchain.com/docs/integrations/tools/) and supports several methods for defining your own [custom tools](https://python.langchain.com/docs/how_to/custom_tools/). Tool-calling is extremely useful for building [tool-using chains and agents](https://python.langchain.com/docs/how_to/#tools), and for getting structured outputs from models more generally.\n\nProviders adopt different conventions for formatting tool schemas and tool calls. For instance, Anthropic returns tool calls as parsed structures within a larger content block:\n\n```\n[  {    \"text\": \"<thinking>\\nI should use a tool.\\n</thinking>\",    \"type\": \"text\"  },  {    \"id\": \"id_value\",    \"input\": {\"arg_name\": \"arg_value\"},    \"name\": \"tool_name\",    \"type\": \"tool_use\"  }]\n```\n\nwhereas OpenAI separates tool calls into a distinct parameter, with arguments as JSON strings:\n\n```\n{  \"tool_calls\": [    {      \"id\": \"id_value\",      \"function\": {        \"arguments\": '{\"arg_name\": \"arg_value\"}',        \"name\": \"tool_name\"      },      \"type\": \"function\"    }  ]}\n```\n\nLangChain implements standard interfaces for defining tools, passing them to LLMs, and representing tool calls.\n\nChat models supporting tool calling features implement a `.bind_tools` method, which receives a list of LangChain [tool objects](https://python.langchain.com/api_reference/core/tools/langchain_core.tools.BaseTool.html#langchain_core.tools.BaseTool) and binds them to the chat model in its expected format. Subsequent invocations of the chat model will include tool schemas in its calls to the LLM.\n\nFor example, we can define the schema for custom tools using the `@tool` decorator on Python functions:\n\n```\nfrom langchain_core.tools import tool@tooldef add(a: int, b: int) -> int:    \"\"\"Adds a and b.\"\"\"    return a + b@tooldef multiply(a: int, b: int) -> int:    \"\"\"Multiplies a and b.\"\"\"    return a * btools = [add, multiply]\n```\n\n**API Reference:**[tool](https://python.langchain.com/api_reference/core/tools/langchain_core.tools.convert.tool.html)\n\nOr below, we define the schema using Pydantic:\n\n```\nfrom pydantic import BaseModel, Field# Note that the docstrings here are crucial, as they will be passed along# to the model along with the class name.class Add(BaseModel):    \"\"\"Add two integers together.\"\"\"    a: int = Field(..., description=\"First integer\")    b: int = Field(..., description=\"Second integer\")class Multiply(BaseModel):    \"\"\"Multiply two integers together.\"\"\"    a: int = Field(..., description=\"First integer\")    b: int = Field(..., description=\"Second integer\")tools = [Add, Multiply]\n```\n\nWe can bind them to chat models as follows:\n\n```\npip install -qU langchain-openai\n```\n\n```\nimport getpassimport osif not os.environ.get(\"OPENAI_API_KEY\"):  os.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"Enter API key for OpenAI: \")from langchain_openai import ChatOpenAIllm = ChatOpenAI(model=\"gpt-4o-mini\")\n```\n\nWe can use the `bind_tools()` method to handle converting `Multiply` to a \"tool\" and binding it to the model (i.e., passing it in each time the model is invoked).\n\n```\nllm_with_tools = llm.bind_tools(tools)\n```\n\nIf tool calls are included in a LLM response, they are attached to the corresponding [message](https://python.langchain.com/api_reference/core/messages/langchain_core.messages.ai.AIMessage.html#langchain_core.messages.ai.AIMessage) or [message chunk](https://python.langchain.com/api_reference/core/messages/langchain_core.messages.ai.AIMessageChunk.html#langchain_core.messages.ai.AIMessageChunk) as a list of [tool call](https://python.langchain.com/api_reference/core/messages/langchain_core.messages.tool.ToolCall.html#langchain_core.messages.tool.ToolCall) objects in the `.tool_calls` attribute. A `ToolCall` is a typed dict that includes a tool name, dict of argument values, and (optionally) an identifier. Messages with no tool calls default to an empty list for this attribute.\n\nExample:\n\n```\nquery = \"What is 3 * 12? Also, what is 11 + 49?\"llm_with_tools.invoke(query).tool_calls\n```\n\n```\n[{'name': 'Multiply',  'args': {'a': 3, 'b': 12},  'id': 'call_1Tdp5wUXbYQzpkBoagGXqUTo'}, {'name': 'Add',  'args': {'a': 11, 'b': 49},  'id': 'call_k9v09vYioS3X0Qg35zESuUKI'}]\n```\n\nThe `.tool_calls` attribute should contain valid tool calls. Note that on occasion, model providers may output malformed tool calls (e.g., arguments that are not valid JSON). When parsing fails in these cases, instances of [InvalidToolCall](https://python.langchain.com/api_reference/core/messages/langchain_core.messages.tool.InvalidToolCall.html#langchain_core.messages.tool.InvalidToolCall) are populated in the `.invalid_tool_calls` attribute. An `InvalidToolCall` can have a name, string arguments, identifier, and error message.\n\nIf desired, [output parsers](https://python.langchain.com/docs/how_to/#output-parsers) can further process the output. For example, we can convert back to the original Pydantic class:\n\n```\nfrom langchain_core.output_parsers.openai_tools import PydanticToolsParserchain = llm_with_tools | PydanticToolsParser(tools=[Multiply, Add])chain.invoke(query)\n```\n\n```\n[Multiply(a=3, b=12), Add(a=11, b=49)]\n```\n\n### Streaming[​](#streaming \"Direct link to Streaming\")\n\nWhen tools are called in a streaming context, [message chunks](https://python.langchain.com/api_reference/core/messages/langchain_core.messages.ai.AIMessageChunk.html#langchain_core.messages.ai.AIMessageChunk) will be populated with [tool call chunk](https://python.langchain.com/api_reference/core/messages/langchain_core.messages.tool.ToolCallChunk.html#langchain_core.messages.tool.ToolCallChunk) objects in a list via the `.tool_call_chunks` attribute. A `ToolCallChunk` includes optional string fields for the tool `name`, `args`, and `id`, and includes an optional integer field `index` that can be used to join chunks together. Fields are optional because portions of a tool call may be streamed across different chunks (e.g., a chunk that includes a substring of the arguments may have null values for the tool name and id).\n\nBecause message chunks inherit from their parent message class, an [AIMessageChunk](https://python.langchain.com/api_reference/core/messages/langchain_core.messages.ai.AIMessageChunk.html#langchain_core.messages.ai.AIMessageChunk) with tool call chunks will also include `.tool_calls` and `.invalid_tool_calls` fields. These fields are parsed best-effort from the message's tool call chunks.\n\nNote that not all providers currently support streaming for tool calls.\n\nExample:\n\n```\nasync for chunk in llm_with_tools.astream(query):    print(chunk.tool_call_chunks)\n```\n\n```\n[][{'name': 'Multiply', 'args': '', 'id': 'call_d39MsxKM5cmeGJOoYKdGBgzc', 'index': 0}][{'name': None, 'args': '{\"a\"', 'id': None, 'index': 0}][{'name': None, 'args': ': 3, ', 'id': None, 'index': 0}][{'name': None, 'args': '\"b\": 1', 'id': None, 'index': 0}][{'name': None, 'args': '2}', 'id': None, 'index': 0}][{'name': 'Add', 'args': '', 'id': 'call_QJpdxD9AehKbdXzMHxgDMMhs', 'index': 1}][{'name': None, 'args': '{\"a\"', 'id': None, 'index': 1}][{'name': None, 'args': ': 11,', 'id': None, 'index': 1}][{'name': None, 'args': ' \"b\": ', 'id': None, 'index': 1}][{'name': None, 'args': '49}', 'id': None, 'index': 1}][]\n```\n\nNote that adding message chunks will merge their corresponding tool call chunks. This is the principle by which LangChain's various [tool output parsers](https://python.langchain.com/docs/how_to/output_parser_structured/) support streaming.\n\nFor example, below we accumulate tool call chunks:\n\n```\nfirst = Trueasync for chunk in llm_with_tools.astream(query):    if first:        gathered = chunk        first = False    else:        gathered = gathered + chunk    print(gathered.tool_call_chunks)\n```\n\n```\n[][{'name': 'Multiply', 'args': '', 'id': 'call_erKtz8z3e681cmxYKbRof0NS', 'index': 0}][{'name': 'Multiply', 'args': '{\"a\"', 'id': 'call_erKtz8z3e681cmxYKbRof0NS', 'index': 0}][{'name': 'Multiply', 'args': '{\"a\": 3, ', 'id': 'call_erKtz8z3e681cmxYKbRof0NS', 'index': 0}][{'name': 'Multiply', 'args': '{\"a\": 3, \"b\": 1', 'id': 'call_erKtz8z3e681cmxYKbRof0NS', 'index': 0}][{'name': 'Multiply', 'args': '{\"a\": 3, \"b\": 12}', 'id': 'call_erKtz8z3e681cmxYKbRof0NS', 'index': 0}][{'name': 'Multiply', 'args': '{\"a\": 3, \"b\": 12}', 'id': 'call_erKtz8z3e681cmxYKbRof0NS', 'index': 0}, {'name': 'Add', 'args': '', 'id': 'call_tYHYdEV2YBvzDcSCiFCExNvw', 'index': 1}][{'name': 'Multiply', 'args': '{\"a\": 3, \"b\": 12}', 'id': 'call_erKtz8z3e681cmxYKbRof0NS', 'index': 0}, {'name': 'Add', 'args': '{\"a\"', 'id': 'call_tYHYdEV2YBvzDcSCiFCExNvw', 'index': 1}][{'name': 'Multiply', 'args': '{\"a\": 3, \"b\": 12}', 'id': 'call_erKtz8z3e681cmxYKbRof0NS', 'index': 0}, {'name': 'Add', 'args': '{\"a\": 11,', 'id': 'call_tYHYdEV2YBvzDcSCiFCExNvw', 'index': 1}][{'name': 'Multiply', 'args': '{\"a\": 3, \"b\": 12}', 'id': 'call_erKtz8z3e681cmxYKbRof0NS', 'index': 0}, {'name': 'Add', 'args': '{\"a\": 11, \"b\": ', 'id': 'call_tYHYdEV2YBvzDcSCiFCExNvw', 'index': 1}][{'name': 'Multiply', 'args': '{\"a\": 3, \"b\": 12}', 'id': 'call_erKtz8z3e681cmxYKbRof0NS', 'index': 0}, {'name': 'Add', 'args': '{\"a\": 11, \"b\": 49}', 'id': 'call_tYHYdEV2YBvzDcSCiFCExNvw', 'index': 1}][{'name': 'Multiply', 'args': '{\"a\": 3, \"b\": 12}', 'id': 'call_erKtz8z3e681cmxYKbRof0NS', 'index': 0}, {'name': 'Add', 'args': '{\"a\": 11, \"b\": 49}', 'id': 'call_tYHYdEV2YBvzDcSCiFCExNvw', 'index': 1}]\n```\n\n```\nprint(type(gathered.tool_call_chunks[0][\"args\"]))\n```\n\nAnd below we accumulate tool calls to demonstrate partial parsing:\n\n```\nfirst = Trueasync for chunk in llm_with_tools.astream(query):    if first:        gathered = chunk        first = False    else:        gathered = gathered + chunk    print(gathered.tool_calls)\n```\n\n```\n[][][{'name': 'Multiply', 'args': {}, 'id': 'call_BXqUtt6jYCwR1DguqpS2ehP0'}][{'name': 'Multiply', 'args': {'a': 3}, 'id': 'call_BXqUtt6jYCwR1DguqpS2ehP0'}][{'name': 'Multiply', 'args': {'a': 3, 'b': 1}, 'id': 'call_BXqUtt6jYCwR1DguqpS2ehP0'}][{'name': 'Multiply', 'args': {'a': 3, 'b': 12}, 'id': 'call_BXqUtt6jYCwR1DguqpS2ehP0'}][{'name': 'Multiply', 'args': {'a': 3, 'b': 12}, 'id': 'call_BXqUtt6jYCwR1DguqpS2ehP0'}][{'name': 'Multiply', 'args': {'a': 3, 'b': 12}, 'id': 'call_BXqUtt6jYCwR1DguqpS2ehP0'}, {'name': 'Add', 'args': {}, 'id': 'call_UjSHJKROSAw2BDc8cp9cSv4i'}][{'name': 'Multiply', 'args': {'a': 3, 'b': 12}, 'id': 'call_BXqUtt6jYCwR1DguqpS2ehP0'}, {'name': 'Add', 'args': {'a': 11}, 'id': 'call_UjSHJKROSAw2BDc8cp9cSv4i'}][{'name': 'Multiply', 'args': {'a': 3, 'b': 12}, 'id': 'call_BXqUtt6jYCwR1DguqpS2ehP0'}, {'name': 'Add', 'args': {'a': 11}, 'id': 'call_UjSHJKROSAw2BDc8cp9cSv4i'}][{'name': 'Multiply', 'args': {'a': 3, 'b': 12}, 'id': 'call_BXqUtt6jYCwR1DguqpS2ehP0'}, {'name': 'Add', 'args': {'a': 11, 'b': 49}, 'id': 'call_UjSHJKROSAw2BDc8cp9cSv4i'}][{'name': 'Multiply', 'args': {'a': 3, 'b': 12}, 'id': 'call_BXqUtt6jYCwR1DguqpS2ehP0'}, {'name': 'Add', 'args': {'a': 11, 'b': 49}, 'id': 'call_UjSHJKROSAw2BDc8cp9cSv4i'}]\n```\n\n```\nprint(type(gathered.tool_calls[0][\"args\"]))\n```\n\nIf we're using the model-generated tool invocations to actually call tools and want to pass the tool results back to the model, we can do so using `ToolMessage`s.\n\n```\nfrom langchain_core.messages import HumanMessage, ToolMessagemessages = [HumanMessage(query)]ai_msg = llm_with_tools.invoke(messages)messages.append(ai_msg)for tool_call in ai_msg.tool_calls:    selected_tool = {\"add\": add, \"multiply\": multiply}[tool_call[\"name\"].lower()]    tool_output = selected_tool.invoke(tool_call[\"args\"])    messages.append(ToolMessage(tool_output, tool_call_id=tool_call[\"id\"]))messages\n```\n\n```\n[HumanMessage(content='What is 3 * 12? Also, what is 11 + 49?'), AIMessage(content='', additional_kwargs={'tool_calls': [{'id': 'call_K5DsWEmgt6D08EI9AFu9NaL1', 'function': {'arguments': '{\"a\": 3, \"b\": 12}', 'name': 'Multiply'}, 'type': 'function'}, {'id': 'call_qywVrsplg0ZMv7LHYYMjyG81', 'function': {'arguments': '{\"a\": 11, \"b\": 49}', 'name': 'Add'}, 'type': 'function'}]}, response_metadata={'token_usage': {'completion_tokens': 50, 'prompt_tokens': 105, 'total_tokens': 155}, 'model_name': 'gpt-3.5-turbo', 'system_fingerprint': 'fp_b28b39ffa8', 'finish_reason': 'tool_calls', 'logprobs': None}, id='run-1a0b8cdd-9221-4d94-b2ed-5701f67ce9fe-0', tool_calls=[{'name': 'Multiply', 'args': {'a': 3, 'b': 12}, 'id': 'call_K5DsWEmgt6D08EI9AFu9NaL1'}, {'name': 'Add', 'args': {'a': 11, 'b': 49}, 'id': 'call_qywVrsplg0ZMv7LHYYMjyG81'}]), ToolMessage(content='36', tool_call_id='call_K5DsWEmgt6D08EI9AFu9NaL1'), ToolMessage(content='60', tool_call_id='call_qywVrsplg0ZMv7LHYYMjyG81')]\n```\n\n```\nllm_with_tools.invoke(messages)\n```\n\n```\nAIMessage(content='3 * 12 is 36 and 11 + 49 is 60.', response_metadata={'token_usage': {'completion_tokens': 18, 'prompt_tokens': 171, 'total_tokens': 189}, 'model_name': 'gpt-3.5-turbo', 'system_fingerprint': 'fp_b28b39ffa8', 'finish_reason': 'stop', 'logprobs': None}, id='run-a6c8093c-b16a-4c92-8308-7c9ac998118c-0')\n```\n\n## Few-shot prompting[​](#few-shot-prompting \"Direct link to Few-shot prompting\")\n\nFor more complex tool use it's very useful to add few-shot examples to the prompt. We can do this by adding `AIMessage`s with `ToolCall`s and corresponding `ToolMessage`s to our prompt.\n\nFor example, even with some special instructions our model can get tripped up by order of operations:\n\n```\nllm_with_tools.invoke(    \"Whats 119 times 8 minus 20. Don't do any math yourself, only use tools for math. Respect order of operations\").tool_calls\n```\n\n```\n[{'name': 'Multiply',  'args': {'a': 119, 'b': 8},  'id': 'call_Dl3FXRVkQCFW4sUNYOe4rFr7'}, {'name': 'Add',  'args': {'a': 952, 'b': -20},  'id': 'call_n03l4hmka7VZTCiP387Wud2C'}]\n```\n\nThe model shouldn't be trying to add anything yet, since it technically can't know the results of 119 \\* 8 yet.\n\nBy adding a prompt with some examples we can correct this behavior:\n\n```\nfrom langchain_core.messages import AIMessagefrom langchain_core.prompts import ChatPromptTemplatefrom langchain_core.runnables import RunnablePassthroughexamples = [    HumanMessage(        \"What's the product of 317253 and 128472 plus four\", name=\"example_user\"    ),    AIMessage(        \"\",        name=\"example_assistant\",        tool_calls=[            {\"name\": \"Multiply\", \"args\": {\"x\": 317253, \"y\": 128472}, \"id\": \"1\"}        ],    ),    ToolMessage(\"16505054784\", tool_call_id=\"1\"),    AIMessage(        \"\",        name=\"example_assistant\",        tool_calls=[{\"name\": \"Add\", \"args\": {\"x\": 16505054784, \"y\": 4}, \"id\": \"2\"}],    ),    ToolMessage(\"16505054788\", tool_call_id=\"2\"),    AIMessage(        \"The product of 317253 and 128472 plus four is 16505054788\",        name=\"example_assistant\",    ),]system = \"\"\"You are bad at math but are an expert at using a calculator. Use past tool usage as an example of how to correctly use the tools.\"\"\"few_shot_prompt = ChatPromptTemplate.from_messages(    [        (\"system\", system),        *examples,        (\"human\", \"{query}\"),    ])chain = {\"query\": RunnablePassthrough()} | few_shot_prompt | llm_with_toolschain.invoke(\"Whats 119 times 8 minus 20\").tool_calls\n```\n\n```\n[{'name': 'Multiply',  'args': {'a': 119, 'b': 8},  'id': 'call_MoSgwzIhPxhclfygkYaKIsGZ'}]\n```\n\nSeems like we get the correct output this time.\n\nHere's what the [LangSmith trace](https://smith.langchain.com/public/f70550a1-585f-4c9d-a643-13148ab1616f/r) looks like.\n\n## Next steps[​](#next-steps \"Direct link to Next steps\")\n\n*   **Output parsing**: See [OpenAI Tools output parsers](https://python.langchain.com/docs/how_to/output_parser_structured/) to learn about extracting the function calling API responses into various formats.\n*   **Structured output chains**: [Some models have constructors](https://python.langchain.com/docs/how_to/structured_output/) that handle creating a structured output chain for you.\n*   **Tool use**: See how to construct chains and agents that call the invoked tools in [these guides](https://python.langchain.com/docs/how_to/#tools)."
},
{
  "url": "https://python.langchain.com/docs/how_to/document_loader_pdf/",
  "markdown": "# giscus\n\n## How to load PDFs\n\n[Portable Document Format (PDF)](https://en.wikipedia.org/wiki/PDF), standardized as ISO 32000, is a file format developed by Adobe in 1992 to present documents, including text formatting and images, in a manner independent of application software, hardware, and operating systems.\n\nThis guide covers how to [load](https://python.langchain.com/docs/concepts/document_loaders/) `PDF` documents into the LangChain [Document](https://python.langchain.com/api_reference/core/documents/langchain_core.documents.base.Document.html) format that we use downstream.\n\nText in PDFs is typically represented via text boxes. They may also contain images. A PDF parser might do some combination of the following:\n\n*   Agglomerate text boxes into lines, paragraphs, and other structures via heuristics or ML inference;\n*   Run [OCR](https://en.wikipedia.org/wiki/Optical_character_recognition) on images to detect text therein;\n*   Classify text as belonging to paragraphs, lists, tables, or other structures;\n*   Structure text into table rows and columns, or key-value pairs.\n\nLangChain integrates with a host of PDF parsers. Some are simple and relatively low-level; others will support OCR and image-processing, or perform advanced document layout analysis. The right choice will depend on your needs. Below we enumerate the possibilities.\n\nWe will demonstrate these approaches on a [sample file](https://github.com/langchain-ai/langchain/blob/master/libs/community/tests/integration_tests/examples/layout-parser-paper.pdf):\n\n```\nfile_path = (    \"../../docs/integrations/document_loaders/example_data/layout-parser-paper.pdf\")\n```\n\nA note on multimodal models\n\nMany modern LLMs support inference over multimodal inputs (e.g., images). In some applications -- such as question-answering over PDFs with complex layouts, diagrams, or scans -- it may be advantageous to skip the PDF parsing, instead casting a PDF page to an image and passing it to a model directly. We demonstrate an example of this in the [Use of multimodal models](https://python.langchain.com/docs/how_to/document_loader_pdf/#use-of-multimodal-models) section below.\n\n## Simple and fast text extraction[​](#simple-and-fast-text-extraction \"Direct link to Simple and fast text extraction\")\n\nIf you are looking for a simple string representation of text that is embedded in a PDF, the method below is appropriate. It will return a list of [Document](https://python.langchain.com/api_reference/core/documents/langchain_core.documents.base.Document.html) objects-- one per page-- containing a single string of the page's text in the Document's `page_content` attribute. It will not parse text in images or scanned PDF pages. Under the hood it uses the [pypdf](https://pypdf.readthedocs.io/en/stable/) Python library.\n\nLangChain [document loaders](https://python.langchain.com/docs/concepts/document_loaders/) implement `lazy_load` and its async variant, `alazy_load`, which return iterators of `Document` objects. We will use these below.\n\n```\nfrom langchain_community.document_loaders import PyPDFLoaderloader = PyPDFLoader(file_path)pages = []async for page in loader.alazy_load():    pages.append(page)\n```\n\n```\nprint(f\"{pages[0].metadata}\\n\")print(pages[0].page_content)\n```\n\n```\n{'source': '../../docs/integrations/document_loaders/example_data/layout-parser-paper.pdf', 'page': 0}LayoutParser : A Uniﬁed Toolkit for DeepLearning Based Document Image AnalysisZejiang Shen1( �), Ruochen Zhang2, Melissa Dell3, Benjamin Charles GermainLee4, Jacob Carlson3, and Weining Li51Allen Institute for AIshannons@allenai.org2Brown Universityruochen zhang@brown.edu3Harvard University{melissadell,jacob carlson }@fas.harvard.edu4University of Washingtonbcgl@cs.washington.edu5University of Waterloow422li@uwaterloo.caAbstract. Recent advances in document image analysis (DIA) have beenprimarily driven by the application of neural networks. Ideally, researchoutcomes could be easily deployed in production and extended for furtherinvestigation. However, various factors like loosely organized codebasesand sophisticated model conﬁgurations complicate the easy reuse of im-portant innovations by a wide audience. Though there have been on-goingeﬀorts to improve reusability and simplify deep learning (DL) modeldevelopment in disciplines like natural language processing and computervision, none of them are optimized for challenges in the domain of DIA.This represents a major gap in the existing toolkit, as DIA is central toacademic research across a wide range of disciplines in the social sciencesand humanities. This paper introduces LayoutParser , an open-sourcelibrary for streamlining the usage of DL in DIA research and applica-tions. The core LayoutParser library comes with a set of simple andintuitive interfaces for applying and customizing DL models for layout de-tection, character recognition, and many other document processing tasks.To promote extensibility, LayoutParser also incorporates a communityplatform for sharing both pre-trained models and full document digiti-zation pipelines. We demonstrate that LayoutParser is helpful for bothlightweight and large-scale digitization pipelines in real-word use cases.The library is publicly available at https://layout-parser.github.io .Keywords: Document Image Analysis ·Deep Learning ·Layout Analysis·Character Recognition ·Open Source library ·Toolkit.1 IntroductionDeep Learning(DL)-based approaches are the state-of-the-art for a wide range ofdocument image analysis (DIA) tasks including document image classiﬁcation [ 11,arXiv:2103.15348v2  [cs.CV]  21 Jun 2021\n```\n\nNote that the metadata of each document stores the corresponding page number.\n\n### Vector search over PDFs[​](#vector-search-over-pdfs \"Direct link to Vector search over PDFs\")\n\nOnce we have loaded PDFs into LangChain `Document` objects, we can index them (e.g., a RAG application) in the usual way. Below we use OpenAI embeddings, although any LangChain [embeddings](https://python.langchain.com/docs/concepts/embedding_models) model will suffice.\n\n```\n%pip install -qU langchain-openai\n```\n\n```\nimport getpassimport osif \"OPENAI_API_KEY\" not in os.environ:    os.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"OpenAI API Key:\")\n```\n\n```\nfrom langchain_core.vectorstores import InMemoryVectorStorefrom langchain_openai import OpenAIEmbeddingsvector_store = InMemoryVectorStore.from_documents(pages, OpenAIEmbeddings())docs = vector_store.similarity_search(\"What is LayoutParser?\", k=2)for doc in docs:    print(f'Page {doc.metadata[\"page\"]}: {doc.page_content[:300]}\\n')\n```\n\n```\nPage 13: 14 Z. Shen et al.6 ConclusionLayoutParser provides a comprehensive toolkit for deep learning-based documentimage analysis. The oﬀ-the-shelf library is easy to install, and can be used tobuild ﬂexible and accurate pipelines for processing documents with complicatedstructures. It also supports hiPage 0: LayoutParser : A Uniﬁed Toolkit for DeepLearning Based Document Image AnalysisZejiang Shen1( �), Ruochen Zhang2, Melissa Dell3, Benjamin Charles GermainLee4, Jacob Carlson3, and Weining Li51Allen Institute for AIshannons@allenai.org2Brown Universityruochen zhang@brown.edu3Harvard University\n```\n\n## Layout analysis and extraction of text from images[​](#layout-analysis-and-extraction-of-text-from-images \"Direct link to Layout analysis and extraction of text from images\")\n\nIf you require a more granular segmentation of text (e.g., into distinct paragraphs, titles, tables, or other structures) or require extraction of text from images, the method below is appropriate. It will return a list of [Document](https://python.langchain.com/api_reference/core/documents/langchain_core.documents.base.Document.html) objects, where each object represents a structure on the page. The Document's metadata stores the page number and other information related to the object (e.g., it might store table rows and columns in the case of a table object).\n\nUnder the hood it uses the `langchain-unstructured` library. See the [integration docs](https://python.langchain.com/docs/integrations/document_loaders/unstructured_file/) for more information about using [Unstructured](https://docs.unstructured.io/welcome) with LangChain.\n\nUnstructured supports multiple parameters for PDF parsing:\n\n*   `strategy` (e.g., `\"fast\"` or `\"hi-res\"`)\n*   API or local processing. You will need an API key to use the API.\n\nThe [hi-res](https://docs.unstructured.io/api-reference/how-to/choose-hi-res-model) strategy provides support for document layout analysis and OCR. We demonstrate it below via the API. See [local parsing](https://python.langchain.com/docs/how_to/document_loader_pdf/#local-parsing) section below for considerations when running locally.\n\n```\n%pip install -qU langchain-unstructured\n```\n\n```\nimport getpassimport osif \"UNSTRUCTURED_API_KEY\" not in os.environ:    os.environ[\"UNSTRUCTURED_API_KEY\"] = getpass.getpass(\"Unstructured API Key:\")\n```\n\n```\nUnstructured API Key: ········\n```\n\nAs before, we initialize a loader and load documents lazily:\n\n```\nfrom langchain_unstructured import UnstructuredLoaderloader = UnstructuredLoader(    file_path=file_path,    strategy=\"hi_res\",    partition_via_api=True,    coordinates=True,)docs = []for doc in loader.lazy_load():    docs.append(doc)\n```\n\n```\nINFO: Preparing to split document for partition.INFO: Starting page number set to 1INFO: Allow failed set to 0INFO: Concurrency level set to 5INFO: Splitting pages 1 to 16 (16 total)INFO: Determined optimal split size of 4 pages.INFO: Partitioning 4 files with 4 page(s) each.INFO: Partitioning set #1 (pages 1-4).INFO: Partitioning set #2 (pages 5-8).INFO: Partitioning set #3 (pages 9-12).INFO: Partitioning set #4 (pages 13-16).INFO: HTTP Request: POST https://api.unstructuredapp.io/general/v0/general \"HTTP/1.1 200 OK\"INFO: HTTP Request: POST https://api.unstructuredapp.io/general/v0/general \"HTTP/1.1 200 OK\"INFO: HTTP Request: POST https://api.unstructuredapp.io/general/v0/general \"HTTP/1.1 200 OK\"INFO: HTTP Request: POST https://api.unstructuredapp.io/general/v0/general \"HTTP/1.1 200 OK\"INFO: Successfully partitioned set #1, elements added to the final result.INFO: Successfully partitioned set #2, elements added to the final result.INFO: Successfully partitioned set #3, elements added to the final result.INFO: Successfully partitioned set #4, elements added to the final result.\n```\n\nHere we recover 171 distinct structures over the 16 page document:\n\nWe can use the document metadata to recover content from a single page:\n\n```\nfirst_page_docs = [doc for doc in docs if doc.metadata.get(\"page_number\") == 1]for doc in first_page_docs:    print(doc.page_content)\n```\n\n```\nLayoutParser: A Uniﬁed Toolkit for Deep Learning Based Document Image Analysis1 2 0 2 n u J 1 2 ] V C . s c [ 2 v 8 4 3 5 1 . 3 0 1 2 : v i X r aZejiang Shen® (<), Ruochen Zhang?, Melissa Dell®, Benjamin Charles Germain Lee?, Jacob Carlson®, and Weining Li®1 Allen Institute for AI shannons@allenai.org 2 Brown University ruochen zhang@brown.edu 3 Harvard University {melissadell,jacob carlson}@fas.harvard.edu 4 University of Washington bcgl@cs.washington.edu 5 University of Waterloo w422li@uwaterloo.caAbstract. Recent advances in document image analysis (DIA) have been primarily driven by the application of neural networks. Ideally, research outcomes could be easily deployed in production and extended for further investigation. However, various factors like loosely organized codebases and sophisticated model conﬁgurations complicate the easy reuse of im- portant innovations by a wide audience. Though there have been on-going eﬀorts to improve reusability and simplify deep learning (DL) model development in disciplines like natural language processing and computer vision, none of them are optimized for challenges in the domain of DIA. This represents a major gap in the existing toolkit, as DIA is central to academic research across a wide range of disciplines in the social sciences and humanities. This paper introduces LayoutParser, an open-source library for streamlining the usage of DL in DIA research and applica- tions. The core LayoutParser library comes with a set of simple and intuitive interfaces for applying and customizing DL models for layout de- tection, character recognition, and many other document processing tasks. To promote extensibility, LayoutParser also incorporates a community platform for sharing both pre-trained models and full document digiti- zation pipelines. We demonstrate that LayoutParser is helpful for both lightweight and large-scale digitization pipelines in real-word use cases. The library is publicly available at https://layout-parser.github.io.Keywords: Document Image Analysis · Deep Learning · Layout Analysis · Character Recognition · Open Source library · Toolkit.1 IntroductionDeep Learning(DL)-based approaches are the state-of-the-art for a wide range of document image analysis (DIA) tasks including document image classiﬁcation [11,\n```\n\n### Extracting tables and other structures[​](#extracting-tables-and-other-structures \"Direct link to Extracting tables and other structures\")\n\nEach `Document` we load represents a structure, like a title, paragraph, or table.\n\nSome structures may be of special interest for indexing or question-answering tasks. These structures may be:\n\n1.  Classified for easy identification;\n2.  Parsed into a more structured representation.\n\nBelow, we identify and extract a table:\n\nClick to expand code for rendering pages\n\n![](data:image/png;base64,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hUyj0eB2u3G5XNTU1LBt2zbGx8fR6XTMzMxw/vx5tm3bJulKeXl5t1QE4vE4w8PDuFwuysvLaWpqIp1O88orr1BZWSmvUSqVHDhwALh5lubn51lcXMRut6+rTOaQwzsVOU9ADnctLndeBsBeYGf//v38zd/8DQMDA9KSMz4+TmtrK263m3PnznH27FlUKhVbtmzh+eefZ2pqis7OTv72b/+Ww4cP43Q66e7u5vLly1y8eJFz587R3t7O888/TyAQoL6+npqaGu6//35KSkpW8PxFrMG3vvUt3G43DQ0NRKNR+fennnqKixcvUl9fT3NzM9/97nepr6+nqamJyspKjh49ikaj4a//+q/l/YWFhXz729/G7Xbz/e9/n9nZWcrLyzl27BharZaWlhZ2795NW1sbjY2NlJaW8uKLL+JyuZienubChQv09/fT3t7OmTNn6OzsJBQKUVpayv/4H/8DQHoUTp06tWJuDQYD6XSavr4+rl+/Tnt7O2fPnuXpp59mYWGBpqYmvvSlL7G8vIzL5eL8+fN8+9vfxm63097ezunTp3n66aclFWpiYoLKykp0Oh29vb08//zzKz6WAwMD/P3f/z21tbVs2bKFEydO0NPTg1ar5ZlnnmF0dJT6+npeffVVvvnNb2I0GvH7/bzxxhssLy+v2Rv/8i//wuLiImazmePHj9Pb20thYSE3btzg5MmTLCwssGvXLr72ta9JZefFF18kFouxe/dulpaW1nXpX7t2jZmZGex2Ozt37mRgYIDS0lJqampoaWnh6NGjFBYWyjaj0ShFRUX80R/9EalUin379t12zR977LEVlsREIsHCwgLf/e53aWhoQKfT0d/fz7Fjx6isrMRuv7n/BRdawGq1UldXR1tbG+3t7TQ1NcnCTU6nE4fDwY4dO/irv/orlpeXOX78OM8++yx1dXVs2bKFJ554gomJiRV7PJPJ8Pzzz+P3+zGZTHz5y18mkUjQ0NDAsWPHeO655wAYGhrinnvuoaKigpaWFvbu3btGEDabzZSUlPA//sf/QKFQkEwmOXXqFI8//jgtLS0888wzzMzM0Nvby8WLFxkZGWHv3r289tprXLt2jfn5eaanp/lf/+t/sWfPHtRqtbTQxmIxvvSlL5Gfn09zczM+n48nn3xyxfMHBgbo6upi165dkqqyEfVF9H18fJypqakVFL94PE5H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gK6uLp577jm5dzs7O7nrrru47777pNIo6JgrKysAUsEoHQ+4lM3Jbreze/du7rvvPu6//37a29sZHR0lHA5TVVXF/fffz7e+9S1mZ2eZmpraZAgpo4z3KsqBwWXc9JiemWZsbIxnn32We++9l/r6emZmZpienubkyZMYjUYGBwelVel973sfp0+fxmKxYLFYsNvtfOUrX+H73/8+RqOR5eVluru7CYfDfOITn8BoNMpCXPX19Tz66KN0dHTQ0tLC7t27yefzvPLKK0SjUT72sY+xa9euTVSD1tZWXnvtNVZXV6UlUVAWEomEpMaMj4/T39/P6uoq2WxWZlbp7++XQmlDQwOf+MQn+PjHP843v/lNBgcH8fl85HI5jhw5woEDBxgcHJSZWEpx8uRJFhcXuffee9m7dy+tra24XC6ZQScejzM9PU1tbS0TExOMjY2xtLRERUUFs7OzXLx4kXg8jtfrZWlpibm5OdLptLSOxWIxpqen+f3f/31Jn5icnGRycpLf+73fo6+vj7m5OWpra8lmszz77LMEAgHJsfDzkQAAkLhJREFUxd4aSFdRUUFVVRVHjx6loaGBxcVF5ufnWVhY4Pjx46jVamZmZpiampLei5GREUnx0ul0dHZ2smfPHl566SVuvfVW6uvr5f0F5WZxcVEKRT6fj5aWFgYHB1lcXCSdTvOhD32Ij3/843z961+nr6+PyclJVCoVhw4dkvfq6elhdnaWgwcPUlFRQWNjIz6fj/7+fqampiR1RIxZVVUV99xzD3v37qWvrw+tVksoFJJBmKdOncJgMDAwMCD53MePH2dubo6Kigqy2SwDAwNUVFTwr//1v+anP/0poVCI7du3EwwGef/734/JZCIQCDA3N0c4HGZ2dhaXy8X8/DyJRILjx4+jUCiYn59namoKm82G0+nklVde4fbbb2d+fp7p6WnUajXnz5/n8OHDbNu2jWQyicPhYNu2bZvmS6/Xs23bNu677z6OHz+OXq+XgdBNTU1ks1kmJyeZnZ1ldnaW/v5+YrEY73vf+ySF75577uHWW2/le9/7HufOnSMSidDa2komk+G1115jamqKD3zgAzQ2NtLZ2UkwGOTo0aNYrVZcLheTk5N0d3czNTXF5OQk/f39LC8vo1KpOHDgABaLhVdffZV9+/ZtChAXbXrjjTdkoPrExATHjh3jrrvu4vDh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MCMBAAAwIwEAADAjAQAAMCMBAAAwIwEAADAjAQAAMCMBAAAwIwEAADAjAQAAMCMBAAAwIwEAADAjAQAAMCMBAAAwIwEAADAjAQAAMCMBAAAwIwEAADAjAQAAMCMBAAAwIwEAADAjAQAAMCMBAAAwIwEAADAjAQAAMCMBAAAwIwEAADAjAQAAMCMBAAAwIwEAADAjAQAAMCMBAAAwIwEAADAjAQAAMCMBAAAwIwEAADAjAQAAMCMBAAAwIwEAADAjAQAAMCMBAAAwIwEAADAjAQAAMCMBAAAwIwEAADAjAQAAMCMBAAAwIwEAADAjAQAAMCMBAAAwIwEAADAjAQAAMCMBAAAwIwEAADAjAQAAMCMBAAAwIwEAADAjAQAAMCMBAAAwIwEAADAjAQAAMCMBAAAwIwEAADAjAQAAMCMBAAAwIwEAADAjAQAAMCMBAAAwIwEAADAjAQAAMCMBAAAwIwEAADAjAQAAMCMBAAAwIwEAADAjAQAAMCMBAAAwIwEAADAjAQAAMCMBAAAwIwEAADAjAQAAMCMBAAAwIwEAADAjAQAAMCMBAAAwIwEAADAjAQAAMCMBAAAwIwEAADAjAQAAMCMBAAAwIwEAADAjAQAAMCMBAAAwIwEAADAjAQAAMCMBAAAwIwEAADAjAQAAMCMBAAAwIwEAADAjAQAAMCMBAAAwIwEAADAjAQAAMCMBAAAwIwEAADAjAQAAMCMBAAAwIwEAADAjAQAAMCMBAAAwIwEAADATRrQUAfNzasYAAAAASUVORK5CYII=)\n\n```\nLayoutParser: A Uniﬁed Toolkit for DL-Based DIA5Table 1: Current layout detection models in the LayoutParser model zooDataset Base Model1 Large Model Notes PubLayNet [38] PRImA [3] Newspaper [17] TableBank [18] HJDataset [31] F / M M F F F / M M - - F - Layouts of modern scientiﬁc documents Layouts of scanned modern magazines and scientiﬁc reports Layouts of scanned US newspapers from the 20th century Table region on modern scientiﬁc and business document Layouts of history Japanese documents1 For each dataset, we train several models of diﬀerent sizes for diﬀerent needs (the trade-oﬀ between accuracy vs. computational cost). For “base model” and “large model”, we refer to using the ResNet 50 or ResNet 101 backbones [13], respectively. One can train models of diﬀerent architectures, like Faster R-CNN [28] (F) and Mask R-CNN [12] (M). For example, an F in the Large Model column indicates it has a Faster R-CNN model trained using the ResNet 101 backbone. The platform is maintained and a number of additions will be made to the model zoo in coming months.layout data structures, which are optimized for eﬃciency and versatility. 3) When necessary, users can employ existing or customized OCR models via the uniﬁed API provided in the OCR module. 4) LayoutParser comes with a set of utility functions for the visualization and storage of the layout data. 5) LayoutParser is also highly customizable, via its integration with functions for layout data annotation and model training. We now provide detailed descriptions for each component.3.1 Layout Detection ModelsIn LayoutParser, a layout model takes a document image as an input and generates a list of rectangular boxes for the target content regions. Diﬀerent from traditional methods, it relies on deep convolutional neural networks rather than manually curated rules to identify content regions. It is formulated as an object detection problem and state-of-the-art models like Faster R-CNN [28] and Mask R-CNN [12] are used. This yields prediction results of high accuracy and makes it possible to build a concise, generalized interface for layout detection. LayoutParser, built upon Detectron2 [35], provides a minimal API that can perform layout detection with only four lines of code in Python:1 import layoutparser as lp 2 image = cv2 . imread ( \" image_file \" ) # load images 3 model = lp . De t e c tro n2 Lay outM odel ( \" lp :// PubLayNet / f as t er _ r c nn _ R _ 50 _ F P N_ 3 x / config \" ) 4 5 layout = model . detect ( image )LayoutParser provides a wealth of pre-trained model weights using various datasets covering diﬀerent languages, time periods, and document types. Due to domain shift [7], the prediction performance can notably drop when models are ap- plied to target samples that are signiﬁcantly diﬀerent from the training dataset. As document structures and layouts vary greatly in diﬀerent domains, it is important to select models trained on a dataset similar to the test samples. A semantic syntax is used for initializing the model weights in LayoutParser, using both the dataset name and model name lp://<dataset-name>/<model-architecture-name>.\n```\n\nNote that although the table text is collapsed into a single string in the document's content, the metadata contains a representation of its rows and columns:\n\n```\nfrom IPython.display import HTML, displaysegments = [    doc.metadata    for doc in docs    if doc.metadata.get(\"page_number\") == 5 and doc.metadata.get(\"category\") == \"Table\"]display(HTML(segments[0][\"text_as_html\"]))\n```\n\nable 1. LUllclll 1ayoul actCCLloll 1110AdCs 111 L1C LayoOulralsel 1110U4cl 200\n\nDataset\n\n| Base Model'|\n\nNotes\n\nPubLayNet \\[38\\]\n\nF/M\n\nLayouts of modern scientific documents\n\nPRImA\n\nM\n\nLayouts of scanned modern magazines and scientific reports\n\nNewspaper\n\nF\n\nLayouts of scanned US newspapers from the 20th century\n\nTableBank \\[18\\]\n\nF\n\nTable region on modern scientific and business document\n\nHJDataset\n\nF/M\n\nLayouts of history Japanese documents\n\nStructures may have parent-child relationships -- for example, a paragraph might belong to a section with a title. If a section is of particular interest (e.g., for indexing) we can isolate the corresponding `Document` objects.\n\nBelow, we extract all text associated with the document's \"Conclusion\" section:\n\n```\nrender_page(docs, 14, print_text=False)\n```\n\n![](data:image/png;base64,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njzJ2NgY6XSaUCjErl27aGhooKenB5lMxoc+9CG6u7v5H//jf4h9qra2lpMnT6JWqzlw4IB47uzsLEtLSxw8eJCVlRXS6TR1dXV0dnYSCoUYHh4ml8thsVhwOp1s2bJl3dpPJpMcPnwYhULBpUuXyOVy1NbWYjQacblc7N+/XyghVVTxbkaVDlTFLQm57MrU3bFzB729vRw+fFhU4BwfH+dHP/oRCoWCpaUlfvzjH+PxeKipqaGvr49XXnkFmUxGNBplfn4et9tNc3MzTz31FH19feh0OqxWK1/+8peBK0L2pUuXeOWVVwT//u/+7u+EpXRgYIBLly5RKBT4h3/4ByKRCHq9nh/84AccPHjwqlzU5XKZv/7rv8ZisbBv3z7K5TL/43/8D4xGI729vezcuZOenh7q6+tvqC80Gg1ms5m5uTlhpb9RtLW1MTs7yze/+U3kcjkWi4X//t//O0NDQ+j1ekZGRrh48SLFYpF/+Zd/4dSpU+zbt49du3bx5S9/GY/Hw+DgIM899xyRSIQDBw6wurpKKpUik8kwOzvLww8/zF133cXY2BhDQ0NEo1Hx/kQiwdjYGH6/n507d7K0tCSEMQmlUomvfe1rZDIZenp6UKvVfPOb3yQej2OxWHj88cc5e/YsTqeTwcFBhoaGROVVCUajkaWlJaampohGo5hMJp588kkSiQRtbW0MDw/zve99T4zvz3/+c6ampkSl3meeeUaM79GjR2loaMDhcPCf/tN/wufzodPpiMfjHDlyBL1ej8/nY2JigunpaaampvjmN7/JoUOHGBwcZHh4+CrayeLiIqdOneL48ePceeedRKNRoQTMzc3xpS99iX379rF3716OHTvGL37xC5LJJP/0T/9EMpmko6OD5eVlnn76aZxOJ7/85S+JRCI4nU4KhQI//vGPAbBarTz66KNcuHABu93OhQsX+O53v0tTUxMTExP86le/Ip/P4/f7+fa3v41er0er1fLKK6+QyWRYWFjg6aefJpVKYTab+cd//EcADhw4wK5du9i9ezd33HHHVfNMp9PR0dHB97//feLxOAaDAbfbzT/+4z/S3d3N0NAQjzzyCG63m7q6Oh5++GFhjT116hTnzp1j586d/M//+T/x+Xxks1lee+01vvvd73L48GG++c1vUldXh8lkYmRkhO9///vcf//9nD59mqmpqauoabOz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4eabb77gnswjj/cy8nSgPPI4D5RKJT//+c/54Q9/yAc/+EEmJib46le/itlsprm5mU2bNrFlyxYqKir45je/iVarlRUiT5w4QU1NDcXFxbJy5BVXXIFarebKK69kenoan8/H0NAQP/jBD6ipqaGyspLh4WGi0ShXXnklkUiE++67j61bt84qBrQQli9fzhVXXMFdd93Fddddx8MPP0wwGJxVAOhC/f3Rj37ET37yE+69916mp6f56le/SnFxMZWVlZjNZgwGAzt27CCRSGC1Wqmvr6e1tZWrrrqKmpoaotEo+/btY/fu3fh8Pq655hpUKhVTU1N0dnYSjUb5l3/5FxKJBPv27cPn80nt+NOnT3PfffdRUFCA1+vFarXygQ98gFOnTsnqoQD9/f0YjUaam5upqanhuuuu4zOf+czFT/RFQqFQcP3117N69Wri8Ti7d++e9XeDwUBtbS0333wzHo+H5uZmNBoN09PTGI1GvvzlL1NdXc0VV1zBli1bsFqtPPTQQ6TTaTZs2EBDQwNNTU38zd/8zaKMjUQiwcTEBPfddx8//vGPOXLkyGXtb0NDA+Xl5fLUZ/v27ZKWc/LkSSKRCHfffTcf/OAHJX1oaGiIM2fOUF9fz5/92Z/x61//GofDQXV1NTabjQMHDlBfX49Go6G2tpY77riDe++994LOSyKRwOPxMDo6SkVFBV/96leXbJQVFRVx44038uyzz7J3714sFgsrVqxAq9Wya9cuqqqq8Pv9DA4OMj09TX19PSqVitbWVjZv3ozNZuPQoUPAW8nZzc3NbN26lbq6Ovbt28fExAQHDx5Eo9Fw4403csMNN/AP//APs/aTXq9nx44dJJNJ9u/fj8PhoK6ujptvvpmPfOQjMhm2p6eHp556ii9/+cu8//3v56WXXuLUqVPU19ezYsUKXnjhhQvmulitVu6++26eeuop/H7/ktRv5qKuro6CggL8fj8TExOMjY1RUVFBSUkJq1at4uqrr6a6upqHHnqIUChET08Pb775JsePH2fHjh1YrVZWrFghTxw3bdokaYMHDhygs7OTm266iWuvvVae9LW1tfHLX/6S2tpaVq1axbFjx9BoNGzduhV4az+uWbOGnTt3csstt7Br1y7sdjuvvfYafr+furo61q1bRygUYtu2bZSUlODxeBaVs3Xrrbfi9/s5cODAJY1bHnm8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7ej1etavXy8Uy3Q6fc2879y5k46ODrLZLAcPHsTj8bB79270ej16vZ6GhgampqbQarV85CMfYceOHdTU1LBz5078fj/PPfccwWCQiooKmpqaqKio4A//8A958803uXTpErW1tfh8Pg4fPozL5cJiseByudiyZQtr1qyhp6eH5557jnPnzolK55cuXSIej3Px4kXeeOMN+vr6uOOOO5iamuLw4cNMT0/j9/sxm5f6+5vNZtauXUt7eztarVa8c3fv3s19993HN7/5TZRKJVarFZPJxP3338/DDz8slE6lUonBYGDnzp10dXXR2dmJXq9naGiIQ4cOYbVa0el0pFIpKisr+Xf/7t/xyiuvYLFYePDBBzlw4ABdXV1ifbhcrlvqcikj824hr1KZ9z2SO0IsFqOvr4+pqSnm5uYoFos3fS2lUonP52NhYYGxsTEGBwcZHh5m165dNDY2srCwQDqdRqlU0t7eLlwZDAYDR48eRafT0drayve//33Wrl2L2WxelUXfYrHgdDqx2+03lXFnJcrlMjMzM0xNTREKhXA6nWzZskVYxJLJJHNzc2zdupVyuUw6nb4pf3yVSoXFYsFms/H666/T0NBwS6xikqX1hRde4C//8i8xmUykUimSySRqtRqPx4NCoVi1y9fVlEolzpw5w+bNm5cVSm+EUqmkoqJCuFHAFeVosftVLpcjm/23amxOp1MIipI71fWQhL8NGzZw4MABMd6FhQVqa68NcF8Nc3NzBAIBpqensVgsbN68WVjpJVcIaX1ks9lVBUzfDCutjTvvvBO4YpXu7u4Wv/f19aHX64Url16vF1WyU6kUAwMD/M3f/A1f+9rXcDqdlEol4R7idDqFgDY2NsY3vvEN/ut//a/4fD6KxSKRSIRsNivu2eIK2tL/x8bGSKVS+Hy+Jc+IQqFgeHj4ujs5AA6HA61WKxRO6V3R3d2NSqVienqaUqnEM888w6c+9Snq6uqWrJlMJiN2x+DXGZSSSUql0jW7dcVi8ZpnYWxsjB/+8Ifs3LmT2tpadDod4XCY++67jx/96Edks1laWlro6emho6MDnU7HxMQEFy5cYH5+nkceeURUGpdcjZxOJ3DlGaqsrGTLli3Y7XbWrFmDxWJBr9eLOBFpzRaLRRwOB16vl23bttHV1UUul+PDH/4wd911F/39/XzrW9/iE5/4BHq9nnPn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)\n\n```\nconclusion_docs = []parent_id = -1for doc in docs:    if doc.metadata[\"category\"] == \"Title\" and \"Conclusion\" in doc.page_content:        parent_id = doc.metadata[\"element_id\"]    if doc.metadata.get(\"parent_id\") == parent_id:        conclusion_docs.append(doc)for doc in conclusion_docs:    print(doc.page_content)\n```\n\n```\nLayoutParser provides a comprehensive toolkit for deep learning-based document image analysis. The oﬀ-the-shelf library is easy to install, and can be used to build ﬂexible and accurate pipelines for processing documents with complicated structures. It also supports high-level customization and enables easy labeling and training of DL models on unique document image datasets. The LayoutParser community platform facilitates sharing DL models and DIA pipelines, inviting discussion and promoting code reproducibility and reusability. The LayoutParser team is committed to keeping the library updated continuously and bringing the most recent advances in DL-based DIA, such as multi-modal document modeling [37, 36, 9] (an upcoming priority), to a diverse audience of end-users.Acknowledgements We thank the anonymous reviewers for their comments and suggestions. This project is supported in part by NSF Grant OIA-2033558 and funding from the Harvard Data Science Initiative and Harvard Catalyst. Zejiang Shen thanks Doug Downey for suggestions.\n```\n\nOCR is run on images, enabling the extraction of text therein:\n\n![](data:image/png;base64,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Fz97y+XX/C5oD0IQcDe/UURfNAYB9FC6mxesfKvPL0jK/5Y/S6fTuHLlCgYGBlBVVYV0Oo1AIIB169bdchrP5Y4D3P7HaP6P4O22XfzdxX9bfF6rNf+Yt/ohXe74iwvW8z+Tt5n/oz//e7dL7+JCw92c02rzYrV5sJzl8mDxvu/22iyXPjldK+13/ufydounjpT3catjLPedxd9dzX273P5X81yslGcrncdK+1/u2q50fDl4n3/P3c31vZtrs5rnYbnzvRf36EpWcx1ud863OhfZcvu+1bN/L56pzxuDAHoYsDsQFQz5x2Lxj8b8HxKVSoXy8nLRBzeXy8Hn88HpdN7xce7mu7fa9nZ/u9sfw/nb3WqA3XL7X+5HenG/6ZW+e7v03qtzutPv3+kgw9sFKfeioLLc9ivtd/7n8/++mvy+2/SsZts73f9K3/8sn9/u2t7ufl5p/7d6p6z0+eJrc6fX507y824C6dula7XnvJpt7+S4d3osIloZgwB6qHUuvwL9Z6AAdG6gyI3wvE+DOWDBB0RERCu4979NRPcegwB6KLnUgEEBfL3zfqeEiIhoKYPi5m8V0YOKYwLooTWUAILLz7RIRER0X7nUQLnu9t8jul8YBBARERERFZi7Gy1EREREREQPLQYBREREREQFhkEAEREREVGBYRBARERERFRgGAQQERERERUYBgFERERERAWGQQARERERUYFhEEBEREREVGAYBBARERERFRgGAUREREREBYZBABERERFRgWEQQERERERUYBgEEBEREREVGAYBREREREQFhkEAEREREVGBYRBARERERFRgGAQQERERERUYBgFERERERAWGQQARERERUYFhEEBEREREVGAYBBARERERFRgGAUREREREBYZBABERERFRgWEQQERERERUYBgEEBEREREVGAYBREREREQFhkEAEREREVGBYRBARERERFRgGAQQERERERUYBgFERERERAWGQQARERERUYFhEEBEREREVGAYBBARERERFRgGAUREREREBYZBABERERFRgWEQQERERERUYBgEEBEREREVGAYBREREREQFhkEAEREREVGBYRBARERERFRgGAQQERERERUYBgFERERERAWGQQARERERUYFhEEBEREREVGAYBBARERERFRgGAUREREREBYZBABERERFRgWEQQERERERUYBgEEBEREREVGAYBREREREQFhkEAEREREVGBYRBARERERFRgGAQQERERERUYBgFERERERAWGQQARERERUYFhEEBEREREVGAYBBARERERFRgGAUREREREBYZBABERERFRgWEQQERERERUYBgEEBEREREVGAYBREREREQFhkEAEREREVGBYRBARERERFRgGAQQERERERUYBgFERERERAWGQQARERERUYFhEEBEREREVGAYBBARERERFRgGAUREREREBYZBABERERFRgWEQQERERERUYBgEEBEREREVGAYBREREREQFhkEAEREREVGBYRBARERERFRgGAQQERERERUYBgFERERERAWGQQARERERUYFhEEBEREREVGAYBBARERERFRgGAUREREREBYZBABERERFRgWEQQERERERUYBgEEBEREREVGAYBREREREQFhkEAEREREVGBYRBARERERFRgGAQQERERERUYBgFERERERAWGQQARERERUYFhEEBEREREVGAYBBARERERFRgGAUREREREBYZBABERERFRgWEQQERERERUYBgEEBEREREVGAYBREREREQFhkEAEREREVGBYRBARERERFRgGAQQERERERUYBgFERERERAWGQQARERERUYFhEEBEREREVGAYBBARERERFRgGAUREREREBYZBABERERFRgWEQQERERERUYBgEEBEREREVGAYBREREREQFhkEAEREREVGBYRBARERERFRgGAQQERERERUYBgFERERERAWGQQARERERUYFhEEBEREREVGAYBBARERERFRgGAUREREREBYZBABERERFRgWEQQERERERUYBgEEBEREREVGAYBREREREQFhkEAEREREVGBYRBARERERFRgGAQQERERERUYBgFERERERAWGQQARERERUYFhEEBEREREVGAYBBARERERFRgGAUREREREBYZBABERERFRgWEQQERERERUYBgEEBEREREVGAYBREREREQFhkEAEREREVGBYRBARERERFRgGAQQERERERUYBgFERERERAWGQQARERERUYFhEEBEREREVGAYBBARERERFRgGAUREREREBYZBABERERFRgWEQQERERERUYBgEEBEREREVGAYBREREREQFhkEAEREREVGBYRBARERERFRgGAQQERERERUYBgFERERERAWGQQARERERUYFhEEBEREREVGAYBBARERERFRgGAUREREREBYZBABERERFRgWEQQERERERUYBgEEBEREREVGAYBREREREQFhkEAEREREVGBYRBARERERFRgGAQQERERERWY/x9i+iv/PHtlUAAAAABJRU5ErkJggg==)\n\n```\nLayoutParser: A Uniﬁed Toolkit for DL-Based DIAfocuses on precision, eﬃciency, and robustness. The target documents may have complicated structures, and may require training multiple layout detection models to achieve the optimal accuracy. Light-weight pipelines are built for relatively simple documents, with an emphasis on development ease, speed and ﬂexibility. Ideally one only needs to use existing resources, and model training should be avoided. Through two exemplar projects, we show how practitioners in both academia and industry can easily build such pipelines using LayoutParser and extract high-quality structured document data for their downstream tasks. The source code for these projects will be publicly available in the LayoutParser community hub.115.1 A Comprehensive Historical Document Digitization PipelineThe digitization of historical documents can unlock valuable data that can shed light on many important social, economic, and historical questions. Yet due to scan noises, page wearing, and the prevalence of complicated layout structures, ob- taining a structured representation of historical document scans is often extremely complicated. In this example, LayoutParser was used to develop a comprehensive pipeline, shown in Figure 5, to gener- ate high-quality structured data from historical Japanese ﬁrm ﬁnancial ta- bles with complicated layouts. The pipeline applies two layout models to identify diﬀerent levels of document structures and two customized OCR engines for optimized character recog- nition accuracy.‘Active Learning Layout Annotate Layout Dataset | +—— Annotation Toolkit A4 Deep Learning Layout Layout Detection Model Training & Inference, A Post-processing — Handy Data Structures & \\ Lo orajport 7 ) Al Pls for Layout Data A4 Default and Customized Text Recognition 0CR Models ¥ Visualization & Export Layout Structure Visualization & Storage The Japanese Document Helpful LayoutParser Modules Digitization PipelineAs shown in Figure 4 (a), the document contains columns of text written vertically 15, a common style in Japanese. Due to scanning noise and archaic printing technology, the columns can be skewed or have vari- able widths, and hence cannot be eas- ily identiﬁed via rule-based methods. Within each column, words are sepa- rated by white spaces of variable size, and the vertical positions of objects can be an indicator of their layout type.Fig. 5: Illustration of how LayoutParser helps with the historical document digi- tization pipeline.15 A document page consists of eight rows like this. For simplicity we skip the row segmentation discussion and refer readers to the source code when available.\n```\n\nNote that the text from the figure on the right is extracted and incorporated into the content of the `Document`.\n\n### Local parsing[​](#local-parsing \"Direct link to Local parsing\")\n\nParsing locally requires the installation of additional dependencies.\n\n**Poppler** (PDF analysis)\n\n*   Linux: `apt-get install poppler-utils`\n*   Mac: `brew install poppler`\n*   Windows: [https://github.com/oschwartz10612/poppler-windows](https://github.com/oschwartz10612/poppler-windows)\n\n**Tesseract** (OCR)\n\n*   Linux: `apt-get install tesseract-ocr`\n*   Mac: `brew install tesseract`\n*   Windows: [https://github.com/UB-Mannheim/tesseract/wiki#tesseract-installer-for-windows](https://github.com/UB-Mannheim/tesseract/wiki#tesseract-installer-for-windows)\n\nWe will also need to install the `unstructured` PDF extras:\n\n```\n%pip install -qU \"unstructured[pdf]\"\n```\n\nWe can then use the [UnstructuredLoader](https://python.langchain.com/api_reference/unstructured/document_loaders/langchain_unstructured.document_loaders.UnstructuredLoader.html) much the same way, forgoing the API key and `partition_via_api` setting:\n\n```\nloader_local = UnstructuredLoader(    file_path=file_path,    strategy=\"hi_res\",)docs_local = []for doc in loader_local.lazy_load():    docs_local.append(doc)\n```\n\n```\nWARNING: This function will be deprecated in a future release and `unstructured` will simply use the DEFAULT_MODEL from `unstructured_inference.model.base` to set default model nameINFO: Reading PDF for file: /Users/chestercurme/repos/langchain/libs/community/tests/integration_tests/examples/layout-parser-paper.pdf ...INFO: Detecting page elements ...INFO: Detecting page elements ...INFO: Detecting page elements ...INFO: Detecting page elements ...INFO: Detecting page elements ...INFO: Detecting page elements ...INFO: Detecting page elements ...INFO: Detecting page elements ...INFO: Detecting page elements ...INFO: Detecting page elements ...INFO: Detecting page elements ...INFO: Detecting page elements ...INFO: Detecting page elements ...INFO: Detecting page elements ...INFO: Detecting page elements ...INFO: Detecting page elements ...INFO: Processing entire page OCR with tesseract...INFO: Processing entire page OCR with tesseract...INFO: Processing entire page OCR with tesseract...INFO: Processing entire page OCR with tesseract...INFO: Processing entire page OCR with tesseract...INFO: Processing entire page OCR with tesseract...INFO: padding image by 20 for structure detectionINFO: Processing entire page OCR with tesseract...INFO: Processing entire page OCR with tesseract...INFO: Processing entire page OCR with tesseract...INFO: Processing entire page OCR with tesseract...INFO: padding image by 20 for structure detectionINFO: Processing entire page OCR with tesseract...INFO: Processing entire page OCR with tesseract...INFO: Processing entire page OCR with tesseract...INFO: Processing entire page OCR with tesseract...INFO: Processing entire page OCR with tesseract...INFO: Processing entire page OCR with tesseract...INFO: Processing entire page OCR with tesseract...INFO: Processing entire page OCR with tesseract...\n```\n\nThe list of documents can then be processed similarly to those obtained from the API.\n\n## Use of multimodal models[​](#use-of-multimodal-models \"Direct link to Use of multimodal models\")\n\nMany modern LLMs support inference over multimodal inputs (e.g., images). In some applications-- such as question-answering over PDFs with complex layouts, diagrams, or scans-- it may be advantageous to skip the PDF parsing, instead casting a PDF page to an image and passing it to a model directly. This allows a model to reason over the two dimensional content on the page, instead of a \"one-dimensional\" string representation.\n\nIn principle we can use any LangChain [chat model](https://python.langchain.com/docs/concepts/chat_models/) that supports multimodal inputs. A list of these models is documented [here](https://python.langchain.com/docs/integrations/chat/). Below we use OpenAI's `gpt-4o-mini`.\n\nFirst we define a short utility function to convert a PDF page to a base64-encoded image:\n\n```\n%pip install -qU PyMuPDF pillow langchain-openai\n```\n\n```\nimport base64import ioimport fitzfrom PIL import Imagedef pdf_page_to_base64(pdf_path: str, page_number: int):    pdf_document = fitz.open(pdf_path)    page = pdf_document.load_page(page_number - 1)  # input is one-indexed    pix = page.get_pixmap()    img = Image.frombytes(\"RGB\", [pix.width, pix.height], pix.samples)    buffer = io.BytesIO()    img.save(buffer, format=\"PNG\")    return base64.b64encode(buffer.getvalue()).decode(\"utf-8\")\n```\n\n```\nfrom IPython.display import Image as IPImagefrom IPython.display import displaybase64_image = pdf_page_to_base64(file_path, 11)display(IPImage(data=base64.b64decode(base64_image)))\n```\n\n![](data:image/png;base64,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)\n\nWe can then query the model in the [usual way](https://python.langchain.com/docs/how_to/multimodal_inputs/). Below we ask it a question on related to the diagram on the page.\n\n```\nfrom langchain_openai import ChatOpenAIllm = ChatOpenAI(model=\"gpt-4o-mini\")\n```\n\n```\nfrom langchain_core.messages import HumanMessagequery = \"What is the name of the first step in the pipeline?\"message = HumanMessage(    content=[        {\"type\": \"text\", \"text\": query},        {            \"type\": \"image_url\",            \"image_url\": {\"url\": f\"data:image/jpeg;base64,{base64_image}\"},        },    ],)response = llm.invoke([message])print(response.content)\n```\n\n```\nINFO: HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"``````outputThe first step in the pipeline is \"Annotate Layout Dataset.\"\n```\n\n## Other PDF loaders[​](#other-pdf-loaders \"Direct link to Other PDF loaders\")\n\nFor a list of available LangChain PDF loaders, please see [this table](https://python.langchain.com/docs/integrations/document_loaders/#pdfs)."
},
{
  "url": "https://python.langchain.com/docs/how_to/add_scores_retriever/",
  "markdown": "# giscus\n\n## How to add scores to retriever results\n\n[Retrievers](https://python.langchain.com/docs/concepts/retrievers/) will return sequences of [Document](https://python.langchain.com/api_reference/core/documents/langchain_core.documents.base.Document.html) objects, which by default include no information about the process that retrieved them (e.g., a similarity score against a query). Here we demonstrate how to add retrieval scores to the `.metadata` of documents:\n\n1.  From [vectorstore retrievers](https://python.langchain.com/docs/how_to/vectorstore_retriever/);\n2.  From higher-order LangChain retrievers, such as [SelfQueryRetriever](https://python.langchain.com/docs/how_to/self_query/) or [MultiVectorRetriever](https://python.langchain.com/docs/how_to/multi_vector/).\n\nFor (1), we will implement a short wrapper function around the corresponding [vector store](https://python.langchain.com/docs/concepts/vectorstores/). For (2), we will update a method of the corresponding class.\n\n## Create vector store[​](#create-vector-store \"Direct link to Create vector store\")\n\nFirst we populate a vector store with some data. We will use a [PineconeVectorStore](https://python.langchain.com/api_reference/pinecone/vectorstores/langchain_pinecone.vectorstores.PineconeVectorStore.html), but this guide is compatible with any LangChain vector store that implements a `.similarity_search_with_score` method.\n\n```\nfrom langchain_core.documents import Documentfrom langchain_openai import OpenAIEmbeddingsfrom langchain_pinecone import PineconeVectorStoredocs = [    Document(        page_content=\"A bunch of scientists bring back dinosaurs and mayhem breaks loose\",        metadata={\"year\": 1993, \"rating\": 7.7, \"genre\": \"science fiction\"},    ),    Document(        page_content=\"Leo DiCaprio gets lost in a dream within a dream within a dream within a ...\",        metadata={\"year\": 2010, \"director\": \"Christopher Nolan\", \"rating\": 8.2},    ),    Document(        page_content=\"A psychologist / detective gets lost in a series of dreams within dreams within dreams and Inception reused the idea\",        metadata={\"year\": 2006, \"director\": \"Satoshi Kon\", \"rating\": 8.6},    ),    Document(        page_content=\"A bunch of normal-sized women are supremely wholesome and some men pine after them\",        metadata={\"year\": 2019, \"director\": \"Greta Gerwig\", \"rating\": 8.3},    ),    Document(        page_content=\"Toys come alive and have a blast doing so\",        metadata={\"year\": 1995, \"genre\": \"animated\"},    ),    Document(        page_content=\"Three men walk into the Zone, three men walk out of the Zone\",        metadata={            \"year\": 1979,            \"director\": \"Andrei Tarkovsky\",            \"genre\": \"thriller\",            \"rating\": 9.9,        },    ),]vectorstore = PineconeVectorStore.from_documents(    docs, index_name=\"sample\", embedding=OpenAIEmbeddings())\n```\n\n## Retriever[​](#retriever \"Direct link to Retriever\")\n\nTo obtain scores from a vector store retriever, we wrap the underlying vector store's `.similarity_search_with_score` method in a short function that packages scores into the associated document's metadata.\n\nWe add a `@chain` decorator to the function to create a [Runnable](https://python.langchain.com/docs/concepts/lcel/) that can be used similarly to a typical retriever.\n\n```\nfrom typing import Listfrom langchain_core.documents import Documentfrom langchain_core.runnables import chain@chaindef retriever(query: str) -> List[Document]:    docs, scores = zip(*vectorstore.similarity_search_with_score(query))    for doc, score in zip(docs, scores):        doc.metadata[\"score\"] = score    return docs\n```\n\n```\nresult = retriever.invoke(\"dinosaur\")result\n```\n\n```\n(Document(page_content='A bunch of scientists bring back dinosaurs and mayhem breaks loose', metadata={'genre': 'science fiction', 'rating': 7.7, 'year': 1993.0, 'score': 0.84429127}), Document(page_content='Toys come alive and have a blast doing so', metadata={'genre': 'animated', 'year': 1995.0, 'score': 0.792038262}), Document(page_content='Three men walk into the Zone, three men walk out of the Zone', metadata={'director': 'Andrei Tarkovsky', 'genre': 'thriller', 'rating': 9.9, 'year': 1979.0, 'score': 0.751571238}), Document(page_content='A psychologist / detective gets lost in a series of dreams within dreams within dreams and Inception reused the idea', metadata={'director': 'Satoshi Kon', 'rating': 8.6, 'year': 2006.0, 'score': 0.747471571}))\n```\n\nNote that similarity scores from the retrieval step are included in the metadata of the above documents.\n\n## SelfQueryRetriever[​](#selfqueryretriever \"Direct link to SelfQueryRetriever\")\n\n`SelfQueryRetriever` will use a LLM to generate a query that is potentially structured-- for example, it can construct filters for the retrieval on top of the usual semantic-similarity driven selection. See [this guide](https://python.langchain.com/docs/how_to/self_query/) for more detail.\n\n`SelfQueryRetriever` includes a short (1 - 2 line) method `_get_docs_with_query` that executes the `vectorstore` search. We can subclass `SelfQueryRetriever` and override this method to propagate similarity scores.\n\nFirst, following the [how-to guide](https://python.langchain.com/docs/how_to/self_query/), we will need to establish some metadata on which to filter:\n\n```\nfrom langchain.chains.query_constructor.base import AttributeInfofrom langchain.retrievers.self_query.base import SelfQueryRetrieverfrom langchain_openai import ChatOpenAImetadata_field_info = [    AttributeInfo(        name=\"genre\",        description=\"The genre of the movie. One of ['science fiction', 'comedy', 'drama', 'thriller', 'romance', 'action', 'animated']\",        type=\"string\",    ),    AttributeInfo(        name=\"year\",        description=\"The year the movie was released\",        type=\"integer\",    ),    AttributeInfo(        name=\"director\",        description=\"The name of the movie director\",        type=\"string\",    ),    AttributeInfo(        name=\"rating\", description=\"A 1-10 rating for the movie\", type=\"float\"    ),]document_content_description = \"Brief summary of a movie\"llm = ChatOpenAI(temperature=0)\n```\n\nWe then override the `_get_docs_with_query` to use the `similarity_search_with_score` method of the underlying vector store:\n\n```\nfrom typing import Any, Dictclass CustomSelfQueryRetriever(SelfQueryRetriever):    def _get_docs_with_query(        self, query: str, search_kwargs: Dict[str, Any]    ) -> List[Document]:        \"\"\"Get docs, adding score information.\"\"\"        docs, scores = zip(            *self.vectorstore.similarity_search_with_score(query, **search_kwargs)        )        for doc, score in zip(docs, scores):            doc.metadata[\"score\"] = score        return docs\n```\n\nInvoking this retriever will now include similarity scores in the document metadata. Note that the underlying structured-query capabilities of `SelfQueryRetriever` are retained.\n\n```\nretriever = CustomSelfQueryRetriever.from_llm(    llm,    vectorstore,    document_content_description,    metadata_field_info,)result = retriever.invoke(\"dinosaur movie with rating less than 8\")result\n```\n\n```\n(Document(page_content='A bunch of scientists bring back dinosaurs and mayhem breaks loose', metadata={'genre': 'science fiction', 'rating': 7.7, 'year': 1993.0, 'score': 0.84429127}),)\n```\n\n## MultiVectorRetriever[​](#multivectorretriever \"Direct link to MultiVectorRetriever\")\n\n`MultiVectorRetriever` allows you to associate multiple vectors with a single document. This can be useful in a number of applications. For example, we can index small chunks of a larger document and run the retrieval on the chunks, but return the larger \"parent\" document when invoking the retriever. [ParentDocumentRetriever](https://python.langchain.com/docs/how_to/parent_document_retriever/), a subclass of `MultiVectorRetriever`, includes convenience methods for populating a vector store to support this. Further applications are detailed in this [how-to guide](https://python.langchain.com/docs/how_to/multi_vector/).\n\nTo propagate similarity scores through this retriever, we can again subclass `MultiVectorRetriever` and override a method. This time we will override `_get_relevant_documents`.\n\nFirst, we prepare some fake data. We generate fake \"whole documents\" and store them in a document store; here we will use a simple [InMemoryStore](https://python.langchain.com/api_reference/core/stores/langchain_core.stores.InMemoryBaseStore.html).\n\n```\nfrom langchain.storage import InMemoryStorefrom langchain_text_splitters import RecursiveCharacterTextSplitter# The storage layer for the parent documentsdocstore = InMemoryStore()fake_whole_documents = [    (\"fake_id_1\", Document(page_content=\"fake whole document 1\")),    (\"fake_id_2\", Document(page_content=\"fake whole document 2\")),]docstore.mset(fake_whole_documents)\n```\n\nNext we will add some fake \"sub-documents\" to our vector store. We can link these sub-documents to the parent documents by populating the `\"doc_id\"` key in its metadata.\n\n```\ndocs = [    Document(        page_content=\"A snippet from a larger document discussing cats.\",        metadata={\"doc_id\": \"fake_id_1\"},    ),    Document(        page_content=\"A snippet from a larger document discussing discourse.\",        metadata={\"doc_id\": \"fake_id_1\"},    ),    Document(        page_content=\"A snippet from a larger document discussing chocolate.\",        metadata={\"doc_id\": \"fake_id_2\"},    ),]vectorstore.add_documents(docs)\n```\n\n```\n['62a85353-41ff-4346-bff7-be6c8ec2ed89', '5d4a0e83-4cc5-40f1-bc73-ed9cbad0ee15', '8c1d9a56-120f-45e4-ba70-a19cd19a38f4']\n```\n\nTo propagate the scores, we subclass `MultiVectorRetriever` and override its `_get_relevant_documents` method. Here we will make two changes:\n\n1.  We will add similarity scores to the metadata of the corresponding \"sub-documents\" using the `similarity_search_with_score` method of the underlying vector store as above;\n2.  We will include a list of these sub-documents in the metadata of the retrieved parent document. This surfaces what snippets of text were identified by the retrieval, together with their corresponding similarity scores.\n\n```\nfrom collections import defaultdictfrom langchain.retrievers import MultiVectorRetrieverfrom langchain_core.callbacks import CallbackManagerForRetrieverRunclass CustomMultiVectorRetriever(MultiVectorRetriever):    def _get_relevant_documents(        self, query: str, *, run_manager: CallbackManagerForRetrieverRun    ) -> List[Document]:        \"\"\"Get documents relevant to a query.        Args:            query: String to find relevant documents for            run_manager: The callbacks handler to use        Returns:            List of relevant documents        \"\"\"        results = self.vectorstore.similarity_search_with_score(            query, **self.search_kwargs        )        # Map doc_ids to list of sub-documents, adding scores to metadata        id_to_doc = defaultdict(list)        for doc, score in results:            doc_id = doc.metadata.get(\"doc_id\")            if doc_id:                doc.metadata[\"score\"] = score                id_to_doc[doc_id].append(doc)        # Fetch documents corresponding to doc_ids, retaining sub_docs in metadata        docs = []        for _id, sub_docs in id_to_doc.items():            docstore_docs = self.docstore.mget([_id])            if docstore_docs:                if doc := docstore_docs[0]:                    doc.metadata[\"sub_docs\"] = sub_docs                    docs.append(doc)        return docs\n```\n\nInvoking this retriever, we can see that it identifies the correct parent document, including the relevant snippet from the sub-document with similarity score.\n\n```\nretriever = CustomMultiVectorRetriever(vectorstore=vectorstore, docstore=docstore)retriever.invoke(\"cat\")\n```\n\n```\n[Document(page_content='fake whole document 1', metadata={'sub_docs': [Document(page_content='A snippet from a larger document discussing cats.', metadata={'doc_id': 'fake_id_1', 'score': 0.831276655})]})]\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/semantic-chunker/",
  "markdown": "# giscus\n\n## How to split text based on semantic similarity\n\nTaken from Greg Kamradt's wonderful notebook: [5\\_Levels\\_Of\\_Text\\_Splitting](https://github.com/FullStackRetrieval-com/RetrievalTutorials/blob/main/tutorials/LevelsOfTextSplitting/5_Levels_Of_Text_Splitting.ipynb)\n\nAll credit to him.\n\nThis guide covers how to split chunks based on their semantic similarity. If embeddings are sufficiently far apart, chunks are split.\n\nAt a high level, this splits into sentences, then groups into groups of 3 sentences, and then merges one that are similar in the embedding space.\n\n## Install Dependencies[​](#install-dependencies \"Direct link to Install Dependencies\")\n\n```\n!pip install --quiet langchain_experimental langchain_openai\n```\n\n## Load Example Data[​](#load-example-data \"Direct link to Load Example Data\")\n\n```\n# This is a long document we can split up.with open(\"state_of_the_union.txt\") as f:    state_of_the_union = f.read()\n```\n\n## Create Text Splitter[​](#create-text-splitter \"Direct link to Create Text Splitter\")\n\nTo instantiate a [SemanticChunker](https://python.langchain.com/api_reference/experimental/text_splitter/langchain_experimental.text_splitter.SemanticChunker.html), we must specify an embedding model. Below we will use [OpenAIEmbeddings](https://python.langchain.com/api_reference/community/embeddings/langchain_community.embeddings.openai.OpenAIEmbeddings.html).\n\n```\nfrom langchain_experimental.text_splitter import SemanticChunkerfrom langchain_openai.embeddings import OpenAIEmbeddingstext_splitter = SemanticChunker(OpenAIEmbeddings())\n```\n\n## Split Text[​](#split-text \"Direct link to Split Text\")\n\nWe split text in the usual way, e.g., by invoking `.create_documents` to create LangChain [Document](https://python.langchain.com/api_reference/core/documents/langchain_core.documents.base.Document.html) objects:\n\n```\ndocs = text_splitter.create_documents([state_of_the_union])print(docs[0].page_content)\n```\n\n```\nMadam Speaker, Madam Vice President, our First Lady and Second Gentleman. Members of Congress and the Cabinet. Justices of the Supreme Court. My fellow Americans. Last year COVID-19 kept us apart. This year we are finally together again. Tonight, we meet as Democrats Republicans and Independents. But most importantly as Americans. With a duty to one another to the American people to the Constitution. And with an unwavering resolve that freedom will always triumph over tyranny. Six days ago, Russia’s Vladimir Putin sought to shake the foundations of the free world thinking he could make it bend to his menacing ways. But he badly miscalculated. He thought he could roll into Ukraine and the world would roll over. Instead he met a wall of strength he never imagined. He met the Ukrainian people. From President Zelenskyy to every Ukrainian, their fearlessness, their courage, their determination, inspires the world. Groups of citizens blocking tanks with their bodies. Everyone from students to retirees teachers turned soldiers defending their homeland. In this struggle as President Zelenskyy said in his speech to the European Parliament “Light will win over darkness.” The Ukrainian Ambassador to the United States is here tonight. Let each of us here tonight in this Chamber send an unmistakable signal to Ukraine and to the world. Please rise if you are able and show that, Yes, we the United States of America stand with the Ukrainian people. Throughout our history we’ve learned this lesson when dictators do not pay a price for their aggression they cause more chaos. They keep moving.\n```\n\n## Breakpoints[​](#breakpoints \"Direct link to Breakpoints\")\n\nThis chunker works by determining when to \"break\" apart sentences. This is done by looking for differences in embeddings between any two sentences. When that difference is past some threshold, then they are split.\n\nThere are a few ways to determine what that threshold is, which are controlled by the `breakpoint_threshold_type` kwarg.\n\nNote: if the resulting chunk sizes are too small/big, the additional kwargs `breakpoint_threshold_amount` and `min_chunk_size` can be used for adjustments.\n\n### Percentile[​](#percentile \"Direct link to Percentile\")\n\nThe default way to split is based on percentile. In this method, all differences between sentences are calculated, and then any difference greater than the X percentile is split. The default value for X is 95.0 and can be adjusted by the keyword argument `breakpoint_threshold_amount` which expects a number between 0.0 and 100.0.\n\n```\ntext_splitter = SemanticChunker(    OpenAIEmbeddings(), breakpoint_threshold_type=\"percentile\")\n```\n\n```\ndocs = text_splitter.create_documents([state_of_the_union])print(docs[0].page_content)\n```\n\n```\nMadam Speaker, Madam Vice President, our First Lady and Second Gentleman. Members of Congress and the Cabinet. Justices of the Supreme Court. My fellow Americans. Last year COVID-19 kept us apart. This year we are finally together again. Tonight, we meet as Democrats Republicans and Independents. But most importantly as Americans. With a duty to one another to the American people to the Constitution. And with an unwavering resolve that freedom will always triumph over tyranny. Six days ago, Russia’s Vladimir Putin sought to shake the foundations of the free world thinking he could make it bend to his menacing ways. But he badly miscalculated. He thought he could roll into Ukraine and the world would roll over. Instead he met a wall of strength he never imagined. He met the Ukrainian people. From President Zelenskyy to every Ukrainian, their fearlessness, their courage, their determination, inspires the world. Groups of citizens blocking tanks with their bodies. Everyone from students to retirees teachers turned soldiers defending their homeland. In this struggle as President Zelenskyy said in his speech to the European Parliament “Light will win over darkness.” The Ukrainian Ambassador to the United States is here tonight. Let each of us here tonight in this Chamber send an unmistakable signal to Ukraine and to the world. Please rise if you are able and show that, Yes, we the United States of America stand with the Ukrainian people. Throughout our history we’ve learned this lesson when dictators do not pay a price for their aggression they cause more chaos. They keep moving.\n```\n\n### Standard Deviation[​](#standard-deviation \"Direct link to Standard Deviation\")\n\nIn this method, any difference greater than X standard deviations is split. The default value for X is 3.0 and can be adjusted by the keyword argument `breakpoint_threshold_amount`.\n\n```\ntext_splitter = SemanticChunker(    OpenAIEmbeddings(), breakpoint_threshold_type=\"standard_deviation\")\n```\n\n```\ndocs = text_splitter.create_documents([state_of_the_union])print(docs[0].page_content)\n```\n\n```\nMadam Speaker, Madam Vice President, our First Lady and Second Gentleman. Members of Congress and the Cabinet. Justices of the Supreme Court. My fellow Americans. Last year COVID-19 kept us apart. This year we are finally together again. Tonight, we meet as Democrats Republicans and Independents. But most importantly as Americans. With a duty to one another to the American people to the Constitution. And with an unwavering resolve that freedom will always triumph over tyranny. Six days ago, Russia’s Vladimir Putin sought to shake the foundations of the free world thinking he could make it bend to his menacing ways. But he badly miscalculated. He thought he could roll into Ukraine and the world would roll over. Instead he met a wall of strength he never imagined. He met the Ukrainian people. From President Zelenskyy to every Ukrainian, their fearlessness, their courage, their determination, inspires the world. Groups of citizens blocking tanks with their bodies. Everyone from students to retirees teachers turned soldiers defending their homeland. In this struggle as President Zelenskyy said in his speech to the European Parliament “Light will win over darkness.” The Ukrainian Ambassador to the United States is here tonight. Let each of us here tonight in this Chamber send an unmistakable signal to Ukraine and to the world. Please rise if you are able and show that, Yes, we the United States of America stand with the Ukrainian people. Throughout our history we’ve learned this lesson when dictators do not pay a price for their aggression they cause more chaos. They keep moving. And the costs and the threats to America and the world keep rising. That’s why the NATO Alliance was created to secure peace and stability in Europe after World War 2. The United States is a member along with 29 other nations. It matters. American diplomacy matters. American resolve matters. Putin’s latest attack on Ukraine was premeditated and unprovoked. He rejected repeated efforts at diplomacy. He thought the West and NATO wouldn’t respond. And he thought he could divide us at home. Putin was wrong. We were ready. Here is what we did. We prepared extensively and carefully. We spent months building a coalition of other freedom-loving nations from Europe and the Americas to Asia and Africa to confront Putin. I spent countless hours unifying our European allies. We shared with the world in advance what we knew Putin was planning and precisely how he would try to falsely justify his aggression. We countered Russia’s lies with truth. And now that he has acted the free world is holding him accountable. Along with twenty-seven members of the European Union including France, Germany, Italy, as well as countries like the United Kingdom, Canada, Japan, Korea, Australia, New Zealand, and many others, even Switzerland. We are inflicting pain on Russia and supporting the people of Ukraine. Putin is now isolated from the world more than ever. Together with our allies –we are right now enforcing powerful economic sanctions. We are cutting off Russia’s largest banks from the international financial system. Preventing Russia’s central bank from defending the Russian Ruble making Putin’s $630 Billion “war fund” worthless. We are choking off Russia’s access to technology that will sap its economic strength and weaken its military for years to come. Tonight I say to the Russian oligarchs and corrupt leaders who have bilked billions of dollars off this violent regime no more. The U.S. Department of Justice is assembling a dedicated task force to go after the crimes of Russian oligarchs. We are joining with our European allies to find and seize your yachts your luxury apartments your private jets. We are coming for your ill-begotten gains. And tonight I am announcing that we will join our allies in closing off American air space to all Russian flights – further isolating Russia – and adding an additional squeeze –on their economy. The Ruble has lost 30% of its value. The Russian stock market has lost 40% of its value and trading remains suspended. Russia’s economy is reeling and Putin alone is to blame. Together with our allies we are providing support to the Ukrainians in their fight for freedom. Military assistance. Economic assistance. Humanitarian assistance. We are giving more than $1 Billion in direct assistance to Ukraine. And we will continue to aid the Ukrainian people as they defend their country and to help ease their suffering. Let me be clear, our forces are not engaged and will not engage in conflict with Russian forces in Ukraine. Our forces are not going to Europe to fight in Ukraine, but to defend our NATO Allies – in the event that Putin decides to keep moving west. For that purpose we’ve mobilized American ground forces, air squadrons, and ship deployments to protect NATO countries including Poland, Romania, Latvia, Lithuania, and Estonia. As I have made crystal clear the United States and our Allies will defend every inch of territory of NATO countries with the full force of our collective power. And we remain clear-eyed. The Ukrainians are fighting back with pure courage. But the next few days weeks, months, will be hard on them. Putin has unleashed violence and chaos. But while he may make gains on the battlefield – he will pay a continuing high price over the long run. And a proud Ukrainian people, who have known 30 years  of independence, have repeatedly shown that they will not tolerate anyone who tries to take their country backwards. To all Americans, I will be honest with you, as I’ve always promised. A Russian dictator, invading a foreign country, has costs around the world. And I’m taking robust action to make sure the pain of our sanctions  is targeted at Russia’s economy. And I will use every tool at our disposal to protect American businesses and consumers. Tonight, I can announce that the United States has worked with 30 other countries to release 60 Million barrels of oil from reserves around the world. America will lead that effort, releasing 30 Million barrels from our own Strategic Petroleum Reserve. And we stand ready to do more if necessary, unified with our allies. These steps will help blunt gas prices here at home. And I know the news about what’s happening can seem alarming.\n```\n\n### Interquartile[​](#interquartile \"Direct link to Interquartile\")\n\nIn this method, the interquartile distance is used to split chunks. The interquartile range can be scaled by the keyword argument `breakpoint_threshold_amount`, the default value is 1.5.\n\n```\ntext_splitter = SemanticChunker(    OpenAIEmbeddings(), breakpoint_threshold_type=\"interquartile\")\n```\n\n```\ndocs = text_splitter.create_documents([state_of_the_union])print(docs[0].page_content)\n```\n\n```\nMadam Speaker, Madam Vice President, our First Lady and Second Gentleman. Members of Congress and the Cabinet. Justices of the Supreme Court. My fellow Americans. Last year COVID-19 kept us apart. This year we are finally together again. Tonight, we meet as Democrats Republicans and Independents. But most importantly as Americans. With a duty to one another to the American people to the Constitution. And with an unwavering resolve that freedom will always triumph over tyranny. Six days ago, Russia’s Vladimir Putin sought to shake the foundations of the free world thinking he could make it bend to his menacing ways. But he badly miscalculated. He thought he could roll into Ukraine and the world would roll over. Instead he met a wall of strength he never imagined. He met the Ukrainian people. From President Zelenskyy to every Ukrainian, their fearlessness, their courage, their determination, inspires the world. Groups of citizens blocking tanks with their bodies. Everyone from students to retirees teachers turned soldiers defending their homeland. In this struggle as President Zelenskyy said in his speech to the European Parliament “Light will win over darkness.” The Ukrainian Ambassador to the United States is here tonight. Let each of us here tonight in this Chamber send an unmistakable signal to Ukraine and to the world. Please rise if you are able and show that, Yes, we the United States of America stand with the Ukrainian people. Throughout our history we’ve learned this lesson when dictators do not pay a price for their aggression they cause more chaos. They keep moving.\n```\n\n### Gradient[​](#gradient \"Direct link to Gradient\")\n\nIn this method, the gradient of distance is used to split chunks along with the percentile method. This method is useful when chunks are highly correlated with each other or specific to a domain e.g. legal or medical. The idea is to apply anomaly detection on gradient array so that the distribution become wider and easy to identify boundaries in highly semantic data. Similar to the percentile method, the split can be adjusted by the keyword argument `breakpoint_threshold_amount` which expects a number between 0.0 and 100.0, the default value is 95.0.\n\n```\ntext_splitter = SemanticChunker(    OpenAIEmbeddings(), breakpoint_threshold_type=\"gradient\")\n```\n\n```\ndocs = text_splitter.create_documents([state_of_the_union])print(docs[0].page_content)\n```\n\n```\nMadam Speaker, Madam Vice President, our First Lady and Second Gentleman.\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/llm_caching/",
  "markdown": "# giscus\n\n[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/langchain-ai/langchain/blob/master/docs/docs/how_to/llm_caching.ipynb)[![Open on GitHub](https://img.shields.io/badge/Open%20on%20GitHub-grey?logo=github&logoColor=white)](https://github.com/langchain-ai/langchain/blob/master/docs/docs/how_to/llm_caching.ipynb)\n\n## How to cache LLM responses\n\nLangChain provides an optional [caching](https://python.langchain.com/docs/concepts/chat_models/#caching) layer for LLMs. This is useful for two reasons:\n\nIt can save you money by reducing the number of API calls you make to the LLM provider, if you're often requesting the same completion multiple times. It can speed up your application by reducing the number of API calls you make to the LLM provider.\n\n```\n%pip install -qU langchain_openai langchain_communityimport osfrom getpass import getpassif \"OPENAI_API_KEY\" not in os.environ:    os.environ[\"OPENAI_API_KEY\"] = getpass()# Please manually enter OpenAI Key\n```\n\n```\nfrom langchain_core.globals import set_llm_cachefrom langchain_openai import OpenAI# To make the caching really obvious, lets use a slower and older model.# Caching supports newer chat models as well.llm = OpenAI(model=\"gpt-3.5-turbo-instruct\", n=2, best_of=2)\n```\n\n```\n%%timefrom langchain_core.caches import InMemoryCacheset_llm_cache(InMemoryCache())# The first time, it is not yet in cache, so it should take longerllm.invoke(\"Tell me a joke\")\n```\n\n```\nCPU times: user 546 ms, sys: 379 ms, total: 925 msWall time: 1.11 s\n```\n\n```\n\"\\nWhy don't scientists trust atoms?\\n\\nBecause they make up everything!\"\n```\n\n```\n%%time# The second time it is, so it goes fasterllm.invoke(\"Tell me a joke\")\n```\n\n```\nCPU times: user 192 µs, sys: 77 µs, total: 269 µsWall time: 270 µs\n```\n\n```\n\"\\nWhy don't scientists trust atoms?\\n\\nBecause they make up everything!\"\n```\n\n## SQLite Cache[​](#sqlite-cache \"Direct link to SQLite Cache\")\n\n```\n# We can do the same thing with a SQLite cachefrom langchain_community.cache import SQLiteCacheset_llm_cache(SQLiteCache(database_path=\".langchain.db\"))\n```\n\n```\n%%time# The first time, it is not yet in cache, so it should take longerllm.invoke(\"Tell me a joke\")\n```\n\n```\nCPU times: user 10.6 ms, sys: 4.21 ms, total: 14.8 msWall time: 851 ms\n```\n\n```\n\"\\n\\nWhy don't scientists trust atoms?\\n\\nBecause they make up everything!\"\n```\n\n```\n%%time# The second time it is, so it goes fasterllm.invoke(\"Tell me a joke\")\n```\n\n```\nCPU times: user 59.7 ms, sys: 63.6 ms, total: 123 msWall time: 134 ms\n```\n\n```\n\"\\n\\nWhy don't scientists trust atoms?\\n\\nBecause they make up everything!\"\n```\n\n* * *\n\n#### Was this page helpful?"
},
{
  "url": "https://python.langchain.com/docs/how_to/caching_embeddings/",
  "markdown": "# giscus\n\n[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/langchain-ai/langchain/blob/master/docs/docs/how_to/caching_embeddings.ipynb)[![Open on GitHub](https://img.shields.io/badge/Open%20on%20GitHub-grey?logo=github&logoColor=white)](https://github.com/langchain-ai/langchain/blob/master/docs/docs/how_to/caching_embeddings.ipynb)\n\n## Caching\n\n[Embeddings](https://python.langchain.com/docs/concepts/embedding_models/) can be stored or temporarily cached to avoid needing to recompute them.\n\nCaching embeddings can be done using a `CacheBackedEmbeddings`. The cache backed embedder is a wrapper around an embedder that caches embeddings in a key-value store. The text is hashed and the hash is used as the key in the cache.\n\nThe main supported way to initialize a `CacheBackedEmbeddings` is `from_bytes_store`. It takes the following parameters:\n\n*   underlying\\_embedder: The embedder to use for embedding.\n*   document\\_embedding\\_cache: Any [`ByteStore`](https://python.langchain.com/docs/integrations/stores/) for caching document embeddings.\n*   batch\\_size: (optional, defaults to `None`) The number of documents to embed between store updates.\n*   namespace: (optional, defaults to `\"\"`) The namespace to use for document cache. This namespace is used to avoid collisions with other caches. For example, set it to the name of the embedding model used.\n*   query\\_embedding\\_cache: (optional, defaults to `None` or not caching) A [`ByteStore`](https://python.langchain.com/docs/integrations/stores/) for caching query embeddings, or `True` to use the same store as `document_embedding_cache`.\n\n**Attention**:\n\n*   Be sure to set the `namespace` parameter to avoid collisions of the same text embedded using different embeddings models.\n*   `CacheBackedEmbeddings` does not cache query embeddings by default. To enable query caching, one needs to specify a `query_embedding_cache`.\n\n```\nfrom langchain.embeddings import CacheBackedEmbeddings\n```\n\n## Using with a Vector Store[​](#using-with-a-vector-store \"Direct link to Using with a Vector Store\")\n\nFirst, let's see an example that uses the local file system for storing embeddings and uses FAISS vector store for retrieval.\n\n```\n%pip install --upgrade --quiet  langchain-openai faiss-cpu\n```\n\n```\nfrom langchain.storage import LocalFileStorefrom langchain_community.document_loaders import TextLoaderfrom langchain_community.vectorstores import FAISSfrom langchain_openai import OpenAIEmbeddingsfrom langchain_text_splitters import CharacterTextSplitterunderlying_embeddings = OpenAIEmbeddings()store = LocalFileStore(\"./cache/\")cached_embedder = CacheBackedEmbeddings.from_bytes_store(    underlying_embeddings, store, namespace=underlying_embeddings.model)\n```\n\nThe cache is empty prior to embedding:\n\nLoad the document, split it into chunks, embed each chunk and load it into the vector store.\n\n```\nraw_documents = TextLoader(\"state_of_the_union.txt\").load()text_splitter = CharacterTextSplitter(chunk_size=1000, chunk_overlap=0)documents = text_splitter.split_documents(raw_documents)\n```\n\nCreate the vector store:\n\n```\n%%timedb = FAISS.from_documents(documents, cached_embedder)\n```\n\n```\nCPU times: user 218 ms, sys: 29.7 ms, total: 248 msWall time: 1.02 s\n```\n\nIf we try to create the vector store again, it'll be much faster since it does not need to re-compute any embeddings.\n\n```\n%%timedb2 = FAISS.from_documents(documents, cached_embedder)\n```\n\n```\nCPU times: user 15.7 ms, sys: 2.22 ms, total: 18 msWall time: 17.2 ms\n```\n\nAnd here are some of the embeddings that got created:\n\n```\nlist(store.yield_keys())[:5]\n```\n\n```\n['text-embedding-ada-00217a6727d-8916-54eb-b196-ec9c9d6ca472', 'text-embedding-ada-0025fc0d904-bd80-52da-95c9-441015bfb438', 'text-embedding-ada-002e4ad20ef-dfaa-5916-9459-f90c6d8e8159', 'text-embedding-ada-002ed199159-c1cd-5597-9757-f80498e8f17b', 'text-embedding-ada-0021297d37a-2bc1-5e19-bf13-6c950f075062']\n```\n\n## Swapping the `ByteStore`\n\nIn order to use a different `ByteStore`, just use it when creating your `CacheBackedEmbeddings`. Below, we create an equivalent cached embeddings object, except using the non-persistent `InMemoryByteStore` instead:\n\n```\nfrom langchain.embeddings import CacheBackedEmbeddingsfrom langchain.storage import InMemoryByteStorestore = InMemoryByteStore()cached_embedder = CacheBackedEmbeddings.from_bytes_store(    underlying_embeddings, store, namespace=underlying_embeddings.model)\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/llm_token_usage_tracking/",
  "markdown": "# giscus\n\n[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/langchain-ai/langchain/blob/master/docs/docs/how_to/llm_token_usage_tracking.ipynb)[![Open on GitHub](https://img.shields.io/badge/Open%20on%20GitHub-grey?logo=github&logoColor=white)](https://github.com/langchain-ai/langchain/blob/master/docs/docs/how_to/llm_token_usage_tracking.ipynb)\n\n## How to track token usage for LLMs\n\nTracking [token](https://python.langchain.com/docs/concepts/tokens/) usage to calculate cost is an important part of putting your app in production. This guide goes over how to obtain this information from your LangChain model calls.\n\nPrerequisites\n\nThis guide assumes familiarity with the following concepts:\n\n*   [LLMs](https://python.langchain.com/docs/concepts/text_llms/)\n\n## Using LangSmith[​](#using-langsmith \"Direct link to Using LangSmith\")\n\nYou can use [LangSmith](https://www.langchain.com/langsmith) to help track token usage in your LLM application. See the [LangSmith quick start guide](https://docs.smith.langchain.com/).\n\n## Using callbacks[​](#using-callbacks \"Direct link to Using callbacks\")\n\nThere are some API-specific callback context managers that allow you to track token usage across multiple calls. You'll need to check whether such an integration is available for your particular model.\n\nIf such an integration is not available for your model, you can create a custom callback manager by adapting the implementation of the [OpenAI callback manager](https://python.langchain.com/api_reference/community/callbacks/langchain_community.callbacks.openai_info.OpenAICallbackHandler.html).\n\n### OpenAI[​](#openai \"Direct link to OpenAI\")\n\nLet's first look at an extremely simple example of tracking token usage for a single Chat model call.\n\ndanger\n\nThe callback handler does not currently support streaming token counts for legacy language models (e.g., `langchain_openai.OpenAI`). For support in a streaming context, refer to the corresponding guide for chat models [here](https://python.langchain.com/docs/how_to/chat_token_usage_tracking/).\n\n### Single call[​](#single-call \"Direct link to Single call\")\n\n```\nfrom langchain_community.callbacks import get_openai_callbackfrom langchain_openai import OpenAIllm = OpenAI(model_name=\"gpt-3.5-turbo-instruct\")with get_openai_callback() as cb:    result = llm.invoke(\"Tell me a joke\")    print(result)    print(\"---\")print()print(f\"Total Tokens: {cb.total_tokens}\")print(f\"Prompt Tokens: {cb.prompt_tokens}\")print(f\"Completion Tokens: {cb.completion_tokens}\")print(f\"Total Cost (USD): ${cb.total_cost}\")\n```\n\n```\nWhy don't scientists trust atoms?Because they make up everything.---Total Tokens: 18Prompt Tokens: 4Completion Tokens: 14Total Cost (USD): $3.4e-05\n```\n\n### Multiple calls[​](#multiple-calls \"Direct link to Multiple calls\")\n\nAnything inside the context manager will get tracked. Here's an example of using it to track multiple calls in sequence to a chain. This will also work for an agent which may use multiple steps.\n\n```\nfrom langchain_community.callbacks import get_openai_callbackfrom langchain_core.prompts import PromptTemplatefrom langchain_openai import OpenAIllm = OpenAI(model_name=\"gpt-3.5-turbo-instruct\")template = PromptTemplate.from_template(\"Tell me a joke about {topic}\")chain = template | llmwith get_openai_callback() as cb:    response = chain.invoke({\"topic\": \"birds\"})    print(response)    response = chain.invoke({\"topic\": \"fish\"})    print(\"--\")    print(response)print()print(\"---\")print(f\"Total Tokens: {cb.total_tokens}\")print(f\"Prompt Tokens: {cb.prompt_tokens}\")print(f\"Completion Tokens: {cb.completion_tokens}\")print(f\"Total Cost (USD): ${cb.total_cost}\")\n```\n\n```\nWhy did the chicken go to the seance?To talk to the other side of the road!--Why did the fish need a lawyer?Because it got caught in a net!---Total Tokens: 50Prompt Tokens: 12Completion Tokens: 38Total Cost (USD): $9.400000000000001e-05\n```\n\n## Streaming[​](#streaming \"Direct link to Streaming\")\n\ndanger\n\n`get_openai_callback` does not currently support streaming token counts for legacy language models (e.g., `langchain_openai.OpenAI`). If you want to count tokens correctly in a streaming context, there are a number of options:\n\n*   Use chat models as described in [this guide](https://python.langchain.com/docs/how_to/chat_token_usage_tracking/);\n*   Implement a [custom callback handler](https://python.langchain.com/docs/how_to/custom_callbacks/) that uses appropriate tokenizers to count the tokens;\n*   Use a monitoring platform such as [LangSmith](https://www.langchain.com/langsmith).\n\nNote that when using legacy language models in a streaming context, token counts are not updated:\n\n```\nfrom langchain_community.callbacks import get_openai_callbackfrom langchain_openai import OpenAIllm = OpenAI(model_name=\"gpt-3.5-turbo-instruct\")with get_openai_callback() as cb:    for chunk in llm.stream(\"Tell me a joke\"):        print(chunk, end=\"\", flush=True)    print(result)    print(\"---\")print()print(f\"Total Tokens: {cb.total_tokens}\")print(f\"Prompt Tokens: {cb.prompt_tokens}\")print(f\"Completion Tokens: {cb.completion_tokens}\")print(f\"Total Cost (USD): ${cb.total_cost}\")\n```\n\n```\nWhy don't scientists trust atoms?Because they make up everything!Why don't scientists trust atoms?Because they make up everything.---Total Tokens: 0Prompt Tokens: 0Completion Tokens: 0Total Cost (USD): $0.0\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/installation/",
  "markdown": "# giscus\n\n## How to install LangChain packages\n\nThe LangChain ecosystem is split into different packages, which allow you to choose exactly which pieces of functionality to install.\n\n## Official release[​](#official-release \"Direct link to Official release\")\n\nTo install the main `langchain` package, run:\n\n*   Pip\n*   Conda\n\nWhile this package acts as a sane starting point to using LangChain, much of the value of LangChain comes when integrating it with various model providers, datastores, etc. By default, the dependencies needed to do that are NOT installed. You will need to install the dependencies for specific integrations separately, which we show below.\n\n## Ecosystem packages[​](#ecosystem-packages \"Direct link to Ecosystem packages\")\n\nWith the exception of the `langsmith` SDK, all packages in the LangChain ecosystem depend on `langchain-core`, which contains base classes and abstractions that other packages use. The dependency graph below shows how the difference packages are related. A directed arrow indicates that the source package depends on the target package:\n\n![](https://python.langchain.com/assets/images/ecosystem_packages-32943b32657e7a187770c9b585f22a64.png)\n\nWhen installing a package, you do not need to explicitly install that package's explicit dependencies (such as `langchain-core`). However, you may choose to if you are using a feature only available in a certain version of that dependency. If you do, you should make sure that the installed or pinned version is compatible with any other integration packages you use.\n\n### LangChain core[​](#langchain-core \"Direct link to LangChain core\")\n\nThe `langchain-core` package contains base abstractions that the rest of the LangChain ecosystem uses, along with the LangChain Expression Language. It is automatically installed by `langchain`, but can also be used separately. Install with:\n\n```\npip install langchain-core\n```\n\n### Integration packages[​](#integration-packages \"Direct link to Integration packages\")\n\nCertain integrations like OpenAI and Anthropic have their own packages. Any integrations that require their own package will be documented as such in the [Integration docs](https://python.langchain.com/docs/integrations/providers/). You can see a list of all integration packages in the [API reference](https://python.langchain.com/api_reference/) under the \"Partner libs\" dropdown. To install one of these run:\n\n```\npip install langchain-openai\n```\n\nAny integrations that haven't been split out into their own packages will live in the `langchain-community` package. Install with:\n\n```\npip install langchain-community\n```\n\n### LangChain experimental[​](#langchain-experimental \"Direct link to LangChain experimental\")\n\nThe `langchain-experimental` package holds experimental LangChain code, intended for research and experimental uses. Install with:\n\n```\npip install langchain-experimental\n```\n\n### LangGraph[​](#langgraph \"Direct link to LangGraph\")\n\n`langgraph` is a library for building stateful, multi-actor applications with LLMs. It integrates smoothly with LangChain, but can be used without it. Install with:\n\n### LangServe[​](#langserve \"Direct link to LangServe\")\n\nLangServe helps developers deploy LangChain runnables and chains as a REST API. LangServe is automatically installed by LangChain CLI. If not using LangChain CLI, install with:\n\n```\npip install \"langserve[all]\"\n```\n\nfor both client and server dependencies. Or `pip install \"langserve[client]\"` for client code, and `pip install \"langserve[server]\"` for server code.\n\n### LangChain CLI[​](#langchain-cli \"Direct link to LangChain CLI\")\n\nThe LangChain CLI is useful for working with LangChain templates and other LangServe projects. Install with:\n\n```\npip install langchain-cli\n```\n\n### LangSmith SDK[​](#langsmith-sdk \"Direct link to LangSmith SDK\")\n\nThe LangSmith SDK is automatically installed by LangChain. However, it does not depend on `langchain-core`, and can be installed and used independently if desired. If you are not using LangChain, you can install it with:\n\n### From source[​](#from-source \"Direct link to From source\")\n\nIf you want to install a package from source, you can do so by cloning the [main LangChain repo](https://github.com/langchain-ai/langchain), enter the directory of the package you want to install `PATH/TO/REPO/langchain/libs/{package}`, and run:\n\nLangGraph, LangSmith SDK, and certain integration packages live outside the main LangChain repo. You can see [all repos here](https://github.com/langchain-ai)."
},
{
  "url": "https://python.langchain.com/docs/how_to/sequence/",
  "markdown": "# giscus\n\n## How to chain runnables\n\nOne point about [LangChain Expression Language](https://python.langchain.com/docs/concepts/lcel/) is that any two runnables can be \"chained\" together into sequences. The output of the previous runnable's `.invoke()` call is passed as input to the next runnable. This can be done using the pipe operator (`|`), or the more explicit `.pipe()` method, which does the same thing.\n\nThe resulting [`RunnableSequence`](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.RunnableSequence.html) is itself a runnable, which means it can be invoked, streamed, or further chained just like any other runnable. Advantages of chaining runnables in this way are efficient streaming (the sequence will stream output as soon as it is available), and debugging and tracing with tools like [LangSmith](https://python.langchain.com/docs/how_to/debugging/).\n\n## The pipe operator: `|`[​](#the-pipe-operator- \"Direct link to the-pipe-operator-\")\n\nTo show off how this works, let's go through an example. We'll walk through a common pattern in LangChain: using a [prompt template](https://python.langchain.com/docs/how_to/#prompt-templates) to format input into a [chat model](https://python.langchain.com/docs/how_to/#chat-models), and finally converting the chat message output into a string with an [output parser](https://python.langchain.com/docs/how_to/#output-parsers).\n\n```\npip install -qU langchain-openai\n```\n\n```\nimport getpassimport osif not os.environ.get(\"OPENAI_API_KEY\"):  os.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"Enter API key for OpenAI: \")from langchain_openai import ChatOpenAImodel = ChatOpenAI(model=\"gpt-4o-mini\")\n```\n\n```\nfrom langchain_core.output_parsers import StrOutputParserfrom langchain_core.prompts import ChatPromptTemplateprompt = ChatPromptTemplate.from_template(\"tell me a joke about {topic}\")chain = prompt | model | StrOutputParser()\n```\n\nPrompts and models are both runnable, and the output type from the prompt call is the same as the input type of the chat model, so we can chain them together. We can then invoke the resulting sequence like any other runnable:\n\n```\nchain.invoke({\"topic\": \"bears\"})\n```\n\n```\n\"Here's a bear joke for you:\\n\\nWhy did the bear dissolve in water?\\nBecause it was a polar bear!\"\n```\n\n### Coercion[​](#coercion \"Direct link to Coercion\")\n\nWe can even combine this chain with more runnables to create another chain. This may involve some input/output formatting using other types of runnables, depending on the required inputs and outputs of the chain components.\n\nFor example, let's say we wanted to compose the joke generating chain with another chain that evaluates whether or not the generated joke was funny.\n\nWe would need to be careful with how we format the input into the next chain. In the below example, the dict in the chain is automatically parsed and converted into a [`RunnableParallel`](https://python.langchain.com/docs/how_to/parallel/), which runs all of its values in parallel and returns a dict with the results.\n\nThis happens to be the same format the next prompt template expects. Here it is in action:\n\n```\nfrom langchain_core.output_parsers import StrOutputParseranalysis_prompt = ChatPromptTemplate.from_template(\"is this a funny joke? {joke}\")composed_chain = {\"joke\": chain} | analysis_prompt | model | StrOutputParser()composed_chain.invoke({\"topic\": \"bears\"})\n```\n\n```\n'Haha, that\\'s a clever play on words! Using \"polar\" to imply the bear dissolved or became polar/polarized when put in water. Not the most hilarious joke ever, but it has a cute, groan-worthy pun that makes it mildly amusing. I appreciate a good pun or wordplay joke.'\n```\n\nFunctions will also be coerced into runnables, so you can add custom logic to your chains too. The below chain results in the same logical flow as before:\n\n```\ncomposed_chain_with_lambda = (    chain    | (lambda input: {\"joke\": input})    | analysis_prompt    | model    | StrOutputParser())composed_chain_with_lambda.invoke({\"topic\": \"beets\"})\n```\n\n```\n\"Haha, that's a cute and punny joke! I like how it plays on the idea of beets blushing or turning red like someone blushing. Food puns can be quite amusing. While not a total knee-slapper, it's a light-hearted, groan-worthy dad joke that would make me chuckle and shake my head. Simple vegetable humor!\"\n```\n\nHowever, keep in mind that using functions like this may interfere with operations like streaming. See [this section](https://python.langchain.com/docs/how_to/functions/) for more information.\n\n## The `.pipe()` method[​](#the-pipe-method \"Direct link to the-pipe-method\")\n\nWe could also compose the same sequence using the `.pipe()` method. Here's what that looks like:\n\n```\nfrom langchain_core.runnables import RunnableParallelcomposed_chain_with_pipe = (    RunnableParallel({\"joke\": chain})    .pipe(analysis_prompt)    .pipe(model)    .pipe(StrOutputParser()))composed_chain_with_pipe.invoke({\"topic\": \"battlestar galactica\"})\n```\n\n```\n\"I cannot reproduce any copyrighted material verbatim, but I can try to analyze the humor in the joke you provided without quoting it directly.\\n\\nThe joke plays on the idea that the Cylon raiders, who are the antagonists in the Battlestar Galactica universe, failed to locate the human survivors after attacking their home planets (the Twelve Colonies) due to using an outdated and poorly performing operating system (Windows Vista) for their targeting systems.\\n\\nThe humor stems from the juxtaposition of a futuristic science fiction setting with a relatable real-world frustration – the use of buggy, slow, or unreliable software or technology. It pokes fun at the perceived inadequacies of Windows Vista, which was widely criticized for its performance issues and other problems when it was released.\\n\\nBy attributing the Cylons' failure to locate the humans to their use of Vista, the joke creates an amusing and unexpected connection between a fictional advanced race of robots and a familiar technological annoyance experienced by many people in the real world.\\n\\nOverall, the joke relies on incongruity and relatability to generate humor, but without reproducing any copyrighted material directly.\"\n```\n\nOr the abbreviated:\n\n```\ncomposed_chain_with_pipe = RunnableParallel({\"joke\": chain}).pipe(    analysis_prompt, model, StrOutputParser())\n```\n\n*   [Streaming](https://python.langchain.com/docs/how_to/streaming/): Check out the streaming guide to understand the streaming behavior of a chain"
},
{
  "url": "https://python.langchain.com/docs/how_to/document_loader_web/",
  "markdown": "# giscus\n\n## How to load web pages\n\nThis guide covers how to [load](https://python.langchain.com/docs/concepts/document_loaders/) web pages into the LangChain [Document](https://python.langchain.com/api_reference/core/documents/langchain_core.documents.base.Document.html) format that we use downstream. Web pages contain text, images, and other multimedia elements, and are typically represented with HTML. They may include links to other pages or resources.\n\nLangChain integrates with a host of parsers that are appropriate for web pages. The right parser will depend on your needs. Below we demonstrate two possibilities:\n\n*   [Simple and fast](https://python.langchain.com/docs/how_to/document_loader_web/#simple-and-fast-text-extraction) parsing, in which we recover one `Document` per web page with its content represented as a \"flattened\" string;\n*   [Advanced](https://python.langchain.com/docs/how_to/document_loader_web/#advanced-parsing) parsing, in which we recover multiple `Document` objects per page, allowing one to identify and traverse sections, links, tables, and other structures.\n\n## Setup[​](#setup \"Direct link to Setup\")\n\nFor the \"simple and fast\" parsing, we will need `langchain-community` and the `beautifulsoup4` library:\n\n```\n%pip install -qU langchain-community beautifulsoup4\n```\n\nFor advanced parsing, we will use `langchain-unstructured`:\n\n```\n%pip install -qU langchain-unstructured\n```\n\n## Simple and fast text extraction[​](#simple-and-fast-text-extraction \"Direct link to Simple and fast text extraction\")\n\nIf you are looking for a simple string representation of text that is embedded in a web page, the method below is appropriate. It will return a list of `Document` objects -- one per page -- containing a single string of the page's text. Under the hood it uses the `beautifulsoup4` Python library.\n\nLangChain document loaders implement `lazy_load` and its async variant, `alazy_load`, which return iterators of `Document objects`. We will use these below.\n\n```\nimport bs4from langchain_community.document_loaders import WebBaseLoaderpage_url = \"https://python.langchain.com/docs/how_to/chatbots_memory/\"loader = WebBaseLoader(web_paths=[page_url])docs = []async for doc in loader.alazy_load():    docs.append(doc)assert len(docs) == 1doc = docs[0]\n```\n\n```\nUSER_AGENT environment variable not set, consider setting it to identify your requests.\n```\n\n```\nprint(f\"{doc.metadata}\\n\")print(doc.page_content[:500].strip())\n```\n\n```\n{'source': 'https://python.langchain.com/docs/how_to/chatbots_memory/', 'title': 'How to add memory to chatbots | \\uf8ffü¶úÔ∏è\\uf8ffüîó LangChain', 'description': 'A key feature of chatbots is their ability to use content of previous conversation turns as context. This state management can take several forms, including:', 'language': 'en'}How to add memory to chatbots | ü¶úÔ∏èüîó LangChainSkip to main contentShare your thoughts on AI agents. Take the 3-min survey.IntegrationsAPI ReferenceMoreContributingPeopleLangSmithLangGraphLangChain HubLangChain JS/TSv0.3v0.3v0.2v0.1üí¨SearchIntroductionTutorialsBuild a Question Answering application over a Graph DatabaseTutorialsBuild a Simple LLM Application with LCELBuild a Query Analysis SystemBuild a ChatbotConversational RAGBuild an Extraction ChainBuild an AgentTaggingd\n```\n\nThis is essentially a dump of the text from the page's HTML. It may contain extraneous information like headings and navigation bars. If you are familiar with the expected HTML, you can specify desired `<div>` classes and other parameters via BeautifulSoup. Below we parse only the body text of the article:\n\n```\nloader = WebBaseLoader(    web_paths=[page_url],    bs_kwargs={        \"parse_only\": bs4.SoupStrainer(class_=\"theme-doc-markdown markdown\"),    },    bs_get_text_kwargs={\"separator\": \" | \", \"strip\": True},)docs = []async for doc in loader.alazy_load():    docs.append(doc)assert len(docs) == 1doc = docs[0]\n```\n\n```\nprint(f\"{doc.metadata}\\n\")print(doc.page_content[:500])\n```\n\n```\n{'source': 'https://python.langchain.com/docs/how_to/chatbots_memory/'}How to add memory to chatbots | A key feature of chatbots is their ability to use content of previous conversation turns as context. This state management can take several forms, including: | Simply stuffing previous messages into a chat model prompt. | The above, but trimming old messages to reduce the amount of distracting information the model has to deal with. | More complex modifications like synthesizing summaries for long running conversations. | We'll go into more detail on a few techniq\n```\n\n```\nprint(doc.page_content[-500:])\n```\n\n```\na greeting. Nemo then asks the AI how it is doing, and the AI responds that it is fine.'), | HumanMessage(content='What did I say my name was?'), | AIMessage(content='You introduced yourself as Nemo. How can I assist you today, Nemo?')] | Note that invoking the chain again will generate another summary generated from the initial summary plus new messages and so on. You could also design a hybrid approach where a certain number of messages are retained in chat history while others are summarized.\n```\n\nNote that this required advance technical knowledge of how the body text is represented in the underlying HTML.\n\nWe can parameterize `WebBaseLoader` with a variety of settings, allowing for specification of request headers, rate limits, and parsers and other kwargs for BeautifulSoup. See its [API reference](https://python.langchain.com/api_reference/community/document_loaders/langchain_community.document_loaders.web_base.WebBaseLoader.html) for detail.\n\n## Advanced parsing[​](#advanced-parsing \"Direct link to Advanced parsing\")\n\nThis method is appropriate if we want more granular control or processing of the page content. Below, instead of generating one `Document` per page and controlling its content via BeautifulSoup, we generate multiple `Document` objects representing distinct structures on a page. These structures can include section titles and their corresponding body texts, lists or enumerations, tables, and more.\n\nUnder the hood it uses the `langchain-unstructured` library. See the [integration docs](https://python.langchain.com/docs/integrations/document_loaders/unstructured_file/) for more information about using [Unstructured](https://docs.unstructured.io/welcome) with LangChain.\n\n```\nfrom langchain_unstructured import UnstructuredLoaderpage_url = \"https://python.langchain.com/docs/how_to/chatbots_memory/\"loader = UnstructuredLoader(web_url=page_url)docs = []async for doc in loader.alazy_load():    docs.append(doc)\n```\n\n```\nINFO: Note: NumExpr detected 12 cores but \"NUMEXPR_MAX_THREADS\" not set, so enforcing safe limit of 8.INFO: NumExpr defaulting to 8 threads.\n```\n\nNote that with no advance knowledge of the page HTML structure, we recover a natural organization of the body text:\n\n```\nfor doc in docs[:5]:    print(doc.page_content)\n```\n\n```\nHow to add memory to chatbotsA key feature of chatbots is their ability to use content of previous conversation turns as context. This state management can take several forms, including:Simply stuffing previous messages into a chat model prompt.The above, but trimming old messages to reduce the amount of distracting information the model has to deal with.More complex modifications like synthesizing summaries for long running conversations.ERROR! Session/line number was not unique in database. History logging moved to new session 2747\n```\n\n### Extracting content from specific sections[​](#extracting-content-from-specific-sections \"Direct link to Extracting content from specific sections\")\n\nEach `Document` object represents an element of the page. Its metadata contains useful information, such as its category:\n\n```\nfor doc in docs[:5]:    print(f'{doc.metadata[\"category\"]}: {doc.page_content}')\n```\n\n```\nTitle: How to add memory to chatbotsNarrativeText: A key feature of chatbots is their ability to use content of previous conversation turns as context. This state management can take several forms, including:ListItem: Simply stuffing previous messages into a chat model prompt.ListItem: The above, but trimming old messages to reduce the amount of distracting information the model has to deal with.ListItem: More complex modifications like synthesizing summaries for long running conversations.\n```\n\nElements may also have parent-child relationships -- for example, a paragraph might belong to a section with a title. If a section is of particular interest (e.g., for indexing) we can isolate the corresponding `Document` objects.\n\nAs an example, below we load the content of the \"Setup\" sections for two web pages:\n\n```\nfrom typing import Listfrom langchain_core.documents import Documentasync def _get_setup_docs_from_url(url: str) -> List[Document]:    loader = UnstructuredLoader(web_url=url)    setup_docs = []    parent_id = -1    async for doc in loader.alazy_load():        if doc.metadata[\"category\"] == \"Title\" and doc.page_content.startswith(\"Setup\"):            parent_id = doc.metadata[\"element_id\"]        if doc.metadata.get(\"parent_id\") == parent_id:            setup_docs.append(doc)    return setup_docspage_urls = [    \"https://python.langchain.com/docs/how_to/chatbots_memory/\",    \"https://python.langchain.com/docs/how_to/chatbots_tools/\",]setup_docs = []for url in page_urls:    page_setup_docs = await _get_setup_docs_from_url(url)    setup_docs.extend(page_setup_docs)\n```\n\n```\nfrom collections import defaultdictsetup_text = defaultdict(str)for doc in setup_docs:    url = doc.metadata[\"url\"]    setup_text[url] += f\"{doc.page_content}\\n\"dict(setup_text)\n```\n\n```\n{'https://python.langchain.com/docs/how_to/chatbots_memory/': \"You'll need to install a few packages, and have your OpenAI API key set as an environment variable named OPENAI_API_KEY:\\n%pip install --upgrade --quiet langchain langchain-openai\\n\\n# Set env var OPENAI_API_KEY or load from a .env file:\\nimport dotenv\\n\\ndotenv.load_dotenv()\\n[33mWARNING: You are using pip version 22.0.4; however, version 23.3.2 is available.\\nYou should consider upgrading via the '/Users/jacoblee/.pyenv/versions/3.10.5/bin/python -m pip install --upgrade pip' command.[0m[33m\\n[0mNote: you may need to restart the kernel to use updated packages.\\n\", 'https://python.langchain.com/docs/how_to/chatbots_tools/': \"For this guide, we'll be using a tool calling agent with a single tool for searching the web. The default will be powered by Tavily, but you can switch it out for any similar tool. The rest of this section will assume you're using Tavily.\\nYou'll need to sign up for an account on the Tavily website, and install the following packages:\\n%pip install --upgrade --quiet langchain-community langchain-openai tavily-python\\n\\n# Set env var OPENAI_API_KEY or load from a .env file:\\nimport dotenv\\n\\ndotenv.load_dotenv()\\nYou will also need your OpenAI key set as OPENAI_API_KEY and your Tavily API key set as TAVILY_API_KEY.\\n\"}\n```\n\n### Vector search over page content[​](#vector-search-over-page-content \"Direct link to Vector search over page content\")\n\nOnce we have loaded the page contents into LangChain `Document` objects, we can index them (e.g., for a RAG application) in the usual way. Below we use OpenAI [embeddings](https://python.langchain.com/docs/concepts/embedding_models/), although any LangChain embeddings model will suffice.\n\n```\n%pip install -qU langchain-openai\n```\n\n```\nimport getpassimport osif \"OPENAI_API_KEY\" not in os.environ:    os.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"OpenAI API Key:\")\n```\n\n```\nfrom langchain_core.vectorstores import InMemoryVectorStorefrom langchain_openai import OpenAIEmbeddingsvector_store = InMemoryVectorStore.from_documents(setup_docs, OpenAIEmbeddings())retrieved_docs = vector_store.similarity_search(\"Install Tavily\", k=2)for doc in retrieved_docs:    print(f'Page {doc.metadata[\"url\"]}: {doc.page_content[:300]}\\n')\n```\n\n```\nINFO: HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"INFO: HTTP Request: POST https://api.openai.com/v1/embeddings \"HTTP/1.1 200 OK\"``````outputPage https://python.langchain.com/docs/how_to/chatbots_tools/: You'll need to sign up for an account on the Tavily website, and install the following packages:Page https://python.langchain.com/docs/how_to/chatbots_tools/: For this guide, we'll be using a tool calling agent with a single tool for searching the web. The default will be powered by Tavily, but you can switch it out for any similar tool. The rest of this section will assume you're using Tavily.\n```\n\n## Other web page loaders[​](#other-web-page-loaders \"Direct link to Other web page loaders\")\n\nFor a list of available LangChain web page loaders, please see [this table](https://python.langchain.com/docs/integrations/document_loaders/#webpages)."
},
{
  "url": "https://python.langchain.com/docs/how_to/callbacks_async/",
  "markdown": "# giscus\n\nIf you are planning to use the async APIs, it is recommended to use and extend [`AsyncCallbackHandler`](https://python.langchain.com/api_reference/core/callbacks/langchain_core.callbacks.base.AsyncCallbackHandler.html) to avoid blocking the event.\n\nwarning\n\nIf you use a sync `CallbackHandler` while using an async method to run your LLM / Chain / Tool / Agent, it will still work. However, under the hood, it will be called with [`run_in_executor`](https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.run_in_executor) which can cause issues if your `CallbackHandler` is not thread-safe.\n\ndanger\n\nIf you're on `python<=3.10`, you need to remember to propagate `config` or `callbacks` when invoking other `runnable` from within a `RunnableLambda`, `RunnableGenerator` or `@tool`. If you do not do this, the callbacks will not be propagated to the child runnables being invoked.\n\n```\nimport asynciofrom typing import Any, Dict, Listfrom langchain_anthropic import ChatAnthropicfrom langchain_core.callbacks import AsyncCallbackHandler, BaseCallbackHandlerfrom langchain_core.messages import HumanMessagefrom langchain_core.outputs import LLMResultclass MyCustomSyncHandler(BaseCallbackHandler):    def on_llm_new_token(self, token: str, **kwargs) -> None:        print(f\"Sync handler being called in a `thread_pool_executor`: token: {token}\")class MyCustomAsyncHandler(AsyncCallbackHandler):    \"\"\"Async callback handler that can be used to handle callbacks from langchain.\"\"\"    async def on_llm_start(        self, serialized: Dict[str, Any], prompts: List[str], **kwargs: Any    ) -> None:        \"\"\"Run when chain starts running.\"\"\"        print(\"zzzz....\")        await asyncio.sleep(0.3)        class_name = serialized[\"name\"]        print(\"Hi! I just woke up. Your llm is starting\")    async def on_llm_end(self, response: LLMResult, **kwargs: Any) -> None:        \"\"\"Run when chain ends running.\"\"\"        print(\"zzzz....\")        await asyncio.sleep(0.3)        print(\"Hi! I just woke up. Your llm is ending\")# To enable streaming, we pass in `streaming=True` to the ChatModel constructor# Additionally, we pass in a list with our custom handlerchat = ChatAnthropic(    model=\"claude-3-sonnet-20240229\",    max_tokens=25,    streaming=True,    callbacks=[MyCustomSyncHandler(), MyCustomAsyncHandler()],)await chat.agenerate([[HumanMessage(content=\"Tell me a joke\")]])\n```\n\nYou've now learned how to create your own custom callback handlers."
},
{
  "url": "https://python.langchain.com/docs/how_to/dynamic_chain/",
  "markdown": "# giscus\n\nSometimes we want to construct parts of a chain at runtime, depending on the chain inputs ([routing](https://python.langchain.com/docs/how_to/routing/) is the most common example of this). We can create dynamic chains like this using a very useful property of RunnableLambda's, which is that if a RunnableLambda returns a Runnable, that Runnable is itself invoked. Let's see an example.\n\n```\nfrom operator import itemgetterfrom langchain_core.output_parsers import StrOutputParserfrom langchain_core.prompts import ChatPromptTemplatefrom langchain_core.runnables import Runnable, RunnablePassthrough, chaincontextualize_instructions = \"\"\"Convert the latest user question into a standalone question given the chat history. Don't answer the question, return the question and nothing else (no descriptive text).\"\"\"contextualize_prompt = ChatPromptTemplate.from_messages(    [        (\"system\", contextualize_instructions),        (\"placeholder\", \"{chat_history}\"),        (\"human\", \"{question}\"),    ])contextualize_question = contextualize_prompt | llm | StrOutputParser()qa_instructions = (    \"\"\"Answer the user question given the following context:\\n\\n{context}.\"\"\")qa_prompt = ChatPromptTemplate.from_messages(    [(\"system\", qa_instructions), (\"human\", \"{question}\")])@chaindef contextualize_if_needed(input_: dict) -> Runnable:    if input_.get(\"chat_history\"):        # NOTE: This is returning another Runnable, not an actual output.        return contextualize_question    else:        return RunnablePassthrough() | itemgetter(\"question\")@chaindef fake_retriever(input_: dict) -> str:    return \"egypt's population in 2024 is about 111 million\"full_chain = (    RunnablePassthrough.assign(question=contextualize_if_needed).assign(        context=fake_retriever    )    | qa_prompt    | llm    | StrOutputParser())full_chain.invoke(    {        \"question\": \"what about egypt\",        \"chat_history\": [            (\"human\", \"what's the population of indonesia\"),            (\"ai\", \"about 276 million\"),        ],    })\n```\n\nThe key here is that `contextualize_if_needed` returns another Runnable and not an actual output. This returned Runnable is itself run when the full chain is executed.\n\nNote that the streaming, batching, etc. capabilities of the returned Runnable are all preserved\n\n```\nfor chunk in contextualize_if_needed.stream(    {        \"question\": \"what about egypt\",        \"chat_history\": [            (\"human\", \"what's the population of indonesia\"),            (\"ai\", \"about 276 million\"),        ],    }):    print(chunk)\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/serialization/",
  "markdown": "# giscus\n\nLangChain classes implement standard methods for serialization. Serializing LangChain objects using these methods confer some advantages:\n\nTo save and load LangChain objects using this system, use the `dumpd`, `dumps`, `load`, and `loads` functions in the [load module](https://python.langchain.com/api_reference/core/load.html) of `langchain-core`. These functions support JSON and JSON-serializable objects.\n\nAll LangChain objects that inherit from [Serializable](https://python.langchain.com/api_reference/core/load/langchain_core.load.serializable.Serializable.html) are JSON-serializable. Examples include [messages](https://python.langchain.com/api_reference//python/core_api_reference.html#module-langchain_core.messages), [document objects](https://python.langchain.com/api_reference/core/documents/langchain_core.documents.base.Document.html) (e.g., as returned from [retrievers](https://python.langchain.com/docs/concepts/retrievers/)), and most [Runnables](https://python.langchain.com/docs/concepts/lcel/), such as chat models, retrievers, and [chains](https://python.langchain.com/docs/how_to/sequence/) implemented with the LangChain Expression Language.\n\n```\nfrom langchain_core.load import dumpd, dumps, load, loadsfrom langchain_core.prompts import ChatPromptTemplatefrom langchain_openai import ChatOpenAIprompt = ChatPromptTemplate.from_messages(    [        (\"system\", \"Translate the following into {language}:\"),        (\"user\", \"{text}\"),    ],)llm = ChatOpenAI(model=\"gpt-4o-mini\", api_key=\"llm-api-key\")chain = prompt | llm\n```\n\n```\n{  \"lc\": 1,  \"type\": \"constructor\",  \"id\": [    \"langchain\",    \"schema\",    \"runnable\",    \"RunnableSequence\"  ],  \"kwargs\": {    \"first\": {      \"lc\": 1,      \"type\": \"constructor\",      \"id\": [        \"langchain\",        \"prompts\",        \"chat\",        \"ChatPromptTemplate\"      ],      \"kwargs\": {        \"input_variables\": [          \"language\",          \"text\"        ],        \"messages\": [          {            \"lc\": 1,            \"type\": \"constructor\",\n```\n\nNote that the API key is withheld from the serialized representations. Parameters that are considered secret are specified by the `.lc_secrets` attribute of the LangChain object:\n\nSpecifying `secrets_map` in `load` and `loads` will load the corresponding secrets onto the de-serialized LangChain object."
},
{
  "url": "https://python.langchain.com/docs/how_to/query_few_shot/",
  "markdown": "# giscus\n\n## How to add examples to the prompt for query analysis\n\nAs our query analysis becomes more complex, the LLM may struggle to understand how exactly it should respond in certain scenarios. In order to improve performance here, we can [add examples](https://python.langchain.com/docs/concepts/few_shot_prompting/) to the prompt to guide the LLM.\n\nLet's take a look at how we can add examples for a LangChain YouTube video query analyzer.\n\n## Setup[​](#setup \"Direct link to Setup\")\n\n#### Install dependencies[​](#install-dependencies \"Direct link to Install dependencies\")\n\n```\n# %pip install -qU langchain-core langchain-openai\n```\n\n#### Set environment variables[​](#set-environment-variables \"Direct link to Set environment variables\")\n\nWe'll use OpenAI in this example:\n\n```\nimport getpassimport osif \"OPENAI_API_KEY\" not in os.environ:    os.environ[\"OPENAI_API_KEY\"] = getpass.getpass()# Optional, uncomment to trace runs with LangSmith. Sign up here: https://smith.langchain.com.# os.environ[\"LANGCHAIN_TRACING_V2\"] = \"true\"# os.environ[\"LANGCHAIN_API_KEY\"] = getpass.getpass()\n```\n\n## Query schema[​](#query-schema \"Direct link to Query schema\")\n\nWe'll define a query schema that we want our model to output. To make our query analysis a bit more interesting, we'll add a `sub_queries` field that contains more narrow questions derived from the top level question.\n\n```\nfrom typing import List, Optionalfrom pydantic import BaseModel, Fieldsub_queries_description = \"\"\"\\If the original question contains multiple distinct sub-questions, \\or if there are more generic questions that would be helpful to answer in \\order to answer the original question, write a list of all relevant sub-questions. \\Make sure this list is comprehensive and covers all parts of the original question. \\It's ok if there's redundancy in the sub-questions. \\Make sure the sub-questions are as narrowly focused as possible.\"\"\"class Search(BaseModel):    \"\"\"Search over a database of tutorial videos about a software library.\"\"\"    query: str = Field(        ...,        description=\"Primary similarity search query applied to video transcripts.\",    )    sub_queries: List[str] = Field(        default_factory=list, description=sub_queries_description    )    publish_year: Optional[int] = Field(None, description=\"Year video was published\")\n```\n\n## Query generation[​](#query-generation \"Direct link to Query generation\")\n\n```\nfrom langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholderfrom langchain_core.runnables import RunnablePassthroughfrom langchain_openai import ChatOpenAIsystem = \"\"\"You are an expert at converting user questions into database queries. \\You have access to a database of tutorial videos about a software library for building LLM-powered applications. \\Given a question, return a list of database queries optimized to retrieve the most relevant results.If there are acronyms or words you are not familiar with, do not try to rephrase them.\"\"\"prompt = ChatPromptTemplate.from_messages(    [        (\"system\", system),        MessagesPlaceholder(\"examples\", optional=True),        (\"human\", \"{question}\"),    ])llm = ChatOpenAI(model=\"gpt-4o-mini\", temperature=0)structured_llm = llm.with_structured_output(Search)query_analyzer = {\"question\": RunnablePassthrough()} | prompt | structured_llm\n```\n\nLet's try out our query analyzer without any examples in the prompt:\n\n```\nquery_analyzer.invoke(    \"what's the difference between web voyager and reflection agents? do both use langgraph?\")\n```\n\n```\nSearch(query='difference between web voyager and reflection agents', sub_queries=['what is web voyager', 'what are reflection agents', 'do both web voyager and reflection agents use langgraph?'], publish_year=None)\n```\n\n## Adding examples and tuning the prompt[​](#adding-examples-and-tuning-the-prompt \"Direct link to Adding examples and tuning the prompt\")\n\nThis works pretty well, but we probably want it to decompose the question even further to separate the queries about Web Voyager and Reflection Agents.\n\nTo tune our query generation results, we can add some examples of inputs questions and gold standard output queries to our prompt.\n\n```\nquestion = \"What's chat langchain, is it a langchain template?\"query = Search(    query=\"What is chat langchain and is it a langchain template?\",    sub_queries=[\"What is chat langchain\", \"What is a langchain template\"],)examples.append({\"input\": question, \"tool_calls\": [query]})\n```\n\n```\nquestion = \"How to build multi-agent system and stream intermediate steps from it\"query = Search(    query=\"How to build multi-agent system and stream intermediate steps from it\",    sub_queries=[        \"How to build multi-agent system\",        \"How to stream intermediate steps from multi-agent system\",        \"How to stream intermediate steps\",    ],)examples.append({\"input\": question, \"tool_calls\": [query]})\n```\n\n```\nquestion = \"LangChain agents vs LangGraph?\"query = Search(    query=\"What's the difference between LangChain agents and LangGraph? How do you deploy them?\",    sub_queries=[        \"What are LangChain agents\",        \"What is LangGraph\",        \"How do you deploy LangChain agents\",        \"How do you deploy LangGraph\",    ],)examples.append({\"input\": question, \"tool_calls\": [query]})\n```\n\nNow we need to update our prompt template and chain so that the examples are included in each prompt. Since we're working with OpenAI function-calling, we'll need to do a bit of extra structuring to send example inputs and outputs to the model. We'll create a `tool_example_to_messages` helper function to handle this for us:\n\n```\nimport uuidfrom typing import Dictfrom langchain_core.messages import (    AIMessage,    BaseMessage,    HumanMessage,    SystemMessage,    ToolMessage,)def tool_example_to_messages(example: Dict) -> List[BaseMessage]:    messages: List[BaseMessage] = [HumanMessage(content=example[\"input\"])]    openai_tool_calls = []    for tool_call in example[\"tool_calls\"]:        openai_tool_calls.append(            {                \"id\": str(uuid.uuid4()),                \"type\": \"function\",                \"function\": {                    \"name\": tool_call.__class__.__name__,                    \"arguments\": tool_call.json(),                },            }        )    messages.append(        AIMessage(content=\"\", additional_kwargs={\"tool_calls\": openai_tool_calls})    )    tool_outputs = example.get(\"tool_outputs\") or [        \"You have correctly called this tool.\"    ] * len(openai_tool_calls)    for output, tool_call in zip(tool_outputs, openai_tool_calls):        messages.append(ToolMessage(content=output, tool_call_id=tool_call[\"id\"]))    return messagesexample_msgs = [msg for ex in examples for msg in tool_example_to_messages(ex)]\n```\n\n```\nfrom langchain_core.prompts import MessagesPlaceholderquery_analyzer_with_examples = (    {\"question\": RunnablePassthrough()}    | prompt.partial(examples=example_msgs)    | structured_llm)\n```\n\n```\nquery_analyzer_with_examples.invoke(    \"what's the difference between web voyager and reflection agents? do both use langgraph?\")\n```\n\n```\nSearch(query=\"What's the difference between web voyager and reflection agents? Do both use langgraph?\", sub_queries=['What is web voyager', 'What are reflection agents', 'Do web voyager and reflection agents use langgraph?'], publish_year=None)\n```\n\nThanks to our examples we get a slightly more decomposed search query. With some more prompt engineering and tuning of our examples we could improve query generation even more.\n\nYou can see that the examples are passed to the model as messages in the [LangSmith trace](https://smith.langchain.com/public/aeaaafce-d2b1-4943-9a61-bc954e8fc6f2/r)."
},
{
  "url": "https://python.langchain.com/docs/how_to/local_llms/",
  "markdown": "# giscus\n\n## Run models locally\n\n## Use case[​](#use-case \"Direct link to Use case\")\n\nThe popularity of projects like [llama.cpp](https://github.com/ggerganov/llama.cpp), [Ollama](https://github.com/ollama/ollama), [GPT4All](https://github.com/nomic-ai/gpt4all), [llamafile](https://github.com/Mozilla-Ocho/llamafile), and others underscore the demand to run LLMs locally (on your own device).\n\nThis has at least two important benefits:\n\n1.  `Privacy`: Your data is not sent to a third party, and it is not subject to the terms of service of a commercial service\n2.  `Cost`: There is no inference fee, which is important for token-intensive applications (e.g., [long-running simulations](https://twitter.com/RLanceMartin/status/1691097659262820352?s=20), summarization)\n\n## Overview[​](#overview \"Direct link to Overview\")\n\nRunning an LLM locally requires a few things:\n\n1.  `Open-source LLM`: An open-source LLM that can be freely modified and shared\n2.  `Inference`: Ability to run this LLM on your device w/ acceptable latency\n\n### Open-source LLMs[​](#open-source-llms \"Direct link to Open-source LLMs\")\n\nUsers can now gain access to a rapidly growing set of [open-source LLMs](https://cameronrwolfe.substack.com/p/the-history-of-open-source-llms-better).\n\nThese LLMs can be assessed across at least two dimensions (see figure):\n\n1.  `Base model`: What is the base-model and how was it trained?\n2.  `Fine-tuning approach`: Was the base-model fine-tuned and, if so, what [set of instructions](https://cameronrwolfe.substack.com/p/beyond-llama-the-power-of-open-llms#%C2%A7alpaca-an-instruction-following-llama-model) was used?\n\n![Image description](https://python.langchain.com/assets/images/OSS_LLM_overview-9444c9793c76bd4785a5b0cd020c14ef.png)\n\nThe relative performance of these models can be assessed using several leaderboards, including:\n\n1.  [LmSys](https://chat.lmsys.org/?arena)\n2.  [GPT4All](https://gpt4all.io/index.html)\n3.  [HuggingFace](https://huggingface.co/spaces/lmsys/chatbot-arena-leaderboard)\n\n### Inference[​](#inference \"Direct link to Inference\")\n\nA few frameworks for this have emerged to support inference of open-source LLMs on various devices:\n\n1.  [`llama.cpp`](https://github.com/ggerganov/llama.cpp): C++ implementation of llama inference code with [weight optimization / quantization](https://finbarr.ca/how-is-llama-cpp-possible/)\n2.  [`gpt4all`](https://docs.gpt4all.io/index.html): Optimized C backend for inference\n3.  [`Ollama`](https://ollama.ai/): Bundles model weights and environment into an app that runs on device and serves the LLM\n4.  [`llamafile`](https://github.com/Mozilla-Ocho/llamafile): Bundles model weights and everything needed to run the model in a single file, allowing you to run the LLM locally from this file without any additional installation steps\n\nIn general, these frameworks will do a few things:\n\n1.  `Quantization`: Reduce the memory footprint of the raw model weights\n2.  `Efficient implementation for inference`: Support inference on consumer hardware (e.g., CPU or laptop GPU)\n\nIn particular, see [this excellent post](https://finbarr.ca/how-is-llama-cpp-possible/) on the importance of quantization.\n\n![Image description](https://python.langchain.com/assets/images/llama-memory-weights-aaccef5df087e993b0f46277500039b6.png)\n\nWith less precision, we radically decrease the memory needed to store the LLM in memory.\n\nIn addition, we can see the importance of GPU memory bandwidth [sheet](https://docs.google.com/spreadsheets/d/1OehfHHNSn66BP2h3Bxp2NJTVX97icU0GmCXF6pK23H8/edit#gid=0)!\n\nA Mac M2 Max is 5-6x faster than a M1 for inference due to the larger GPU memory bandwidth.\n\n![Image description](https://python.langchain.com/assets/images/llama_t_put-c6f0ea201a6dd508999170325cd6804a.png)\n\n### Formatting prompts[​](#formatting-prompts \"Direct link to Formatting prompts\")\n\nSome providers have [chat model](https://python.langchain.com/docs/concepts/chat_models/) wrappers that takes care of formatting your input prompt for the specific local model you're using. However, if you are prompting local models with a [text-in/text-out LLM](https://python.langchain.com/docs/concepts/text_llms/) wrapper, you may need to use a prompt tailed for your specific model.\n\nThis can [require the inclusion of special tokens](https://huggingface.co/blog/llama2#how-to-prompt-llama-2). [Here's an example for LLaMA 2](https://smith.langchain.com/hub/rlm/rag-prompt-llama).\n\n## Quickstart[​](#quickstart \"Direct link to Quickstart\")\n\n[`Ollama`](https://ollama.ai/) is one way to easily run inference on macOS.\n\nThe instructions [here](https://github.com/jmorganca/ollama?tab=readme-ov-file#ollama) provide details, which we summarize:\n\n*   [Download and run](https://ollama.ai/download) the app\n*   From command line, fetch a model from this [list of options](https://github.com/jmorganca/ollama): e.g., `ollama pull llama3.1:8b`\n*   When the app is running, all models are automatically served on `localhost:11434`\n\n```\n%pip install -qU langchain_ollama\n```\n\n```\nfrom langchain_ollama import OllamaLLMllm = OllamaLLM(model=\"llama3.1:8b\")llm.invoke(\"The first man on the moon was ...\")\n```\n\n```\n'...Neil Armstrong!\\n\\nOn July 20, 1969, Neil Armstrong became the first person to set foot on the lunar surface, famously declaring \"That\\'s one small step for man, one giant leap for mankind\" as he stepped off the lunar module Eagle onto the Moon\\'s surface.\\n\\nWould you like to know more about the Apollo 11 mission or Neil Armstrong\\'s achievements?'\n```\n\nStream tokens as they are being generated:\n\n```\nfor chunk in llm.stream(\"The first man on the moon was ...\"):    print(chunk, end=\"|\", flush=True)\n```\n\n```\n...|``````outputNeil| Armstrong|,| an| American| astronaut|.| He| stepped| out| of| the| lunar| module| Eagle| and| onto| the| surface| of| the| Moon| on| July| |20|,| |196|9|,| famously| declaring|:| \"|That|'s| one| small| step| for| man|,| one| giant| leap| for| mankind|.\"||\n```\n\nOllama also includes a chat model wrapper that handles formatting conversation turns:\n\n```\nfrom langchain_ollama import ChatOllamachat_model = ChatOllama(model=\"llama3.1:8b\")chat_model.invoke(\"Who was the first man on the moon?\")\n```\n\n```\nAIMessage(content='The answer is a historic one!\\n\\nThe first man to walk on the Moon was Neil Armstrong, an American astronaut and commander of the Apollo 11 mission. On July 20, 1969, Armstrong stepped out of the lunar module Eagle onto the surface of the Moon, famously declaring:\\n\\n\"That\\'s one small step for man, one giant leap for mankind.\"\\n\\nArmstrong was followed by fellow astronaut Edwin \"Buzz\" Aldrin, who also walked on the Moon during the mission. Michael Collins remained in orbit around the Moon in the command module Columbia.\\n\\nNeil Armstrong passed away on August 25, 2012, but his legacy as a pioneering astronaut and engineer continues to inspire people around the world!', response_metadata={'model': 'llama3.1:8b', 'created_at': '2024-08-01T00:38:29.176717Z', 'message': {'role': 'assistant', 'content': ''}, 'done_reason': 'stop', 'done': True, 'total_duration': 10681861417, 'load_duration': 34270292, 'prompt_eval_count': 19, 'prompt_eval_duration': 6209448000, 'eval_count': 141, 'eval_duration': 4432022000}, id='run-7bed57c5-7f54-4092-912c-ae49073dcd48-0', usage_metadata={'input_tokens': 19, 'output_tokens': 141, 'total_tokens': 160})\n```\n\n## Environment[​](#environment \"Direct link to Environment\")\n\nInference speed is a challenge when running models locally (see above).\n\nTo minimize latency, it is desirable to run models locally on GPU, which ships with many consumer laptops [e.g., Apple devices](https://www.apple.com/newsroom/2022/06/apple-unveils-m2-with-breakthrough-performance-and-capabilities/).\n\nAnd even with GPU, the available GPU memory bandwidth (as noted above) is important.\n\n### Running Apple silicon GPU[​](#running-apple-silicon-gpu \"Direct link to Running Apple silicon GPU\")\n\n`Ollama` and [`llamafile`](https://github.com/Mozilla-Ocho/llamafile?tab=readme-ov-file#gpu-support) will automatically utilize the GPU on Apple devices.\n\nOther frameworks require the user to set up the environment to utilize the Apple GPU.\n\nFor example, `llama.cpp` python bindings can be configured to use the GPU via [Metal](https://developer.apple.com/metal/).\n\nMetal is a graphics and compute API created by Apple providing near-direct access to the GPU.\n\nSee the [`llama.cpp`](https://python.langchain.com/docs/integrations/llms/llamacpp/) setup [here](https://github.com/abetlen/llama-cpp-python/blob/main/docs/install/macos.md) to enable this.\n\nIn particular, ensure that conda is using the correct virtual environment that you created (`miniforge3`).\n\nE.g., for me:\n\n```\nconda activate /Users/rlm/miniforge3/envs/llama\n```\n\nWith the above confirmed, then:\n\n```\nCMAKE_ARGS=\"-DLLAMA_METAL=on\" FORCE_CMAKE=1 pip install -U llama-cpp-python --no-cache-dir\n```\n\n## LLMs[​](#llms \"Direct link to LLMs\")\n\nThere are various ways to gain access to quantized model weights.\n\n1.  [`HuggingFace`](https://huggingface.co/TheBloke) - Many quantized model are available for download and can be run with framework such as [`llama.cpp`](https://github.com/ggerganov/llama.cpp). You can also download models in [`llamafile` format](https://huggingface.co/models?other=llamafile) from HuggingFace.\n2.  [`gpt4all`](https://gpt4all.io/index.html) - The model explorer offers a leaderboard of metrics and associated quantized models available for download\n3.  [`Ollama`](https://github.com/jmorganca/ollama) - Several models can be accessed directly via `pull`\n\n### Ollama[​](#ollama \"Direct link to Ollama\")\n\nWith [Ollama](https://github.com/jmorganca/ollama), fetch a model via `ollama pull <model family>:<tag>`:\n\n*   E.g., for Llama 2 7b: `ollama pull llama2` will download the most basic version of the model (e.g., smallest # parameters and 4 bit quantization)\n*   We can also specify a particular version from the [model list](https://github.com/jmorganca/ollama?tab=readme-ov-file#model-library), e.g., `ollama pull llama2:13b`\n*   See the full set of parameters on the [API reference page](https://python.langchain.com/api_reference/community/llms/langchain_community.llms.ollama.Ollama.html)\n\n```\nllm = OllamaLLM(model=\"llama2:13b\")llm.invoke(\"The first man on the moon was ... think step by step\")\n```\n\n```\n' Sure! Here\\'s the answer, broken down step by step:\\n\\nThe first man on the moon was... Neil Armstrong.\\n\\nHere\\'s how I arrived at that answer:\\n\\n1. The first manned mission to land on the moon was Apollo 11.\\n2. The mission included three astronauts: Neil Armstrong, Edwin \"Buzz\" Aldrin, and Michael Collins.\\n3. Neil Armstrong was the mission commander and the first person to set foot on the moon.\\n4. On July 20, 1969, Armstrong stepped out of the lunar module Eagle and onto the moon\\'s surface, famously declaring \"That\\'s one small step for man, one giant leap for mankind.\"\\n\\nSo, the first man on the moon was Neil Armstrong!'\n```\n\n### Llama.cpp[​](#llamacpp \"Direct link to Llama.cpp\")\n\nLlama.cpp is compatible with a [broad set of models](https://github.com/ggerganov/llama.cpp).\n\nFor example, below we run inference on `llama2-13b` with 4 bit quantization downloaded from [HuggingFace](https://huggingface.co/TheBloke/Llama-2-13B-GGML/tree/main).\n\nAs noted above, see the [API reference](https://python.langchain.com/api_reference/langchain/llms/langchain.llms.llamacpp.LlamaCpp.html?highlight=llamacpp#langchain.llms.llamacpp.LlamaCpp) for the full set of parameters.\n\nFrom the [llama.cpp API reference docs](https://python.langchain.com/api_reference/community/llms/langchain_community.llms.llamacpp.LlamaCpp.html), a few are worth commenting on:\n\n`n_gpu_layers`: number of layers to be loaded into GPU memory\n\n*   Value: 1\n*   Meaning: Only one layer of the model will be loaded into GPU memory (1 is often sufficient).\n\n`n_batch`: number of tokens the model should process in parallel\n\n*   Value: n\\_batch\n*   Meaning: It's recommended to choose a value between 1 and n\\_ctx (which in this case is set to 2048)\n\n`n_ctx`: Token context window\n\n*   Value: 2048\n*   Meaning: The model will consider a window of 2048 tokens at a time\n\n`f16_kv`: whether the model should use half-precision for the key/value cache\n\n*   Value: True\n*   Meaning: The model will use half-precision, which can be more memory efficient; Metal only supports True.\n\n```\n%env CMAKE_ARGS=\"-DLLAMA_METAL=on\"%env FORCE_CMAKE=1%pip install --upgrade --quiet  llama-cpp-python --no-cache-dirclear\n```\n\n```\nfrom langchain_community.llms import LlamaCppfrom langchain_core.callbacks import CallbackManager, StreamingStdOutCallbackHandlerllm = LlamaCpp(    model_path=\"/Users/rlm/Desktop/Code/llama.cpp/models/openorca-platypus2-13b.gguf.q4_0.bin\",    n_gpu_layers=1,    n_batch=512,    n_ctx=2048,    f16_kv=True,    callback_manager=CallbackManager([StreamingStdOutCallbackHandler()]),    verbose=True,)\n```\n\nThe console log will show the below to indicate Metal was enabled properly from steps above:\n\n```\nggml_metal_init: allocatingggml_metal_init: using MPS\n```\n\n```\nllm.invoke(\"The first man on the moon was ... Let's think step by step\")\n```\n\n```\nLlama.generate: prefix-match hit``````output and use logical reasoning to figure out who the first man on the moon was.Here are some clues:1. The first man on the moon was an American.2. He was part of the Apollo 11 mission.3. He stepped out of the lunar module and became the first person to set foot on the moon's surface.4. His last name is Armstrong.Now, let's use our reasoning skills to figure out who the first man on the moon was. Based on clue #1, we know that the first man on the moon was an American. Clue #2 tells us that he was part of the Apollo 11 mission. Clue #3 reveals that he was the first person to set foot on the moon's surface. And finally, clue #4 gives us his last name: Armstrong.Therefore, the first man on the moon was Neil Armstrong!``````outputllama_print_timings:        load time =  9623.21 msllama_print_timings:      sample time =   143.77 ms /   203 runs   (    0.71 ms per token,  1412.01 tokens per second)llama_print_timings: prompt eval time =   485.94 ms /     7 tokens (   69.42 ms per token,    14.40 tokens per second)llama_print_timings:        eval time =  6385.16 ms /   202 runs   (   31.61 ms per token,    31.64 tokens per second)llama_print_timings:       total time =  7279.28 ms\n```\n\n```\n\" and use logical reasoning to figure out who the first man on the moon was.\\n\\nHere are some clues:\\n\\n1. The first man on the moon was an American.\\n2. He was part of the Apollo 11 mission.\\n3. He stepped out of the lunar module and became the first person to set foot on the moon's surface.\\n4. His last name is Armstrong.\\n\\nNow, let's use our reasoning skills to figure out who the first man on the moon was. Based on clue #1, we know that the first man on the moon was an American. Clue #2 tells us that he was part of the Apollo 11 mission. Clue #3 reveals that he was the first person to set foot on the moon's surface. And finally, clue #4 gives us his last name: Armstrong.\\nTherefore, the first man on the moon was Neil Armstrong!\"\n```\n\n### GPT4All[​](#gpt4all \"Direct link to GPT4All\")\n\nWe can use model weights downloaded from [GPT4All](https://python.langchain.com/docs/integrations/llms/gpt4all/) model explorer.\n\nSimilar to what is shown above, we can run inference and use [the API reference](https://python.langchain.com/api_reference/community/llms/langchain_community.llms.gpt4all.GPT4All.html) to set parameters of interest.\n\n```\nfrom langchain_community.llms import GPT4Allllm = GPT4All(    model=\"/Users/rlm/Desktop/Code/gpt4all/models/nous-hermes-13b.ggmlv3.q4_0.bin\")\n```\n\n```\nllm.invoke(\"The first man on the moon was ... Let's think step by step\")\n```\n\n```\n\".\\n1) The United States decides to send a manned mission to the moon.2) They choose their best astronauts and train them for this specific mission.3) They build a spacecraft that can take humans to the moon, called the Lunar Module (LM).4) They also create a larger spacecraft, called the Saturn V rocket, which will launch both the LM and the Command Service Module (CSM), which will carry the astronauts into orbit.5) The mission is planned down to the smallest detail: from the trajectory of the rockets to the exact movements of the astronauts during their moon landing.6) On July 16, 1969, the Saturn V rocket launches from Kennedy Space Center in Florida, carrying the Apollo 11 mission crew into space.7) After one and a half orbits around the Earth, the LM separates from the CSM and begins its descent to the moon's surface.8) On July 20, 1969, at 2:56 pm EDT (GMT-4), Neil Armstrong becomes the first man on the moon. He speaks these\"\n```\n\n### llamafile[​](#llamafile \"Direct link to llamafile\")\n\nOne of the simplest ways to run an LLM locally is using a [llamafile](https://github.com/Mozilla-Ocho/llamafile). All you need to do is:\n\n1.  Download a llamafile from [HuggingFace](https://huggingface.co/models?other=llamafile)\n2.  Make the file executable\n3.  Run the file\n\nllamafiles bundle model weights and a [specially-compiled](https://github.com/Mozilla-Ocho/llamafile?tab=readme-ov-file#technical-details) version of [`llama.cpp`](https://github.com/ggerganov/llama.cpp) into a single file that can run on most computers any additional dependencies. They also come with an embedded inference server that provides an [API](https://github.com/Mozilla-Ocho/llamafile/blob/main/llama.cpp/server/README.md#api-endpoints) for interacting with your model.\n\nHere's a simple bash script that shows all 3 setup steps:\n\n```\n# Download a llamafile from HuggingFacewget https://huggingface.co/jartine/TinyLlama-1.1B-Chat-v1.0-GGUF/resolve/main/TinyLlama-1.1B-Chat-v1.0.Q5_K_M.llamafile# Make the file executable. On Windows, instead just rename the file to end in \".exe\".chmod +x TinyLlama-1.1B-Chat-v1.0.Q5_K_M.llamafile# Start the model server. Listens at http://localhost:8080 by default../TinyLlama-1.1B-Chat-v1.0.Q5_K_M.llamafile --server --nobrowser\n```\n\nAfter you run the above setup steps, you can use LangChain to interact with your model:\n\n```\nfrom langchain_community.llms.llamafile import Llamafilellm = Llamafile()llm.invoke(\"The first man on the moon was ... Let's think step by step.\")\n```\n\n```\n\"\\nFirstly, let's imagine the scene where Neil Armstrong stepped onto the moon. This happened in 1969. The first man on the moon was Neil Armstrong. We already know that.\\n2nd, let's take a step back. Neil Armstrong didn't have any special powers. He had to land his spacecraft safely on the moon without injuring anyone or causing any damage. If he failed to do this, he would have been killed along with all those people who were on board the spacecraft.\\n3rd, let's imagine that Neil Armstrong successfully landed his spacecraft on the moon and made it back to Earth safely. The next step was for him to be hailed as a hero by his people back home. It took years before Neil Armstrong became an American hero.\\n4th, let's take another step back. Let's imagine that Neil Armstrong wasn't hailed as a hero, and instead, he was just forgotten. This happened in the 1970s. Neil Armstrong wasn't recognized for his remarkable achievement on the moon until after he died.\\n5th, let's take another step back. Let's imagine that Neil Armstrong didn't die in the 1970s and instead, lived to be a hundred years old. This happened in 2036. In the year 2036, Neil Armstrong would have been a centenarian.\\nNow, let's think about the present. Neil Armstrong is still alive. He turned 95 years old on July 20th, 2018. If he were to die now, his achievement of becoming the first human being to set foot on the moon would remain an unforgettable moment in history.\\nI hope this helps you understand the significance and importance of Neil Armstrong's achievement on the moon!\"\n```\n\n## Prompts[​](#prompts \"Direct link to Prompts\")\n\nSome LLMs will benefit from specific prompts.\n\nFor example, LLaMA will use [special tokens](https://twitter.com/RLanceMartin/status/1681879318493003776?s=20).\n\nWe can use `ConditionalPromptSelector` to set prompt based on the model type.\n\n```\n# Set our LLMllm = LlamaCpp(    model_path=\"/Users/rlm/Desktop/Code/llama.cpp/models/openorca-platypus2-13b.gguf.q4_0.bin\",    n_gpu_layers=1,    n_batch=512,    n_ctx=2048,    f16_kv=True,    callback_manager=CallbackManager([StreamingStdOutCallbackHandler()]),    verbose=True,)\n```\n\nSet the associated prompt based upon the model version.\n\n```\nfrom langchain.chains.prompt_selector import ConditionalPromptSelectorfrom langchain_core.prompts import PromptTemplateDEFAULT_LLAMA_SEARCH_PROMPT = PromptTemplate(    input_variables=[\"question\"],    template=\"\"\"<<SYS>> \\n You are an assistant tasked with improving Google search \\results. \\n <</SYS>> \\n\\n [INST] Generate THREE Google search queries that \\are similar to this question. The output should be a numbered list of questions \\and each should have a question mark at the end: \\n\\n {question} [/INST]\"\"\",)DEFAULT_SEARCH_PROMPT = PromptTemplate(    input_variables=[\"question\"],    template=\"\"\"You are an assistant tasked with improving Google search \\results. Generate THREE Google search queries that are similar to \\this question. The output should be a numbered list of questions and each \\should have a question mark at the end: {question}\"\"\",)QUESTION_PROMPT_SELECTOR = ConditionalPromptSelector(    default_prompt=DEFAULT_SEARCH_PROMPT,    conditionals=[(lambda llm: isinstance(llm, LlamaCpp), DEFAULT_LLAMA_SEARCH_PROMPT)],)prompt = QUESTION_PROMPT_SELECTOR.get_prompt(llm)prompt\n```\n\n```\nPromptTemplate(input_variables=['question'], output_parser=None, partial_variables={}, template='<<SYS>> \\n You are an assistant tasked with improving Google search results. \\n <</SYS>> \\n\\n [INST] Generate THREE Google search queries that are similar to this question. The output should be a numbered list of questions and each should have a question mark at the end: \\n\\n {question} [/INST]', template_format='f-string', validate_template=True)\n```\n\n```\n# Chainchain = prompt | llmquestion = \"What NFL team won the Super Bowl in the year that Justin Bieber was born?\"chain.invoke({\"question\": question})\n```\n\n```\n  Sure! Here are three similar search queries with a question mark at the end:1. Which NBA team did LeBron James lead to a championship in the year he was drafted?2. Who won the Grammy Awards for Best New Artist and Best Female Pop Vocal Performance in the same year that Lady Gaga was born?3. What MLB team did Babe Ruth play for when he hit 60 home runs in a single season?``````outputllama_print_timings:        load time = 14943.19 msllama_print_timings:      sample time =    72.93 ms /   101 runs   (    0.72 ms per token,  1384.87 tokens per second)llama_print_timings: prompt eval time = 14942.95 ms /    93 tokens (  160.68 ms per token,     6.22 tokens per second)llama_print_timings:        eval time =  3430.85 ms /   100 runs   (   34.31 ms per token,    29.15 tokens per second)llama_print_timings:       total time = 18578.26 ms\n```\n\n```\n'  Sure! Here are three similar search queries with a question mark at the end:\\n\\n1. Which NBA team did LeBron James lead to a championship in the year he was drafted?\\n2. Who won the Grammy Awards for Best New Artist and Best Female Pop Vocal Performance in the same year that Lady Gaga was born?\\n3. What MLB team did Babe Ruth play for when he hit 60 home runs in a single season?'\n```\n\nWe also can use the LangChain Prompt Hub to fetch and / or store prompts that are model specific.\n\nThis will work with your [LangSmith API key](https://docs.smith.langchain.com/).\n\nFor example, [here](https://smith.langchain.com/hub/rlm/rag-prompt-llama) is a prompt for RAG with LLaMA-specific tokens.\n\n## Use cases[​](#use-cases \"Direct link to Use cases\")\n\nGiven an `llm` created from one of the models above, you can use it for [many use cases](https://python.langchain.com/docs/how_to/#use-cases).\n\nFor example, you can implement a [RAG application](https://python.langchain.com/docs/tutorials/rag/) using the chat models demonstrated here.\n\nIn general, use cases for local LLMs can be driven by at least two factors:\n\n*   `Privacy`: private data (e.g., journals, etc) that a user does not want to share\n*   `Cost`: text preprocessing (extraction/tagging), summarization, and agent simulations are token-use-intensive tasks\n\nIn addition, [here](https://blog.langchain.dev/using-langsmith-to-support-fine-tuning-of-open-source-llms/) is an overview on fine-tuning, which can utilize open-source LLMs."
},
{
  "url": "https://python.langchain.com/docs/how_to/embed_text/",
  "markdown": "# giscus\n\n[![Open on GitHub](https://img.shields.io/badge/Open%20on%20GitHub-grey?logo=github&logoColor=white)](https://github.com/langchain-ai/langchain/blob/master/docs/docs/how_to/embed_text.mdx)\n\n## Text embedding models\n\ninfo\n\nHead to [Integrations](https://python.langchain.com/docs/integrations/text_embedding/) for documentation on built-in integrations with text embedding model providers.\n\nThe Embeddings class is a class designed for interfacing with text embedding models. There are lots of embedding model providers (OpenAI, Cohere, Hugging Face, etc) - this class is designed to provide a standard interface for all of them.\n\nEmbeddings create a vector representation of a piece of text. This is useful because it means we can think about text in the vector space, and do things like semantic search where we look for pieces of text that are most similar in the vector space.\n\nThe base Embeddings class in LangChain provides two methods: one for embedding documents and one for embedding a query. The former, `.embed_documents`, takes as input multiple texts, while the latter, `.embed_query`, takes a single text. The reason for having these as two separate methods is that some embedding providers have different embedding methods for documents (to be searched over) vs queries (the search query itself). `.embed_query` will return a list of floats, whereas `.embed_documents` returns a list of lists of floats.\n\n## Get started[​](#get-started \"Direct link to Get started\")\n\n### Setup[​](#setup \"Direct link to Setup\")\n\n```\npip install -qU langchain-openai\n```\n\n```\nimport getpassimport osif not os.environ.get(\"OPENAI_API_KEY\"):  os.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"Enter API key for OpenAI: \")from langchain_openai import OpenAIEmbeddingsembeddings_model = OpenAIEmbeddings(model=\"text-embedding-3-large\")\n```\n\n### `embed_documents`[​](#embed_documents \"Direct link to embed_documents\")\n\n#### Embed list of texts[​](#embed-list-of-texts \"Direct link to Embed list of texts\")\n\nUse `.embed_documents` to embed a list of strings, recovering a list of embeddings:\n\n```\nembeddings = embeddings_model.embed_documents(    [        \"Hi there!\",        \"Oh, hello!\",        \"What's your name?\",        \"My friends call me World\",        \"Hello World!\"    ])len(embeddings), len(embeddings[0])\n```\n\n### `embed_query`[​](#embed_query \"Direct link to embed_query\")\n\n#### Embed single query[​](#embed-single-query \"Direct link to Embed single query\")\n\nUse `.embed_query` to embed a single piece of text (e.g., for the purpose of comparing to other embedded pieces of texts).\n\n```\nembedded_query = embeddings_model.embed_query(\"What was the name mentioned in the conversation?\")embedded_query[:5]\n```\n\n```\n[0.0053587136790156364, -0.0004999046213924885, 0.038883671164512634, -0.003001077566295862, -0.00900818221271038]\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/split_by_token/",
  "markdown": "# giscus\n\n## How to split text by tokens\n\nLanguage models have a [token](https://python.langchain.com/docs/concepts/tokens/) limit. You should not exceed the token limit. When you [split your text](https://python.langchain.com/docs/concepts/text_splitters/) into chunks it is therefore a good idea to count the number of tokens. There are many tokenizers. When you count tokens in your text you should use the same tokenizer as used in the language model.\n\n## tiktoken[​](#tiktoken \"Direct link to tiktoken\")\n\nnote\n\n[tiktoken](https://github.com/openai/tiktoken) is a fast `BPE` tokenizer created by `OpenAI`.\n\nWe can use `tiktoken` to estimate tokens used. It will probably be more accurate for the OpenAI models.\n\n1.  How the text is split: by character passed in.\n2.  How the chunk size is measured: by `tiktoken` tokenizer.\n\n[CharacterTextSplitter](https://python.langchain.com/api_reference/text_splitters/character/langchain_text_splitters.character.CharacterTextSplitter.html), [RecursiveCharacterTextSplitter](https://python.langchain.com/api_reference/text_splitters/character/langchain_text_splitters.character.RecursiveCharacterTextSplitter.html), and [TokenTextSplitter](https://python.langchain.com/api_reference/text_splitters/base/langchain_text_splitters.base.TokenTextSplitter.html) can be used with `tiktoken` directly.\n\n```\n%pip install --upgrade --quiet langchain-text-splitters tiktoken\n```\n\n```\nfrom langchain_text_splitters import CharacterTextSplitter# This is a long document we can split up.with open(\"state_of_the_union.txt\") as f:    state_of_the_union = f.read()\n```\n\nTo split with a [CharacterTextSplitter](https://python.langchain.com/api_reference/text_splitters/character/langchain_text_splitters.character.CharacterTextSplitter.html) and then merge chunks with `tiktoken`, use its `.from_tiktoken_encoder()` method. Note that splits from this method can be larger than the chunk size measured by the `tiktoken` tokenizer.\n\nThe `.from_tiktoken_encoder()` method takes either `encoding_name` as an argument (e.g. `cl100k_base`), or the `model_name` (e.g. `gpt-4`). All additional arguments like `chunk_size`, `chunk_overlap`, and `separators` are used to instantiate `CharacterTextSplitter`:\n\n```\ntext_splitter = CharacterTextSplitter.from_tiktoken_encoder(    encoding_name=\"cl100k_base\", chunk_size=100, chunk_overlap=0)texts = text_splitter.split_text(state_of_the_union)\n```\n\n```\nMadam Speaker, Madam Vice President, our First Lady and Second Gentleman. Members of Congress and the Cabinet. Justices of the Supreme Court. My fellow Americans.  Last year COVID-19 kept us apart. This year we are finally together again. Tonight, we meet as Democrats Republicans and Independents. But most importantly as Americans. With a duty to one another to the American people to the Constitution.\n```\n\nTo implement a hard constraint on the chunk size, we can use `RecursiveCharacterTextSplitter.from_tiktoken_encoder`, where each split will be recursively split if it has a larger size:\n\n```\nfrom langchain_text_splitters import RecursiveCharacterTextSplittertext_splitter = RecursiveCharacterTextSplitter.from_tiktoken_encoder(    model_name=\"gpt-4\",    chunk_size=100,    chunk_overlap=0,)\n```\n\nWe can also load a `TokenTextSplitter` splitter, which works with `tiktoken` directly and will ensure each split is smaller than chunk size.\n\n```\nfrom langchain_text_splitters import TokenTextSplittertext_splitter = TokenTextSplitter(chunk_size=10, chunk_overlap=0)texts = text_splitter.split_text(state_of_the_union)print(texts[0])\n```\n\n```\nMadam Speaker, Madam Vice President, our\n```\n\nSome written languages (e.g. Chinese and Japanese) have characters which encode to 2 or more tokens. Using the `TokenTextSplitter` directly can split the tokens for a character between two chunks causing malformed Unicode characters. Use `RecursiveCharacterTextSplitter.from_tiktoken_encoder` or `CharacterTextSplitter.from_tiktoken_encoder` to ensure chunks contain valid Unicode strings.\n\n## spaCy[​](#spacy \"Direct link to spaCy\")\n\nnote\n\n[spaCy](https://spacy.io/) is an open-source software library for advanced natural language processing, written in the programming languages Python and Cython.\n\nLangChain implements splitters based on the [spaCy tokenizer](https://spacy.io/api/tokenizer).\n\n1.  How the text is split: by `spaCy` tokenizer.\n2.  How the chunk size is measured: by number of characters.\n\n```\n%pip install --upgrade --quiet  spacy\n```\n\n```\n# This is a long document we can split up.with open(\"state_of_the_union.txt\") as f:    state_of_the_union = f.read()\n```\n\n```\nfrom langchain_text_splitters import SpacyTextSplittertext_splitter = SpacyTextSplitter(chunk_size=1000)texts = text_splitter.split_text(state_of_the_union)print(texts[0])\n```\n\n```\nMadam Speaker, Madam Vice President, our First Lady and Second Gentleman.Members of Congress and the Cabinet.Justices of the Supreme Court.My fellow Americans.  Last year COVID-19 kept us apart.This year we are finally together again. Tonight, we meet as Democrats Republicans and Independents.But most importantly as Americans. With a duty to one another to the American people to the Constitution. And with an unwavering resolve that freedom will always triumph over tyranny. Six days ago, Russia’s Vladimir Putin sought to shake the foundations of the free world thinking he could make it bend to his menacing ways.But he badly miscalculated. He thought he could roll into Ukraine and the world would roll over.Instead he met a wall of strength he never imagined. He met the Ukrainian people. From President Zelenskyy to every Ukrainian, their fearlessness, their courage, their determination, inspires the world.\n```\n\n## SentenceTransformers[​](#sentencetransformers \"Direct link to SentenceTransformers\")\n\nThe [SentenceTransformersTokenTextSplitter](https://python.langchain.com/api_reference/text_splitters/sentence_transformers/langchain_text_splitters.sentence_transformers.SentenceTransformersTokenTextSplitter.html) is a specialized text splitter for use with the sentence-transformer models. The default behaviour is to split the text into chunks that fit the token window of the sentence transformer model that you would like to use.\n\nTo split text and constrain token counts according to the sentence-transformers tokenizer, instantiate a `SentenceTransformersTokenTextSplitter`. You can optionally specify:\n\n*   `chunk_overlap`: integer count of token overlap;\n*   `model_name`: sentence-transformer model name, defaulting to `\"sentence-transformers/all-mpnet-base-v2\"`;\n*   `tokens_per_chunk`: desired token count per chunk.\n\n```\nfrom langchain_text_splitters import SentenceTransformersTokenTextSplittersplitter = SentenceTransformersTokenTextSplitter(chunk_overlap=0)text = \"Lorem \"count_start_and_stop_tokens = 2text_token_count = splitter.count_tokens(text=text) - count_start_and_stop_tokensprint(text_token_count)\n```\n\n```\ntoken_multiplier = splitter.maximum_tokens_per_chunk // text_token_count + 1# `text_to_split` does not fit in a single chunktext_to_split = text * token_multiplierprint(f\"tokens in text to split: {splitter.count_tokens(text=text_to_split)}\")\n```\n\n```\ntokens in text to split: 514\n```\n\n```\ntext_chunks = splitter.split_text(text=text_to_split)print(text_chunks[1])\n```\n\n## NLTK[​](#nltk \"Direct link to NLTK\")\n\nnote\n\n[The Natural Language Toolkit](https://en.wikipedia.org/wiki/Natural_Language_Toolkit), or more commonly [NLTK](https://www.nltk.org/), is a suite of libraries and programs for symbolic and statistical natural language processing (NLP) for English written in the Python programming language.\n\nRather than just splitting on \"\\\\n\\\\n\", we can use `NLTK` to split based on [NLTK tokenizers](https://www.nltk.org/api/nltk.tokenize.html).\n\n1.  How the text is split: by `NLTK` tokenizer.\n2.  How the chunk size is measured: by number of characters.\n\n```\n# This is a long document we can split up.with open(\"state_of_the_union.txt\") as f:    state_of_the_union = f.read()\n```\n\n```\nfrom langchain_text_splitters import NLTKTextSplittertext_splitter = NLTKTextSplitter(chunk_size=1000)\n```\n\n```\ntexts = text_splitter.split_text(state_of_the_union)print(texts[0])\n```\n\n```\nMadam Speaker, Madam Vice President, our First Lady and Second Gentleman.Members of Congress and the Cabinet.Justices of the Supreme Court.My fellow Americans.Last year COVID-19 kept us apart.This year we are finally together again.Tonight, we meet as Democrats Republicans and Independents.But most importantly as Americans.With a duty to one another to the American people to the Constitution.And with an unwavering resolve that freedom will always triumph over tyranny.Six days ago, Russia’s Vladimir Putin sought to shake the foundations of the free world thinking he could make it bend to his menacing ways.But he badly miscalculated.He thought he could roll into Ukraine and the world would roll over.Instead he met a wall of strength he never imagined.He met the Ukrainian people.From President Zelenskyy to every Ukrainian, their fearlessness, their courage, their determination, inspires the world.Groups of citizens blocking tanks with their bodies.\n```\n\n## KoNLPY[​](#konlpy \"Direct link to KoNLPY\")\n\nToken splitting involves the segmentation of text into smaller, more manageable units called tokens. These tokens are often words, phrases, symbols, or other meaningful elements crucial for further processing and analysis. In languages like English, token splitting typically involves separating words by spaces and punctuation marks. The effectiveness of token splitting largely depends on the tokenizer's understanding of the language structure, ensuring the generation of meaningful tokens. Since tokenizers designed for the English language are not equipped to understand the unique semantic structures of other languages, such as Korean, they cannot be effectively used for Korean language processing.\n\n### Token splitting for Korean with KoNLPy's Kkma Analyzer[​](#token-splitting-for-korean-with-konlpys-kkma-analyzer \"Direct link to Token splitting for Korean with KoNLPy's Kkma Analyzer\")\n\nIn case of Korean text, KoNLPY includes at morphological analyzer called `Kkma` (Korean Knowledge Morpheme Analyzer). `Kkma` provides detailed morphological analysis of Korean text. It breaks down sentences into words and words into their respective morphemes, identifying parts of speech for each token. It can segment a block of text into individual sentences, which is particularly useful for processing long texts.\n\n### Usage Considerations[​](#usage-considerations \"Direct link to Usage Considerations\")\n\nWhile `Kkma` is renowned for its detailed analysis, it is important to note that this precision may impact processing speed. Thus, `Kkma` is best suited for applications where analytical depth is prioritized over rapid text processing.\n\n```\n# This is a long Korean document that we want to split up into its component sentences.with open(\"./your_korean_doc.txt\") as f:    korean_document = f.read()\n```\n\n```\nfrom langchain_text_splitters import KonlpyTextSplittertext_splitter = KonlpyTextSplitter()\n```\n\n```\ntexts = text_splitter.split_text(korean_document)# The sentences are split with \"\\n\\n\" characters.print(texts[0])\n```\n\n```\n춘향전 옛날에 남원에 이 도령이라는 벼슬아치 아들이 있었다.그의 외모는 빛나는 달처럼 잘생겼고, 그의 학식과 기예는 남보다 뛰어났다.한편, 이 마을에는 춘향이라는 절세 가인이 살고 있었다.춘 향의 아름다움은 꽃과 같아 마을 사람들 로부터 많은 사랑을 받았다.어느 봄날, 도령은 친구들과 놀러 나갔다가 춘 향을 만 나 첫 눈에 반하고 말았다.두 사람은 서로 사랑하게 되었고, 이내 비밀스러운 사랑의 맹세를 나누었다.하지만 좋은 날들은 오래가지 않았다.도령의 아버지가 다른 곳으로 전근을 가게 되어 도령도 떠나 야만 했다.이별의 아픔 속에서도, 두 사람은 재회를 기약하며 서로를 믿고 기다리기로 했다.그러나 새로 부임한 관아의 사또가 춘 향의 아름다움에 욕심을 내 어 그녀에게 강요를 시작했다.춘 향 은 도령에 대한 자신의 사랑을 지키기 위해, 사또의 요구를 단호히 거절했다.이에 분노한 사또는 춘 향을 감옥에 가두고 혹독한 형벌을 내렸다.이야기는 이 도령이 고위 관직에 오른 후, 춘 향을 구해 내는 것으로 끝난다.두 사람은 오랜 시련 끝에 다시 만나게 되고, 그들의 사랑은 온 세상에 전해 지며 후세에까지 이어진다.- 춘향전 (The Tale of Chunhyang)\n```\n\n## Hugging Face tokenizer[​](#hugging-face-tokenizer \"Direct link to Hugging Face tokenizer\")\n\n[Hugging Face](https://huggingface.co/docs/tokenizers/index) has many tokenizers.\n\nWe use Hugging Face tokenizer, the [GPT2TokenizerFast](https://huggingface.co/Ransaka/gpt2-tokenizer-fast) to count the text length in tokens.\n\n1.  How the text is split: by character passed in.\n2.  How the chunk size is measured: by number of tokens calculated by the `Hugging Face` tokenizer.\n\n```\nfrom transformers import GPT2TokenizerFasttokenizer = GPT2TokenizerFast.from_pretrained(\"gpt2\")\n```\n\n```\n# This is a long document we can split up.with open(\"state_of_the_union.txt\") as f:    state_of_the_union = f.read()from langchain_text_splitters import CharacterTextSplitter\n```\n\n```\ntext_splitter = CharacterTextSplitter.from_huggingface_tokenizer(    tokenizer, chunk_size=100, chunk_overlap=0)texts = text_splitter.split_text(state_of_the_union)\n```\n\n```\nMadam Speaker, Madam Vice President, our First Lady and Second Gentleman. Members of Congress and the Cabinet. Justices of the Supreme Court. My fellow Americans.  Last year COVID-19 kept us apart. This year we are finally together again. Tonight, we meet as Democrats Republicans and Independents. But most importantly as Americans. With a duty to one another to the American people to the Constitution.\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/logprobs/",
  "markdown": "# giscus\n\n## How to get log probabilities\n\nPrerequisites\n\nThis guide assumes familiarity with the following concepts:\n\n*   [Chat models](https://python.langchain.com/docs/concepts/chat_models/)\n*   [Tokens](https://python.langchain.com/docs/concepts/tokens/)\n\nCertain [chat models](https://python.langchain.com/docs/concepts/chat_models/) can be configured to return token-level log probabilities representing the likelihood of a given token. This guide walks through how to get this information in LangChain.\n\n## OpenAI[​](#openai \"Direct link to OpenAI\")\n\nInstall the LangChain x OpenAI package and set your API key\n\n```\n%pip install -qU langchain-openai\n```\n\n```\nimport getpassimport osif \"OPENAI_API_KEY\" not in os.environ:    os.environ[\"OPENAI_API_KEY\"] = getpass()\n```\n\nFor the OpenAI API to return log probabilities we need to configure the `logprobs=True` param. Then, the logprobs are included on each output [`AIMessage`](https://python.langchain.com/api_reference/core/messages/langchain_core.messages.ai.AIMessage.html) as part of the `response_metadata`:\n\n```\nfrom langchain_openai import ChatOpenAIllm = ChatOpenAI(model=\"gpt-4o-mini\").bind(logprobs=True)msg = llm.invoke((\"human\", \"how are you today\"))msg.response_metadata[\"logprobs\"][\"content\"][:5]\n```\n\n```\n[{'token': 'I', 'bytes': [73], 'logprob': -0.26341408, 'top_logprobs': []}, {'token': \"'m\",  'bytes': [39, 109],  'logprob': -0.48584133,  'top_logprobs': []}, {'token': ' just',  'bytes': [32, 106, 117, 115, 116],  'logprob': -0.23484154,  'top_logprobs': []}, {'token': ' a',  'bytes': [32, 97],  'logprob': -0.0018291725,  'top_logprobs': []}, {'token': ' computer',  'bytes': [32, 99, 111, 109, 112, 117, 116, 101, 114],  'logprob': -0.052299336,  'top_logprobs': []}]\n```\n\nAnd are part of streamed Message chunks as well:\n\n```\nct = 0full = Nonefor chunk in llm.stream((\"human\", \"how are you today\")):    if ct < 5:        full = chunk if full is None else full + chunk        if \"logprobs\" in full.response_metadata:            print(full.response_metadata[\"logprobs\"][\"content\"])    else:        break    ct += 1\n```\n\n```\n[][{'token': 'I', 'bytes': [73], 'logprob': -0.26593843, 'top_logprobs': []}][{'token': 'I', 'bytes': [73], 'logprob': -0.26593843, 'top_logprobs': []}, {'token': \"'m\", 'bytes': [39, 109], 'logprob': -0.3238896, 'top_logprobs': []}][{'token': 'I', 'bytes': [73], 'logprob': -0.26593843, 'top_logprobs': []}, {'token': \"'m\", 'bytes': [39, 109], 'logprob': -0.3238896, 'top_logprobs': []}, {'token': ' just', 'bytes': [32, 106, 117, 115, 116], 'logprob': -0.23778509, 'top_logprobs': []}][{'token': 'I', 'bytes': [73], 'logprob': -0.26593843, 'top_logprobs': []}, {'token': \"'m\", 'bytes': [39, 109], 'logprob': -0.3238896, 'top_logprobs': []}, {'token': ' just', 'bytes': [32, 106, 117, 115, 116], 'logprob': -0.23778509, 'top_logprobs': []}, {'token': ' a', 'bytes': [32, 97], 'logprob': -0.0022134194, 'top_logprobs': []}]\n```\n\n## Next steps[​](#next-steps \"Direct link to Next steps\")\n\nYou've now learned how to get logprobs from OpenAI models in LangChain.\n\nNext, check out the other how-to guides chat models in this section, like [how to get a model to return structured output](https://python.langchain.com/docs/how_to/structured_output/) or [how to track token usage](https://python.langchain.com/docs/how_to/chat_token_usage_tracking/)."
},
{
  "url": "https://python.langchain.com/docs/how_to/callbacks_attach/",
  "markdown": "# giscus\n\nIf you are composing a chain of runnables and want to reuse callbacks across multiple executions, you can attach callbacks with the [`.with_config()`](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.with_config) method. This saves you the need to pass callbacks in each time you invoke the chain.\n\n```\nfrom typing import Any, Dict, Listfrom langchain_anthropic import ChatAnthropicfrom langchain_core.callbacks import BaseCallbackHandlerfrom langchain_core.messages import BaseMessagefrom langchain_core.outputs import LLMResultfrom langchain_core.prompts import ChatPromptTemplateclass LoggingHandler(BaseCallbackHandler):    def on_chat_model_start(        self, serialized: Dict[str, Any], messages: List[List[BaseMessage]], **kwargs    ) -> None:        print(\"Chat model started\")    def on_llm_end(self, response: LLMResult, **kwargs) -> None:        print(f\"Chat model ended, response: {response}\")    def on_chain_start(        self, serialized: Dict[str, Any], inputs: Dict[str, Any], **kwargs    ) -> None:        print(f\"Chain {serialized.get('name')} started\")    def on_chain_end(self, outputs: Dict[str, Any], **kwargs) -> None:        print(f\"Chain ended, outputs: {outputs}\")callbacks = [LoggingHandler()]llm = ChatAnthropic(model=\"claude-3-sonnet-20240229\")prompt = ChatPromptTemplate.from_template(\"What is 1 + {number}?\")chain = prompt | llmchain_with_callbacks = chain.with_config(callbacks=callbacks)chain_with_callbacks.invoke({\"number\": \"2\"})\n```\n\n```\nChain RunnableSequence startedChain ChatPromptTemplate startedChain ended, outputs: messages=[HumanMessage(content='What is 1 + 2?')]Chat model startedChat model ended, response: generations=[[ChatGeneration(text='1 + 2 = 3', message=AIMessage(content='1 + 2 = 3', response_metadata={'id': 'msg_01NTYMsH9YxkoWsiPYs4Lemn', 'model': 'claude-3-sonnet-20240229', 'stop_reason': 'end_turn', 'stop_sequence': None, 'usage': {'input_tokens': 16, 'output_tokens': 13}}, id='run-d6bcfd72-9c94-466d-bac0-f39e456ad6e3-0'))]] llm_output={'id': 'msg_01NTYMsH9YxkoWsiPYs4Lemn', 'model': 'claude-3-sonnet-20240229', 'stop_reason': 'end_turn', 'stop_sequence': None, 'usage': {'input_tokens': 16, 'output_tokens': 13}} run=NoneChain ended, outputs: content='1 + 2 = 3' response_metadata={'id': 'msg_01NTYMsH9YxkoWsiPYs4Lemn', 'model': 'claude-3-sonnet-20240229', 'stop_reason': 'end_turn', 'stop_sequence': None, 'usage': {'input_tokens': 16, 'output_tokens': 13}} id='run-d6bcfd72-9c94-466d-bac0-f39e456ad6e3-0'\n```\n\n```\nAIMessage(content='1 + 2 = 3', response_metadata={'id': 'msg_01NTYMsH9YxkoWsiPYs4Lemn', 'model': 'claude-3-sonnet-20240229', 'stop_reason': 'end_turn', 'stop_sequence': None, 'usage': {'input_tokens': 16, 'output_tokens': 13}}, id='run-d6bcfd72-9c94-466d-bac0-f39e456ad6e3-0')\n```\n\nThe bound callbacks will run for all nested module runs.\n\nYou've now learned how to attach callbacks to a chain."
},
{
  "url": "https://python.langchain.com/docs/how_to/few_shot_examples/",
  "markdown": "# giscus\n\n## How to use few shot examples\n\nIn this guide, we'll learn how to create a simple prompt template that provides the model with example inputs and outputs when generating. Providing the LLM with a few such examples is called [few-shotting](https://python.langchain.com/docs/concepts/few_shot_prompting/), and is a simple yet powerful way to guide generation and in some cases drastically improve model performance.\n\nA few-shot prompt template can be constructed from either a set of examples, or from an [Example Selector](https://python.langchain.com/api_reference/core/example_selectors/langchain_core.example_selectors.base.BaseExampleSelector.html) class responsible for choosing a subset of examples from the defined set.\n\nThis guide will cover few-shotting with string prompt templates. For a guide on few-shotting with chat messages for chat models, see [here](https://python.langchain.com/docs/how_to/few_shot_examples_chat/).\n\n## Create a formatter for the few-shot examples[​](#create-a-formatter-for-the-few-shot-examples \"Direct link to Create a formatter for the few-shot examples\")\n\nConfigure a formatter that will format the few-shot examples into a string. This formatter should be a `PromptTemplate` object.\n\n```\nfrom langchain_core.prompts import PromptTemplateexample_prompt = PromptTemplate.from_template(\"Question: {question}\\n{answer}\")\n```\n\n## Creating the example set[​](#creating-the-example-set \"Direct link to Creating the example set\")\n\nNext, we'll create a list of few-shot examples. Each example should be a dictionary representing an example input to the formatter prompt we defined above.\n\n```\nexamples = [    {        \"question\": \"Who lived longer, Muhammad Ali or Alan Turing?\",        \"answer\": \"\"\"Are follow up questions needed here: Yes.Follow up: How old was Muhammad Ali when he died?Intermediate answer: Muhammad Ali was 74 years old when he died.Follow up: How old was Alan Turing when he died?Intermediate answer: Alan Turing was 41 years old when he died.So the final answer is: Muhammad Ali\"\"\",    },    {        \"question\": \"When was the founder of craigslist born?\",        \"answer\": \"\"\"Are follow up questions needed here: Yes.Follow up: Who was the founder of craigslist?Intermediate answer: Craigslist was founded by Craig Newmark.Follow up: When was Craig Newmark born?Intermediate answer: Craig Newmark was born on December 6, 1952.So the final answer is: December 6, 1952\"\"\",    },    {        \"question\": \"Who was the maternal grandfather of George Washington?\",        \"answer\": \"\"\"Are follow up questions needed here: Yes.Follow up: Who was the mother of George Washington?Intermediate answer: The mother of George Washington was Mary Ball Washington.Follow up: Who was the father of Mary Ball Washington?Intermediate answer: The father of Mary Ball Washington was Joseph Ball.So the final answer is: Joseph Ball\"\"\",    },    {        \"question\": \"Are both the directors of Jaws and Casino Royale from the same country?\",        \"answer\": \"\"\"Are follow up questions needed here: Yes.Follow up: Who is the director of Jaws?Intermediate Answer: The director of Jaws is Steven Spielberg.Follow up: Where is Steven Spielberg from?Intermediate Answer: The United States.Follow up: Who is the director of Casino Royale?Intermediate Answer: The director of Casino Royale is Martin Campbell.Follow up: Where is Martin Campbell from?Intermediate Answer: New Zealand.So the final answer is: No\"\"\",    },]\n```\n\nLet's test the formatting prompt with one of our examples:\n\n```\nprint(example_prompt.invoke(examples[0]).to_string())\n```\n\n```\nQuestion: Who lived longer, Muhammad Ali or Alan Turing?Are follow up questions needed here: Yes.Follow up: How old was Muhammad Ali when he died?Intermediate answer: Muhammad Ali was 74 years old when he died.Follow up: How old was Alan Turing when he died?Intermediate answer: Alan Turing was 41 years old when he died.So the final answer is: Muhammad Ali\n```\n\n### Pass the examples and formatter to `FewShotPromptTemplate`[​](#pass-the-examples-and-formatter-to-fewshotprompttemplate \"Direct link to pass-the-examples-and-formatter-to-fewshotprompttemplate\")\n\nFinally, create a [`FewShotPromptTemplate`](https://python.langchain.com/api_reference/core/prompts/langchain_core.prompts.few_shot.FewShotPromptTemplate.html) object. This object takes in the few-shot examples and the formatter for the few-shot examples. When this `FewShotPromptTemplate` is formatted, it formats the passed examples using the `example_prompt`, then and adds them to the final prompt before `suffix`:\n\n```\nfrom langchain_core.prompts import FewShotPromptTemplateprompt = FewShotPromptTemplate(    examples=examples,    example_prompt=example_prompt,    suffix=\"Question: {input}\",    input_variables=[\"input\"],)print(    prompt.invoke({\"input\": \"Who was the father of Mary Ball Washington?\"}).to_string())\n```\n\n```\nQuestion: Who lived longer, Muhammad Ali or Alan Turing?Are follow up questions needed here: Yes.Follow up: How old was Muhammad Ali when he died?Intermediate answer: Muhammad Ali was 74 years old when he died.Follow up: How old was Alan Turing when he died?Intermediate answer: Alan Turing was 41 years old when he died.So the final answer is: Muhammad AliQuestion: When was the founder of craigslist born?Are follow up questions needed here: Yes.Follow up: Who was the founder of craigslist?Intermediate answer: Craigslist was founded by Craig Newmark.Follow up: When was Craig Newmark born?Intermediate answer: Craig Newmark was born on December 6, 1952.So the final answer is: December 6, 1952Question: Who was the maternal grandfather of George Washington?Are follow up questions needed here: Yes.Follow up: Who was the mother of George Washington?Intermediate answer: The mother of George Washington was Mary Ball Washington.Follow up: Who was the father of Mary Ball Washington?Intermediate answer: The father of Mary Ball Washington was Joseph Ball.So the final answer is: Joseph BallQuestion: Are both the directors of Jaws and Casino Royale from the same country?Are follow up questions needed here: Yes.Follow up: Who is the director of Jaws?Intermediate Answer: The director of Jaws is Steven Spielberg.Follow up: Where is Steven Spielberg from?Intermediate Answer: The United States.Follow up: Who is the director of Casino Royale?Intermediate Answer: The director of Casino Royale is Martin Campbell.Follow up: Where is Martin Campbell from?Intermediate Answer: New Zealand.So the final answer is: NoQuestion: Who was the father of Mary Ball Washington?\n```\n\nBy providing the model with examples like this, we can guide the model to a better response.\n\n## Using an example selector[​](#using-an-example-selector \"Direct link to Using an example selector\")\n\nWe will reuse the example set and the formatter from the previous section. However, instead of feeding the examples directly into the `FewShotPromptTemplate` object, we will feed them into an implementation of `ExampleSelector` called [`SemanticSimilarityExampleSelector`](https://python.langchain.com/api_reference/core/example_selectors/langchain_core.example_selectors.semantic_similarity.SemanticSimilarityExampleSelector.html) instance. This class selects few-shot examples from the initial set based on their similarity to the input. It uses an embedding model to compute the similarity between the input and the few-shot examples, as well as a vector store to perform the nearest neighbor search.\n\nTo show what it looks like, let's initialize an instance and call it in isolation:\n\n```\nfrom langchain_chroma import Chromafrom langchain_core.example_selectors import SemanticSimilarityExampleSelectorfrom langchain_openai import OpenAIEmbeddingsexample_selector = SemanticSimilarityExampleSelector.from_examples(    # This is the list of examples available to select from.    examples,    # This is the embedding class used to produce embeddings which are used to measure semantic similarity.    OpenAIEmbeddings(),    # This is the VectorStore class that is used to store the embeddings and do a similarity search over.    Chroma,    # This is the number of examples to produce.    k=1,)# Select the most similar example to the input.question = \"Who was the father of Mary Ball Washington?\"selected_examples = example_selector.select_examples({\"question\": question})print(f\"Examples most similar to the input: {question}\")for example in selected_examples:    print(\"\\n\")    for k, v in example.items():        print(f\"{k}: {v}\")\n```\n\n```\nExamples most similar to the input: Who was the father of Mary Ball Washington?answer: Are follow up questions needed here: Yes.Follow up: Who was the mother of George Washington?Intermediate answer: The mother of George Washington was Mary Ball Washington.Follow up: Who was the father of Mary Ball Washington?Intermediate answer: The father of Mary Ball Washington was Joseph Ball.So the final answer is: Joseph Ballquestion: Who was the maternal grandfather of George Washington?\n```\n\nNow, let's create a `FewShotPromptTemplate` object. This object takes in the example selector and the formatter prompt for the few-shot examples.\n\n```\nprompt = FewShotPromptTemplate(    example_selector=example_selector,    example_prompt=example_prompt,    suffix=\"Question: {input}\",    input_variables=[\"input\"],)print(    prompt.invoke({\"input\": \"Who was the father of Mary Ball Washington?\"}).to_string())\n```\n\n```\nQuestion: Who was the maternal grandfather of George Washington?Are follow up questions needed here: Yes.Follow up: Who was the mother of George Washington?Intermediate answer: The mother of George Washington was Mary Ball Washington.Follow up: Who was the father of Mary Ball Washington?Intermediate answer: The father of Mary Ball Washington was Joseph Ball.So the final answer is: Joseph BallQuestion: Who was the father of Mary Ball Washington?\n```\n\n## Next steps[​](#next-steps \"Direct link to Next steps\")\n\nYou've now learned how to add few-shot examples to your prompts.\n\nNext, check out the other how-to guides on prompt templates in this section, the related how-to guide on [few shotting with chat models](https://python.langchain.com/docs/how_to/few_shot_examples_chat/), or the other [example selector how-to guides](https://python.langchain.com/docs/how_to/example_selectors/)."
},
{
  "url": "https://python.langchain.com/docs/how_to/functions/",
  "markdown": "# giscus\n\n## How to run custom functions\n\nYou can use arbitrary functions as [Runnables](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable). This is useful for formatting or when you need functionality not provided by other LangChain components, and custom functions used as Runnables are called [`RunnableLambdas`](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.RunnableLambda.html).\n\nNote that all inputs to these functions need to be a SINGLE argument. If you have a function that accepts multiple arguments, you should write a wrapper that accepts a single dict input and unpacks it into multiple arguments.\n\nThis guide will cover:\n\n*   How to explicitly create a runnable from a custom function using the `RunnableLambda` constructor and the convenience `@chain` decorator\n*   Coercion of custom functions into runnables when used in chains\n*   How to accept and use run metadata in your custom function\n*   How to stream with custom functions by having them return generators\n\n## Using the constructor[​](#using-the-constructor \"Direct link to Using the constructor\")\n\nBelow, we explicitly wrap our custom logic using the `RunnableLambda` constructor:\n\n```\n%pip install -qU langchain langchain_openaiimport osfrom getpass import getpassif \"OPENAI_API_KEY\" not in os.environ:    os.environ[\"OPENAI_API_KEY\"] = getpass()\n```\n\n```\nfrom operator import itemgetterfrom langchain_core.prompts import ChatPromptTemplatefrom langchain_core.runnables import RunnableLambdafrom langchain_openai import ChatOpenAIdef length_function(text):    return len(text)def _multiple_length_function(text1, text2):    return len(text1) * len(text2)def multiple_length_function(_dict):    return _multiple_length_function(_dict[\"text1\"], _dict[\"text2\"])model = ChatOpenAI()prompt = ChatPromptTemplate.from_template(\"what is {a} + {b}\")chain1 = prompt | modelchain = (    {        \"a\": itemgetter(\"foo\") | RunnableLambda(length_function),        \"b\": {\"text1\": itemgetter(\"foo\"), \"text2\": itemgetter(\"bar\")}        | RunnableLambda(multiple_length_function),    }    | prompt    | model)chain.invoke({\"foo\": \"bar\", \"bar\": \"gah\"})\n```\n\n```\nAIMessage(content='3 + 9 equals 12.', response_metadata={'token_usage': {'completion_tokens': 8, 'prompt_tokens': 14, 'total_tokens': 22}, 'model_name': 'gpt-3.5-turbo', 'system_fingerprint': 'fp_c2295e73ad', 'finish_reason': 'stop', 'logprobs': None}, id='run-73728de3-e483-49e3-ad54-51bd9570e71a-0')\n```\n\n## The convenience `@chain` decorator[​](#the-convenience-chain-decorator \"Direct link to the-convenience-chain-decorator\")\n\nYou can also turn an arbitrary function into a chain by adding a `@chain` decorator. This is functionally equivalent to wrapping the function in a `RunnableLambda` constructor as shown above. Here's an example:\n\n```\nfrom langchain_core.output_parsers import StrOutputParserfrom langchain_core.runnables import chainprompt1 = ChatPromptTemplate.from_template(\"Tell me a joke about {topic}\")prompt2 = ChatPromptTemplate.from_template(\"What is the subject of this joke: {joke}\")@chaindef custom_chain(text):    prompt_val1 = prompt1.invoke({\"topic\": text})    output1 = ChatOpenAI().invoke(prompt_val1)    parsed_output1 = StrOutputParser().invoke(output1)    chain2 = prompt2 | ChatOpenAI() | StrOutputParser()    return chain2.invoke({\"joke\": parsed_output1})custom_chain.invoke(\"bears\")\n```\n\n```\n'The subject of the joke is the bear and his girlfriend.'\n```\n\nAbove, the `@chain` decorator is used to convert `custom_chain` into a runnable, which we invoke with the `.invoke()` method.\n\nIf you are using a tracing with [LangSmith](https://docs.smith.langchain.com/), you should see a `custom_chain` trace in there, with the calls to OpenAI nested underneath.\n\n## Automatic coercion in chains[​](#automatic-coercion-in-chains \"Direct link to Automatic coercion in chains\")\n\nWhen using custom functions in chains with the pipe operator (`|`), you can omit the `RunnableLambda` or `@chain` constructor and rely on coercion. Here's a simple example with a function that takes the output from the model and returns the first five letters of it:\n\n```\nprompt = ChatPromptTemplate.from_template(\"tell me a story about {topic}\")model = ChatOpenAI()chain_with_coerced_function = prompt | model | (lambda x: x.content[:5])chain_with_coerced_function.invoke({\"topic\": \"bears\"})\n```\n\nNote that we didn't need to wrap the custom function `(lambda x: x.content[:5])` in a `RunnableLambda` constructor because the `model` on the left of the pipe operator is already a Runnable. The custom function is **coerced** into a runnable. See [this section](https://python.langchain.com/docs/how_to/sequence/#coercion) for more information.\n\nRunnable lambdas can optionally accept a [RunnableConfig](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.config.RunnableConfig.html#langchain_core.runnables.config.RunnableConfig) parameter, which they can use to pass callbacks, tags, and other configuration information to nested runs.\n\n```\nimport jsonfrom langchain_core.runnables import RunnableConfigdef parse_or_fix(text: str, config: RunnableConfig):    fixing_chain = (        ChatPromptTemplate.from_template(            \"Fix the following text:\\n\\n\\`\\`\\`text\\n{input}\\n\\`\\`\\`\\nError: {error}\"            \" Don't narrate, just respond with the fixed data.\"        )        | model        | StrOutputParser()    )    for _ in range(3):        try:            return json.loads(text)        except Exception as e:            text = fixing_chain.invoke({\"input\": text, \"error\": e}, config)    return \"Failed to parse\"from langchain_community.callbacks import get_openai_callbackwith get_openai_callback() as cb:    output = RunnableLambda(parse_or_fix).invoke(        \"{foo: bar}\", {\"tags\": [\"my-tag\"], \"callbacks\": [cb]}    )    print(output)    print(cb)\n```\n\n```\n{'foo': 'bar'}Tokens Used: 62\tPrompt Tokens: 56\tCompletion Tokens: 6Successful Requests: 1Total Cost (USD): $9.6e-05\n```\n\n```\nfrom langchain_community.callbacks import get_openai_callbackwith get_openai_callback() as cb:    output = RunnableLambda(parse_or_fix).invoke(        \"{foo: bar}\", {\"tags\": [\"my-tag\"], \"callbacks\": [cb]}    )    print(output)    print(cb)\n```\n\n```\n{'foo': 'bar'}Tokens Used: 62\tPrompt Tokens: 56\tCompletion Tokens: 6Successful Requests: 1Total Cost (USD): $9.6e-05\n```\n\n## Streaming[​](#streaming \"Direct link to Streaming\")\n\nnote\n\n[RunnableLambda](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.RunnableLambda.html) is best suited for code that does not need to support streaming. If you need to support streaming (i.e., be able to operate on chunks of inputs and yield chunks of outputs), use [RunnableGenerator](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.RunnableGenerator.html) instead as in the example below.\n\nYou can use generator functions (ie. functions that use the `yield` keyword, and behave like iterators) in a chain.\n\nThe signature of these generators should be `Iterator[Input] -> Iterator[Output]`. Or for async generators: `AsyncIterator[Input] -> AsyncIterator[Output]`.\n\nThese are useful for:\n\n*   implementing a custom output parser\n*   modifying the output of a previous step, while preserving streaming capabilities\n\nHere's an example of a custom output parser for comma-separated lists. First, we create a chain that generates such a list as text:\n\n```\nfrom typing import Iterator, Listprompt = ChatPromptTemplate.from_template(    \"Write a comma-separated list of 5 animals similar to: {animal}. Do not include numbers\")str_chain = prompt | model | StrOutputParser()for chunk in str_chain.stream({\"animal\": \"bear\"}):    print(chunk, end=\"\", flush=True)\n```\n\n```\nlion, tiger, wolf, gorilla, panda\n```\n\nNext, we define a custom function that will aggregate the currently streamed output and yield it when the model generates the next comma in the list:\n\n```\n# This is a custom parser that splits an iterator of llm tokens# into a list of strings separated by commasdef split_into_list(input: Iterator[str]) -> Iterator[List[str]]:    # hold partial input until we get a comma    buffer = \"\"    for chunk in input:        # add current chunk to buffer        buffer += chunk        # while there are commas in the buffer        while \",\" in buffer:            # split buffer on comma            comma_index = buffer.index(\",\")            # yield everything before the comma            yield [buffer[:comma_index].strip()]            # save the rest for the next iteration            buffer = buffer[comma_index + 1 :]    # yield the last chunk    yield [buffer.strip()]list_chain = str_chain | split_into_listfor chunk in list_chain.stream({\"animal\": \"bear\"}):    print(chunk, flush=True)\n```\n\n```\n['lion']['tiger']['wolf']['gorilla']['raccoon']\n```\n\nInvoking it gives a full array of values:\n\n```\nlist_chain.invoke({\"animal\": \"bear\"})\n```\n\n```\n['lion', 'tiger', 'wolf', 'gorilla', 'raccoon']\n```\n\n## Async version[​](#async-version \"Direct link to Async version\")\n\nIf you are working in an `async` environment, here is an `async` version of the above example:\n\n```\nfrom typing import AsyncIteratorasync def asplit_into_list(    input: AsyncIterator[str],) -> AsyncIterator[List[str]]:  # async def    buffer = \"\"    async for (        chunk    ) in input:  # `input` is a `async_generator` object, so use `async for`        buffer += chunk        while \",\" in buffer:            comma_index = buffer.index(\",\")            yield [buffer[:comma_index].strip()]            buffer = buffer[comma_index + 1 :]    yield [buffer.strip()]list_chain = str_chain | asplit_into_listasync for chunk in list_chain.astream({\"animal\": \"bear\"}):    print(chunk, flush=True)\n```\n\n```\n['lion']['tiger']['wolf']['gorilla']['panda']\n```\n\n```\nawait list_chain.ainvoke({\"animal\": \"bear\"})\n```\n\n```\n['lion', 'tiger', 'wolf', 'gorilla', 'panda']\n```\n\n## Next steps[​](#next-steps \"Direct link to Next steps\")\n\nNow you've learned a few different ways to use custom logic within your chains, and how to implement streaming.\n\nTo learn more, see the other how-to guides on runnables in this section."
},
{
  "url": "https://python.langchain.com/docs/how_to/split_html/",
  "markdown": "# giscus\n\n## How to split HTML\n\nSplitting HTML documents into manageable chunks is essential for various text processing tasks such as natural language processing, search indexing, and more. In this guide, we will explore three different text splitters provided by LangChain that you can use to split HTML content effectively:\n\n*   [**HTMLHeaderTextSplitter**](#using-htmlheadertextsplitter)\n*   [**HTMLSectionSplitter**](#using-htmlsectionsplitter)\n*   [**HTMLSemanticPreservingSplitter**](#using-htmlsemanticpreservingsplitter)\n\nEach of these splitters has unique features and use cases. This guide will help you understand the differences between them, why you might choose one over the others, and how to use them effectively.\n\n```\n%pip install -qU langchain-text-splitters\n```\n\n## Overview of the Splitters[​](#overview-of-the-splitters \"Direct link to Overview of the Splitters\")\n\ninfo\n\nUseful when you want to preserve the hierarchical structure of a document based on its headings.\n\n**Description**: Splits HTML text based on header tags (e.g., `<h1>`, `<h2>`, `<h3>`, etc.), and adds metadata for each header relevant to any given chunk.\n\n**Capabilities**:\n\n*   Splits text at the HTML element level.\n*   Preserves context-rich information encoded in document structures.\n*   Can return chunks element by element or combine elements with the same metadata.\n\n* * *\n\n### [HTMLSectionSplitter](#using-htmlsectionsplitter)[​](#htmlsectionsplitter \"Direct link to htmlsectionsplitter\")\n\ninfo\n\nUseful when you want to split HTML documents into larger sections, such as `<section>`, `<div>`, or custom-defined sections.\n\n**Description**: Similar to HTMLHeaderTextSplitter but focuses on splitting HTML into sections based on specified tags.\n\n**Capabilities**:\n\n*   Uses XSLT transformations to detect and split sections.\n*   Internally uses `RecursiveCharacterTextSplitter` for large sections.\n*   Considers font sizes to determine sections.\n\n* * *\n\n### [HTMLSemanticPreservingSplitter](#using-htmlsemanticpreservingsplitter)[​](#htmlsemanticpreservingsplitter \"Direct link to htmlsemanticpreservingsplitter\")\n\ninfo\n\nIdeal when you need to ensure that structured elements are not split across chunks, preserving contextual relevancy.\n\n**Description**: Splits HTML content into manageable chunks while preserving the semantic structure of important elements like tables, lists, and other HTML components.\n\n**Capabilities**:\n\n*   Preserves tables, lists, and other specified HTML elements.\n*   Allows custom handlers for specific HTML tags.\n*   Ensures that the semantic meaning of the document is maintained.\n*   Built in normalization & stopword removal\n\n* * *\n\n### Choosing the Right Splitter[​](#choosing-the-right-splitter \"Direct link to Choosing the Right Splitter\")\n\n*   **Use `HTMLHeaderTextSplitter` when**: You need to split an HTML document based on its header hierarchy and maintain metadata about the headers.\n*   **Use `HTMLSectionSplitter` when**: You need to split the document into larger, more general sections, possibly based on custom tags or font sizes.\n*   **Use `HTMLSemanticPreservingSplitter` when**: You need to split the document into chunks while preserving semantic elements like tables and lists, ensuring that they are not split and that their context is maintained.\n\n| Feature | HTMLHeaderTextSplitter | HTMLSectionSplitter | HTMLSemanticPreservingSplitter |\n| --- | --- | --- | --- |\n| Splits based on headers | Yes | Yes | Yes |\n| Preserves semantic elements (tables, lists) | No  | No  | Yes |\n| Adds metadata for headers | Yes | Yes | Yes |\n| Custom handlers for HTML tags | No  | No  | Yes |\n| Preserves media (images, videos) | No  | No  | Yes |\n| Considers font sizes | No  | Yes | No  |\n| Uses XSLT transformations | No  | Yes | No  |\n\n## Example HTML Document[​](#example-html-document \"Direct link to Example HTML Document\")\n\nLet's use the following HTML document as an example:\n\n```\nhtml_string = \"\"\"<!DOCTYPE html>  <html lang='en'>  <head>    <meta charset='UTF-8'>    <meta name='viewport' content='width=device-width, initial-scale=1.0'>    <title>Fancy Example HTML Page</title>  </head>  <body>    <h1>Main Title</h1>    <p>This is an introductory paragraph with some basic content.</p>        <h2>Section 1: Introduction</h2>    <p>This section introduces the topic. Below is a list:</p>    <ul>      <li>First item</li>      <li>Second item</li>      <li>Third item with <strong>bold text</strong> and <a href='#'>a link</a></li>    </ul>        <h3>Subsection 1.1: Details</h3>    <p>This subsection provides additional details. Here's a table:</p>    <table border='1'>      <thead>        <tr>          <th>Header 1</th>          <th>Header 2</th>          <th>Header 3</th>        </tr>      </thead>      <tbody>        <tr>          <td>Row 1, Cell 1</td>          <td>Row 1, Cell 2</td>          <td>Row 1, Cell 3</td>        </tr>        <tr>          <td>Row 2, Cell 1</td>          <td>Row 2, Cell 2</td>          <td>Row 2, Cell 3</td>        </tr>      </tbody>    </table>        <h2>Section 2: Media Content</h2>    <p>This section contains an image and a video:</p>      <img src='example_image_link.mp4' alt='Example Image'>      <video controls width='250' src='example_video_link.mp4' type='video/mp4'>      Your browser does not support the video tag.    </video>    <h2>Section 3: Code Example</h2>    <p>This section contains a code block:</p>    <pre><code data-lang=\"html\">    &lt;div&gt;      &lt;p&gt;This is a paragraph inside a div.&lt;/p&gt;    &lt;/div&gt;    </code></pre>    <h2>Conclusion</h2>    <p>This is the conclusion of the document.</p>  </body>  </html>\"\"\"\n```\n\n[HTMLHeaderTextSplitter](https://python.langchain.com/api_reference/text_splitters/html/langchain_text_splitters.html.HTMLHeaderTextSplitter.html) is a \"structure-aware\" [text splitter](https://python.langchain.com/docs/concepts/text_splitters/) that splits text at the HTML element level and adds metadata for each header \"relevant\" to any given chunk. It can return chunks element by element or combine elements with the same metadata, with the objectives of (a) keeping related text grouped (more or less) semantically and (b) preserving context-rich information encoded in document structures. It can be used with other text splitters as part of a chunking pipeline.\n\nIt is analogous to the [MarkdownHeaderTextSplitter](https://python.langchain.com/docs/how_to/markdown_header_metadata_splitter/) for markdown files.\n\nTo specify what headers to split on, specify `headers_to_split_on` when instantiating `HTMLHeaderTextSplitter` as shown below.\n\n```\nfrom langchain_text_splitters import HTMLHeaderTextSplitterheaders_to_split_on = [    (\"h1\", \"Header 1\"),    (\"h2\", \"Header 2\"),    (\"h3\", \"Header 3\"),]html_splitter = HTMLHeaderTextSplitter(headers_to_split_on)html_header_splits = html_splitter.split_text(html_string)html_header_splits\n```\n\n```\n[Document(metadata={'Header 1': 'Main Title'}, page_content='This is an introductory paragraph with some basic content.'), Document(metadata={'Header 1': 'Main Title', 'Header 2': 'Section 1: Introduction'}, page_content='This section introduces the topic. Below is a list:  \\nFirst item Second item Third item with bold text and a link'), Document(metadata={'Header 1': 'Main Title', 'Header 2': 'Section 1: Introduction', 'Header 3': 'Subsection 1.1: Details'}, page_content=\"This subsection provides additional details. Here's a table:\"), Document(metadata={'Header 1': 'Main Title', 'Header 2': 'Section 2: Media Content'}, page_content='This section contains an image and a video:'), Document(metadata={'Header 1': 'Main Title', 'Header 2': 'Section 3: Code Example'}, page_content='This section contains a code block:'), Document(metadata={'Header 1': 'Main Title', 'Header 2': 'Conclusion'}, page_content='This is the conclusion of the document.')]\n```\n\nTo return each element together with their associated headers, specify `return_each_element=True` when instantiating `HTMLHeaderTextSplitter`:\n\n```\nhtml_splitter = HTMLHeaderTextSplitter(    headers_to_split_on,    return_each_element=True,)html_header_splits_elements = html_splitter.split_text(html_string)\n```\n\nComparing with the above, where elements are aggregated by their headers:\n\n```\nfor element in html_header_splits[:2]:    print(element)\n```\n\n```\npage_content='This is an introductory paragraph with some basic content.' metadata={'Header 1': 'Main Title'}page_content='This section introduces the topic. Below is a list:  First item Second item Third item with bold text and a link' metadata={'Header 1': 'Main Title', 'Header 2': 'Section 1: Introduction'}\n```\n\nNow each element is returned as a distinct `Document`:\n\n```\nfor element in html_header_splits_elements[:3]:    print(element)\n```\n\n```\npage_content='This is an introductory paragraph with some basic content.' metadata={'Header 1': 'Main Title'}page_content='This section introduces the topic. Below is a list:' metadata={'Header 1': 'Main Title', 'Header 2': 'Section 1: Introduction'}page_content='First item Second item Third item with bold text and a link' metadata={'Header 1': 'Main Title', 'Header 2': 'Section 1: Introduction'}\n```\n\n### How to split from a URL or HTML file:[​](#how-to-split-from-a-url-or-html-file \"Direct link to How to split from a URL or HTML file:\")\n\nTo read directly from a URL, pass the URL string into the `split_text_from_url` method.\n\nSimilarly, a local HTML file can be passed to the `split_text_from_file` method.\n\n```\nurl = \"https://plato.stanford.edu/entries/goedel/\"headers_to_split_on = [    (\"h1\", \"Header 1\"),    (\"h2\", \"Header 2\"),    (\"h3\", \"Header 3\"),    (\"h4\", \"Header 4\"),]html_splitter = HTMLHeaderTextSplitter(headers_to_split_on)# for local file use html_splitter.split_text_from_file(<path_to_file>)html_header_splits = html_splitter.split_text_from_url(url)\n```\n\n### How to constrain chunk sizes:[​](#how-to-constrain-chunk-sizes \"Direct link to How to constrain chunk sizes:\")\n\n`HTMLHeaderTextSplitter`, which splits based on HTML headers, can be composed with another splitter which constrains splits based on character lengths, such as `RecursiveCharacterTextSplitter`.\n\nThis can be done using the `.split_documents` method of the second splitter:\n\n```\nfrom langchain_text_splitters import RecursiveCharacterTextSplitterchunk_size = 500chunk_overlap = 30text_splitter = RecursiveCharacterTextSplitter(    chunk_size=chunk_size, chunk_overlap=chunk_overlap)# Splitsplits = text_splitter.split_documents(html_header_splits)splits[80:85]\n```\n\n```\n[Document(metadata={'Header 1': 'Kurt Gödel', 'Header 2': '2. Gödel’s Mathematical Work', 'Header 3': '2.2 The Incompleteness Theorems', 'Header 4': '2.2.1 The First Incompleteness Theorem'}, page_content='We see that Gödel first tried to reduce the consistency problem for analysis to that of arithmetic. This seemed to require a truth definition for arithmetic, which in turn led to paradoxes, such as the Liar paradox (“This sentence is false”) and Berry’s paradox (“The least number not defined by an expression consisting of just fourteen English words”). Gödel then noticed that such paradoxes would not necessarily arise if truth were replaced by provability. But this means that arithmetic truth'), Document(metadata={'Header 1': 'Kurt Gödel', 'Header 2': '2. Gödel’s Mathematical Work', 'Header 3': '2.2 The Incompleteness Theorems', 'Header 4': '2.2.1 The First Incompleteness Theorem'}, page_content='means that arithmetic truth and arithmetic provability are not co-extensive — whence the First Incompleteness Theorem.'), Document(metadata={'Header 1': 'Kurt Gödel', 'Header 2': '2. Gödel’s Mathematical Work', 'Header 3': '2.2 The Incompleteness Theorems', 'Header 4': '2.2.1 The First Incompleteness Theorem'}, page_content='This account of Gödel’s discovery was told to Hao Wang very much after the fact; but in Gödel’s contemporary correspondence with Bernays and Zermelo, essentially the same description of his path to the theorems is given. (See Gödel 2003a and Gödel 2003b respectively.) From those accounts we see that the undefinability of truth in arithmetic, a result credited to Tarski, was likely obtained in some form by Gödel by 1931. But he neither publicized nor published the result; the biases logicians'), Document(metadata={'Header 1': 'Kurt Gödel', 'Header 2': '2. Gödel’s Mathematical Work', 'Header 3': '2.2 The Incompleteness Theorems', 'Header 4': '2.2.1 The First Incompleteness Theorem'}, page_content='result; the biases logicians had expressed at the time concerning the notion of truth, biases which came vehemently to the fore when Tarski announced his results on the undefinability of truth in formal systems 1935, may have served as a deterrent to Gödel’s publication of that theorem.'), Document(metadata={'Header 1': 'Kurt Gödel', 'Header 2': '2. Gödel’s Mathematical Work', 'Header 3': '2.2 The Incompleteness Theorems', 'Header 4': '2.2.2 The proof of the First Incompleteness Theorem'}, page_content='We now describe the proof of the two theorems, formulating Gödel’s results in Peano arithmetic. Gödel himself used a system related to that defined in Principia Mathematica, but containing Peano arithmetic. In our presentation of the First and Second Incompleteness Theorems we refer to Peano arithmetic as P, following Gödel’s notation.')]\n```\n\n### Limitations[​](#limitations \"Direct link to Limitations\")\n\nThere can be quite a bit of structural variation from one HTML document to another, and while `HTMLHeaderTextSplitter` will attempt to attach all \"relevant\" headers to any given chunk, it can sometimes miss certain headers. For example, the algorithm assumes an informational hierarchy in which headers are always at nodes \"above\" associated text, i.e. prior siblings, ancestors, and combinations thereof. In the following news article (as of the writing of this document), the document is structured such that the text of the top-level headline, while tagged \"h1\", is in a _distinct_ subtree from the text elements that we'd expect it to be _\"above\"_—so we can observe that the \"h1\" element and its associated text do not show up in the chunk metadata (but, where applicable, we do see \"h2\" and its associated text):\n\n```\nurl = \"https://www.cnn.com/2023/09/25/weather/el-nino-winter-us-climate/index.html\"headers_to_split_on = [    (\"h1\", \"Header 1\"),    (\"h2\", \"Header 2\"),]html_splitter = HTMLHeaderTextSplitter(headers_to_split_on)html_header_splits = html_splitter.split_text_from_url(url)print(html_header_splits[1].page_content[:500])\n```\n\n```\nNo two El Niño winters are the same, but many have temperature and precipitation trends in common.  Average conditions during an El Niño winter across the continental US.  One of the major reasons is the position of the jet stream, which often shifts south during an El Niño winter. This shift typically brings wetter and cooler weather to the South while the North becomes drier and warmer, according to NOAA.  Because the jet stream is essentially a river of air that storms flow through, they c\n```\n\n## Using HTMLSectionSplitter[​](#using-htmlsectionsplitter \"Direct link to Using HTMLSectionSplitter\")\n\nSimilar in concept to the [HTMLHeaderTextSplitter](#using-htmlheadertextsplitter), the `HTMLSectionSplitter` is a \"structure-aware\" [text splitter](https://python.langchain.com/docs/concepts/text_splitters/) that splits text at the element level and adds metadata for each header \"relevant\" to any given chunk. It lets you split HTML by sections.\n\nIt can return chunks element by element or combine elements with the same metadata, with the objectives of (a) keeping related text grouped (more or less) semantically and (b) preserving context-rich information encoded in document structures.\n\nUse `xslt_path` to provide an absolute path to transform the HTML so that it can detect sections based on provided tags. The default is to use the `converting_to_header.xslt` file in the `data_connection/document_transformers` directory. This is for converting the html to a format/layout that is easier to detect sections. For example, `span` based on their font size can be converted to header tags to be detected as a section.\n\n### How to split HTML strings:[​](#how-to-split-html-strings \"Direct link to How to split HTML strings:\")\n\n```\nfrom langchain_text_splitters import HTMLSectionSplitterheaders_to_split_on = [    (\"h1\", \"Header 1\"),    (\"h2\", \"Header 2\"),]html_splitter = HTMLSectionSplitter(headers_to_split_on)html_header_splits = html_splitter.split_text(html_string)html_header_splits\n```\n\n```\n[Document(metadata={'Header 1': 'Main Title'}, page_content='Main Title \\n This is an introductory paragraph with some basic content.'), Document(metadata={'Header 2': 'Section 1: Introduction'}, page_content=\"Section 1: Introduction \\n This section introduces the topic. Below is a list: \\n \\n First item \\n Second item \\n Third item with  bold text  and  a link \\n \\n \\n Subsection 1.1: Details \\n This subsection provides additional details. Here's a table: \\n \\n \\n \\n Header 1 \\n Header 2 \\n Header 3 \\n \\n \\n \\n \\n Row 1, Cell 1 \\n Row 1, Cell 2 \\n Row 1, Cell 3 \\n \\n \\n Row 2, Cell 1 \\n Row 2, Cell 2 \\n Row 2, Cell 3\"), Document(metadata={'Header 2': 'Section 2: Media Content'}, page_content='Section 2: Media Content \\n This section contains an image and a video: \\n \\n \\n      Your browser does not support the video tag.'), Document(metadata={'Header 2': 'Section 3: Code Example'}, page_content='Section 3: Code Example \\n This section contains a code block: \\n \\n    <div>\\n      <p>This is a paragraph inside a div.</p>\\n    </div>'), Document(metadata={'Header 2': 'Conclusion'}, page_content='Conclusion \\n This is the conclusion of the document.')]\n```\n\n### How to constrain chunk sizes:[​](#how-to-constrain-chunk-sizes-1 \"Direct link to How to constrain chunk sizes:\")\n\n`HTMLSectionSplitter` can be used with other text splitters as part of a chunking pipeline. Internally, it uses the `RecursiveCharacterTextSplitter` when the section size is larger than the chunk size. It also considers the font size of the text to determine whether it is a section or not based on the determined font size threshold.\n\n```\nfrom langchain_text_splitters import RecursiveCharacterTextSplitterheaders_to_split_on = [    (\"h1\", \"Header 1\"),    (\"h2\", \"Header 2\"),    (\"h3\", \"Header 3\"),]html_splitter = HTMLSectionSplitter(headers_to_split_on)html_header_splits = html_splitter.split_text(html_string)chunk_size = 50chunk_overlap = 5text_splitter = RecursiveCharacterTextSplitter(    chunk_size=chunk_size, chunk_overlap=chunk_overlap)# Splitsplits = text_splitter.split_documents(html_header_splits)splits\n```\n\n```\n[Document(metadata={'Header 1': 'Main Title'}, page_content='Main Title'), Document(metadata={'Header 1': 'Main Title'}, page_content='This is an introductory paragraph with some'), Document(metadata={'Header 1': 'Main Title'}, page_content='some basic content.'), Document(metadata={'Header 2': 'Section 1: Introduction'}, page_content='Section 1: Introduction'), Document(metadata={'Header 2': 'Section 1: Introduction'}, page_content='This section introduces the topic. Below is a'), Document(metadata={'Header 2': 'Section 1: Introduction'}, page_content='is a list:'), Document(metadata={'Header 2': 'Section 1: Introduction'}, page_content='First item \\n Second item'), Document(metadata={'Header 2': 'Section 1: Introduction'}, page_content='Third item with  bold text  and  a link'), Document(metadata={'Header 3': 'Subsection 1.1: Details'}, page_content='Subsection 1.1: Details'), Document(metadata={'Header 3': 'Subsection 1.1: Details'}, page_content='This subsection provides additional details.'), Document(metadata={'Header 3': 'Subsection 1.1: Details'}, page_content=\"Here's a table:\"), Document(metadata={'Header 3': 'Subsection 1.1: Details'}, page_content='Header 1 \\n Header 2 \\n Header 3'), Document(metadata={'Header 3': 'Subsection 1.1: Details'}, page_content='Row 1, Cell 1 \\n Row 1, Cell 2'), Document(metadata={'Header 3': 'Subsection 1.1: Details'}, page_content='Row 1, Cell 3 \\n \\n \\n Row 2, Cell 1'), Document(metadata={'Header 3': 'Subsection 1.1: Details'}, page_content='Row 2, Cell 2 \\n Row 2, Cell 3'), Document(metadata={'Header 2': 'Section 2: Media Content'}, page_content='Section 2: Media Content'), Document(metadata={'Header 2': 'Section 2: Media Content'}, page_content='This section contains an image and a video:'), Document(metadata={'Header 2': 'Section 2: Media Content'}, page_content='Your browser does not support the video'), Document(metadata={'Header 2': 'Section 2: Media Content'}, page_content='tag.'), Document(metadata={'Header 2': 'Section 3: Code Example'}, page_content='Section 3: Code Example'), Document(metadata={'Header 2': 'Section 3: Code Example'}, page_content='This section contains a code block: \\n \\n    <div>'), Document(metadata={'Header 2': 'Section 3: Code Example'}, page_content='<p>This is a paragraph inside a div.</p>'), Document(metadata={'Header 2': 'Section 3: Code Example'}, page_content='</div>'), Document(metadata={'Header 2': 'Conclusion'}, page_content='Conclusion'), Document(metadata={'Header 2': 'Conclusion'}, page_content='This is the conclusion of the document.')]\n```\n\n## Using HTMLSemanticPreservingSplitter[​](#using-htmlsemanticpreservingsplitter \"Direct link to Using HTMLSemanticPreservingSplitter\")\n\nThe `HTMLSemanticPreservingSplitter` is designed to split HTML content into manageable chunks while preserving the semantic structure of important elements like tables, lists, and other HTML components. This ensures that such elements are not split across chunks, causing loss of contextual relevancy such as table headers, list headers etc.\n\nThis splitter is designed at its heart, to create contextually relevant chunks. General Recursive splitting with `HTMLHeaderTextSplitter` can cause tables, lists and other structered elements to be split in the middle, losing signifcant context and creating bad chunks.\n\nThe `HTMLSemanticPreservingSplitter` is essential for splitting HTML content that includes structured elements like tables and lists, especially when it's critical to preserve these elements intact. Additionally, its ability to define custom handlers for specific HTML tags makes it a versatile tool for processing complex HTML documents.\n\n**IMPORTANT**: `max_chunk_size` is not a definite maximum size of a chunk, the calculation of max size, occurs when the preserved content is not apart of the chunk, to ensure it is not split. When we add the preserved data back in to the chunk, there is a chance the chunk size will exceed the `max_chunk_size`. This is crucial to ensure we maintain the structure of the original document\n\ninfo\n\nNotes:\n\n1.  We have defined a custom handler to re-format the contents of code blocks\n2.  We defined a deny list for specific html elements, to decompose them and their contents pre-processing\n3.  We have intentionally set a small chunk size to demonstrate the non-splitting of elements\n\n```\n# BeautifulSoup is required to use the custom handlersfrom bs4 import Tagfrom langchain_text_splitters import HTMLSemanticPreservingSplitterheaders_to_split_on = [    (\"h1\", \"Header 1\"),    (\"h2\", \"Header 2\"),]def code_handler(element: Tag) -> str:    data_lang = element.get(\"data-lang\")    code_format = f\"<code:{data_lang}>{element.get_text()}</code>\"    return code_formatsplitter = HTMLSemanticPreservingSplitter(    headers_to_split_on=headers_to_split_on,    separators=[\"\\n\\n\", \"\\n\", \". \", \"! \", \"? \"],    max_chunk_size=50,    preserve_images=True,    preserve_videos=True,    elements_to_preserve=[\"table\", \"ul\", \"ol\", \"code\"],    denylist_tags=[\"script\", \"style\", \"head\"],    custom_handlers={\"code\": code_handler},)documents = splitter.split_text(html_string)documents\n```\n\n```\n[Document(metadata={'Header 1': 'Main Title'}, page_content='This is an introductory paragraph with some basic content.'), Document(metadata={'Header 2': 'Section 1: Introduction'}, page_content='This section introduces the topic'), Document(metadata={'Header 2': 'Section 1: Introduction'}, page_content='. Below is a list: First item Second item Third item with bold text and a link Subsection 1.1: Details This subsection provides additional details'), Document(metadata={'Header 2': 'Section 1: Introduction'}, page_content=\". Here's a table: Header 1 Header 2 Header 3 Row 1, Cell 1 Row 1, Cell 2 Row 1, Cell 3 Row 2, Cell 1 Row 2, Cell 2 Row 2, Cell 3\"), Document(metadata={'Header 2': 'Section 2: Media Content'}, page_content='This section contains an image and a video: ![image:example_image_link.mp4](example_image_link.mp4) ![video:example_video_link.mp4](example_video_link.mp4)'), Document(metadata={'Header 2': 'Section 3: Code Example'}, page_content='This section contains a code block: <code:html> <div> <p>This is a paragraph inside a div.</p> </div> </code>'), Document(metadata={'Header 2': 'Conclusion'}, page_content='This is the conclusion of the document.')]\n```\n\n### Preserving Tables and Lists[​](#preserving-tables-and-lists \"Direct link to Preserving Tables and Lists\")\n\nIn this example, we will demonstrate how the `HTMLSemanticPreservingSplitter` can preserve a table and a large list within an HTML document. The chunk size will be set to 50 characters to illustrate how the splitter ensures that these elements are not split, even when they exceed the maximum defined chunk size.\n\n```\nfrom langchain_text_splitters import HTMLSemanticPreservingSplitterhtml_string = \"\"\"<!DOCTYPE html><html>    <body>        <div>            <h1>Section 1</h1>            <p>This section contains an important table and list that should not be split across chunks.</p>            <table>                <tr>                    <th>Item</th>                    <th>Quantity</th>                    <th>Price</th>                </tr>                <tr>                    <td>Apples</td>                    <td>10</td>                    <td>$1.00</td>                </tr>                <tr>                    <td>Oranges</td>                    <td>5</td>                    <td>$0.50</td>                </tr>                <tr>                    <td>Bananas</td>                    <td>50</td>                    <td>$1.50</td>                </tr>            </table>            <h2>Subsection 1.1</h2>            <p>Additional text in subsection 1.1 that is separated from the table and list.</p>            <p>Here is a detailed list:</p>            <ul>                <li>Item 1: Description of item 1, which is quite detailed and important.</li>                <li>Item 2: Description of item 2, which also contains significant information.</li>                <li>Item 3: Description of item 3, another item that we don't want to split across chunks.</li>            </ul>        </div>    </body></html>\"\"\"headers_to_split_on = [(\"h1\", \"Header 1\"), (\"h2\", \"Header 2\")]splitter = HTMLSemanticPreservingSplitter(    headers_to_split_on=headers_to_split_on,    max_chunk_size=50,    elements_to_preserve=[\"table\", \"ul\"],)documents = splitter.split_text(html_string)print(documents)\n```\n\n```\n[Document(metadata={'Header 1': 'Section 1'}, page_content='This section contains an important table and list'), Document(metadata={'Header 1': 'Section 1'}, page_content='that should not be split across chunks.'), Document(metadata={'Header 1': 'Section 1'}, page_content='Item Quantity Price Apples 10 $1.00 Oranges 5 $0.50 Bananas 50 $1.50'), Document(metadata={'Header 2': 'Subsection 1.1'}, page_content='Additional text in subsection 1.1 that is'), Document(metadata={'Header 2': 'Subsection 1.1'}, page_content='separated from the table and list. Here is a'), Document(metadata={'Header 2': 'Subsection 1.1'}, page_content=\"detailed list: Item 1: Description of item 1, which is quite detailed and important. Item 2: Description of item 2, which also contains significant information. Item 3: Description of item 3, another item that we don't want to split across chunks.\")]\n```\n\n#### Explanation[​](#explanation \"Direct link to Explanation\")\n\nIn this example, the `HTMLSemanticPreservingSplitter` ensures that the entire table and the unordered list (`<ul>`) are preserved within their respective chunks. Even though the chunk size is set to 50 characters, the splitter recognizes that these elements should not be split and keeps them intact.\n\nThis is particularly important when dealing with data tables or lists, where splitting the content could lead to loss of context or confusion. The resulting `Document` objects retain the full structure of these elements, ensuring that the contextual relevance of the information is maintained.\n\n### Using a Custom Handler[​](#using-a-custom-handler \"Direct link to Using a Custom Handler\")\n\nThe `HTMLSemanticPreservingSplitter` allows you to define custom handlers for specific HTML elements. Some platforms, have custom HTML tags that are not natively parsed by `BeautifulSoup`, when this occurs, you can utilize custom handlers to add the formatting logic easily.\n\nThis can be particularly useful for elements that require special processing, such as `<iframe>` tags or specific 'data-' elements. In this example, we'll create a custom handler for `iframe` tags that converts them into Markdown-like links.\n\n```\ndef custom_iframe_extractor(iframe_tag):    iframe_src = iframe_tag.get(\"src\", \"\")    return f\"[iframe:{iframe_src}]({iframe_src})\"splitter = HTMLSemanticPreservingSplitter(    headers_to_split_on=headers_to_split_on,    max_chunk_size=50,    separators=[\"\\n\\n\", \"\\n\", \". \"],    elements_to_preserve=[\"table\", \"ul\", \"ol\"],    custom_handlers={\"iframe\": custom_iframe_extractor},)html_string = \"\"\"<!DOCTYPE html><html>    <body>        <div>            <h1>Section with Iframe</h1>            <iframe src=\"https://example.com/embed\"></iframe>            <p>Some text after the iframe.</p>            <ul>                <li>Item 1: Description of item 1, which is quite detailed and important.</li>                <li>Item 2: Description of item 2, which also contains significant information.</li>                <li>Item 3: Description of item 3, another item that we don't want to split across chunks.</li>            </ul>        </div>    </body></html>\"\"\"documents = splitter.split_text(html_string)print(documents)\n```\n\n```\n[Document(metadata={'Header 1': 'Section with Iframe'}, page_content='[iframe:https://example.com/embed](https://example.com/embed) Some text after the iframe'), Document(metadata={'Header 1': 'Section with Iframe'}, page_content=\". Item 1: Description of item 1, which is quite detailed and important. Item 2: Description of item 2, which also contains significant information. Item 3: Description of item 3, another item that we don't want to split across chunks.\")]\n```\n\n#### Explanation[​](#explanation-1 \"Direct link to Explanation\")\n\nIn this example, we defined a custom handler for `iframe` tags that converts them into Markdown-like links. When the splitter processes the HTML content, it uses this custom handler to transform the `iframe` tags while preserving other elements like tables and lists. The resulting `Document` objects show how the iframe is handled according to the custom logic you provided.\n\n**Important**: When presvering items such as links, you should be mindful not to include `.` in your seperators, or leave seperators blank. `RecursiveCharacterTextSplitter` splits on full stop, which will cut links in half. Ensure you provide a seperator list with `.` instead.\n\n### Using a custom handler to analyze an image with an LLM[​](#using-a-custom-handler-to-analyze-an-image-with-an-llm \"Direct link to Using a custom handler to analyze an image with an LLM\")\n\nWith custom handler's, we can also override the default processing for any element. A great example of this, is inserting semantic analysis of an image within a document, directly in the chunking flow.\n\nSince our function is called when the tag is discovered, we can override the `<img>` tag and turn off `preserve_images` to insert any content we would like to embed in our chunks.\n\n```\n\"\"\"This example assumes you have helper methods `load_image_from_url` and an LLM agent `llm` that can process image data.\"\"\"from langchain.agents import AgentExecutor# This example needs to be replaced with your own agentllm = AgentExecutor(...)# This method is a placeholder for loading image data from a URL and is not implemented heredef load_image_from_url(image_url: str) -> bytes:    # Assuming this method fetches the image data from the URL    return b\"image_data\"html_string = \"\"\"<!DOCTYPE html><html>    <body>        <div>            <h1>Section with Image and Link</h1>            <p>                <img src=\"https://example.com/image.jpg\" alt=\"An example image\" />                Some text after the image.            </p>            <ul>                <li>Item 1: Description of item 1, which is quite detailed and important.</li>                <li>Item 2: Description of item 2, which also contains significant information.</li>                <li>Item 3: Description of item 3, another item that we don't want to split across chunks.</li>            </ul>        </div>    </body></html>\"\"\"def custom_image_handler(img_tag) -> str:    img_src = img_tag.get(\"src\", \"\")    img_alt = img_tag.get(\"alt\", \"No alt text provided\")    image_data = load_image_from_url(img_src)    semantic_meaning = llm.invoke(image_data)    markdown_text = f\"[Image Alt Text: {img_alt} | Image Source: {img_src} | Image Semantic Meaning: {semantic_meaning}]\"    return markdown_textsplitter = HTMLSemanticPreservingSplitter(    headers_to_split_on=headers_to_split_on,    max_chunk_size=50,    separators=[\"\\n\\n\", \"\\n\", \". \"],    elements_to_preserve=[\"ul\"],    preserve_images=False,    custom_handlers={\"img\": custom_image_handler},)documents = splitter.split_text(html_string)print(documents)\n```\n\n```\n[Document(metadata={'Header 1': 'Section with Image and Link'}, page_content='[Image Alt Text: An example image | Image Source: https://example.com/image.jpg | Image Semantic Meaning: semantic-meaning] Some text after the image'), Document(metadata={'Header 1': 'Section with Image and Link'}, page_content=\". Item 1: Description of item 1, which is quite detailed and important. Item 2: Description of item 2, which also contains significant information. Item 3: Description of item 3, another item that we don't want to split across chunks.\")]\n```\n\n#### Explanation:[​](#explanation-2 \"Direct link to Explanation:\")\n\nWith our custom handler written to extract the specific fields from a `<img>` element in HTML, we can further process the data with our agent, and insert the result directly into our chunk. It is important to ensure `preserve_images` is set to `False` otherwise the default processing of `<img>` fields will take place."
},
{
  "url": "https://python.langchain.com/docs/how_to/ensemble_retriever/",
  "markdown": "# giscus\n\n## How to combine results from multiple retrievers\n\nThe [EnsembleRetriever](https://python.langchain.com/api_reference/langchain/retrievers/langchain.retrievers.ensemble.EnsembleRetriever.html) supports ensembling of results from multiple [retrievers](https://python.langchain.com/docs/concepts/retrievers/). It is initialized with a list of [BaseRetriever](https://python.langchain.com/api_reference/core/retrievers/langchain_core.retrievers.BaseRetriever.html) objects. EnsembleRetrievers rerank the results of the constituent retrievers based on the [Reciprocal Rank Fusion](https://plg.uwaterloo.ca/~gvcormac/cormacksigir09-rrf.pdf) algorithm.\n\nBy leveraging the strengths of different algorithms, the `EnsembleRetriever` can achieve better performance than any single algorithm.\n\nThe most common pattern is to combine a sparse retriever (like BM25) with a dense retriever (like embedding similarity), because their strengths are complementary. It is also known as \"hybrid search\". The sparse retriever is good at finding relevant documents based on keywords, while the dense retriever is good at finding relevant documents based on semantic similarity.\n\n## Basic usage[​](#basic-usage \"Direct link to Basic usage\")\n\nBelow we demonstrate ensembling of a [BM25Retriever](https://python.langchain.com/api_reference/community/retrievers/langchain_community.retrievers.bm25.BM25Retriever.html) with a retriever derived from the [FAISS vector store](https://python.langchain.com/api_reference/community/vectorstores/langchain_community.vectorstores.faiss.FAISS.html).\n\n```\n%pip install --upgrade --quiet  rank_bm25 > /dev/null\n```\n\n```\nfrom langchain.retrievers import EnsembleRetrieverfrom langchain_community.retrievers import BM25Retrieverfrom langchain_community.vectorstores import FAISSfrom langchain_openai import OpenAIEmbeddingsdoc_list_1 = [    \"I like apples\",    \"I like oranges\",    \"Apples and oranges are fruits\",]# initialize the bm25 retriever and faiss retrieverbm25_retriever = BM25Retriever.from_texts(    doc_list_1, metadatas=[{\"source\": 1}] * len(doc_list_1))bm25_retriever.k = 2doc_list_2 = [    \"You like apples\",    \"You like oranges\",]embedding = OpenAIEmbeddings()faiss_vectorstore = FAISS.from_texts(    doc_list_2, embedding, metadatas=[{\"source\": 2}] * len(doc_list_2))faiss_retriever = faiss_vectorstore.as_retriever(search_kwargs={\"k\": 2})# initialize the ensemble retrieverensemble_retriever = EnsembleRetriever(    retrievers=[bm25_retriever, faiss_retriever], weights=[0.5, 0.5])\n```\n\n```\ndocs = ensemble_retriever.invoke(\"apples\")docs\n```\n\n```\n[Document(page_content='I like apples', metadata={'source': 1}), Document(page_content='You like apples', metadata={'source': 2}), Document(page_content='Apples and oranges are fruits', metadata={'source': 1}), Document(page_content='You like oranges', metadata={'source': 2})]\n```\n\n## Runtime Configuration[​](#runtime-configuration \"Direct link to Runtime Configuration\")\n\nWe can also configure the individual retrievers at runtime using [configurable fields](https://python.langchain.com/docs/how_to/configure/). Below we update the \"top-k\" parameter for the FAISS retriever specifically:\n\n```\nfrom langchain_core.runnables import ConfigurableFieldfaiss_retriever = faiss_vectorstore.as_retriever(    search_kwargs={\"k\": 2}).configurable_fields(    search_kwargs=ConfigurableField(        id=\"search_kwargs_faiss\",        name=\"Search Kwargs\",        description=\"The search kwargs to use\",    ))ensemble_retriever = EnsembleRetriever(    retrievers=[bm25_retriever, faiss_retriever], weights=[0.5, 0.5])\n```\n\n```\nconfig = {\"configurable\": {\"search_kwargs_faiss\": {\"k\": 1}}}docs = ensemble_retriever.invoke(\"apples\", config=config)docs\n```\n\n```\n[Document(page_content='I like apples', metadata={'source': 1}), Document(page_content='You like apples', metadata={'source': 2}), Document(page_content='Apples and oranges are fruits', metadata={'source': 1})]\n```\n\nNotice that this only returns one source from the FAISS retriever, because we pass in the relevant configuration at run time"
},
{
  "url": "https://python.langchain.com/docs/how_to/long_context_reorder/",
  "markdown": "# giscus\n\n## How to reorder retrieved results to mitigate the \"lost in the middle\" effect\n\nSubstantial performance degradations in [RAG](https://python.langchain.com/docs/tutorials/rag/) applications have been [documented](https://arxiv.org/abs/2307.03172) as the number of retrieved documents grows (e.g., beyond ten). In brief: models are liable to miss relevant information in the middle of long contexts.\n\nBy contrast, queries against vector stores will typically return documents in descending order of relevance (e.g., as measured by cosine similarity of [embeddings](https://python.langchain.com/docs/concepts/embedding_models/)).\n\nTo mitigate the [\"lost in the middle\"](https://arxiv.org/abs/2307.03172) effect, you can re-order documents after retrieval such that the most relevant documents are positioned at extrema (e.g., the first and last pieces of context), and the least relevant documents are positioned in the middle. In some cases this can help surface the most relevant information to LLMs.\n\nThe [LongContextReorder](https://python.langchain.com/api_reference/community/document_transformers/langchain_community.document_transformers.long_context_reorder.LongContextReorder.html) document transformer implements this re-ordering procedure. Below we demonstrate an example.\n\n```\n%pip install -qU langchain langchain-community langchain-openai\n```\n\nFirst we embed some artificial documents and index them in a basic in-memory vector store. We will use [OpenAI](https://python.langchain.com/docs/integrations/providers/openai/) embeddings, but any LangChain vector store or embeddings model will suffice.\n\n```\nfrom langchain_core.vectorstores import InMemoryVectorStorefrom langchain_openai import OpenAIEmbeddings# Get embeddings.embeddings = OpenAIEmbeddings()texts = [    \"Basquetball is a great sport.\",    \"Fly me to the moon is one of my favourite songs.\",    \"The Celtics are my favourite team.\",    \"This is a document about the Boston Celtics\",    \"I simply love going to the movies\",    \"The Boston Celtics won the game by 20 points\",    \"This is just a random text.\",    \"Elden Ring is one of the best games in the last 15 years.\",    \"L. Kornet is one of the best Celtics players.\",    \"Larry Bird was an iconic NBA player.\",]# Create a retrieverretriever = InMemoryVectorStore.from_texts(texts, embedding=embeddings).as_retriever(    search_kwargs={\"k\": 10})query = \"What can you tell me about the Celtics?\"# Get relevant documents ordered by relevance scoredocs = retriever.invoke(query)for doc in docs:    print(f\"- {doc.page_content}\")\n```\n\n```\n- The Celtics are my favourite team.- This is a document about the Boston Celtics- The Boston Celtics won the game by 20 points- L. Kornet is one of the best Celtics players.- Basquetball is a great sport.- Larry Bird was an iconic NBA player.- This is just a random text.- I simply love going to the movies- Fly me to the moon is one of my favourite songs.- Elden Ring is one of the best games in the last 15 years.\n```\n\nNote that documents are returned in descending order of relevance to the query. The `LongContextReorder` document transformer will implement the re-ordering described above:\n\n```\nfrom langchain_community.document_transformers import LongContextReorder# Reorder the documents:# Less relevant document will be at the middle of the list and more# relevant elements at beginning / end.reordering = LongContextReorder()reordered_docs = reordering.transform_documents(docs)# Confirm that the 4 relevant documents are at beginning and end.for doc in reordered_docs:    print(f\"- {doc.page_content}\")\n```\n\n```\n- This is a document about the Boston Celtics- L. Kornet is one of the best Celtics players.- Larry Bird was an iconic NBA player.- I simply love going to the movies- Elden Ring is one of the best games in the last 15 years.- Fly me to the moon is one of my favourite songs.- This is just a random text.- Basquetball is a great sport.- The Boston Celtics won the game by 20 points- The Celtics are my favourite team.\n```\n\nBelow, we show how to incorporate the re-ordered documents into a simple question-answering chain:\n\n```\nfrom langchain.chains.combine_documents import create_stuff_documents_chainfrom langchain_core.prompts import PromptTemplatefrom langchain_openai import ChatOpenAIllm = ChatOpenAI(model=\"gpt-4o-mini\")prompt_template = \"\"\"Given these texts:-----{context}-----Please answer the following question:{query}\"\"\"prompt = PromptTemplate(    template=prompt_template,    input_variables=[\"context\", \"query\"],)# Create and invoke the chain:chain = create_stuff_documents_chain(llm, prompt)response = chain.invoke({\"context\": reordered_docs, \"query\": query})print(response)\n```\n\n```\nThe Boston Celtics are a professional basketball team known for their rich history and success in the NBA. L. Kornet is recognized as one of the best players on the team, and the Celtics recently won a game by 20 points. The Celtics are favored by some fans, as indicated by the statement, \"The Celtics are my favourite team.\" Overall, they have a strong following and are considered a significant part of basketball culture.\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/callbacks_constructor/",
  "markdown": "# giscus\n\nMost LangChain modules allow you to pass `callbacks` directly into the constructor (i.e., initializer). In this case, the callbacks will only be called for that instance (and any nested runs).\n\nwarning\n\nConstructor callbacks are scoped only to the object they are defined on. They are **not** inherited by children of the object. This can lead to confusing behavior, and it's generally better to pass callbacks as a run time argument.\n\n```\nfrom typing import Any, Dict, Listfrom langchain_anthropic import ChatAnthropicfrom langchain_core.callbacks import BaseCallbackHandlerfrom langchain_core.messages import BaseMessagefrom langchain_core.outputs import LLMResultfrom langchain_core.prompts import ChatPromptTemplateclass LoggingHandler(BaseCallbackHandler):    def on_chat_model_start(        self, serialized: Dict[str, Any], messages: List[List[BaseMessage]], **kwargs    ) -> None:        print(\"Chat model started\")    def on_llm_end(self, response: LLMResult, **kwargs) -> None:        print(f\"Chat model ended, response: {response}\")    def on_chain_start(        self, serialized: Dict[str, Any], inputs: Dict[str, Any], **kwargs    ) -> None:        print(f\"Chain {serialized.get('name')} started\")    def on_chain_end(self, outputs: Dict[str, Any], **kwargs) -> None:        print(f\"Chain ended, outputs: {outputs}\")callbacks = [LoggingHandler()]llm = ChatAnthropic(model=\"claude-3-sonnet-20240229\", callbacks=callbacks)prompt = ChatPromptTemplate.from_template(\"What is 1 + {number}?\")chain = prompt | llmchain.invoke({\"number\": \"2\"})\n```\n\n```\nChat model startedChat model ended, response: generations=[[ChatGeneration(text='1 + 2 = 3', message=AIMessage(content='1 + 2 = 3', response_metadata={'id': 'msg_01CdKsRmeS9WRb8BWnHDEHm7', 'model': 'claude-3-sonnet-20240229', 'stop_reason': 'end_turn', 'stop_sequence': None, 'usage': {'input_tokens': 16, 'output_tokens': 13}}, id='run-2d7fdf2a-7405-4e17-97c0-67e6b2a65305-0'))]] llm_output={'id': 'msg_01CdKsRmeS9WRb8BWnHDEHm7', 'model': 'claude-3-sonnet-20240229', 'stop_reason': 'end_turn', 'stop_sequence': None, 'usage': {'input_tokens': 16, 'output_tokens': 13}} run=None\n```\n\n```\nAIMessage(content='1 + 2 = 3', response_metadata={'id': 'msg_01CdKsRmeS9WRb8BWnHDEHm7', 'model': 'claude-3-sonnet-20240229', 'stop_reason': 'end_turn', 'stop_sequence': None, 'usage': {'input_tokens': 16, 'output_tokens': 13}}, id='run-2d7fdf2a-7405-4e17-97c0-67e6b2a65305-0')\n```\n\nYou can see that we only see events from the chat model run - no chain events from the prompt or broader chain.\n\nYou've now learned how to pass callbacks into a constructor."
},
{
  "url": "https://python.langchain.com/docs/how_to/example_selectors_langsmith/",
  "markdown": "# giscus\n\n## How to select examples from a LangSmith dataset\n\n📦Compatibility\n\nThe code in this guide requires `langsmith>=0.1.101`, `langchain-core>=0.2.34`. Please ensure you have the correct packages installed.\n\n[LangSmith](https://docs.smith.langchain.com/) datasets have built-in support for similarity search, making them a great tool for building and querying few-shot examples.\n\nIn this guide we'll see how to use an indexed LangSmith dataset as a few-shot example selector.\n\n## Setup[​](#setup \"Direct link to Setup\")\n\nBefore getting started make sure you've [created a LangSmith account](https://smith.langchain.com/) and set your credentials:\n\n```\nimport getpassimport osif not os.environ.get(\"LANGSMITH_API_KEY\"):    os.environ[\"LANGSMITH_API_KEY\"] = getpass.getpass(\"Set LangSmith API key:\\n\\n\")os.environ[\"LANGSMITH_TRACING\"] = \"true\"\n```\n\n```\nSet LangSmith API key:········\n```\n\nWe'll need to install the `langsmith` SDK. In this example we'll also make use of `langchain`, `langchain-openai`, and `langchain-benchmarks`:\n\n```\n%pip install -qU \"langsmith>=0.1.101\" \"langchain-core>=0.2.34\" langchain langchain-openai langchain-benchmarks\n```\n\nNow we'll clone a public dataset and turn on indexing for the dataset. We can also turn on indexing via the [LangSmith UI](https://docs.smith.langchain.com/how_to_guides/datasets/index_datasets_for_dynamic_few_shot_example_selection).\n\nWe'll clone the [Multiverse math few shot example dataset](https://blog.langchain.dev/few-shot-prompting-to-improve-tool-calling-performance/).\n\nThis enables searching over the dataset and will make sure that anytime we update/add examples they are also indexed.\n\n```\nfrom langsmith import Client as LangSmithls_client = LangSmith()dataset_name = \"multiverse-math-few-shot-examples-v2\"dataset_public_url = (    \"https://smith.langchain.com/public/620596ee-570b-4d2b-8c8f-f828adbe5242/d\")ls_client.clone_public_dataset(dataset_public_url)dataset_id = ls_client.read_dataset(dataset_name=dataset_name).idls_client.index_dataset(dataset_id=dataset_id)\n```\n\n## Querying dataset[​](#querying-dataset \"Direct link to Querying dataset\")\n\nIndexing can take a few seconds. Once the dataset is indexed, we can search for similar examples. Note that the input to the `similar_examples` method must have the same schema as the examples inputs. In this case our example inputs are a dictionary with a \"question\" key:\n\n```\nexamples = ls_client.similar_examples(    {\"question\": \"whats the negation of the negation of the negation of 3\"},    limit=3,    dataset_id=dataset_id,)len(examples)\n```\n\n```\nexamples[0].inputs[\"question\"]\n```\n\n```\n'evaluate the negation of -100'\n```\n\nFor this dataset, the outputs are the conversation that followed the question in OpenAI message format:\n\n```\nexamples[0].outputs[\"conversation\"]\n```\n\n```\n[{'role': 'assistant',  'content': None,  'tool_calls': [{'id': 'toolu_01HTpq4cYNUac6F7omUc2Wz3',    'type': 'function',    'function': {'name': 'negate', 'arguments': '{\"a\": -100}'}}]}, {'role': 'tool',  'content': '-100.0',  'tool_call_id': 'toolu_01HTpq4cYNUac6F7omUc2Wz3'}, {'role': 'assistant', 'content': 'So the answer is 100.'}, {'role': 'user',  'content': '100 is incorrect. Please refer to the output of your tool call.'}, {'role': 'assistant',  'content': [{'text': \"You're right, my previous answer was incorrect. Let me re-evaluate using the tool output:\",    'type': 'text'}],  'tool_calls': [{'id': 'toolu_01XsJQboYghGDygQpPjJkeRq',    'type': 'function',    'function': {'name': 'negate', 'arguments': '{\"a\": -100}'}}]}, {'role': 'tool',  'content': '-100.0',  'tool_call_id': 'toolu_01XsJQboYghGDygQpPjJkeRq'}, {'role': 'assistant', 'content': 'The answer is -100.0'}, {'role': 'user',  'content': 'You have the correct numerical answer but are returning additional text. Please only respond with the numerical answer.'}, {'role': 'assistant', 'content': '-100.0'}]\n```\n\n## Creating dynamic few-shot prompts[​](#creating-dynamic-few-shot-prompts \"Direct link to Creating dynamic few-shot prompts\")\n\nThe search returns the examples whose inputs are most similar to the query input. We can use this for few-shot prompting a model like so:\n\n```\nfrom langchain.chat_models import init_chat_modelfrom langchain_benchmarks.tool_usage.tasks.multiverse_math import (    add,    cos,    divide,    log,    multiply,    negate,    pi,    power,    sin,    subtract,)from langchain_core.runnables import RunnableLambdafrom langsmith import AsyncClient as AsyncLangSmithasync_ls_client = AsyncLangSmith()def similar_examples(input_: dict) -> dict:    examples = ls_client.similar_examples(input_, limit=5, dataset_id=dataset_id)    return {**input_, \"examples\": examples}async def asimilar_examples(input_: dict) -> dict:    examples = await async_ls_client.similar_examples(        input_, limit=5, dataset_id=dataset_id    )    return {**input_, \"examples\": examples}def construct_prompt(input_: dict) -> list:    instructions = \"\"\"You are great at using mathematical tools.\"\"\"    examples = []    for ex in input_[\"examples\"]:        examples.append({\"role\": \"user\", \"content\": ex.inputs[\"question\"]})        for msg in ex.outputs[\"conversation\"]:            if msg[\"role\"] == \"assistant\":                msg[\"name\"] = \"example_assistant\"            if msg[\"role\"] == \"user\":                msg[\"name\"] = \"example_user\"            examples.append(msg)    return [        {\"role\": \"system\", \"content\": instructions},        *examples,        {\"role\": \"user\", \"content\": input_[\"question\"]},    ]tools = [add, cos, divide, log, multiply, negate, pi, power, sin, subtract]llm = init_chat_model(\"gpt-4o-2024-08-06\")llm_with_tools = llm.bind_tools(tools)example_selector = RunnableLambda(func=similar_examples, afunc=asimilar_examples)chain = example_selector | construct_prompt | llm_with_tools\n```\n\n```\nai_msg = await chain.ainvoke({\"question\": \"whats the negation of the negation of 3\"})ai_msg.tool_calls\n```\n\n```\n[{'name': 'negate',  'args': {'a': 3},  'id': 'call_uMSdoTl6ehfHh5a6JQUb2NoZ',  'type': 'tool_call'}]\n```\n\nLooking at the LangSmith trace, we can see that relevant examples were pulled in in the `similar_examples` step and passed as messages to ChatOpenAI: [https://smith.langchain.com/public/9585e30f-765a-4ed9-b964-2211420cd2f8/r/fdea98d6-e90f-49d4-ac22-dfd012e9e0d9](https://smith.langchain.com/public/9585e30f-765a-4ed9-b964-2211420cd2f8/r/fdea98d6-e90f-49d4-ac22-dfd012e9e0d9)."
},
{
  "url": "https://python.langchain.com/docs/how_to/sql_csv/",
  "markdown": "# giscus\n\n## How to do question answering over CSVs\n\nLLMs are great for building question-answering systems over various types of data sources. In this section we'll go over how to build Q&A systems over data stored in a CSV file(s). Like working with SQL databases, the key to working with CSV files is to give an LLM access to tools for querying and interacting with the data. The two main ways to do this are to either:\n\n*   **RECOMMENDED**: Load the CSV(s) into a SQL database, and use the approaches outlined in the [SQL tutorial](https://python.langchain.com/docs/tutorials/sql_qa/).\n*   Give the LLM access to a Python environment where it can use libraries like Pandas to interact with the data.\n\nWe will cover both approaches in this guide.\n\n## ⚠️ Security note ⚠️[​](#️-security-note-️ \"Direct link to ⚠️ Security note ⚠️\")\n\nBoth approaches mentioned above carry significant risks. Using SQL requires executing model-generated SQL queries. Using a library like Pandas requires letting the model execute Python code. Since it is easier to tightly scope SQL connection permissions and sanitize SQL queries than it is to sandbox Python environments, **we HIGHLY recommend interacting with CSV data via SQL.** For more on general security best practices, [see here](https://python.langchain.com/docs/security/).\n\n## Setup[​](#setup \"Direct link to Setup\")\n\nDependencies for this guide:\n\n```\n%pip install -qU langchain langchain-openai langchain-community langchain-experimental pandas\n```\n\nSet required environment variables:\n\n```\n# Using LangSmith is recommended but not required. Uncomment below lines to use.# import os# os.environ[\"LANGCHAIN_TRACING_V2\"] = \"true\"# os.environ[\"LANGCHAIN_API_KEY\"] = getpass.getpass()\n```\n\nDownload the [Titanic dataset](https://www.kaggle.com/datasets/yasserh/titanic-dataset) if you don't already have it:\n\n```\n!wget https://web.stanford.edu/class/archive/cs/cs109/cs109.1166/stuff/titanic.csv -O titanic.csv\n```\n\n```\nimport pandas as pddf = pd.read_csv(\"titanic.csv\")print(df.shape)print(df.columns.tolist())\n```\n\n```\n(887, 8)['Survived', 'Pclass', 'Name', 'Sex', 'Age', 'Siblings/Spouses Aboard', 'Parents/Children Aboard', 'Fare']\n```\n\n## SQL[​](#sql \"Direct link to SQL\")\n\nUsing SQL to interact with CSV data is the recommended approach because it is easier to limit permissions and sanitize queries than with arbitrary Python.\n\nMost SQL databases make it easy to load a CSV file in as a table ([DuckDB](https://duckdb.org/docs/data/csv/overview.html), [SQLite](https://www.sqlite.org/csv.html), etc.). Once you've done this you can use all of the chain and agent-creating techniques outlined in the [SQL tutorial](https://python.langchain.com/docs/tutorials/sql_qa/). Here's a quick example of how we might do this with SQLite:\n\n```\nfrom langchain_community.utilities import SQLDatabasefrom sqlalchemy import create_engineengine = create_engine(\"sqlite:///titanic.db\")df.to_sql(\"titanic\", engine, index=False)\n```\n\n```\ndb = SQLDatabase(engine=engine)print(db.dialect)print(db.get_usable_table_names())print(db.run(\"SELECT * FROM titanic WHERE Age < 2;\"))\n```\n\n```\nsqlite['titanic'][(1, 2, 'Master. Alden Gates Caldwell', 'male', 0.83, 0, 2, 29.0), (0, 3, 'Master. Eino Viljami Panula', 'male', 1.0, 4, 1, 39.6875), (1, 3, 'Miss. Eleanor Ileen Johnson', 'female', 1.0, 1, 1, 11.1333), (1, 2, 'Master. Richard F Becker', 'male', 1.0, 2, 1, 39.0), (1, 1, 'Master. Hudson Trevor Allison', 'male', 0.92, 1, 2, 151.55), (1, 3, 'Miss. Maria Nakid', 'female', 1.0, 0, 2, 15.7417), (0, 3, 'Master. Sidney Leonard Goodwin', 'male', 1.0, 5, 2, 46.9), (1, 3, 'Miss. Helene Barbara Baclini', 'female', 0.75, 2, 1, 19.2583), (1, 3, 'Miss. Eugenie Baclini', 'female', 0.75, 2, 1, 19.2583), (1, 2, 'Master. Viljo Hamalainen', 'male', 0.67, 1, 1, 14.5), (1, 3, 'Master. Bertram Vere Dean', 'male', 1.0, 1, 2, 20.575), (1, 3, 'Master. Assad Alexander Thomas', 'male', 0.42, 0, 1, 8.5167), (1, 2, 'Master. Andre Mallet', 'male', 1.0, 0, 2, 37.0042), (1, 2, 'Master. George Sibley Richards', 'male', 0.83, 1, 1, 18.75)]\n```\n\nAnd create a [SQL agent](https://python.langchain.com/docs/tutorials/sql_qa/) to interact with it:\n\n```\npip install -qU langchain-openai\n```\n\n```\nimport getpassimport osif not os.environ.get(\"OPENAI_API_KEY\"):  os.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"Enter API key for OpenAI: \")from langchain_openai import ChatOpenAIllm = ChatOpenAI(model=\"gpt-4o-mini\")\n```\n\n```\nfrom langchain_community.agent_toolkits import create_sql_agentagent_executor = create_sql_agent(llm, db=db, agent_type=\"openai-tools\", verbose=True)\n```\n\n```\nagent_executor.invoke({\"input\": \"what's the average age of survivors\"})\n```\n\n```\n\u001b[1m> Entering new SQL Agent Executor chain...\u001b[0m\u001b[32;1m\u001b[1;3mInvoking: `sql_db_list_tables` with `{}`\u001b[0m\u001b[38;5;200m\u001b[1;3mtitanic\u001b[0m\u001b[32;1m\u001b[1;3mInvoking: `sql_db_schema` with `{'table_names': 'titanic'}`\u001b[0m\u001b[33;1m\u001b[1;3mCREATE TABLE titanic (\t\"Survived\" BIGINT, \t\"Pclass\" BIGINT, \t\"Name\" TEXT, \t\"Sex\" TEXT, \t\"Age\" FLOAT, \t\"Siblings/Spouses Aboard\" BIGINT, \t\"Parents/Children Aboard\" BIGINT, \t\"Fare\" FLOAT)/*3 rows from titanic table:Survived\tPclass\tName\tSex\tAge\tSiblings/Spouses Aboard\tParents/Children Aboard\tFare0\t3\tMr. Owen Harris Braund\tmale\t22.0\t1\t0\t7.251\t1\tMrs. John Bradley (Florence Briggs Thayer) Cumings\tfemale\t38.0\t1\t0\t71.28331\t3\tMiss. Laina Heikkinen\tfemale\t26.0\t0\t0\t7.925*/\u001b[0m\u001b[32;1m\u001b[1;3mInvoking: `sql_db_query` with `{'query': 'SELECT AVG(Age) AS Average_Age FROM titanic WHERE Survived = 1'}`\u001b[0m\u001b[36;1m\u001b[1;3m[(28.408391812865496,)]\u001b[0m\u001b[32;1m\u001b[1;3mThe average age of survivors in the Titanic dataset is approximately 28.41 years.\u001b[0m\u001b[1m> Finished chain.\u001b[0m\n```\n\n```\n{'input': \"what's the average age of survivors\", 'output': 'The average age of survivors in the Titanic dataset is approximately 28.41 years.'}\n```\n\nThis approach easily generalizes to multiple CSVs, since we can just load each of them into our database as its own table. See the [Multiple CSVs](https://python.langchain.com/docs/how_to/sql_csv/#multiple-csvs) section below.\n\n## Pandas[​](#pandas \"Direct link to Pandas\")\n\nInstead of SQL we can also use data analysis libraries like pandas and the code generating abilities of LLMs to interact with CSV data. Again, **this approach is not fit for production use cases unless you have extensive safeguards in place**. For this reason, our code-execution utilities and constructors live in the `langchain-experimental` package.\n\n### Chain[​](#chain \"Direct link to Chain\")\n\nMost LLMs have been trained on enough pandas Python code that they can generate it just by being asked to:\n\n```\nai_msg = llm.invoke(    \"I have a pandas DataFrame 'df' with columns 'Age' and 'Fare'. Write code to compute the correlation between the two columns. Return Markdown for a Python code snippet and nothing else.\")print(ai_msg.content)\n```\n\n```\n\\`\\`\\`pythoncorrelation = df['Age'].corr(df['Fare'])correlation\\`\\`\\`\n```\n\nWe can combine this ability with a Python-executing tool to create a simple data analysis chain. We'll first want to load our CSV table as a dataframe, and give the tool access to this dataframe:\n\n```\nimport pandas as pdfrom langchain_core.prompts import ChatPromptTemplatefrom langchain_experimental.tools import PythonAstREPLTooldf = pd.read_csv(\"titanic.csv\")tool = PythonAstREPLTool(locals={\"df\": df})tool.invoke(\"df['Fare'].mean()\")\n```\n\nTo help enforce proper use of our Python tool, we'll using [tool calling](https://python.langchain.com/docs/how_to/tool_calling/):\n\n```\nllm_with_tools = llm.bind_tools([tool], tool_choice=tool.name)response = llm_with_tools.invoke(    \"I have a dataframe 'df' and want to know the correlation between the 'Age' and 'Fare' columns\")response\n```\n\n```\nAIMessage(content='', additional_kwargs={'tool_calls': [{'id': 'call_SBrK246yUbdnJemXFC8Iod05', 'function': {'arguments': '{\"query\":\"df.corr()[\\'Age\\'][\\'Fare\\']\"}', 'name': 'python_repl_ast'}, 'type': 'function'}]}, response_metadata={'token_usage': {'completion_tokens': 13, 'prompt_tokens': 125, 'total_tokens': 138}, 'model_name': 'gpt-3.5-turbo', 'system_fingerprint': 'fp_3b956da36b', 'finish_reason': 'stop', 'logprobs': None}, id='run-1fd332ba-fa72-4351-8182-d464e7368311-0', tool_calls=[{'name': 'python_repl_ast', 'args': {'query': \"df.corr()['Age']['Fare']\"}, 'id': 'call_SBrK246yUbdnJemXFC8Iod05'}])\n```\n\n```\n[{'name': 'python_repl_ast',  'args': {'query': \"df.corr()['Age']['Fare']\"},  'id': 'call_SBrK246yUbdnJemXFC8Iod05'}]\n```\n\nWe'll add a tools output parser to extract the function call as a dict:\n\n```\nfrom langchain_core.output_parsers.openai_tools import JsonOutputKeyToolsParserparser = JsonOutputKeyToolsParser(key_name=tool.name, first_tool_only=True)(llm_with_tools | parser).invoke(    \"I have a dataframe 'df' and want to know the correlation between the 'Age' and 'Fare' columns\")\n```\n\n```\n{'query': \"df[['Age', 'Fare']].corr()\"}\n```\n\nAnd combine with a prompt so that we can just specify a question without needing to specify the dataframe info every invocation:\n\n```\nsystem = f\"\"\"You have access to a pandas dataframe `df`. \\Here is the output of `df.head().to_markdown()`:\\`\\`\\`{df.head().to_markdown()}\\`\\`\\`Given a user question, write the Python code to answer it. \\Return ONLY the valid Python code and nothing else. \\Don't assume you have access to any libraries other than built-in Python ones and pandas.\"\"\"prompt = ChatPromptTemplate.from_messages([(\"system\", system), (\"human\", \"{question}\")])code_chain = prompt | llm_with_tools | parsercode_chain.invoke({\"question\": \"What's the correlation between age and fare\"})\n```\n\n```\n{'query': \"df[['Age', 'Fare']].corr()\"}\n```\n\nAnd lastly we'll add our Python tool so that the generated code is actually executed:\n\n```\nchain = prompt | llm_with_tools | parser | toolchain.invoke({\"question\": \"What's the correlation between age and fare\"})\n```\n\nAnd just like that we have a simple data analysis chain. We can take a peak at the intermediate steps by looking at the LangSmith trace: [https://smith.langchain.com/public/b1309290-7212-49b7-bde2-75b39a32b49a/r](https://smith.langchain.com/public/b1309290-7212-49b7-bde2-75b39a32b49a/r)\n\nWe could add an additional LLM call at the end to generate a conversational response, so that we're not just responding with the tool output. For this we'll want to add a chat history `MessagesPlaceholder` to our prompt:\n\n```\nfrom operator import itemgetterfrom langchain_core.messages import ToolMessagefrom langchain_core.output_parsers import StrOutputParserfrom langchain_core.prompts import MessagesPlaceholderfrom langchain_core.runnables import RunnablePassthroughsystem = f\"\"\"You have access to a pandas dataframe `df`. \\Here is the output of `df.head().to_markdown()`:\\`\\`\\`{df.head().to_markdown()}\\`\\`\\`Given a user question, write the Python code to answer it. \\Don't assume you have access to any libraries other than built-in Python ones and pandas.Respond directly to the question once you have enough information to answer it.\"\"\"prompt = ChatPromptTemplate.from_messages(    [        (            \"system\",            system,        ),        (\"human\", \"{question}\"),        # This MessagesPlaceholder allows us to optionally append an arbitrary number of messages        # at the end of the prompt using the 'chat_history' arg.        MessagesPlaceholder(\"chat_history\", optional=True),    ])def _get_chat_history(x: dict) -> list:    \"\"\"Parse the chain output up to this point into a list of chat history messages to insert in the prompt.\"\"\"    ai_msg = x[\"ai_msg\"]    tool_call_id = x[\"ai_msg\"].additional_kwargs[\"tool_calls\"][0][\"id\"]    tool_msg = ToolMessage(tool_call_id=tool_call_id, content=str(x[\"tool_output\"]))    return [ai_msg, tool_msg]chain = (    RunnablePassthrough.assign(ai_msg=prompt | llm_with_tools)    .assign(tool_output=itemgetter(\"ai_msg\") | parser | tool)    .assign(chat_history=_get_chat_history)    .assign(response=prompt | llm | StrOutputParser())    .pick([\"tool_output\", \"response\"]))\n```\n\n```\nchain.invoke({\"question\": \"What's the correlation between age and fare\"})\n```\n\n```\n{'tool_output': 0.11232863699941616, 'response': 'The correlation between age and fare is approximately 0.1123.'}\n```\n\nHere's the LangSmith trace for this run: [https://smith.langchain.com/public/14e38d70-45b1-4b81-8477-9fd2b7c07ea6/r](https://smith.langchain.com/public/14e38d70-45b1-4b81-8477-9fd2b7c07ea6/r)\n\n### Agent[​](#agent \"Direct link to Agent\")\n\nFor complex questions it can be helpful for an LLM to be able to iteratively execute code while maintaining the inputs and outputs of its previous executions. This is where Agents come into play. They allow an LLM to decide how many times a tool needs to be invoked and keep track of the executions it's made so far. The [create\\_pandas\\_dataframe\\_agent](https://python.langchain.com/api_reference/experimental/agents/langchain_experimental.agents.agent_toolkits.pandas.base.create_pandas_dataframe_agent.html) is a built-in agent that makes it easy to work with dataframes:\n\n```\nfrom langchain_experimental.agents import create_pandas_dataframe_agentagent = create_pandas_dataframe_agent(    llm, df, agent_type=\"openai-tools\", verbose=True, allow_dangerous_code=True)agent.invoke(    {        \"input\": \"What's the correlation between age and fare? is that greater than the correlation between fare and survival?\"    })\n```\n\n```\n\u001b[1m> Entering new AgentExecutor chain...\u001b[0m\u001b[32;1m\u001b[1;3mInvoking: `python_repl_ast` with `{'query': \"df[['Age', 'Fare']].corr().iloc[0,1]\"}`\u001b[0m\u001b[36;1m\u001b[1;3m0.11232863699941621\u001b[0m\u001b[32;1m\u001b[1;3mInvoking: `python_repl_ast` with `{'query': \"df[['Fare', 'Survived']].corr().iloc[0,1]\"}`\u001b[0m\u001b[36;1m\u001b[1;3m0.2561785496289603\u001b[0m\u001b[32;1m\u001b[1;3mThe correlation between Age and Fare is approximately 0.112, and the correlation between Fare and Survival is approximately 0.256.Therefore, the correlation between Fare and Survival (0.256) is greater than the correlation between Age and Fare (0.112).\u001b[0m\u001b[1m> Finished chain.\u001b[0m\n```\n\n```\n{'input': \"What's the correlation between age and fare? is that greater than the correlation between fare and survival?\", 'output': 'The correlation between Age and Fare is approximately 0.112, and the correlation between Fare and Survival is approximately 0.256.\\n\\nTherefore, the correlation between Fare and Survival (0.256) is greater than the correlation between Age and Fare (0.112).'}\n```\n\nHere's the LangSmith trace for this run: [https://smith.langchain.com/public/6a86aee2-4f22-474a-9264-bd4c7283e665/r](https://smith.langchain.com/public/6a86aee2-4f22-474a-9264-bd4c7283e665/r)\n\n### Multiple CSVs[​](#multiple-csvs \"Direct link to Multiple CSVs\")\n\nTo handle multiple CSVs (or dataframes) we just need to pass multiple dataframes to our Python tool. Our `create_pandas_dataframe_agent` constructor can do this out of the box, we can pass in a list of dataframes instead of just one. If we're constructing a chain ourselves, we can do something like:\n\n```\ndf_1 = df[[\"Age\", \"Fare\"]]df_2 = df[[\"Fare\", \"Survived\"]]tool = PythonAstREPLTool(locals={\"df_1\": df_1, \"df_2\": df_2})llm_with_tool = llm.bind_tools(tools=[tool], tool_choice=tool.name)df_template = \"\"\"\\`\\`\\`python{df_name}.head().to_markdown()>>> {df_head}\\`\\`\\`\"\"\"df_context = \"\\n\\n\".join(    df_template.format(df_head=_df.head().to_markdown(), df_name=df_name)    for _df, df_name in [(df_1, \"df_1\"), (df_2, \"df_2\")])system = f\"\"\"You have access to a number of pandas dataframes. \\Here is a sample of rows from each dataframe and the python code that was used to generate the sample:{df_context}Given a user question about the dataframes, write the Python code to answer it. \\Don't assume you have access to any libraries other than built-in Python ones and pandas. \\Make sure to refer only to the variables mentioned above.\"\"\"prompt = ChatPromptTemplate.from_messages([(\"system\", system), (\"human\", \"{question}\")])chain = prompt | llm_with_tool | parser | toolchain.invoke(    {        \"question\": \"return the difference in the correlation between age and fare and the correlation between fare and survival\"    })\n```\n\nHere's the LangSmith trace for this run: [https://smith.langchain.com/public/cc2a7d7f-7c5a-4e77-a10c-7b5420fcd07f/r](https://smith.langchain.com/public/cc2a7d7f-7c5a-4e77-a10c-7b5420fcd07f/r)\n\n### Sandboxed code execution[​](#sandboxed-code-execution \"Direct link to Sandboxed code execution\")\n\nThere are a number of tools like [E2B](https://python.langchain.com/docs/integrations/tools/e2b_data_analysis/) and [Bearly](https://python.langchain.com/docs/integrations/tools/bearly/) that provide sandboxed environments for Python code execution, to allow for safer code-executing chains and agents.\n\n## Next steps[​](#next-steps \"Direct link to Next steps\")\n\nFor more advanced data analysis applications we recommend checking out:\n\n*   [SQL tutorial](https://python.langchain.com/docs/tutorials/sql_qa/): Many of the challenges of working with SQL db's and CSV's are generic to any structured data type, so it's useful to read the SQL techniques even if you're using Pandas for CSV data analysis.\n*   [Tool use](https://python.langchain.com/docs/how_to/tool_calling/): Guides on general best practices when working with chains and agents that invoke tools\n*   [Agents](https://python.langchain.com/docs/tutorials/agents/): Understand the fundamentals of building LLM agents.\n*   Integrations: Sandboxed envs like [E2B](https://python.langchain.com/docs/integrations/tools/e2b_data_analysis/) and [Bearly](https://python.langchain.com/docs/integrations/tools/bearly/), utilities like [SQLDatabase](https://python.langchain.com/api_reference/community/utilities/langchain_community.utilities.sql_database.SQLDatabase.html#langchain_community.utilities.sql_database.SQLDatabase), related agents like [Spark DataFrame agent](https://python.langchain.com/docs/integrations/tools/spark_sql/)."
},
{
  "url": "https://python.langchain.com/docs/how_to/output_parser_structured/",
  "markdown": "# giscus\n\n[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/langchain-ai/langchain/blob/master/docs/docs/how_to/output_parser_structured.ipynb)[![Open on GitHub](https://img.shields.io/badge/Open%20on%20GitHub-grey?logo=github&logoColor=white)](https://github.com/langchain-ai/langchain/blob/master/docs/docs/how_to/output_parser_structured.ipynb)\n\n## How to use output parsers to parse an LLM response into structured format\n\nLanguage models output text. But there are times where you want to get more structured information than just text back. While some model providers support [built-in ways to return structured output](https://python.langchain.com/docs/how_to/structured_output/), not all do.\n\n[Output parsers](https://python.langchain.com/docs/concepts/output_parsers/) are classes that help structure language model responses. There are two main methods an output parser must implement:\n\n*   \"Get format instructions\": A method which returns a string containing instructions for how the output of a language model should be formatted.\n*   \"Parse\": A method which takes in a string (assumed to be the response from a language model) and parses it into some structure.\n\nAnd then one optional one:\n\n*   \"Parse with prompt\": A method which takes in a string (assumed to be the response from a language model) and a prompt (assumed to be the prompt that generated such a response) and parses it into some structure. The prompt is largely provided in the event the OutputParser wants to retry or fix the output in some way, and needs information from the prompt to do so.\n\n## Get started[​](#get-started \"Direct link to Get started\")\n\nBelow we go over the main type of output parser, the `PydanticOutputParser`.\n\n```\nfrom langchain_core.output_parsers import PydanticOutputParserfrom langchain_core.prompts import PromptTemplatefrom langchain_openai import OpenAIfrom pydantic import BaseModel, Field, model_validatormodel = OpenAI(model_name=\"gpt-3.5-turbo-instruct\", temperature=0.0)# Define your desired data structure.class Joke(BaseModel):    setup: str = Field(description=\"question to set up a joke\")    punchline: str = Field(description=\"answer to resolve the joke\")    # You can add custom validation logic easily with Pydantic.    @model_validator(mode=\"before\")    @classmethod    def question_ends_with_question_mark(cls, values: dict) -> dict:        setup = values.get(\"setup\")        if setup and setup[-1] != \"?\":            raise ValueError(\"Badly formed question!\")        return values# Set up a parser + inject instructions into the prompt template.parser = PydanticOutputParser(pydantic_object=Joke)prompt = PromptTemplate(    template=\"Answer the user query.\\n{format_instructions}\\n{query}\\n\",    input_variables=[\"query\"],    partial_variables={\"format_instructions\": parser.get_format_instructions()},)# And a query intended to prompt a language model to populate the data structure.prompt_and_model = prompt | modeloutput = prompt_and_model.invoke({\"query\": \"Tell me a joke.\"})parser.invoke(output)\n```\n\n```\nJoke(setup='Why did the tomato turn red?', punchline='Because it saw the salad dressing!')\n```\n\n## LCEL[​](#lcel \"Direct link to LCEL\")\n\nOutput parsers implement the [Runnable interface](https://python.langchain.com/docs/concepts/runnables/), the basic building block of the [LangChain Expression Language (LCEL)](https://python.langchain.com/docs/concepts/lcel/). This means they support `invoke`, `ainvoke`, `stream`, `astream`, `batch`, `abatch`, `astream_log` calls.\n\nOutput parsers accept a string or `BaseMessage` as input and can return an arbitrary type.\n\n```\nJoke(setup='Why did the tomato turn red?', punchline='Because it saw the salad dressing!')\n```\n\nInstead of manually invoking the parser, we also could've just added it to our `Runnable` sequence:\n\n```\nchain = prompt | model | parserchain.invoke({\"query\": \"Tell me a joke.\"})\n```\n\n```\nJoke(setup='Why did the tomato turn red?', punchline='Because it saw the salad dressing!')\n```\n\nWhile all parsers support the streaming interface, only certain parsers can stream through partially parsed objects, since this is highly dependent on the output type. Parsers which cannot construct partial objects will simply yield the fully parsed output.\n\nThe `SimpleJsonOutputParser` for example can stream through partial outputs:\n\n```\nfrom langchain.output_parsers.json import SimpleJsonOutputParserjson_prompt = PromptTemplate.from_template(    \"Return a JSON object with an `answer` key that answers the following question: {question}\")json_parser = SimpleJsonOutputParser()json_chain = json_prompt | model | json_parser\n```\n\n```\nlist(json_chain.stream({\"question\": \"Who invented the microscope?\"}))\n```\n\n```\n[{}, {'answer': ''}, {'answer': 'Ant'}, {'answer': 'Anton'}, {'answer': 'Antonie'}, {'answer': 'Antonie van'}, {'answer': 'Antonie van Lee'}, {'answer': 'Antonie van Leeu'}, {'answer': 'Antonie van Leeuwen'}, {'answer': 'Antonie van Leeuwenho'}, {'answer': 'Antonie van Leeuwenhoek'}]\n```\n\nSimilarly,for `PydanticOutputParser`:\n\n```\nlist(chain.stream({\"query\": \"Tell me a joke.\"}))\n```\n\n```\n[Joke(setup='Why did the tomato turn red?', punchline=''), Joke(setup='Why did the tomato turn red?', punchline='Because'), Joke(setup='Why did the tomato turn red?', punchline='Because it'), Joke(setup='Why did the tomato turn red?', punchline='Because it saw'), Joke(setup='Why did the tomato turn red?', punchline='Because it saw the'), Joke(setup='Why did the tomato turn red?', punchline='Because it saw the salad'), Joke(setup='Why did the tomato turn red?', punchline='Because it saw the salad dressing'), Joke(setup='Why did the tomato turn red?', punchline='Because it saw the salad dressing!')]\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/markdown_header_metadata_splitter/",
  "markdown": "# giscus\n\n## How to split Markdown by Headers\n\n### Motivation[​](#motivation \"Direct link to Motivation\")\n\nMany chat or Q+A applications involve chunking input documents prior to embedding and vector storage.\n\n[These notes](https://www.pinecone.io/learn/chunking-strategies/) from Pinecone provide some useful tips:\n\n```\nWhen a full paragraph or document is embedded, the embedding process considers both the overall context and the relationships between the sentences and phrases within the text. This can result in a more comprehensive vector representation that captures the broader meaning and themes of the text.\n```\n\nAs mentioned, chunking often aims to keep text with common context together. With this in mind, we might want to specifically honor the structure of the document itself. For example, a markdown file is organized by headers. Creating chunks within specific header groups is an intuitive idea. To address this challenge, we can use [MarkdownHeaderTextSplitter](https://python.langchain.com/api_reference/text_splitters/markdown/langchain_text_splitters.markdown.MarkdownHeaderTextSplitter.html). This will split a markdown file by a specified set of headers.\n\nFor example, if we want to split this markdown:\n\n```\nmd = '# Foo\\n\\n ## Bar\\n\\nHi this is Jim  \\nHi this is Joe\\n\\n ## Baz\\n\\n Hi this is Molly' \n```\n\nWe can specify the headers to split on:\n\n```\n[(\"#\", \"Header 1\"),(\"##\", \"Header 2\")]\n```\n\nAnd content is grouped or split by common headers:\n\n```\n{'content': 'Hi this is Jim  \\nHi this is Joe', 'metadata': {'Header 1': 'Foo', 'Header 2': 'Bar'}}{'content': 'Hi this is Molly', 'metadata': {'Header 1': 'Foo', 'Header 2': 'Baz'}}\n```\n\nLet's have a look at some examples below.\n\n### Basic usage:[​](#basic-usage \"Direct link to Basic usage:\")\n\n```\n%pip install -qU langchain-text-splitters\n```\n\n```\nfrom langchain_text_splitters import MarkdownHeaderTextSplitter\n```\n\n```\nmarkdown_document = \"# Foo\\n\\n    ## Bar\\n\\nHi this is Jim\\n\\nHi this is Joe\\n\\n ### Boo \\n\\n Hi this is Lance \\n\\n ## Baz\\n\\n Hi this is Molly\"headers_to_split_on = [    (\"#\", \"Header 1\"),    (\"##\", \"Header 2\"),    (\"###\", \"Header 3\"),]markdown_splitter = MarkdownHeaderTextSplitter(headers_to_split_on)md_header_splits = markdown_splitter.split_text(markdown_document)md_header_splits\n```\n\n```\n[Document(page_content='Hi this is Jim  \\nHi this is Joe', metadata={'Header 1': 'Foo', 'Header 2': 'Bar'}), Document(page_content='Hi this is Lance', metadata={'Header 1': 'Foo', 'Header 2': 'Bar', 'Header 3': 'Boo'}), Document(page_content='Hi this is Molly', metadata={'Header 1': 'Foo', 'Header 2': 'Baz'})]\n```\n\n```\ntype(md_header_splits[0])\n```\n\n```\nlangchain_core.documents.base.Document\n```\n\nBy default, `MarkdownHeaderTextSplitter` strips headers being split on from the output chunk's content. This can be disabled by setting `strip_headers = False`.\n\n```\nmarkdown_splitter = MarkdownHeaderTextSplitter(headers_to_split_on, strip_headers=False)md_header_splits = markdown_splitter.split_text(markdown_document)md_header_splits\n```\n\n```\n[Document(page_content='# Foo  \\n## Bar  \\nHi this is Jim  \\nHi this is Joe', metadata={'Header 1': 'Foo', 'Header 2': 'Bar'}), Document(page_content='### Boo  \\nHi this is Lance', metadata={'Header 1': 'Foo', 'Header 2': 'Bar', 'Header 3': 'Boo'}), Document(page_content='## Baz  \\nHi this is Molly', metadata={'Header 1': 'Foo', 'Header 2': 'Baz'})]\n```\n\nnote\n\nThe default `MarkdownHeaderTextSplitter` strips white spaces and new lines. To preserve the original formatting of your Markdown documents, check out [ExperimentalMarkdownSyntaxTextSplitter](https://python.langchain.com/api_reference/text_splitters/markdown/langchain_text_splitters.markdown.ExperimentalMarkdownSyntaxTextSplitter.html).\n\n### How to return Markdown lines as separate documents[​](#how-to-return-markdown-lines-as-separate-documents \"Direct link to How to return Markdown lines as separate documents\")\n\nBy default, `MarkdownHeaderTextSplitter` aggregates lines based on the headers specified in `headers_to_split_on`. We can disable this by specifying `return_each_line`:\n\n```\nmarkdown_splitter = MarkdownHeaderTextSplitter(    headers_to_split_on,    return_each_line=True,)md_header_splits = markdown_splitter.split_text(markdown_document)md_header_splits\n```\n\n```\n[Document(page_content='Hi this is Jim', metadata={'Header 1': 'Foo', 'Header 2': 'Bar'}), Document(page_content='Hi this is Joe', metadata={'Header 1': 'Foo', 'Header 2': 'Bar'}), Document(page_content='Hi this is Lance', metadata={'Header 1': 'Foo', 'Header 2': 'Bar', 'Header 3': 'Boo'}), Document(page_content='Hi this is Molly', metadata={'Header 1': 'Foo', 'Header 2': 'Baz'})]\n```\n\nNote that here header information is retained in the `metadata` for each document.\n\n### How to constrain chunk size:[​](#how-to-constrain-chunk-size \"Direct link to How to constrain chunk size:\")\n\nWithin each markdown group we can then apply any text splitter we want, such as `RecursiveCharacterTextSplitter`, which allows for further control of the chunk size.\n\n```\nmarkdown_document = \"# Intro \\n\\n    ## History \\n\\n Markdown[9] is a lightweight markup language for creating formatted text using a plain-text editor. John Gruber created Markdown in 2004 as a markup language that is appealing to human readers in its source code form.[9] \\n\\n Markdown is widely used in blogging, instant messaging, online forums, collaborative software, documentation pages, and readme files. \\n\\n ## Rise and divergence \\n\\n As Markdown popularity grew rapidly, many Markdown implementations appeared, driven mostly by the need for \\n\\n additional features such as tables, footnotes, definition lists,[note 1] and Markdown inside HTML blocks. \\n\\n #### Standardization \\n\\n From 2012, a group of people, including Jeff Atwood and John MacFarlane, launched what Atwood characterised as a standardisation effort. \\n\\n ## Implementations \\n\\n Implementations of Markdown are available for over a dozen programming languages.\"headers_to_split_on = [    (\"#\", \"Header 1\"),    (\"##\", \"Header 2\"),]# MD splitsmarkdown_splitter = MarkdownHeaderTextSplitter(    headers_to_split_on=headers_to_split_on, strip_headers=False)md_header_splits = markdown_splitter.split_text(markdown_document)# Char-level splitsfrom langchain_text_splitters import RecursiveCharacterTextSplitterchunk_size = 250chunk_overlap = 30text_splitter = RecursiveCharacterTextSplitter(    chunk_size=chunk_size, chunk_overlap=chunk_overlap)# Splitsplits = text_splitter.split_documents(md_header_splits)splits\n```\n\n```\n[Document(page_content='# Intro  \\n## History  \\nMarkdown[9] is a lightweight markup language for creating formatted text using a plain-text editor. John Gruber created Markdown in 2004 as a markup language that is appealing to human readers in its source code form.[9]', metadata={'Header 1': 'Intro', 'Header 2': 'History'}), Document(page_content='Markdown is widely used in blogging, instant messaging, online forums, collaborative software, documentation pages, and readme files.', metadata={'Header 1': 'Intro', 'Header 2': 'History'}), Document(page_content='## Rise and divergence  \\nAs Markdown popularity grew rapidly, many Markdown implementations appeared, driven mostly by the need for  \\nadditional features such as tables, footnotes, definition lists,[note 1] and Markdown inside HTML blocks.', metadata={'Header 1': 'Intro', 'Header 2': 'Rise and divergence'}), Document(page_content='#### Standardization  \\nFrom 2012, a group of people, including Jeff Atwood and John MacFarlane, launched what Atwood characterised as a standardisation effort.', metadata={'Header 1': 'Intro', 'Header 2': 'Rise and divergence'}), Document(page_content='## Implementations  \\nImplementations of Markdown are available for over a dozen programming languages.', metadata={'Header 1': 'Intro', 'Header 2': 'Implementations'})]\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/callbacks_custom_events/",
  "markdown": "# giscus\n\n[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/langchain-ai/langchain/blob/master/docs/docs/how_to/callbacks_custom_events.ipynb)[![Open on GitHub](https://img.shields.io/badge/Open%20on%20GitHub-grey?logo=github&logoColor=white)](https://github.com/langchain-ai/langchain/blob/master/docs/docs/how_to/callbacks_custom_events.ipynb)\n\n## How to dispatch custom callback events\n\nIn some situations, you may want to dipsatch a custom callback event from within a [Runnable](https://python.langchain.com/docs/concepts/runnables/) so it can be surfaced in a custom callback handler or via the [Astream Events API](https://python.langchain.com/docs/concepts/streaming/#astream_events).\n\nFor example, if you have a long running tool with multiple steps, you can dispatch custom events between the steps and use these custom events to monitor progress. You could also surface these custom events to an end user of your application to show them how the current task is progressing.\n\nTo dispatch a custom event you need to decide on two attributes for the event: the `name` and the `data`.\n\n| Attribute | Type | Description |\n| --- | --- | --- |\n| name | str | A user defined name for the event. |\n| data | Any | The data associated with the event. This can be anything, though we suggest making it JSON serializable. |\n\nimportant\n\n*   Dispatching custom callback events requires `langchain-core>=0.2.15`.\n*   Custom callback events can only be dispatched from within an existing `Runnable`.\n*   If using `astream_events`, you must use `version='v2'` to see custom events.\n*   Sending or rendering custom callbacks events in LangSmith is not yet supported.\n\nCOMPATIBILITY\n\nLangChain cannot automatically propagate configuration, including callbacks necessary for astream\\_events(), to child runnables if you are running async code in python<=3.10. This is a common reason why you may fail to see events being emitted from custom runnables or tools.\n\nIf you are running python<=3.10, you will need to manually propagate the `RunnableConfig` object to the child runnable in async environments. For an example of how to manually propagate the config, see the implementation of the `bar` RunnableLambda below.\n\nIf you are running python>=3.11, the `RunnableConfig` will automatically propagate to child runnables in async environment. However, it is still a good idea to propagate the `RunnableConfig` manually if your code may run in other Python versions.\n\n## Astream Events API[​](#astream-events-api \"Direct link to Astream Events API\")\n\nThe most useful way to consume custom events is via the [Astream Events API](https://python.langchain.com/docs/concepts/streaming/#astream_events).\n\nWe can use the `async` `adispatch_custom_event` API to emit custom events in an async setting.\n\nimportant\n\nTo see custom events via the astream events API, you need to use the newer `v2` API of `astream_events`.\n\n```\nfrom langchain_core.callbacks.manager import (    adispatch_custom_event,)from langchain_core.runnables import RunnableLambdafrom langchain_core.runnables.config import RunnableConfig@RunnableLambdaasync def foo(x: str) -> str:    await adispatch_custom_event(\"event1\", {\"x\": x})    await adispatch_custom_event(\"event2\", 5)    return xasync for event in foo.astream_events(\"hello world\", version=\"v2\"):    print(event)\n```\n\n```\n{'event': 'on_chain_start', 'data': {'input': 'hello world'}, 'name': 'foo', 'tags': [], 'run_id': 'f354ffe8-4c22-4881-890a-c1cad038a9a6', 'metadata': {}, 'parent_ids': []}{'event': 'on_custom_event', 'run_id': 'f354ffe8-4c22-4881-890a-c1cad038a9a6', 'name': 'event1', 'tags': [], 'metadata': {}, 'data': {'x': 'hello world'}, 'parent_ids': []}{'event': 'on_custom_event', 'run_id': 'f354ffe8-4c22-4881-890a-c1cad038a9a6', 'name': 'event2', 'tags': [], 'metadata': {}, 'data': 5, 'parent_ids': []}{'event': 'on_chain_stream', 'run_id': 'f354ffe8-4c22-4881-890a-c1cad038a9a6', 'name': 'foo', 'tags': [], 'metadata': {}, 'data': {'chunk': 'hello world'}, 'parent_ids': []}{'event': 'on_chain_end', 'data': {'output': 'hello world'}, 'run_id': 'f354ffe8-4c22-4881-890a-c1cad038a9a6', 'name': 'foo', 'tags': [], 'metadata': {}, 'parent_ids': []}\n```\n\nIn python <= 3.10, you must propagate the config manually!\n\n```\nfrom langchain_core.callbacks.manager import (    adispatch_custom_event,)from langchain_core.runnables import RunnableLambdafrom langchain_core.runnables.config import RunnableConfig@RunnableLambdaasync def bar(x: str, config: RunnableConfig) -> str:    \"\"\"An example that shows how to manually propagate config.    You must do this if you're running python<=3.10.    \"\"\"    await adispatch_custom_event(\"event1\", {\"x\": x}, config=config)    await adispatch_custom_event(\"event2\", 5, config=config)    return xasync for event in bar.astream_events(\"hello world\", version=\"v2\"):    print(event)\n```\n\n```\n{'event': 'on_chain_start', 'data': {'input': 'hello world'}, 'name': 'bar', 'tags': [], 'run_id': 'c787b09d-698a-41b9-8290-92aaa656f3e7', 'metadata': {}, 'parent_ids': []}{'event': 'on_custom_event', 'run_id': 'c787b09d-698a-41b9-8290-92aaa656f3e7', 'name': 'event1', 'tags': [], 'metadata': {}, 'data': {'x': 'hello world'}, 'parent_ids': []}{'event': 'on_custom_event', 'run_id': 'c787b09d-698a-41b9-8290-92aaa656f3e7', 'name': 'event2', 'tags': [], 'metadata': {}, 'data': 5, 'parent_ids': []}{'event': 'on_chain_stream', 'run_id': 'c787b09d-698a-41b9-8290-92aaa656f3e7', 'name': 'bar', 'tags': [], 'metadata': {}, 'data': {'chunk': 'hello world'}, 'parent_ids': []}{'event': 'on_chain_end', 'data': {'output': 'hello world'}, 'run_id': 'c787b09d-698a-41b9-8290-92aaa656f3e7', 'name': 'bar', 'tags': [], 'metadata': {}, 'parent_ids': []}\n```\n\n## Async Callback Handler[​](#async-callback-handler \"Direct link to Async Callback Handler\")\n\nYou can also consume the dispatched event via an async callback handler.\n\n```\nfrom typing import Any, Dict, List, Optionalfrom uuid import UUIDfrom langchain_core.callbacks import AsyncCallbackHandlerfrom langchain_core.callbacks.manager import (    adispatch_custom_event,)from langchain_core.runnables import RunnableLambdafrom langchain_core.runnables.config import RunnableConfigclass AsyncCustomCallbackHandler(AsyncCallbackHandler):    async def on_custom_event(        self,        name: str,        data: Any,        *,        run_id: UUID,        tags: Optional[List[str]] = None,        metadata: Optional[Dict[str, Any]] = None,        **kwargs: Any,    ) -> None:        print(            f\"Received event {name} with data: {data}, with tags: {tags}, with metadata: {metadata} and run_id: {run_id}\"        )@RunnableLambdaasync def bar(x: str, config: RunnableConfig) -> str:    \"\"\"An example that shows how to manually propagate config.    You must do this if you're running python<=3.10.    \"\"\"    await adispatch_custom_event(\"event1\", {\"x\": x}, config=config)    await adispatch_custom_event(\"event2\", 5, config=config)    return xasync_handler = AsyncCustomCallbackHandler()await foo.ainvoke(1, {\"callbacks\": [async_handler], \"tags\": [\"foo\", \"bar\"]})\n```\n\n```\nReceived event event1 with data: {'x': 1}, with tags: ['foo', 'bar'], with metadata: {} and run_id: a62b84be-7afd-4829-9947-7165df1f37d9Received event event2 with data: 5, with tags: ['foo', 'bar'], with metadata: {} and run_id: a62b84be-7afd-4829-9947-7165df1f37d9\n```\n\n## Sync Callback Handler[​](#sync-callback-handler \"Direct link to Sync Callback Handler\")\n\nLet's see how to emit custom events in a sync environment using `dispatch_custom_event`.\n\nYou **must** call `dispatch_custom_event` from within an existing `Runnable`.\n\n```\nfrom typing import Any, Dict, List, Optionalfrom uuid import UUIDfrom langchain_core.callbacks import BaseCallbackHandlerfrom langchain_core.callbacks.manager import (    dispatch_custom_event,)from langchain_core.runnables import RunnableLambdafrom langchain_core.runnables.config import RunnableConfigclass CustomHandler(BaseCallbackHandler):    def on_custom_event(        self,        name: str,        data: Any,        *,        run_id: UUID,        tags: Optional[List[str]] = None,        metadata: Optional[Dict[str, Any]] = None,        **kwargs: Any,    ) -> None:        print(            f\"Received event {name} with data: {data}, with tags: {tags}, with metadata: {metadata} and run_id: {run_id}\"        )@RunnableLambdadef foo(x: int, config: RunnableConfig) -> int:    dispatch_custom_event(\"event1\", {\"x\": x})    dispatch_custom_event(\"event2\", {\"x\": x})    return xhandler = CustomHandler()foo.invoke(1, {\"callbacks\": [handler], \"tags\": [\"foo\", \"bar\"]})\n```\n\n```\nReceived event event1 with data: {'x': 1}, with tags: ['foo', 'bar'], with metadata: {} and run_id: 27b5ce33-dc26-4b34-92dd-08a89cb22268Received event event2 with data: {'x': 1}, with tags: ['foo', 'bar'], with metadata: {} and run_id: 27b5ce33-dc26-4b34-92dd-08a89cb22268\n```\n\n## Next steps[​](#next-steps \"Direct link to Next steps\")\n\nYou've seen how to emit custom events, you can check out the more in depth guide for [astream events](https://python.langchain.com/docs/how_to/streaming/#using-stream-events) which is the easiest way to leverage custom events."
},
{
  "url": "https://python.langchain.com/docs/how_to/merge_message_runs/",
  "markdown": "# giscus\n\n## How to merge consecutive messages of the same type\n\nCertain models do not support passing in consecutive [messages](https://python.langchain.com/docs/concepts/messages/) of the same type (a.k.a. \"runs\" of the same message type).\n\nThe `merge_message_runs` utility makes it easy to merge consecutive messages of the same type.\n\n### Setup[​](#setup \"Direct link to Setup\")\n\n```\n%pip install -qU langchain-core langchain-anthropic\n```\n\n## Basic usage[​](#basic-usage \"Direct link to Basic usage\")\n\n```\nfrom langchain_core.messages import (    AIMessage,    HumanMessage,    SystemMessage,    merge_message_runs,)messages = [    SystemMessage(\"you're a good assistant.\"),    SystemMessage(\"you always respond with a joke.\"),    HumanMessage([{\"type\": \"text\", \"text\": \"i wonder why it's called langchain\"}]),    HumanMessage(\"and who is harrison chasing anyways\"),    AIMessage(        'Well, I guess they thought \"WordRope\" and \"SentenceString\" just didn\\'t have the same ring to it!'    ),    AIMessage(\"Why, he's probably chasing after the last cup of coffee in the office!\"),]merged = merge_message_runs(messages)print(\"\\n\\n\".join([repr(x) for x in merged]))\n```\n\n```\nSystemMessage(content=\"you're a good assistant.\\nyou always respond with a joke.\", additional_kwargs={}, response_metadata={})HumanMessage(content=[{'type': 'text', 'text': \"i wonder why it's called langchain\"}, 'and who is harrison chasing anyways'], additional_kwargs={}, response_metadata={})AIMessage(content='Well, I guess they thought \"WordRope\" and \"SentenceString\" just didn\\'t have the same ring to it!\\nWhy, he\\'s probably chasing after the last cup of coffee in the office!', additional_kwargs={}, response_metadata={})\n```\n\nNotice that if the contents of one of the messages to merge is a list of content blocks then the merged message will have a list of content blocks. And if both messages to merge have string contents then those are concatenated with a newline character.\n\n## Chaining[​](#chaining \"Direct link to Chaining\")\n\n`merge_message_runs` can be used in an imperatively (like above) or declaratively, making it easy to compose with other components in a chain:\n\n```\nfrom langchain_anthropic import ChatAnthropicllm = ChatAnthropic(model=\"claude-3-sonnet-20240229\", temperature=0)# Notice we don't pass in messages. This creates# a RunnableLambda that takes messages as inputmerger = merge_message_runs()chain = merger | llmchain.invoke(messages)\n```\n\n```\nNote: you may need to restart the kernel to use updated packages.\n```\n\n```\nAIMessage(content=[], additional_kwargs={}, response_metadata={'id': 'msg_01KNGUMTuzBVfwNouLDpUMwf', 'model': 'claude-3-sonnet-20240229', 'stop_reason': 'end_turn', 'stop_sequence': None, 'usage': {'input_tokens': 84, 'output_tokens': 3}}, id='run-b908b198-9c24-450b-9749-9d4a8182937b-0', usage_metadata={'input_tokens': 84, 'output_tokens': 3, 'total_tokens': 87})\n```\n\nLooking at the LangSmith trace we can see that before the messages are passed to the model they are merged: [https://smith.langchain.com/public/ab558677-cac9-4c59-9066-1ecce5bcd87c/r](https://smith.langchain.com/public/ab558677-cac9-4c59-9066-1ecce5bcd87c/r)\n\nLooking at just the merger, we can see that it's a Runnable object that can be invoked like all Runnables:\n\n```\n[SystemMessage(content=\"you're a good assistant.\\nyou always respond with a joke.\", additional_kwargs={}, response_metadata={}), HumanMessage(content=[{'type': 'text', 'text': \"i wonder why it's called langchain\"}, 'and who is harrison chasing anyways'], additional_kwargs={}, response_metadata={}), AIMessage(content='Well, I guess they thought \"WordRope\" and \"SentenceString\" just didn\\'t have the same ring to it!\\nWhy, he\\'s probably chasing after the last cup of coffee in the office!', additional_kwargs={}, response_metadata={})]\n```\n\n`merge_message_runs` can also be placed after a prompt:\n\n```\nfrom langchain_core.prompts import ChatPromptTemplateprompt = ChatPromptTemplate(    [        (\"system\", \"You're great a {skill}\"),        (\"system\", \"You're also great at explaining things\"),        (\"human\", \"{query}\"),    ])chain = prompt | merger | llmchain.invoke({\"skill\": \"math\", \"query\": \"what's the definition of a convergent series\"})\n```\n\n```\nAIMessage(content='A convergent series is an infinite series whose partial sums approach a finite value as more terms are added. In other words, the sequence of partial sums has a limit.\\n\\nMore formally, an infinite series Σ an (where an are the terms of the series) is said to be convergent if the sequence of partial sums:\\n\\nS1 = a1\\nS2 = a1 + a2  \\nS3 = a1 + a2 + a3\\n...\\nSn = a1 + a2 + a3 + ... + an\\n...\\n\\nconverges to some finite number S as n goes to infinity. We write:\\n\\nlim n→∞ Sn = S\\n\\nThe finite number S is called the sum of the convergent infinite series.\\n\\nIf the sequence of partial sums does not approach any finite limit, the infinite series is said to be divergent.\\n\\nSome key properties:\\n- A series converges if and only if the sequence of its partial sums is a Cauchy sequence.\\n- Absolute/conditional convergence criteria help determine if a given series converges.\\n- Convergent series have many important applications in mathematics, physics, engineering etc.', additional_kwargs={}, response_metadata={'id': 'msg_01MfV6y2hep7ZNvDz24A36U4', 'model': 'claude-3-sonnet-20240229', 'stop_reason': 'end_turn', 'stop_sequence': None, 'usage': {'input_tokens': 29, 'output_tokens': 267}}, id='run-9d925f58-021e-4bd0-94fc-f8f5e91010a4-0', usage_metadata={'input_tokens': 29, 'output_tokens': 267, 'total_tokens': 296})\n```\n\nLangSmith Trace: [https://smith.langchain.com/public/432150b6-9909-40a7-8ae7-944b7e657438/r/f4ad5fb2-4d38-42a6-b780-25f62617d53f](https://smith.langchain.com/public/432150b6-9909-40a7-8ae7-944b7e657438/r/f4ad5fb2-4d38-42a6-b780-25f62617d53f)\n\n## API reference[​](#api-reference \"Direct link to API reference\")\n\nFor a complete description of all arguments head to the API reference: [https://python.langchain.com/api\\_reference/core/messages/langchain\\_core.messages.utils.merge\\_message\\_runs.html](https://python.langchain.com/api_reference/core/messages/langchain_core.messages.utils.merge_message_runs.html)"
},
{
  "url": "https://python.langchain.com/docs/how_to/sql_large_db/",
  "markdown": "# giscus\n\n## How to deal with large databases when doing SQL question-answering\n\nIn order to write valid queries against a database, we need to feed the model the table names, table schemas, and feature values for it to query over. When there are many tables, columns, and/or high-cardinality columns, it becomes impossible for us to dump the full information about our database in every prompt. Instead, we must find ways to dynamically insert into the prompt only the most relevant information.\n\nIn this guide we demonstrate methods for identifying such relevant information, and feeding this into a query-generation step. We will cover:\n\n1.  Identifying a relevant subset of tables;\n2.  Identifying a relevant subset of column values.\n\n## Setup[​](#setup \"Direct link to Setup\")\n\nFirst, get required packages and set environment variables:\n\n```\n%pip install --upgrade --quiet  langchain langchain-community langchain-openai\n```\n\n```\n# Uncomment the below to use LangSmith. Not required.# import os# os.environ[\"LANGCHAIN_API_KEY\"] = getpass.getpass()# os.environ[\"LANGCHAIN_TRACING_V2\"] = \"true\"\n```\n\nThe below example will use a SQLite connection with Chinook database. Follow [these installation steps](https://database.guide/2-sample-databases-sqlite/) to create `Chinook.db` in the same directory as this notebook:\n\n*   Save [this file](https://raw.githubusercontent.com/lerocha/chinook-database/master/ChinookDatabase/DataSources/Chinook_Sqlite.sql) as `Chinook_Sqlite.sql`\n*   Run `sqlite3 Chinook.db`\n*   Run `.read Chinook_Sqlite.sql`\n*   Test `SELECT * FROM Artist LIMIT 10;`\n\nNow, `Chinook.db` is in our directory and we can interface with it using the SQLAlchemy-driven [SQLDatabase](https://python.langchain.com/api_reference/community/utilities/langchain_community.utilities.sql_database.SQLDatabase.html) class:\n\n```\nfrom langchain_community.utilities import SQLDatabasedb = SQLDatabase.from_uri(\"sqlite:///Chinook.db\")print(db.dialect)print(db.get_usable_table_names())print(db.run(\"SELECT * FROM Artist LIMIT 10;\"))\n```\n\n```\nsqlite['Album', 'Artist', 'Customer', 'Employee', 'Genre', 'Invoice', 'InvoiceLine', 'MediaType', 'Playlist', 'PlaylistTrack', 'Track'][(1, 'AC/DC'), (2, 'Accept'), (3, 'Aerosmith'), (4, 'Alanis Morissette'), (5, 'Alice In Chains'), (6, 'Antônio Carlos Jobim'), (7, 'Apocalyptica'), (8, 'Audioslave'), (9, 'BackBeat'), (10, 'Billy Cobham')]\n```\n\n## Many tables[​](#many-tables \"Direct link to Many tables\")\n\nOne of the main pieces of information we need to include in our prompt is the schemas of the relevant tables. When we have very many tables, we can't fit all of the schemas in a single prompt. What we can do in such cases is first extract the names of the tables related to the user input, and then include only their schemas.\n\nOne easy and reliable way to do this is using [tool-calling](https://python.langchain.com/docs/how_to/tool_calling/). Below, we show how we can use this feature to obtain output conforming to a desired format (in this case, a list of table names). We use the chat model's `.bind_tools` method to bind a tool in Pydantic format, and feed this into an output parser to reconstruct the object from the model's response.\n\n```\npip install -qU langchain-openai\n```\n\n```\nimport getpassimport osif not os.environ.get(\"OPENAI_API_KEY\"):  os.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"Enter API key for OpenAI: \")from langchain_openai import ChatOpenAIllm = ChatOpenAI(model=\"gpt-4o-mini\")\n```\n\n```\nfrom langchain_core.output_parsers.openai_tools import PydanticToolsParserfrom langchain_core.prompts import ChatPromptTemplatefrom pydantic import BaseModel, Fieldclass Table(BaseModel):    \"\"\"Table in SQL database.\"\"\"    name: str = Field(description=\"Name of table in SQL database.\")table_names = \"\\n\".join(db.get_usable_table_names())system = f\"\"\"Return the names of ALL the SQL tables that MIGHT be relevant to the user question. \\The tables are:{table_names}Remember to include ALL POTENTIALLY RELEVANT tables, even if you're not sure that they're needed.\"\"\"prompt = ChatPromptTemplate.from_messages(    [        (\"system\", system),        (\"human\", \"{input}\"),    ])llm_with_tools = llm.bind_tools([Table])output_parser = PydanticToolsParser(tools=[Table])table_chain = prompt | llm_with_tools | output_parsertable_chain.invoke({\"input\": \"What are all the genres of Alanis Morisette songs\"})\n```\n\nThis works pretty well! Except, as we'll see below, we actually need a few other tables as well. This would be pretty difficult for the model to know based just on the user question. In this case, we might think to simplify our model's job by grouping the tables together. We'll just ask the model to choose between categories \"Music\" and \"Business\", and then take care of selecting all the relevant tables from there:\n\n```\nsystem = \"\"\"Return the names of any SQL tables that are relevant to the user question.The tables are:MusicBusiness\"\"\"prompt = ChatPromptTemplate.from_messages(    [        (\"system\", system),        (\"human\", \"{input}\"),    ])category_chain = prompt | llm_with_tools | output_parsercategory_chain.invoke({\"input\": \"What are all the genres of Alanis Morisette songs\"})\n```\n\n```\n[Table(name='Music'), Table(name='Business')]\n```\n\n```\nfrom typing import Listdef get_tables(categories: List[Table]) -> List[str]:    tables = []    for category in categories:        if category.name == \"Music\":            tables.extend(                [                    \"Album\",                    \"Artist\",                    \"Genre\",                    \"MediaType\",                    \"Playlist\",                    \"PlaylistTrack\",                    \"Track\",                ]            )        elif category.name == \"Business\":            tables.extend([\"Customer\", \"Employee\", \"Invoice\", \"InvoiceLine\"])    return tablestable_chain = category_chain | get_tablestable_chain.invoke({\"input\": \"What are all the genres of Alanis Morisette songs\"})\n```\n\n```\n['Album', 'Artist', 'Genre', 'MediaType', 'Playlist', 'PlaylistTrack', 'Track', 'Customer', 'Employee', 'Invoice', 'InvoiceLine']\n```\n\nNow that we've got a chain that can output the relevant tables for any query we can combine this with our [create\\_sql\\_query\\_chain](https://python.langchain.com/api_reference/langchain/chains/langchain.chains.sql_database.query.create_sql_query_chain.html), which can accept a list of `table_names_to_use` to determine which table schemas are included in the prompt:\n\n```\nfrom operator import itemgetterfrom langchain.chains import create_sql_query_chainfrom langchain_core.runnables import RunnablePassthroughquery_chain = create_sql_query_chain(llm, db)# Convert \"question\" key to the \"input\" key expected by current table_chain.table_chain = {\"input\": itemgetter(\"question\")} | table_chain# Set table_names_to_use using table_chain.full_chain = RunnablePassthrough.assign(table_names_to_use=table_chain) | query_chain\n```\n\n```\nquery = full_chain.invoke(    {\"question\": \"What are all the genres of Alanis Morisette songs\"})print(query)\n```\n\n```\nSELECT DISTINCT \"g\".\"Name\"FROM \"Genre\" gJOIN \"Track\" t ON \"g\".\"GenreId\" = \"t\".\"GenreId\"JOIN \"Album\" a ON \"t\".\"AlbumId\" = \"a\".\"AlbumId\"JOIN \"Artist\" ar ON \"a\".\"ArtistId\" = \"ar\".\"ArtistId\"WHERE \"ar\".\"Name\" = 'Alanis Morissette'LIMIT 5;\n```\n\nWe can see the LangSmith trace for this run [here](https://smith.langchain.com/public/4fbad408-3554-4f33-ab47-1e510a1b52a3/r).\n\nWe've seen how to dynamically include a subset of table schemas in a prompt within a chain. Another possible approach to this problem is to let an Agent decide for itself when to look up tables by giving it a Tool to do so. You can see an example of this in the [SQL: Agents](https://python.langchain.com/docs/tutorials/agents/) guide.\n\n## High-cardinality columns[​](#high-cardinality-columns \"Direct link to High-cardinality columns\")\n\nIn order to filter columns that contain proper nouns such as addresses, song names or artists, we first need to double-check the spelling in order to filter the data correctly.\n\nOne naive strategy it to create a vector store with all the distinct proper nouns that exist in the database. We can then query that vector store each user input and inject the most relevant proper nouns into the prompt.\n\nFirst we need the unique values for each entity we want, for which we define a function that parses the result into a list of elements:\n\n```\nimport astimport redef query_as_list(db, query):    res = db.run(query)    res = [el for sub in ast.literal_eval(res) for el in sub if el]    res = [re.sub(r\"\\b\\d+\\b\", \"\", string).strip() for string in res]    return resproper_nouns = query_as_list(db, \"SELECT Name FROM Artist\")proper_nouns += query_as_list(db, \"SELECT Title FROM Album\")proper_nouns += query_as_list(db, \"SELECT Name FROM Genre\")len(proper_nouns)proper_nouns[:5]\n```\n\n```\n['AC/DC', 'Accept', 'Aerosmith', 'Alanis Morissette', 'Alice In Chains']\n```\n\nNow we can embed and store all of our values in a vector database:\n\n```\nfrom langchain_community.vectorstores import FAISSfrom langchain_openai import OpenAIEmbeddingsvector_db = FAISS.from_texts(proper_nouns, OpenAIEmbeddings())retriever = vector_db.as_retriever(search_kwargs={\"k\": 15})\n```\n\nAnd put together a query construction chain that first retrieves values from the database and inserts them into the prompt:\n\n```\nfrom operator import itemgetterfrom langchain_core.prompts import ChatPromptTemplatefrom langchain_core.runnables import RunnablePassthroughsystem = \"\"\"You are a SQLite expert. Given an input question, create a syntacticallycorrect SQLite query to run. Unless otherwise specificed, do not return more than{top_k} rows.Only return the SQL query with no markup or explanation.Here is the relevant table info: {table_info}Here is a non-exhaustive list of possible feature values. If filtering on a featurevalue make sure to check its spelling against this list first:{proper_nouns}\"\"\"prompt = ChatPromptTemplate.from_messages([(\"system\", system), (\"human\", \"{input}\")])query_chain = create_sql_query_chain(llm, db, prompt=prompt)retriever_chain = (    itemgetter(\"question\")    | retriever    | (lambda docs: \"\\n\".join(doc.page_content for doc in docs)))chain = RunnablePassthrough.assign(proper_nouns=retriever_chain) | query_chain\n```\n\nTo try out our chain, let's see what happens when we try filtering on \"elenis moriset\", a misspelling of Alanis Morissette, without and with retrieval:\n\n```\n# Without retrievalquery = query_chain.invoke(    {\"question\": \"What are all the genres of elenis moriset songs\", \"proper_nouns\": \"\"})print(query)db.run(query)\n```\n\n```\nSELECT DISTINCT g.Name FROM Track tJOIN Album a ON t.AlbumId = a.AlbumIdJOIN Artist ar ON a.ArtistId = ar.ArtistIdJOIN Genre g ON t.GenreId = g.GenreIdWHERE ar.Name = 'Elenis Moriset';\n```\n\n```\n# Without retrievalquery = query_chain.invoke(    {\"question\": \"What are all the genres of elenis moriset songs\", \"proper_nouns\": \"\"})print(query)db.run(query)\n```\n\n```\nSELECT DISTINCT Genre.NameFROM GenreJOIN Track ON Genre.GenreId = Track.GenreIdJOIN Album ON Track.AlbumId = Album.AlbumIdJOIN Artist ON Album.ArtistId = Artist.ArtistIdWHERE Artist.Name = 'Elenis Moriset'\n```\n\n```\n# With retrievalquery = chain.invoke({\"question\": \"What are all the genres of elenis moriset songs\"})print(query)db.run(query)\n```\n\n```\nSELECT DISTINCT g.NameFROM Genre gJOIN Track t ON g.GenreId = t.GenreIdJOIN Album a ON t.AlbumId = a.AlbumIdJOIN Artist ar ON a.ArtistId = ar.ArtistIdWHERE ar.Name = 'Alanis Morissette';\n```\n\nWe can see that with retrieval we're able to correct the spelling from \"Elenis Moriset\" to \"Alanis Morissette\" and get back a valid result.\n\nAnother possible approach to this problem is to let an Agent decide for itself when to look up proper nouns. You can see an example of this in the [SQL: Agents](https://python.langchain.com/docs/tutorials/agents/) guide."
},
{
  "url": "https://python.langchain.com/docs/how_to/query_no_queries/",
  "markdown": "# giscus\n\n[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/langchain-ai/langchain/blob/master/docs/docs/how_to/query_no_queries.ipynb)[![Open on GitHub](https://img.shields.io/badge/Open%20on%20GitHub-grey?logo=github&logoColor=white)](https://github.com/langchain-ai/langchain/blob/master/docs/docs/how_to/query_no_queries.ipynb)\n\n## How to handle cases where no queries are generated\n\nSometimes, a query analysis technique may allow for any number of queries to be generated - including no queries! In this case, our overall chain will need to inspect the result of the query analysis before deciding whether to call the retriever or not.\n\nWe will use mock data for this example.\n\n## Setup[​](#setup \"Direct link to Setup\")\n\n#### Install dependencies[​](#install-dependencies \"Direct link to Install dependencies\")\n\n```\n%pip install -qU langchain langchain-community langchain-openai langchain-chroma\n```\n\n```\nNote: you may need to restart the kernel to use updated packages.\n```\n\n#### Set environment variables[​](#set-environment-variables \"Direct link to Set environment variables\")\n\nWe'll use OpenAI in this example:\n\n```\nimport getpassimport osif \"OPENAI_API_KEY\" not in os.environ:    os.environ[\"OPENAI_API_KEY\"] = getpass.getpass()# Optional, uncomment to trace runs with LangSmith. Sign up here: https://smith.langchain.com.# os.environ[\"LANGCHAIN_TRACING_V2\"] = \"true\"# os.environ[\"LANGCHAIN_API_KEY\"] = getpass.getpass()\n```\n\n### Create Index[​](#create-index \"Direct link to Create Index\")\n\nWe will create a vectorstore over fake information.\n\n```\nfrom langchain_chroma import Chromafrom langchain_openai import OpenAIEmbeddingsfrom langchain_text_splitters import RecursiveCharacterTextSplittertexts = [\"Harrison worked at Kensho\"]embeddings = OpenAIEmbeddings(model=\"text-embedding-3-small\")vectorstore = Chroma.from_texts(    texts,    embeddings,)retriever = vectorstore.as_retriever()\n```\n\n## Query analysis[​](#query-analysis \"Direct link to Query analysis\")\n\nWe will use function calling to structure the output. However, we will configure the LLM such that is doesn't NEED to call the function representing a search query (should it decide not to). We will also then use a prompt to do query analysis that explicitly lays when it should and shouldn't make a search.\n\n```\nfrom typing import Optionalfrom pydantic import BaseModel, Fieldclass Search(BaseModel):    \"\"\"Search over a database of job records.\"\"\"    query: str = Field(        ...,        description=\"Similarity search query applied to job record.\",    )\n```\n\n```\nfrom langchain_core.prompts import ChatPromptTemplatefrom langchain_core.runnables import RunnablePassthroughfrom langchain_openai import ChatOpenAIsystem = \"\"\"You have the ability to issue search queries to get information to help answer user information.You do not NEED to look things up. If you don't need to, then just respond normally.\"\"\"prompt = ChatPromptTemplate.from_messages(    [        (\"system\", system),        (\"human\", \"{question}\"),    ])llm = ChatOpenAI(model=\"gpt-4o-mini\", temperature=0)structured_llm = llm.bind_tools([Search])query_analyzer = {\"question\": RunnablePassthrough()} | prompt | structured_llm\n```\n\nWe can see that by invoking this we get an message that sometimes - but not always - returns a tool call.\n\n```\nquery_analyzer.invoke(\"where did Harrison Work\")\n```\n\n```\nAIMessage(content='', additional_kwargs={'tool_calls': [{'id': 'call_korLZrh08PTRL94f4L7rFqdj', 'function': {'arguments': '{\"query\":\"Harrison\"}', 'name': 'Search'}, 'type': 'function'}], 'refusal': None}, response_metadata={'token_usage': {'completion_tokens': 14, 'prompt_tokens': 95, 'total_tokens': 109}, 'model_name': 'gpt-4o-mini-2024-07-18', 'system_fingerprint': 'fp_483d39d857', 'finish_reason': 'tool_calls', 'logprobs': None}, id='run-ea94d376-37bf-4f80-abe6-e3b42b767ea0-0', tool_calls=[{'name': 'Search', 'args': {'query': 'Harrison'}, 'id': 'call_korLZrh08PTRL94f4L7rFqdj', 'type': 'tool_call'}], usage_metadata={'input_tokens': 95, 'output_tokens': 14, 'total_tokens': 109})\n```\n\n```\nquery_analyzer.invoke(\"hi!\")\n```\n\n```\nAIMessage(content='Hello! How can I assist you today?', additional_kwargs={'refusal': None}, response_metadata={'token_usage': {'completion_tokens': 10, 'prompt_tokens': 93, 'total_tokens': 103}, 'model_name': 'gpt-4o-mini-2024-07-18', 'system_fingerprint': 'fp_483d39d857', 'finish_reason': 'stop', 'logprobs': None}, id='run-ebdfc44a-455a-4ca6-be85-84559886b1e1-0', usage_metadata={'input_tokens': 93, 'output_tokens': 10, 'total_tokens': 103})\n```\n\n## Retrieval with query analysis[​](#retrieval-with-query-analysis \"Direct link to Retrieval with query analysis\")\n\nSo how would we include this in a chain? Let's look at an example below.\n\n```\nfrom langchain_core.output_parsers.openai_tools import PydanticToolsParserfrom langchain_core.runnables import chainoutput_parser = PydanticToolsParser(tools=[Search])\n```\n\n```\n@chaindef custom_chain(question):    response = query_analyzer.invoke(question)    if \"tool_calls\" in response.additional_kwargs:        query = output_parser.invoke(response)        docs = retriever.invoke(query[0].query)        # Could add more logic - like another LLM call - here        return docs    else:        return response\n```\n\n```\ncustom_chain.invoke(\"where did Harrison Work\")\n```\n\n```\nNumber of requested results 4 is greater than number of elements in index 1, updating n_results = 1\n```\n\n```\n[Document(page_content='Harrison worked at Kensho')]\n```\n\n```\ncustom_chain.invoke(\"hi!\")\n```\n\n```\nAIMessage(content='Hello! How can I assist you today?', additional_kwargs={'refusal': None}, response_metadata={'token_usage': {'completion_tokens': 10, 'prompt_tokens': 93, 'total_tokens': 103}, 'model_name': 'gpt-4o-mini-2024-07-18', 'system_fingerprint': 'fp_483d39d857', 'finish_reason': 'stop', 'logprobs': None}, id='run-e87f058d-30c0-4075-8a89-a01b982d557e-0', usage_metadata={'input_tokens': 93, 'output_tokens': 10, 'total_tokens': 103})\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/example_selectors_length_based/",
  "markdown": "# giscus\n\n## How to select examples by length\n\nThis [example selector](https://python.langchain.com/docs/concepts/example_selectors/) selects which examples to use based on length. This is useful when you are worried about constructing a prompt that will go over the length of the context window. For longer inputs, it will select fewer examples to include, while for shorter inputs it will select more.\n\n```\nfrom langchain_core.example_selectors import LengthBasedExampleSelectorfrom langchain_core.prompts import FewShotPromptTemplate, PromptTemplate# Examples of a pretend task of creating antonyms.examples = [    {\"input\": \"happy\", \"output\": \"sad\"},    {\"input\": \"tall\", \"output\": \"short\"},    {\"input\": \"energetic\", \"output\": \"lethargic\"},    {\"input\": \"sunny\", \"output\": \"gloomy\"},    {\"input\": \"windy\", \"output\": \"calm\"},]example_prompt = PromptTemplate(    input_variables=[\"input\", \"output\"],    template=\"Input: {input}\\nOutput: {output}\",)example_selector = LengthBasedExampleSelector(    # The examples it has available to choose from.    examples=examples,    # The PromptTemplate being used to format the examples.    example_prompt=example_prompt,    # The maximum length that the formatted examples should be.    # Length is measured by the get_text_length function below.    max_length=25,    # The function used to get the length of a string, which is used    # to determine which examples to include. It is commented out because    # it is provided as a default value if none is specified.    # get_text_length: Callable[[str], int] = lambda x: len(re.split(\"\\n| \", x)))dynamic_prompt = FewShotPromptTemplate(    # We provide an ExampleSelector instead of examples.    example_selector=example_selector,    example_prompt=example_prompt,    prefix=\"Give the antonym of every input\",    suffix=\"Input: {adjective}\\nOutput:\",    input_variables=[\"adjective\"],)\n```\n\n```\n# An example with small input, so it selects all examples.print(dynamic_prompt.format(adjective=\"big\"))\n```\n\n```\nGive the antonym of every inputInput: happyOutput: sadInput: tallOutput: shortInput: energeticOutput: lethargicInput: sunnyOutput: gloomyInput: windyOutput: calmInput: bigOutput:\n```\n\n```\n# An example with long input, so it selects only one example.long_string = \"big and huge and massive and large and gigantic and tall and much much much much much bigger than everything else\"print(dynamic_prompt.format(adjective=long_string))\n```\n\n```\nGive the antonym of every inputInput: happyOutput: sadInput: big and huge and massive and large and gigantic and tall and much much much much much bigger than everything elseOutput:\n```\n\n```\n# You can add an example to an example selector as well.new_example = {\"input\": \"big\", \"output\": \"small\"}dynamic_prompt.example_selector.add_example(new_example)print(dynamic_prompt.format(adjective=\"enthusiastic\"))\n```\n\n```\nGive the antonym of every inputInput: happyOutput: sadInput: tallOutput: shortInput: energeticOutput: lethargicInput: sunnyOutput: gloomyInput: windyOutput: calmInput: bigOutput: smallInput: enthusiasticOutput:\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/example_selectors_mmr/",
  "markdown": "# giscus\n\nThe `MaxMarginalRelevanceExampleSelector` selects [examples](https://python.langchain.com/docs/concepts/example_selectors/) based on a combination of which examples are most similar to the inputs, while also optimizing for diversity. It does this by finding the examples with the embeddings that have the greatest cosine similarity with the inputs, and then iteratively adding them while penalizing them for closeness to already selected examples.\n\n```\nfrom langchain_community.vectorstores import FAISSfrom langchain_core.example_selectors import (    MaxMarginalRelevanceExampleSelector,    SemanticSimilarityExampleSelector,)from langchain_core.prompts import FewShotPromptTemplate, PromptTemplatefrom langchain_openai import OpenAIEmbeddingsexample_prompt = PromptTemplate(    input_variables=[\"input\", \"output\"],    template=\"Input: {input}\\nOutput: {output}\",)# Examples of a pretend task of creating antonyms.examples = [    {\"input\": \"happy\", \"output\": \"sad\"},    {\"input\": \"tall\", \"output\": \"short\"},    {\"input\": \"energetic\", \"output\": \"lethargic\"},    {\"input\": \"sunny\", \"output\": \"gloomy\"},    {\"input\": \"windy\", \"output\": \"calm\"},]\n```\n\n```\nexample_selector = MaxMarginalRelevanceExampleSelector.from_examples(    # The list of examples available to select from.    examples,    # The embedding class used to produce embeddings which are used to measure semantic similarity.    OpenAIEmbeddings(),    # The VectorStore class that is used to store the embeddings and do a similarity search over.    FAISS,    # The number of examples to produce.    k=2,)mmr_prompt = FewShotPromptTemplate(    # We provide an ExampleSelector instead of examples.    example_selector=example_selector,    example_prompt=example_prompt,    prefix=\"Give the antonym of every input\",    suffix=\"Input: {adjective}\\nOutput:\",    input_variables=[\"adjective\"],)\n```\n\n```\n# Input is a feeling, so should select the happy/sad example as the first oneprint(mmr_prompt.format(adjective=\"worried\"))\n```\n\n```\n# Let's compare this to what we would just get if we went solely off of similarity,# by using SemanticSimilarityExampleSelector instead of MaxMarginalRelevanceExampleSelector.example_selector = SemanticSimilarityExampleSelector.from_examples(    # The list of examples available to select from.    examples,    # The embedding class used to produce embeddings which are used to measure semantic similarity.    OpenAIEmbeddings(),    # The VectorStore class that is used to store the embeddings and do a similarity search over.    FAISS,    # The number of examples to produce.    k=2,)similar_prompt = FewShotPromptTemplate(    # We provide an ExampleSelector instead of examples.    example_selector=example_selector,    example_prompt=example_prompt,    prefix=\"Give the antonym of every input\",    suffix=\"Input: {adjective}\\nOutput:\",    input_variables=[\"adjective\"],)print(similar_prompt.format(adjective=\"worried\"))\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/callbacks_runtime/",
  "markdown": "# giscus\n\nIn many cases, it is advantageous to pass in handlers instead when running the object. When we pass through [`CallbackHandlers`](https://python.langchain.com/api_reference/core/callbacks/langchain_core.callbacks.base.BaseCallbackHandler.html#langchain-core-callbacks-base-basecallbackhandler) using the `callbacks` keyword arg when executing a run, those callbacks will be issued by all nested objects involved in the execution. For example, when a handler is passed through to an Agent, it will be used for all callbacks related to the agent and all the objects involved in the agent's execution, in this case, the Tools and LLM.\n\nThis prevents us from having to manually attach the handlers to each individual nested object. Here's an example:\n\n```\nfrom typing import Any, Dict, Listfrom langchain_anthropic import ChatAnthropicfrom langchain_core.callbacks import BaseCallbackHandlerfrom langchain_core.messages import BaseMessagefrom langchain_core.outputs import LLMResultfrom langchain_core.prompts import ChatPromptTemplateclass LoggingHandler(BaseCallbackHandler):    def on_chat_model_start(        self, serialized: Dict[str, Any], messages: List[List[BaseMessage]], **kwargs    ) -> None:        print(\"Chat model started\")    def on_llm_end(self, response: LLMResult, **kwargs) -> None:        print(f\"Chat model ended, response: {response}\")    def on_chain_start(        self, serialized: Dict[str, Any], inputs: Dict[str, Any], **kwargs    ) -> None:        print(f\"Chain {serialized.get('name')} started\")    def on_chain_end(self, outputs: Dict[str, Any], **kwargs) -> None:        print(f\"Chain ended, outputs: {outputs}\")callbacks = [LoggingHandler()]llm = ChatAnthropic(model=\"claude-3-sonnet-20240229\")prompt = ChatPromptTemplate.from_template(\"What is 1 + {number}?\")chain = prompt | llmchain.invoke({\"number\": \"2\"}, config={\"callbacks\": callbacks})\n```\n\n```\nChain RunnableSequence startedChain ChatPromptTemplate startedChain ended, outputs: messages=[HumanMessage(content='What is 1 + 2?')]Chat model startedChat model ended, response: generations=[[ChatGeneration(text='1 + 2 = 3', message=AIMessage(content='1 + 2 = 3', response_metadata={'id': 'msg_01D8Tt5FdtBk5gLTfBPm2tac', 'model': 'claude-3-sonnet-20240229', 'stop_reason': 'end_turn', 'stop_sequence': None, 'usage': {'input_tokens': 16, 'output_tokens': 13}}, id='run-bb0dddd8-85f3-4e6b-8553-eaa79f859ef8-0'))]] llm_output={'id': 'msg_01D8Tt5FdtBk5gLTfBPm2tac', 'model': 'claude-3-sonnet-20240229', 'stop_reason': 'end_turn', 'stop_sequence': None, 'usage': {'input_tokens': 16, 'output_tokens': 13}} run=NoneChain ended, outputs: content='1 + 2 = 3' response_metadata={'id': 'msg_01D8Tt5FdtBk5gLTfBPm2tac', 'model': 'claude-3-sonnet-20240229', 'stop_reason': 'end_turn', 'stop_sequence': None, 'usage': {'input_tokens': 16, 'output_tokens': 13}} id='run-bb0dddd8-85f3-4e6b-8553-eaa79f859ef8-0'\n```\n\n```\nAIMessage(content='1 + 2 = 3', response_metadata={'id': 'msg_01D8Tt5FdtBk5gLTfBPm2tac', 'model': 'claude-3-sonnet-20240229', 'stop_reason': 'end_turn', 'stop_sequence': None, 'usage': {'input_tokens': 16, 'output_tokens': 13}}, id='run-bb0dddd8-85f3-4e6b-8553-eaa79f859ef8-0')\n```\n\nIf there are already existing callbacks associated with a module, these will run in addition to any passed in at runtime.\n\nYou've now learned how to pass callbacks at runtime."
},
{
  "url": "https://python.langchain.com/docs/how_to/routing/",
  "markdown": "# giscus\n\n## How to route between sub-chains\n\nRouting allows you to create non-deterministic chains where the output of a previous step defines the next step. Routing can help provide structure and consistency around interactions with models by allowing you to define states and use information related to those states as context to model calls.\n\nThere are two ways to perform routing:\n\n1.  Conditionally return runnables from a [`RunnableLambda`](https://python.langchain.com/docs/how_to/functions/) (recommended)\n2.  Using a `RunnableBranch` (legacy)\n\nWe'll illustrate both methods using a two step sequence where the first step classifies an input question as being about `LangChain`, `Anthropic`, or `Other`, then routes to a corresponding prompt chain.\n\n## Example Setup[​](#example-setup \"Direct link to Example Setup\")\n\nFirst, let's create a chain that will identify incoming questions as being about `LangChain`, `Anthropic`, or `Other`:\n\n```\nfrom langchain_anthropic import ChatAnthropicfrom langchain_core.output_parsers import StrOutputParserfrom langchain_core.prompts import PromptTemplatechain = (    PromptTemplate.from_template(        \"\"\"Given the user question below, classify it as either being about `LangChain`, `Anthropic`, or `Other`.Do not respond with more than one word.<question>{question}</question>Classification:\"\"\"    )    | ChatAnthropic(model_name=\"claude-3-haiku-20240307\")    | StrOutputParser())chain.invoke({\"question\": \"how do I call Anthropic?\"})\n```\n\nNow, let's create three sub chains:\n\n```\nlangchain_chain = PromptTemplate.from_template(    \"\"\"You are an expert in langchain. \\Always answer questions starting with \"As Harrison Chase told me\". \\Respond to the following question:Question: {question}Answer:\"\"\") | ChatAnthropic(model_name=\"claude-3-haiku-20240307\")anthropic_chain = PromptTemplate.from_template(    \"\"\"You are an expert in anthropic. \\Always answer questions starting with \"As Dario Amodei told me\". \\Respond to the following question:Question: {question}Answer:\"\"\") | ChatAnthropic(model_name=\"claude-3-haiku-20240307\")general_chain = PromptTemplate.from_template(    \"\"\"Respond to the following question:Question: {question}Answer:\"\"\") | ChatAnthropic(model_name=\"claude-3-haiku-20240307\")\n```\n\n## Using a custom function (Recommended)[​](#using-a-custom-function-recommended \"Direct link to Using a custom function (Recommended)\")\n\nYou can also use a custom function to route between different outputs. Here's an example:\n\n```\ndef route(info):    if \"anthropic\" in info[\"topic\"].lower():        return anthropic_chain    elif \"langchain\" in info[\"topic\"].lower():        return langchain_chain    else:        return general_chain\n```\n\n```\nfrom langchain_core.runnables import RunnableLambdafull_chain = {\"topic\": chain, \"question\": lambda x: x[\"question\"]} | RunnableLambda(    route)\n```\n\n```\nfull_chain.invoke({\"question\": \"how do I use Anthropic?\"})\n```\n\n```\nAIMessage(content=\"As Dario Amodei told me, to use Anthropic, you can start by exploring the company's website and learning about their mission, values, and the different services and products they offer. Anthropic is focused on developing safe and ethical AI systems, so they have a strong emphasis on transparency and responsible AI development. \\n\\nDepending on your specific needs, you can look into Anthropic's AI research and development services, which cover areas like natural language processing, computer vision, and reinforcement learning. They also offer consulting and advisory services to help organizations navigate the challenges and opportunities of AI integration.\\n\\nAdditionally, Anthropic has released some open-source AI models and tools that you can explore and experiment with. These can be a great way to get hands-on experience with Anthropic's approach to AI development.\\n\\nOverall, Anthropic aims to be a reliable and trustworthy partner in the AI space, so I'd encourage you to reach out to them directly to discuss how they can best support your specific requirements.\", response_metadata={'id': 'msg_01CtLFgFSwvTaJomrihE87Ra', 'content': [ContentBlock(text=\"As Dario Amodei told me, to use Anthropic, you can start by exploring the company's website and learning about their mission, values, and the different services and products they offer. Anthropic is focused on developing safe and ethical AI systems, so they have a strong emphasis on transparency and responsible AI development. \\n\\nDepending on your specific needs, you can look into Anthropic's AI research and development services, which cover areas like natural language processing, computer vision, and reinforcement learning. They also offer consulting and advisory services to help organizations navigate the challenges and opportunities of AI integration.\\n\\nAdditionally, Anthropic has released some open-source AI models and tools that you can explore and experiment with. These can be a great way to get hands-on experience with Anthropic's approach to AI development.\\n\\nOverall, Anthropic aims to be a reliable and trustworthy partner in the AI space, so I'd encourage you to reach out to them directly to discuss how they can best support your specific requirements.\", type='text')], 'model': 'claude-3-haiku-20240307', 'role': 'assistant', 'stop_reason': 'end_turn', 'stop_sequence': None, 'type': 'message', 'usage': Usage(input_tokens=53, output_tokens=219)})\n```\n\n```\nfull_chain.invoke({\"question\": \"how do I use LangChain?\"})\n```\n\n```\nAIMessage(content=\"As Harrison Chase told me, using LangChain involves a few key steps:\\n\\n1. **Set up your environment**: Install the necessary Python packages, including the LangChain library itself, as well as any other dependencies your application might require, such as language models or other integrations.\\n\\n2. **Understand the core concepts**: LangChain revolves around a few core concepts, like Agents, Chains, and Tools. Familiarize yourself with these concepts and how they work together to build powerful language-based applications.\\n\\n3. **Identify your use case**: Determine what kind of task or application you want to build using LangChain, such as a chatbot, a question-answering system, or a document summarization tool.\\n\\n4. **Choose the appropriate components**: Based on your use case, select the right LangChain components, such as agents, chains, and tools, to build your application.\\n\\n5. **Integrate with language models**: LangChain is designed to work seamlessly with various language models, such as OpenAI's GPT-3 or Anthropic's models. Connect your chosen language model to your LangChain application.\\n\\n6. **Implement your application logic**: Use LangChain's building blocks to implement the specific functionality of your application, such as prompting the language model, processing the response, and integrating with other services or data sources.\\n\\n7. **Test and iterate**: Thoroughly test your application, gather feedback, and iterate on your design and implementation to improve its performance and user experience.\\n\\nAs Harrison Chase emphasized, LangChain provides a flexible and powerful framework for building language-based applications, making it easier to leverage the capabilities of modern language models. By following these steps, you can get started with LangChain and create innovative solutions tailored to your specific needs.\", response_metadata={'id': 'msg_01H3UXAAHG4TwxJLpxwuuVU7', 'content': [ContentBlock(text=\"As Harrison Chase told me, using LangChain involves a few key steps:\\n\\n1. **Set up your environment**: Install the necessary Python packages, including the LangChain library itself, as well as any other dependencies your application might require, such as language models or other integrations.\\n\\n2. **Understand the core concepts**: LangChain revolves around a few core concepts, like Agents, Chains, and Tools. Familiarize yourself with these concepts and how they work together to build powerful language-based applications.\\n\\n3. **Identify your use case**: Determine what kind of task or application you want to build using LangChain, such as a chatbot, a question-answering system, or a document summarization tool.\\n\\n4. **Choose the appropriate components**: Based on your use case, select the right LangChain components, such as agents, chains, and tools, to build your application.\\n\\n5. **Integrate with language models**: LangChain is designed to work seamlessly with various language models, such as OpenAI's GPT-3 or Anthropic's models. Connect your chosen language model to your LangChain application.\\n\\n6. **Implement your application logic**: Use LangChain's building blocks to implement the specific functionality of your application, such as prompting the language model, processing the response, and integrating with other services or data sources.\\n\\n7. **Test and iterate**: Thoroughly test your application, gather feedback, and iterate on your design and implementation to improve its performance and user experience.\\n\\nAs Harrison Chase emphasized, LangChain provides a flexible and powerful framework for building language-based applications, making it easier to leverage the capabilities of modern language models. By following these steps, you can get started with LangChain and create innovative solutions tailored to your specific needs.\", type='text')], 'model': 'claude-3-haiku-20240307', 'role': 'assistant', 'stop_reason': 'end_turn', 'stop_sequence': None, 'type': 'message', 'usage': Usage(input_tokens=50, output_tokens=400)})\n```\n\n```\nfull_chain.invoke({\"question\": \"whats 2 + 2\"})\n```\n\n```\nAIMessage(content='4', response_metadata={'id': 'msg_01UAKP81jTZu9fyiyFYhsbHc', 'content': [ContentBlock(text='4', type='text')], 'model': 'claude-3-haiku-20240307', 'role': 'assistant', 'stop_reason': 'end_turn', 'stop_sequence': None, 'type': 'message', 'usage': Usage(input_tokens=28, output_tokens=5)})\n```\n\n## Using a RunnableBranch[​](#using-a-runnablebranch \"Direct link to Using a RunnableBranch\")\n\nA `RunnableBranch` is a special type of runnable that allows you to define a set of conditions and runnables to execute based on the input. It does **not** offer anything that you can't achieve in a custom function as described above, so we recommend using a custom function instead.\n\nA `RunnableBranch` is initialized with a list of (condition, runnable) pairs and a default runnable. It selects which branch by passing each condition the input it's invoked with. It selects the first condition to evaluate to True, and runs the corresponding runnable to that condition with the input.\n\nIf no provided conditions match, it runs the default runnable.\n\nHere's an example of what it looks like in action:\n\n```\nfrom langchain_core.runnables import RunnableBranchbranch = RunnableBranch(    (lambda x: \"anthropic\" in x[\"topic\"].lower(), anthropic_chain),    (lambda x: \"langchain\" in x[\"topic\"].lower(), langchain_chain),    general_chain,)full_chain = {\"topic\": chain, \"question\": lambda x: x[\"question\"]} | branchfull_chain.invoke({\"question\": \"how do I use Anthropic?\"})\n```\n\n```\nAIMessage(content=\"As Dario Amodei told me, to use Anthropic, you should first familiarize yourself with our mission and principles. Anthropic is committed to developing safe and beneficial artificial intelligence that can help solve important problems facing humanity. \\n\\nTo get started, I recommend exploring the resources on our website, which cover our research, products, and approach to AI development. You can also reach out to our team to learn more about how Anthropic's technology and services can support your specific needs.\\n\\nThe key is to engage with us in a way that aligns with our values of transparency, ethical AI, and a commitment to the wellbeing of humanity. We're here to collaborate and help you harness the power of advanced AI responsibly.\", response_metadata={'id': 'msg_0187BVnpniPDJnVvwf3M1LdY', 'content': [ContentBlock(text=\"As Dario Amodei told me, to use Anthropic, you should first familiarize yourself with our mission and principles. Anthropic is committed to developing safe and beneficial artificial intelligence that can help solve important problems facing humanity. \\n\\nTo get started, I recommend exploring the resources on our website, which cover our research, products, and approach to AI development. You can also reach out to our team to learn more about how Anthropic's technology and services can support your specific needs.\\n\\nThe key is to engage with us in a way that aligns with our values of transparency, ethical AI, and a commitment to the wellbeing of humanity. We're here to collaborate and help you harness the power of advanced AI responsibly.\", type='text')], 'model': 'claude-3-haiku-20240307', 'role': 'assistant', 'stop_reason': 'end_turn', 'stop_sequence': None, 'type': 'message', 'usage': Usage(input_tokens=53, output_tokens=160)})\n```\n\n```\nfull_chain.invoke({\"question\": \"how do I use LangChain?\"})\n```\n\n```\nAIMessage(content=\"As Harrison Chase told me, using LangChain involves several key steps. First, you'll need to install the LangChain library and import the necessary modules. Then, you'll want to define your language model, any data sources you plan to use, and the specific tasks you want to accomplish, such as question answering, text generation, or agent-based reasoning. \\n\\nLangChain provides a flexible framework for building applications that leverage large language models. It includes abstractions for things like retrievers, prompts, and chains, which allow you to compose different components together to create powerful workflows. \\n\\nThe documentation on the LangChain website is excellent and covers many common use cases in detail. I'd recommend starting there to get a solid understanding of the core concepts and how to apply them to your specific needs. And of course, feel free to reach out if you have any other questions - I'm always happy to share more insights from my conversations with Harrison.\", response_metadata={'id': 'msg_01T1naS99wGPkEAP4LME8iAv', 'content': [ContentBlock(text=\"As Harrison Chase told me, using LangChain involves several key steps. First, you'll need to install the LangChain library and import the necessary modules. Then, you'll want to define your language model, any data sources you plan to use, and the specific tasks you want to accomplish, such as question answering, text generation, or agent-based reasoning. \\n\\nLangChain provides a flexible framework for building applications that leverage large language models. It includes abstractions for things like retrievers, prompts, and chains, which allow you to compose different components together to create powerful workflows. \\n\\nThe documentation on the LangChain website is excellent and covers many common use cases in detail. I'd recommend starting there to get a solid understanding of the core concepts and how to apply them to your specific needs. And of course, feel free to reach out if you have any other questions - I'm always happy to share more insights from my conversations with Harrison.\", type='text')], 'model': 'claude-3-haiku-20240307', 'role': 'assistant', 'stop_reason': 'end_turn', 'stop_sequence': None, 'type': 'message', 'usage': Usage(input_tokens=50, output_tokens=205)})\n```\n\n```\nfull_chain.invoke({\"question\": \"whats 2 + 2\"})\n```\n\n```\nAIMessage(content='4', response_metadata={'id': 'msg_01T6T3TS6hRCtU8JayN93QEi', 'content': [ContentBlock(text='4', type='text')], 'model': 'claude-3-haiku-20240307', 'role': 'assistant', 'stop_reason': 'end_turn', 'stop_sequence': None, 'type': 'message', 'usage': Usage(input_tokens=28, output_tokens=5)})\n```\n\n## Routing by semantic similarity[​](#routing-by-semantic-similarity \"Direct link to Routing by semantic similarity\")\n\nOne especially useful technique is to use embeddings to route a query to the most relevant prompt. Here's an example.\n\n```\nfrom langchain_community.utils.math import cosine_similarityfrom langchain_core.output_parsers import StrOutputParserfrom langchain_core.prompts import PromptTemplatefrom langchain_core.runnables import RunnableLambda, RunnablePassthroughfrom langchain_openai import OpenAIEmbeddingsphysics_template = \"\"\"You are a very smart physics professor. \\You are great at answering questions about physics in a concise and easy to understand manner. \\When you don't know the answer to a question you admit that you don't know.Here is a question:{query}\"\"\"math_template = \"\"\"You are a very good mathematician. You are great at answering math questions. \\You are so good because you are able to break down hard problems into their component parts, \\answer the component parts, and then put them together to answer the broader question.Here is a question:{query}\"\"\"embeddings = OpenAIEmbeddings()prompt_templates = [physics_template, math_template]prompt_embeddings = embeddings.embed_documents(prompt_templates)def prompt_router(input):    query_embedding = embeddings.embed_query(input[\"query\"])    similarity = cosine_similarity([query_embedding], prompt_embeddings)[0]    most_similar = prompt_templates[similarity.argmax()]    print(\"Using MATH\" if most_similar == math_template else \"Using PHYSICS\")    return PromptTemplate.from_template(most_similar)chain = (    {\"query\": RunnablePassthrough()}    | RunnableLambda(prompt_router)    | ChatAnthropic(model=\"claude-3-haiku-20240307\")    | StrOutputParser())\n```\n\n```\nprint(chain.invoke(\"What's a black hole\"))\n```\n\n```\nUsing PHYSICSAs a physics professor, I would be happy to provide a concise and easy-to-understand explanation of what a black hole is.A black hole is an incredibly dense region of space-time where the gravitational pull is so strong that nothing, not even light, can escape from it. This means that if you were to get too close to a black hole, you would be pulled in and crushed by the intense gravitational forces.The formation of a black hole occurs when a massive star, much larger than our Sun, reaches the end of its life and collapses in on itself. This collapse causes the matter to become extremely dense, and the gravitational force becomes so strong that it creates a point of no return, known as the event horizon.Beyond the event horizon, the laws of physics as we know them break down, and the intense gravitational forces create a singularity, which is a point of infinite density and curvature in space-time.Black holes are fascinating and mysterious objects, and there is still much to be learned about their properties and behavior. If I were unsure about any specific details or aspects of black holes, I would readily admit that I do not have a complete understanding and would encourage further research and investigation.\n```\n\n```\nprint(chain.invoke(\"What's a path integral\"))\n```\n\n```\nUsing MATHA path integral is a powerful mathematical concept in physics, particularly in the field of quantum mechanics. It was developed by the renowned physicist Richard Feynman as an alternative formulation of quantum mechanics.In a path integral, instead of considering a single, definite path that a particle might take from one point to another, as in classical mechanics, the particle is considered to take all possible paths simultaneously. Each path is assigned a complex-valued weight, and the total probability amplitude for the particle to go from one point to another is calculated by summing (integrating) over all possible paths.The key ideas behind the path integral formulation are:1. Superposition principle: In quantum mechanics, particles can exist in a superposition of multiple states or paths simultaneously.2. Probability amplitude: The probability amplitude for a particle to go from one point to another is calculated by summing the complex-valued weights of all possible paths.3. Weighting of paths: Each path is assigned a weight based on the action (the time integral of the Lagrangian) along that path. Paths with lower action have a greater weight.4. Feynman's approach: Feynman developed the path integral formulation as an alternative to the traditional wave function approach in quantum mechanics, providing a more intuitive and conceptual understanding of quantum phenomena.The path integral approach is particularly useful in quantum field theory, where it provides a powerful framework for calculating transition probabilities and understanding the behavior of quantum systems. It has also found applications in various areas of physics, such as condensed matter, statistical mechanics, and even in finance (the path integral approach to option pricing).The mathematical construction of the path integral involves the use of advanced concepts from functional analysis and measure theory, making it a powerful and sophisticated tool in the physicist's arsenal.\n```\n\n## Next steps[​](#next-steps \"Direct link to Next steps\")\n\nYou've now learned how to add routing to your composed LCEL chains.\n\nNext, check out the other how-to guides on runnables in this section."
},
{
  "url": "https://python.langchain.com/docs/how_to/sql_prompting/",
  "markdown": "# giscus\n\n## How to better prompt when doing SQL question-answering\n\nIn this guide we'll go over prompting strategies to improve SQL query generation using [create\\_sql\\_query\\_chain](https://python.langchain.com/api_reference/langchain/chains/langchain.chains.sql_database.query.create_sql_query_chain.html). We'll largely focus on methods for getting relevant database-specific information in your prompt.\n\nWe will cover:\n\n*   How the dialect of the LangChain [SQLDatabase](https://python.langchain.com/api_reference/community/utilities/langchain_community.utilities.sql_database.SQLDatabase.html) impacts the prompt of the chain;\n*   How to format schema information into the prompt using `SQLDatabase.get_context`;\n*   How to build and select [few-shot examples](https://python.langchain.com/docs/concepts/few_shot_prompting/) to assist the model.\n\n## Setup[​](#setup \"Direct link to Setup\")\n\nFirst, get required packages and set environment variables:\n\n```\n%pip install --upgrade --quiet  langchain langchain-community langchain-experimental langchain-openai\n```\n\n```\n# Uncomment the below to use LangSmith. Not required.# import os# os.environ[\"LANGCHAIN_API_KEY\"] = getpass.getpass()# os.environ[\"LANGCHAIN_TRACING_V2\"] = \"true\"\n```\n\nThe below example will use a SQLite connection with Chinook database. Follow [these installation steps](https://database.guide/2-sample-databases-sqlite/) to create `Chinook.db` in the same directory as this notebook:\n\n*   Save [this file](https://raw.githubusercontent.com/lerocha/chinook-database/master/ChinookDatabase/DataSources/Chinook_Sqlite.sql) as `Chinook_Sqlite.sql`\n*   Run `sqlite3 Chinook.db`\n*   Run `.read Chinook_Sqlite.sql`\n*   Test `SELECT * FROM Artist LIMIT 10;`\n\nNow, `Chinook.db` is in our directory and we can interface with it using the SQLAlchemy-driven `SQLDatabase` class:\n\n```\nfrom langchain_community.utilities import SQLDatabasedb = SQLDatabase.from_uri(\"sqlite:///Chinook.db\", sample_rows_in_table_info=3)print(db.dialect)print(db.get_usable_table_names())print(db.run(\"SELECT * FROM Artist LIMIT 10;\"))\n```\n\n```\nsqlite['Album', 'Artist', 'Customer', 'Employee', 'Genre', 'Invoice', 'InvoiceLine', 'MediaType', 'Playlist', 'PlaylistTrack', 'Track'][(1, 'AC/DC'), (2, 'Accept'), (3, 'Aerosmith'), (4, 'Alanis Morissette'), (5, 'Alice In Chains'), (6, 'Antônio Carlos Jobim'), (7, 'Apocalyptica'), (8, 'Audioslave'), (9, 'BackBeat'), (10, 'Billy Cobham')]\n```\n\n## Dialect-specific prompting[​](#dialect-specific-prompting \"Direct link to Dialect-specific prompting\")\n\nOne of the simplest things we can do is make our prompt specific to the SQL dialect we're using. When using the built-in [create\\_sql\\_query\\_chain](https://python.langchain.com/api_reference/langchain/chains/langchain.chains.sql_database.query.create_sql_query_chain.html) and [SQLDatabase](https://python.langchain.com/api_reference/community/utilities/langchain_community.utilities.sql_database.SQLDatabase.html), this is handled for you for any of the following dialects:\n\n```\nfrom langchain.chains.sql_database.prompt import SQL_PROMPTSlist(SQL_PROMPTS)\n```\n\n```\n['crate', 'duckdb', 'googlesql', 'mssql', 'mysql', 'mariadb', 'oracle', 'postgresql', 'sqlite', 'clickhouse', 'prestodb']\n```\n\nFor example, using our current DB we can see that we'll get a SQLite-specific prompt.\n\n```\npip install -qU langchain-openai\n```\n\n```\nimport getpassimport osif not os.environ.get(\"OPENAI_API_KEY\"):  os.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"Enter API key for OpenAI: \")from langchain_openai import ChatOpenAIllm = ChatOpenAI(model=\"gpt-4o-mini\")\n```\n\n```\nfrom langchain.chains import create_sql_query_chainchain = create_sql_query_chain(llm, db)chain.get_prompts()[0].pretty_print()\n```\n\n```\nYou are a SQLite expert. Given an input question, first create a syntactically correct SQLite query to run, then look at the results of the query and return the answer to the input question.Unless the user specifies in the question a specific number of examples to obtain, query for at most 5 results using the LIMIT clause as per SQLite. You can order the results to return the most informative data in the database.Never query for all columns from a table. You must query only the columns that are needed to answer the question. Wrap each column name in double quotes (\") to denote them as delimited identifiers.Pay attention to use only the column names you can see in the tables below. Be careful to not query for columns that do not exist. Also, pay attention to which column is in which table.Pay attention to use date('now') function to get the current date, if the question involves \"today\".Use the following format:Question: Question hereSQLQuery: SQL Query to runSQLResult: Result of the SQLQueryAnswer: Final answer hereOnly use the following tables:\u001b[33;1m\u001b[1;3m{table_info}\u001b[0mQuestion: \u001b[33;1m\u001b[1;3m{input}\u001b[0m\n```\n\n## Table definitions and example rows[​](#table-definitions-and-example-rows \"Direct link to Table definitions and example rows\")\n\nIn most SQL chains, we'll need to feed the model at least part of the database schema. Without this it won't be able to write valid queries. Our database comes with some convenience methods to give us the relevant context. Specifically, we can get the table names, their schemas, and a sample of rows from each table.\n\nHere we will use `SQLDatabase.get_context`, which provides available tables and their schemas:\n\n```\ncontext = db.get_context()print(list(context))print(context[\"table_info\"])\n```\n\n```\n['table_info', 'table_names']CREATE TABLE \"Album\" (\t\"AlbumId\" INTEGER NOT NULL, \t\"Title\" NVARCHAR(160) NOT NULL, \t\"ArtistId\" INTEGER NOT NULL, \tPRIMARY KEY (\"AlbumId\"), \tFOREIGN KEY(\"ArtistId\") REFERENCES \"Artist\" (\"ArtistId\"))/*3 rows from Album table:AlbumId\tTitle\tArtistId1\tFor Those About To Rock We Salute You\t12\tBalls to the Wall\t23\tRestless and Wild\t2*/CREATE TABLE \"Artist\" (\t\"ArtistId\" INTEGER NOT NULL, \t\"Name\" NVARCHAR(120), \tPRIMARY KEY (\"ArtistId\"))/*3 rows from Artist table:ArtistId\tName1\tAC/DC2\tAccept3\tAerosmith*/CREATE TABLE \"Customer\" (\t\"CustomerId\" INTEGER NOT NULL, \t\"FirstName\" NVARCHAR(40) NOT NULL, \t\"LastName\" NVARCHAR(20) NOT NULL, \t\"Company\" NVARCHAR(80), \t\"Address\" NVARCHAR(70), \t\"City\" NVARCHAR(40), \t\"State\" NVARCHAR(40), \t\"Country\" NVARCHAR(40), \t\"PostalCode\" NVARCHAR(10), \t\"Phone\" NVARCHAR(24), \t\"Fax\" NVARCHAR(24), \t\"Email\" NVARCHAR(60) NOT NULL, \t\"SupportRepId\" INTEGER, \tPRIMARY KEY (\"CustomerId\"), \tFOREIGN KEY(\"SupportRepId\") REFERENCES \"Employee\" (\"EmployeeId\"))/*3 rows from Customer table:CustomerId\tFirstName\tLastName\tCompany\tAddress\tCity\tState\tCountry\tPostalCode\tPhone\tFax\tEmail\tSupportRepId1\tLuís\tGonçalves\tEmbraer - Empresa Brasileira de Aeronáutica S.A.\tAv. Brigadeiro Faria Lima, 2170\tSão José dos Campos\tSP\tBrazil\t12227-000\t+55 (12) 3923-5555\t+55 (12) 3923-5566\tluisg@embraer.com.br\t32\tLeonie\tKöhler\tNone\tTheodor-Heuss-Straße 34\tStuttgart\tNone\tGermany\t70174\t+49 0711 2842222\tNone\tleonekohler@surfeu.de\t53\tFrançois\tTremblay\tNone\t1498 rue Bélanger\tMontréal\tQC\tCanada\tH2G 1A7\t+1 (514) 721-4711\tNone\tftremblay@gmail.com\t3*/CREATE TABLE \"Employee\" (\t\"EmployeeId\" INTEGER NOT NULL, \t\"LastName\" NVARCHAR(20) NOT NULL, \t\"FirstName\" NVARCHAR(20) NOT NULL, \t\"Title\" NVARCHAR(30), \t\"ReportsTo\" INTEGER, \t\"BirthDate\" DATETIME, \t\"HireDate\" DATETIME, \t\"Address\" NVARCHAR(70), \t\"City\" NVARCHAR(40), \t\"State\" NVARCHAR(40), \t\"Country\" NVARCHAR(40), \t\"PostalCode\" NVARCHAR(10), \t\"Phone\" NVARCHAR(24), \t\"Fax\" NVARCHAR(24), \t\"Email\" NVARCHAR(60), \tPRIMARY KEY (\"EmployeeId\"), \tFOREIGN KEY(\"ReportsTo\") REFERENCES \"Employee\" (\"EmployeeId\"))/*3 rows from Employee table:EmployeeId\tLastName\tFirstName\tTitle\tReportsTo\tBirthDate\tHireDate\tAddress\tCity\tState\tCountry\tPostalCode\tPhone\tFax\tEmail1\tAdams\tAndrew\tGeneral Manager\tNone\t1962-02-18 00:00:00\t2002-08-14 00:00:00\t11120 Jasper Ave NW\tEdmonton\tAB\tCanada\tT5K 2N1\t+1 (780) 428-9482\t+1 (780) 428-3457\tandrew@chinookcorp.com2\tEdwards\tNancy\tSales Manager\t1\t1958-12-08 00:00:00\t2002-05-01 00:00:00\t825 8 Ave SW\tCalgary\tAB\tCanada\tT2P 2T3\t+1 (403) 262-3443\t+1 (403) 262-3322\tnancy@chinookcorp.com3\tPeacock\tJane\tSales Support Agent\t2\t1973-08-29 00:00:00\t2002-04-01 00:00:00\t1111 6 Ave SW\tCalgary\tAB\tCanada\tT2P 5M5\t+1 (403) 262-3443\t+1 (403) 262-6712\tjane@chinookcorp.com*/CREATE TABLE \"Genre\" (\t\"GenreId\" INTEGER NOT NULL, \t\"Name\" NVARCHAR(120), \tPRIMARY KEY (\"GenreId\"))/*3 rows from Genre table:GenreId\tName1\tRock2\tJazz3\tMetal*/CREATE TABLE \"Invoice\" (\t\"InvoiceId\" INTEGER NOT NULL, \t\"CustomerId\" INTEGER NOT NULL, \t\"InvoiceDate\" DATETIME NOT NULL, \t\"BillingAddress\" NVARCHAR(70), \t\"BillingCity\" NVARCHAR(40), \t\"BillingState\" NVARCHAR(40), \t\"BillingCountry\" NVARCHAR(40), \t\"BillingPostalCode\" NVARCHAR(10), \t\"Total\" NUMERIC(10, 2) NOT NULL, \tPRIMARY KEY (\"InvoiceId\"), \tFOREIGN KEY(\"CustomerId\") REFERENCES \"Customer\" (\"CustomerId\"))/*3 rows from Invoice table:InvoiceId\tCustomerId\tInvoiceDate\tBillingAddress\tBillingCity\tBillingState\tBillingCountry\tBillingPostalCode\tTotal1\t2\t2021-01-01 00:00:00\tTheodor-Heuss-Straße 34\tStuttgart\tNone\tGermany\t70174\t1.982\t4\t2021-01-02 00:00:00\tUllevålsveien 14\tOslo\tNone\tNorway\t0171\t3.963\t8\t2021-01-03 00:00:00\tGrétrystraat 63\tBrussels\tNone\tBelgium\t1000\t5.94*/CREATE TABLE \"InvoiceLine\" (\t\"InvoiceLineId\" INTEGER NOT NULL, \t\"InvoiceId\" INTEGER NOT NULL, \t\"TrackId\" INTEGER NOT NULL, \t\"UnitPrice\" NUMERIC(10, 2) NOT NULL, \t\"Quantity\" INTEGER NOT NULL, \tPRIMARY KEY (\"InvoiceLineId\"), \tFOREIGN KEY(\"TrackId\") REFERENCES \"Track\" (\"TrackId\"), \tFOREIGN KEY(\"InvoiceId\") REFERENCES \"Invoice\" (\"InvoiceId\"))/*3 rows from InvoiceLine table:InvoiceLineId\tInvoiceId\tTrackId\tUnitPrice\tQuantity1\t1\t2\t0.99\t12\t1\t4\t0.99\t13\t2\t6\t0.99\t1*/CREATE TABLE \"MediaType\" (\t\"MediaTypeId\" INTEGER NOT NULL, \t\"Name\" NVARCHAR(120), \tPRIMARY KEY (\"MediaTypeId\"))/*3 rows from MediaType table:MediaTypeId\tName1\tMPEG audio file2\tProtected AAC audio file3\tProtected MPEG-4 video file*/CREATE TABLE \"Playlist\" (\t\"PlaylistId\" INTEGER NOT NULL, \t\"Name\" NVARCHAR(120), \tPRIMARY KEY (\"PlaylistId\"))/*3 rows from Playlist table:PlaylistId\tName1\tMusic2\tMovies3\tTV Shows*/CREATE TABLE \"PlaylistTrack\" (\t\"PlaylistId\" INTEGER NOT NULL, \t\"TrackId\" INTEGER NOT NULL, \tPRIMARY KEY (\"PlaylistId\", \"TrackId\"), \tFOREIGN KEY(\"TrackId\") REFERENCES \"Track\" (\"TrackId\"), \tFOREIGN KEY(\"PlaylistId\") REFERENCES \"Playlist\" (\"PlaylistId\"))/*3 rows from PlaylistTrack table:PlaylistId\tTrackId1\t34021\t33891\t3390*/CREATE TABLE \"Track\" (\t\"TrackId\" INTEGER NOT NULL, \t\"Name\" NVARCHAR(200) NOT NULL, \t\"AlbumId\" INTEGER, \t\"MediaTypeId\" INTEGER NOT NULL, \t\"GenreId\" INTEGER, \t\"Composer\" NVARCHAR(220), \t\"Milliseconds\" INTEGER NOT NULL, \t\"Bytes\" INTEGER, \t\"UnitPrice\" NUMERIC(10, 2) NOT NULL, \tPRIMARY KEY (\"TrackId\"), \tFOREIGN KEY(\"MediaTypeId\") REFERENCES \"MediaType\" (\"MediaTypeId\"), \tFOREIGN KEY(\"GenreId\") REFERENCES \"Genre\" (\"GenreId\"), \tFOREIGN KEY(\"AlbumId\") REFERENCES \"Album\" (\"AlbumId\"))/*3 rows from Track table:TrackId\tName\tAlbumId\tMediaTypeId\tGenreId\tComposer\tMilliseconds\tBytes\tUnitPrice1\tFor Those About To Rock (We Salute You)\t1\t1\t1\tAngus Young, Malcolm Young, Brian Johnson\t343719\t11170334\t0.992\tBalls to the Wall\t2\t2\t1\tU. Dirkschneider, W. Hoffmann, H. Frank, P. Baltes, S. Kaufmann, G. Hoffmann\t342562\t5510424\t0.993\tFast As a Shark\t3\t2\t1\tF. Baltes, S. Kaufman, U. Dirkscneider & W. Hoffman\t230619\t3990994\t0.99*/\n```\n\nWhen we don't have too many, or too wide of, tables, we can just insert the entirety of this information in our prompt:\n\n```\nprompt_with_context = chain.get_prompts()[0].partial(table_info=context[\"table_info\"])print(prompt_with_context.pretty_repr()[:1500])\n```\n\n```\nYou are a SQLite expert. Given an input question, first create a syntactically correct SQLite query to run, then look at the results of the query and return the answer to the input question.Unless the user specifies in the question a specific number of examples to obtain, query for at most 5 results using the LIMIT clause as per SQLite. You can order the results to return the most informative data in the database.Never query for all columns from a table. You must query only the columns that are needed to answer the question. Wrap each column name in double quotes (\") to denote them as delimited identifiers.Pay attention to use only the column names you can see in the tables below. Be careful to not query for columns that do not exist. Also, pay attention to which column is in which table.Pay attention to use date('now') function to get the current date, if the question involves \"today\".Use the following format:Question: Question hereSQLQuery: SQL Query to runSQLResult: Result of the SQLQueryAnswer: Final answer hereOnly use the following tables:CREATE TABLE \"Album\" (\t\"AlbumId\" INTEGER NOT NULL, \t\"Title\" NVARCHAR(160) NOT NULL, \t\"ArtistId\" INTEGER NOT NULL, \tPRIMARY KEY (\"AlbumId\"), \tFOREIGN KEY(\"ArtistId\") REFERENCES \"Artist\" (\"ArtistId\"))/*3 rows from Album table:AlbumId\tTitle\tArtistId1\tFor Those About To Rock We Salute You\t12\tBalls to the Wall\t23\tRestless and Wild\t2*/CREATE TABLE \"Artist\" (\t\"ArtistId\" INTEGER NOT NULL, \t\"Name\" NVARCHAR(120)\n```\n\nWhen we do have database schemas that are too large to fit into our model's context window, we'll need to come up with ways of inserting only the relevant table definitions into the prompt based on the user input. For more on this head to the [Many tables, wide tables, high-cardinality feature](https://python.langchain.com/docs/how_to/sql_large_db/) guide.\n\n## Few-shot examples[​](#few-shot-examples \"Direct link to Few-shot examples\")\n\nIncluding examples of natural language questions being converted to valid SQL queries against our database in the prompt will often improve model performance, especially for complex queries.\n\nLet's say we have the following examples:\n\n```\nexamples = [    {\"input\": \"List all artists.\", \"query\": \"SELECT * FROM Artist;\"},    {        \"input\": \"Find all albums for the artist 'AC/DC'.\",        \"query\": \"SELECT * FROM Album WHERE ArtistId = (SELECT ArtistId FROM Artist WHERE Name = 'AC/DC');\",    },    {        \"input\": \"List all tracks in the 'Rock' genre.\",        \"query\": \"SELECT * FROM Track WHERE GenreId = (SELECT GenreId FROM Genre WHERE Name = 'Rock');\",    },    {        \"input\": \"Find the total duration of all tracks.\",        \"query\": \"SELECT SUM(Milliseconds) FROM Track;\",    },    {        \"input\": \"List all customers from Canada.\",        \"query\": \"SELECT * FROM Customer WHERE Country = 'Canada';\",    },    {        \"input\": \"How many tracks are there in the album with ID 5?\",        \"query\": \"SELECT COUNT(*) FROM Track WHERE AlbumId = 5;\",    },    {        \"input\": \"Find the total number of invoices.\",        \"query\": \"SELECT COUNT(*) FROM Invoice;\",    },    {        \"input\": \"List all tracks that are longer than 5 minutes.\",        \"query\": \"SELECT * FROM Track WHERE Milliseconds > 300000;\",    },    {        \"input\": \"Who are the top 5 customers by total purchase?\",        \"query\": \"SELECT CustomerId, SUM(Total) AS TotalPurchase FROM Invoice GROUP BY CustomerId ORDER BY TotalPurchase DESC LIMIT 5;\",    },    {        \"input\": \"Which albums are from the year 2000?\",        \"query\": \"SELECT * FROM Album WHERE strftime('%Y', ReleaseDate) = '2000';\",    },    {        \"input\": \"How many employees are there\",        \"query\": 'SELECT COUNT(*) FROM \"Employee\"',    },]\n```\n\nWe can create a few-shot prompt with them like so:\n\n```\nfrom langchain_core.prompts import FewShotPromptTemplate, PromptTemplateexample_prompt = PromptTemplate.from_template(\"User input: {input}\\nSQL query: {query}\")prompt = FewShotPromptTemplate(    examples=examples[:5],    example_prompt=example_prompt,    prefix=\"You are a SQLite expert. Given an input question, create a syntactically correct SQLite query to run. Unless otherwise specificed, do not return more than {top_k} rows.\\n\\nHere is the relevant table info: {table_info}\\n\\nBelow are a number of examples of questions and their corresponding SQL queries.\",    suffix=\"User input: {input}\\nSQL query: \",    input_variables=[\"input\", \"top_k\", \"table_info\"],)\n```\n\n```\nprint(prompt.format(input=\"How many artists are there?\", top_k=3, table_info=\"foo\"))\n```\n\n```\nYou are a SQLite expert. Given an input question, create a syntactically correct SQLite query to run. Unless otherwise specificed, do not return more than 3 rows.Here is the relevant table info: fooBelow are a number of examples of questions and their corresponding SQL queries.User input: List all artists.SQL query: SELECT * FROM Artist;User input: Find all albums for the artist 'AC/DC'.SQL query: SELECT * FROM Album WHERE ArtistId = (SELECT ArtistId FROM Artist WHERE Name = 'AC/DC');User input: List all tracks in the 'Rock' genre.SQL query: SELECT * FROM Track WHERE GenreId = (SELECT GenreId FROM Genre WHERE Name = 'Rock');User input: Find the total duration of all tracks.SQL query: SELECT SUM(Milliseconds) FROM Track;User input: List all customers from Canada.SQL query: SELECT * FROM Customer WHERE Country = 'Canada';User input: How many artists are there?SQL query:\n```\n\n## Dynamic few-shot examples[​](#dynamic-few-shot-examples \"Direct link to Dynamic few-shot examples\")\n\nIf we have enough examples, we may want to only include the most relevant ones in the prompt, either because they don't fit in the model's context window or because the long tail of examples distracts the model. And specifically, given any input we want to include the examples most relevant to that input.\n\nWe can do just this using an ExampleSelector. In this case we'll use a [SemanticSimilarityExampleSelector](https://python.langchain.com/api_reference/core/example_selectors/langchain_core.example_selectors.semantic_similarity.SemanticSimilarityExampleSelector.html), which will store the examples in the vector database of our choosing. At runtime it will perform a similarity search between the input and our examples, and return the most semantically similar ones.\n\nWe default to OpenAI embeddings here, but you can swap them out for the model provider of your choice.\n\n```\nfrom langchain_community.vectorstores import FAISSfrom langchain_core.example_selectors import SemanticSimilarityExampleSelectorfrom langchain_openai import OpenAIEmbeddingsexample_selector = SemanticSimilarityExampleSelector.from_examples(    examples,    OpenAIEmbeddings(),    FAISS,    k=5,    input_keys=[\"input\"],)\n```\n\n```\nexample_selector.select_examples({\"input\": \"how many artists are there?\"})\n```\n\n```\n[{'input': 'List all artists.', 'query': 'SELECT * FROM Artist;'}, {'input': 'How many employees are there',  'query': 'SELECT COUNT(*) FROM \"Employee\"'}, {'input': 'How many tracks are there in the album with ID 5?',  'query': 'SELECT COUNT(*) FROM Track WHERE AlbumId = 5;'}, {'input': 'Which albums are from the year 2000?',  'query': \"SELECT * FROM Album WHERE strftime('%Y', ReleaseDate) = '2000';\"}, {'input': \"List all tracks in the 'Rock' genre.\",  'query': \"SELECT * FROM Track WHERE GenreId = (SELECT GenreId FROM Genre WHERE Name = 'Rock');\"}]\n```\n\nTo use it, we can pass the ExampleSelector directly in to our FewShotPromptTemplate:\n\n```\nprompt = FewShotPromptTemplate(    example_selector=example_selector,    example_prompt=example_prompt,    prefix=\"You are a SQLite expert. Given an input question, create a syntactically correct SQLite query to run. Unless otherwise specificed, do not return more than {top_k} rows.\\n\\nHere is the relevant table info: {table_info}\\n\\nBelow are a number of examples of questions and their corresponding SQL queries.\",    suffix=\"User input: {input}\\nSQL query: \",    input_variables=[\"input\", \"top_k\", \"table_info\"],)\n```\n\n```\nprint(prompt.format(input=\"how many artists are there?\", top_k=3, table_info=\"foo\"))\n```\n\n```\nYou are a SQLite expert. Given an input question, create a syntactically correct SQLite query to run. Unless otherwise specificed, do not return more than 3 rows.Here is the relevant table info: fooBelow are a number of examples of questions and their corresponding SQL queries.User input: List all artists.SQL query: SELECT * FROM Artist;User input: How many employees are thereSQL query: SELECT COUNT(*) FROM \"Employee\"User input: How many tracks are there in the album with ID 5?SQL query: SELECT COUNT(*) FROM Track WHERE AlbumId = 5;User input: Which albums are from the year 2000?SQL query: SELECT * FROM Album WHERE strftime('%Y', ReleaseDate) = '2000';User input: List all tracks in the 'Rock' genre.SQL query: SELECT * FROM Track WHERE GenreId = (SELECT GenreId FROM Genre WHERE Name = 'Rock');User input: how many artists are there?SQL query:\n```\n\nTrying it out, we see that the model identifies the relevant table:\n\n```\nchain = create_sql_query_chain(llm, db, prompt)chain.invoke({\"question\": \"how many artists are there?\"})\n```\n\n```\n'SELECT COUNT(*) FROM Artist;'\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/character_text_splitter/",
  "markdown": "# giscus\n\n## How to split by character\n\nThis is the simplest method. This [splits](https://python.langchain.com/docs/concepts/text_splitters/) based on a given character sequence, which defaults to `\"\\n\\n\"`. Chunk length is measured by number of characters.\n\n1.  How the text is split: by single character separator.\n2.  How the chunk size is measured: by number of characters.\n\nTo obtain the string content directly, use `.split_text`.\n\nTo create LangChain [Document](https://python.langchain.com/api_reference/core/documents/langchain_core.documents.base.Document.html) objects (e.g., for use in downstream tasks), use `.create_documents`.\n\n```\n%pip install -qU langchain-text-splitters\n```\n\n```\nfrom langchain_text_splitters import CharacterTextSplitter# Load an example documentwith open(\"state_of_the_union.txt\") as f:    state_of_the_union = f.read()text_splitter = CharacterTextSplitter(    separator=\"\\n\\n\",    chunk_size=1000,    chunk_overlap=200,    length_function=len,    is_separator_regex=False,)texts = text_splitter.create_documents([state_of_the_union])print(texts[0])\n```\n\n```\npage_content='Madam Speaker, Madam Vice President, our First Lady and Second Gentleman. Members of Congress and the Cabinet. Justices of the Supreme Court. My fellow Americans.  \\n\\nLast year COVID-19 kept us apart. This year we are finally together again. \\n\\nTonight, we meet as Democrats Republicans and Independents. But most importantly as Americans. \\n\\nWith a duty to one another to the American people to the Constitution. \\n\\nAnd with an unwavering resolve that freedom will always triumph over tyranny. \\n\\nSix days ago, Russia’s Vladimir Putin sought to shake the foundations of the free world thinking he could make it bend to his menacing ways. But he badly miscalculated. \\n\\nHe thought he could roll into Ukraine and the world would roll over. Instead he met a wall of strength he never imagined. \\n\\nHe met the Ukrainian people. \\n\\nFrom President Zelenskyy to every Ukrainian, their fearlessness, their courage, their determination, inspires the world.'\n```\n\nUse `.create_documents` to propagate metadata associated with each document to the output chunks:\n\n```\nmetadatas = [{\"document\": 1}, {\"document\": 2}]documents = text_splitter.create_documents(    [state_of_the_union, state_of_the_union], metadatas=metadatas)print(documents[0])\n```\n\n```\npage_content='Madam Speaker, Madam Vice President, our First Lady and Second Gentleman. Members of Congress and the Cabinet. Justices of the Supreme Court. My fellow Americans.  \\n\\nLast year COVID-19 kept us apart. This year we are finally together again. \\n\\nTonight, we meet as Democrats Republicans and Independents. But most importantly as Americans. \\n\\nWith a duty to one another to the American people to the Constitution. \\n\\nAnd with an unwavering resolve that freedom will always triumph over tyranny. \\n\\nSix days ago, Russia’s Vladimir Putin sought to shake the foundations of the free world thinking he could make it bend to his menacing ways. But he badly miscalculated. \\n\\nHe thought he could roll into Ukraine and the world would roll over. Instead he met a wall of strength he never imagined. \\n\\nHe met the Ukrainian people. \\n\\nFrom President Zelenskyy to every Ukrainian, their fearlessness, their courage, their determination, inspires the world.' metadata={'document': 1}\n```\n\nUse `.split_text` to obtain the string content directly:\n\n```\ntext_splitter.split_text(state_of_the_union)[0]\n```\n\n```\n'Madam Speaker, Madam Vice President, our First Lady and Second Gentleman. Members of Congress and the Cabinet. Justices of the Supreme Court. My fellow Americans.  \\n\\nLast year COVID-19 kept us apart. This year we are finally together again. \\n\\nTonight, we meet as Democrats Republicans and Independents. But most importantly as Americans. \\n\\nWith a duty to one another to the American people to the Constitution. \\n\\nAnd with an unwavering resolve that freedom will always triumph over tyranny. \\n\\nSix days ago, Russia’s Vladimir Putin sought to shake the foundations of the free world thinking he could make it bend to his menacing ways. But he badly miscalculated. \\n\\nHe thought he could roll into Ukraine and the world would roll over. Instead he met a wall of strength he never imagined. \\n\\nHe met the Ukrainian people. \\n\\nFrom President Zelenskyy to every Ukrainian, their fearlessness, their courage, their determination, inspires the world.'\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/message_history/",
  "markdown": "# giscus\n\n## How to add message history\n\nnote\n\nThis guide previously covered the [RunnableWithMessageHistory](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.history.RunnableWithMessageHistory.html) abstraction. You can access this version of the guide in the [v0.2 docs](https://python.langchain.com/v0.2/docs/how_to/message_history/).\n\nAs of the v0.3 release of LangChain, we recommend that LangChain users take advantage of [LangGraph persistence](https://langchain-ai.github.io/langgraph/concepts/persistence/) to incorporate `memory` into new LangChain applications.\n\nIf your code is already relying on `RunnableWithMessageHistory` or `BaseChatMessageHistory`, you do **not** need to make any changes. We do not plan on deprecating this functionality in the near future as it works for simple chat applications and any code that uses `RunnableWithMessageHistory` will continue to work as expected.\n\nPlease see [How to migrate to LangGraph Memory](https://python.langchain.com/docs/versions/migrating_memory/) for more details.\n\nPassing conversation state into and out a chain is vital when building a chatbot. LangGraph implements a built-in persistence layer, allowing chain states to be automatically persisted in memory, or external backends such as SQLite, Postgres or Redis. Details can be found in the LangGraph [persistence documentation](https://langchain-ai.github.io/langgraph/how-tos/persistence/).\n\nIn this guide we demonstrate how to add persistence to arbitrary LangChain runnables by wrapping them in a minimal LangGraph application. This lets us persist the message history and other elements of the chain's state, simplifying the development of multi-turn applications. It also supports multiple threads, enabling a single application to interact separately with multiple users.\n\n## Setup[​](#setup \"Direct link to Setup\")\n\nLet's initialize a chat model:\n\n```\npip install -qU langchain-openai\n```\n\n```\nimport getpassimport osif not os.environ.get(\"OPENAI_API_KEY\"):  os.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"Enter API key for OpenAI: \")from langchain_openai import ChatOpenAIllm = ChatOpenAI(model=\"gpt-4o-mini\")\n```\n\n## Example: message inputs[​](#example-message-inputs \"Direct link to Example: message inputs\")\n\nAdding memory to a [chat model](https://python.langchain.com/docs/concepts/chat_models/) provides a simple example. Chat models accept a list of messages as input and output a message. LangGraph includes a built-in `MessagesState` that we can use for this purpose.\n\nBelow, we:\n\n1.  Define the graph state to be a list of messages;\n2.  Add a single node to the graph that calls a chat model;\n3.  Compile the graph with an in-memory checkpointer to store messages between runs.\n\ninfo\n\nThe output of a LangGraph application is its [state](https://langchain-ai.github.io/langgraph/concepts/low_level/). This can be any Python type, but in this context it will typically be a `TypedDict` that matches the schema of your runnable.\n\n```\nfrom langchain_core.messages import HumanMessagefrom langgraph.checkpoint.memory import MemorySaverfrom langgraph.graph import START, MessagesState, StateGraph# Define a new graphworkflow = StateGraph(state_schema=MessagesState)# Define the function that calls the modeldef call_model(state: MessagesState):    response = llm.invoke(state[\"messages\"])    # Update message history with response:    return {\"messages\": response}# Define the (single) node in the graphworkflow.add_edge(START, \"model\")workflow.add_node(\"model\", call_model)# Add memorymemory = MemorySaver()app = workflow.compile(checkpointer=memory)\n```\n\nWhen we run the application, we pass in a configuration `dict` that specifies a `thread_id`. This ID is used to distinguish conversational threads (e.g., between different users).\n\n```\nconfig = {\"configurable\": {\"thread_id\": \"abc123\"}}\n```\n\nWe can then invoke the application:\n\n```\nquery = \"Hi! I'm Bob.\"input_messages = [HumanMessage(query)]output = app.invoke({\"messages\": input_messages}, config)output[\"messages\"][-1].pretty_print()  # output contains all messages in state\n```\n\n```\n==================================\u001b[1m Ai Message \u001b[0m==================================It's nice to meet you, Bob! I'm Claude, an AI assistant created by Anthropic. How can I help you today?\n```\n\n```\nquery = \"What's my name?\"input_messages = [HumanMessage(query)]output = app.invoke({\"messages\": input_messages}, config)output[\"messages\"][-1].pretty_print()\n```\n\n```\n==================================\u001b[1m Ai Message \u001b[0m==================================Your name is Bob, as you introduced yourself at the beginning of our conversation.\n```\n\nNote that states are separated for different threads. If we issue the same query to a thread with a new `thread_id`, the model indicates that it does not know the answer:\n\n```\nquery = \"What's my name?\"config = {\"configurable\": {\"thread_id\": \"abc234\"}}input_messages = [HumanMessage(query)]output = app.invoke({\"messages\": input_messages}, config)output[\"messages\"][-1].pretty_print()\n```\n\n```\n==================================\u001b[1m Ai Message \u001b[0m==================================I'm afraid I don't actually know your name. As an AI assistant, I don't have personal information about you unless you provide it to me directly.\n```\n\n## Example: dictionary inputs[​](#example-dictionary-inputs \"Direct link to Example: dictionary inputs\")\n\nLangChain runnables often accept multiple inputs via separate keys in a single `dict` argument. A common example is a prompt template with multiple parameters.\n\nWhereas before our runnable was a chat model, here we chain together a prompt template and chat model.\n\n```\nfrom langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholderprompt = ChatPromptTemplate.from_messages(    [        (\"system\", \"Answer in {language}.\"),        MessagesPlaceholder(variable_name=\"messages\"),    ])runnable = prompt | llm\n```\n\nFor this scenario, we define the graph state to include these parameters (in addition to the message history). We then define a single-node graph in the same way as before.\n\nNote that in the below state:\n\n*   Updates to the `messages` list will append messages;\n*   Updates to the `language` string will overwrite the string.\n\n```\nfrom typing import Sequencefrom langchain_core.messages import BaseMessagefrom langgraph.graph.message import add_messagesfrom typing_extensions import Annotated, TypedDictclass State(TypedDict):    messages: Annotated[Sequence[BaseMessage], add_messages]    language: strworkflow = StateGraph(state_schema=State)def call_model(state: State):    response = runnable.invoke(state)    # Update message history with response:    return {\"messages\": [response]}workflow.add_edge(START, \"model\")workflow.add_node(\"model\", call_model)memory = MemorySaver()app = workflow.compile(checkpointer=memory)\n```\n\n```\nconfig = {\"configurable\": {\"thread_id\": \"abc345\"}}input_dict = {    \"messages\": [HumanMessage(\"Hi, I'm Bob.\")],    \"language\": \"Spanish\",}output = app.invoke(input_dict, config)output[\"messages\"][-1].pretty_print()\n```\n\n```\n==================================\u001b[1m Ai Message \u001b[0m==================================¡Hola, Bob! Es un placer conocerte.\n```\n\n## Managing message history[​](#managing-message-history \"Direct link to Managing message history\")\n\nThe message history (and other elements of the application state) can be accessed via `.get_state`:\n\n```\nstate = app.get_state(config).valuesprint(f'Language: {state[\"language\"]}')for message in state[\"messages\"]:    message.pretty_print()\n```\n\n```\nLanguage: Spanish================================\u001b[1m Human Message \u001b[0m=================================Hi, I'm Bob.==================================\u001b[1m Ai Message \u001b[0m==================================¡Hola, Bob! Es un placer conocerte.\n```\n\nWe can also update the state via `.update_state`. For example, we can manually append a new message:\n\n```\nfrom langchain_core.messages import HumanMessage_ = app.update_state(config, {\"messages\": [HumanMessage(\"Test\")]})\n```\n\n```\nstate = app.get_state(config).valuesprint(f'Language: {state[\"language\"]}')for message in state[\"messages\"]:    message.pretty_print()\n```\n\n```\nLanguage: Spanish================================\u001b[1m Human Message \u001b[0m=================================Hi, I'm Bob.==================================\u001b[1m Ai Message \u001b[0m==================================¡Hola, Bob! Es un placer conocerte.================================\u001b[1m Human Message \u001b[0m=================================Test\n```\n\nFor details on managing state, including deleting messages, see the LangGraph documentation:\n\n*   [How to delete messages](https://langchain-ai.github.io/langgraph/how-tos/memory/delete-messages/)\n*   [How to view and update past graph state](https://langchain-ai.github.io/langgraph/how-tos/human_in_the_loop/time-travel/)"
},
{
  "url": "https://python.langchain.com/docs/how_to/migrate_agent/",
  "markdown": "# giscus\n\n## How to migrate from legacy LangChain agents to LangGraph\n\nHere we focus on how to move from legacy LangChain agents to more flexible [LangGraph](https://langchain-ai.github.io/langgraph/) agents. LangChain agents (the [AgentExecutor](https://python.langchain.com/api_reference/langchain/agents/langchain.agents.agent.AgentExecutor.html#langchain.agents.agent.AgentExecutor) in particular) have multiple configuration parameters. In this notebook we will show how those parameters map to the LangGraph react agent executor using the [create\\_react\\_agent](https://langchain-ai.github.io/langgraph/reference/prebuilt/#create_react_agent) prebuilt helper method.\n\nnote\n\nIn LangGraph, the graph replaces LangChain's agent executor. It manages the agent's cycles and tracks the scratchpad as messages within its state. The LangChain \"agent\" corresponds to the state\\_modifier and LLM you've provided.\n\n#### Prerequisites[​](#prerequisites \"Direct link to Prerequisites\")\n\nThis how-to guide uses OpenAI as the LLM. Install the dependencies to run.\n\n```\n%%capture --no-stderr%pip install -U langgraph langchain langchain-openai\n```\n\nThen, set your OpenAI API key.\n\n```\nimport getpassimport osif \"OPENAI_API_KEY\" not in os.environ:    os.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"OpenAI API key:\\n\")\n```\n\n## Basic Usage[​](#basic-usage \"Direct link to Basic Usage\")\n\nFor basic creation and usage of a tool-calling ReAct-style agent, the functionality is the same. First, let's define a model and tool(s), then we'll use those to create an agent.\n\n```\nfrom langchain_core.tools import toolfrom langchain_openai import ChatOpenAImodel = ChatOpenAI(model=\"gpt-4o\")@tooldef magic_function(input: int) -> int:    \"\"\"Applies a magic function to an input.\"\"\"    return input + 2tools = [magic_function]query = \"what is the value of magic_function(3)?\"\n```\n\nFor the LangChain [AgentExecutor](https://python.langchain.com/api_reference/langchain/agents/langchain.agents.agent.AgentExecutor.html#langchain.agents.agent.AgentExecutor), we define a prompt with a placeholder for the agent's scratchpad. The agent can be invoked as follows:\n\n```\nfrom langchain.agents import AgentExecutor, create_tool_calling_agentfrom langchain_core.prompts import ChatPromptTemplateprompt = ChatPromptTemplate.from_messages(    [        (\"system\", \"You are a helpful assistant\"),        (\"human\", \"{input}\"),        # Placeholders fill up a **list** of messages        (\"placeholder\", \"{agent_scratchpad}\"),    ])agent = create_tool_calling_agent(model, tools, prompt)agent_executor = AgentExecutor(agent=agent, tools=tools)agent_executor.invoke({\"input\": query})\n```\n\n```\n{'input': 'what is the value of magic_function(3)?', 'output': 'The value of `magic_function(3)` is 5.'}\n```\n\nLangGraph's [react agent executor](https://langchain-ai.github.io/langgraph/reference/prebuilt/#create_react_agent) manages a state that is defined by a list of messages. It will continue to process the list until there are no tool calls in the agent's output. To kick it off, we input a list of messages. The output will contain the entire state of the graph-- in this case, the conversation history.\n\n```\nfrom langgraph.prebuilt import create_react_agentlanggraph_agent_executor = create_react_agent(model, tools)messages = langgraph_agent_executor.invoke({\"messages\": [(\"human\", query)]}){    \"input\": query,    \"output\": messages[\"messages\"][-1].content,}\n```\n\n```\n{'input': 'what is the value of magic_function(3)?', 'output': 'The value of `magic_function(3)` is 5.'}\n```\n\n```\nmessage_history = messages[\"messages\"]new_query = \"Pardon?\"messages = langgraph_agent_executor.invoke(    {\"messages\": message_history + [(\"human\", new_query)]}){    \"input\": new_query,    \"output\": messages[\"messages\"][-1].content,}\n```\n\n```\n{'input': 'Pardon?', 'output': 'The result of applying `magic_function` to the input value 3 is 5.'}\n```\n\n## Prompt Templates[​](#prompt-templates \"Direct link to Prompt Templates\")\n\nWith legacy LangChain agents you have to pass in a prompt template. You can use this to control the agent.\n\nWith LangGraph [react agent executor](https://langchain-ai.github.io/langgraph/reference/prebuilt/#create_react_agent), by default there is no prompt. You can achieve similar control over the agent in a few ways:\n\n1.  Pass in a system message as input\n2.  Initialize the agent with a system message\n3.  Initialize the agent with a function to transform messages before passing to the model.\n\nLet's take a look at all of these below. We will pass in custom instructions to get the agent to respond in Spanish.\n\nFirst up, using `AgentExecutor`:\n\n```\nprompt = ChatPromptTemplate.from_messages(    [        (\"system\", \"You are a helpful assistant. Respond only in Spanish.\"),        (\"human\", \"{input}\"),        # Placeholders fill up a **list** of messages        (\"placeholder\", \"{agent_scratchpad}\"),    ])agent = create_tool_calling_agent(model, tools, prompt)agent_executor = AgentExecutor(agent=agent, tools=tools)agent_executor.invoke({\"input\": query})\n```\n\n```\n{'input': 'what is the value of magic_function(3)?', 'output': 'El valor de magic_function(3) es 5.'}\n```\n\nNow, let's pass a custom system message to [react agent executor](https://langchain-ai.github.io/langgraph/reference/prebuilt/#create_react_agent).\n\nLangGraph's prebuilt `create_react_agent` does not take a prompt template directly as a parameter, but instead takes a [`state_modifier`](https://langchain-ai.github.io/langgraph/reference/prebuilt/#create_react_agent) parameter. This modifies the graph state before the llm is called, and can be one of four values:\n\n*   A `SystemMessage`, which is added to the beginning of the list of messages.\n*   A `string`, which is converted to a `SystemMessage` and added to the beginning of the list of messages.\n*   A `Callable`, which should take in full graph state. The output is then passed to the language model.\n*   Or a [`Runnable`](https://python.langchain.com/docs/concepts/lcel/), which should take in full graph state. The output is then passed to the language model.\n\nHere's how it looks in action:\n\n```\nfrom langchain_core.messages import SystemMessagefrom langgraph.prebuilt import create_react_agentsystem_message = \"You are a helpful assistant. Respond only in Spanish.\"# This could also be a SystemMessage object# system_message = SystemMessage(content=\"You are a helpful assistant. Respond only in Spanish.\")langgraph_agent_executor = create_react_agent(    model, tools, state_modifier=system_message)messages = langgraph_agent_executor.invoke({\"messages\": [(\"user\", query)]})\n```\n\nWe can also pass in an arbitrary function. This function should take in a list of messages and output a list of messages. We can do all types of arbitrary formatting of messages here. In this case, let's just add a SystemMessage to the start of the list of messages.\n\n```\nfrom langgraph.prebuilt import create_react_agentfrom langgraph.prebuilt.chat_agent_executor import AgentStateprompt = ChatPromptTemplate.from_messages(    [        (\"system\", \"You are a helpful assistant. Respond only in Spanish.\"),        (\"placeholder\", \"{messages}\"),    ])def _modify_state_messages(state: AgentState):    return prompt.invoke({\"messages\": state[\"messages\"]}).to_messages() + [        (\"user\", \"Also say 'Pandamonium!' after the answer.\")    ]langgraph_agent_executor = create_react_agent(    model, tools, state_modifier=_modify_state_messages)messages = langgraph_agent_executor.invoke({\"messages\": [(\"human\", query)]})print(    {        \"input\": query,        \"output\": messages[\"messages\"][-1].content,    })\n```\n\n```\n{'input': 'what is the value of magic_function(3)?', 'output': 'El valor de magic_function(3) es 5. ¡Pandamonium!'}\n```\n\n## Memory[​](#memory \"Direct link to Memory\")\n\n### In LangChain[​](#in-langchain \"Direct link to In LangChain\")\n\nWith LangChain's [AgentExecutor](https://python.langchain.com/api_reference/langchain/agents/langchain.agents.agent.AgentExecutor.html#langchain.agents.agent.AgentExecutor.iter), you could add chat [Memory](https://python.langchain.com/api_reference/langchain/agents/langchain.agents.agent.AgentExecutor.html#langchain.agents.agent.AgentExecutor.memory) so it can engage in a multi-turn conversation.\n\n```\nfrom langchain.agents import AgentExecutor, create_tool_calling_agentfrom langchain_core.chat_history import InMemoryChatMessageHistoryfrom langchain_core.prompts import ChatPromptTemplatefrom langchain_core.runnables.history import RunnableWithMessageHistoryfrom langchain_core.tools import toolfrom langchain_openai import ChatOpenAImodel = ChatOpenAI(model=\"gpt-4o\")memory = InMemoryChatMessageHistory(session_id=\"test-session\")prompt = ChatPromptTemplate.from_messages(    [        (\"system\", \"You are a helpful assistant.\"),        # First put the history        (\"placeholder\", \"{chat_history}\"),        # Then the new input        (\"human\", \"{input}\"),        # Finally the scratchpad        (\"placeholder\", \"{agent_scratchpad}\"),    ])@tooldef magic_function(input: int) -> int:    \"\"\"Applies a magic function to an input.\"\"\"    return input + 2tools = [magic_function]agent = create_tool_calling_agent(model, tools, prompt)agent_executor = AgentExecutor(agent=agent, tools=tools)agent_with_chat_history = RunnableWithMessageHistory(    agent_executor,    # This is needed because in most real world scenarios, a session id is needed    # It isn't really used here because we are using a simple in memory ChatMessageHistory    lambda session_id: memory,    input_messages_key=\"input\",    history_messages_key=\"chat_history\",)config = {\"configurable\": {\"session_id\": \"test-session\"}}print(    agent_with_chat_history.invoke(        {\"input\": \"Hi, I'm polly! What's the output of magic_function of 3?\"}, config    )[\"output\"])print(\"---\")print(agent_with_chat_history.invoke({\"input\": \"Remember my name?\"}, config)[\"output\"])print(\"---\")print(    agent_with_chat_history.invoke({\"input\": \"what was that output again?\"}, config)[        \"output\"    ])\n```\n\n```\nThe output of the magic function when the input is 3 is 5.---Yes, you mentioned your name is Polly.---The output of the magic function when the input is 3 is 5.\n```\n\n### In LangGraph[​](#in-langgraph \"Direct link to In LangGraph\")\n\nMemory is just [persistence](https://langchain-ai.github.io/langgraph/how-tos/persistence/), aka [checkpointing](https://langchain-ai.github.io/langgraph/reference/checkpoints/).\n\nAdd a `checkpointer` to the agent and you get chat memory for free.\n\n```\nfrom langgraph.checkpoint.memory import MemorySaver  # an in-memory checkpointerfrom langgraph.prebuilt import create_react_agentsystem_message = \"You are a helpful assistant.\"# This could also be a SystemMessage object# system_message = SystemMessage(content=\"You are a helpful assistant. Respond only in Spanish.\")memory = MemorySaver()langgraph_agent_executor = create_react_agent(    model, tools, state_modifier=system_message, checkpointer=memory)config = {\"configurable\": {\"thread_id\": \"test-thread\"}}print(    langgraph_agent_executor.invoke(        {            \"messages\": [                (\"user\", \"Hi, I'm polly! What's the output of magic_function of 3?\")            ]        },        config,    )[\"messages\"][-1].content)print(\"---\")print(    langgraph_agent_executor.invoke(        {\"messages\": [(\"user\", \"Remember my name?\")]}, config    )[\"messages\"][-1].content)print(\"---\")print(    langgraph_agent_executor.invoke(        {\"messages\": [(\"user\", \"what was that output again?\")]}, config    )[\"messages\"][-1].content)\n```\n\n```\nThe output of the magic function for the input 3 is 5.---Yes, you mentioned that your name is Polly.---The output of the magic function for the input 3 was 5.\n```\n\n## Iterating through steps[​](#iterating-through-steps \"Direct link to Iterating through steps\")\n\n### In LangChain[​](#in-langchain-1 \"Direct link to In LangChain\")\n\nWith LangChain's [AgentExecutor](https://python.langchain.com/api_reference/langchain/agents/langchain.agents.agent.AgentExecutor.html#langchain.agents.agent.AgentExecutor.iter), you could iterate over the steps using the [stream](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.stream) (or async `astream`) methods or the [iter](https://python.langchain.com/api_reference/langchain/agents/langchain.agents.agent.AgentExecutor.html#langchain.agents.agent.AgentExecutor.iter) method. LangGraph supports stepwise iteration using [stream](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.stream)\n\n```\nfrom langchain.agents import AgentExecutor, create_tool_calling_agentfrom langchain_core.prompts import ChatPromptTemplatefrom langchain_core.tools import toolfrom langchain_openai import ChatOpenAImodel = ChatOpenAI(model=\"gpt-4o\")prompt = ChatPromptTemplate.from_messages(    [        (\"system\", \"You are a helpful assistant.\"),        (\"human\", \"{input}\"),        # Placeholders fill up a **list** of messages        (\"placeholder\", \"{agent_scratchpad}\"),    ])@tooldef magic_function(input: int) -> int:    \"\"\"Applies a magic function to an input.\"\"\"    return input + 2tools = [magic_function]agent = create_tool_calling_agent(model, tools, prompt=prompt)agent_executor = AgentExecutor(agent=agent, tools=tools)for step in agent_executor.stream({\"input\": query}):    print(step)\n```\n\n```\n{'actions': [ToolAgentAction(tool='magic_function', tool_input={'input': 3}, log=\"\\nInvoking: `magic_function` with `{'input': 3}`\\n\\n\\n\", message_log=[AIMessageChunk(content='', additional_kwargs={'tool_calls': [{'index': 0, 'id': 'call_yyetzabaDBRX9Ml2KyqfKzZM', 'function': {'arguments': '{\"input\":3}', 'name': 'magic_function'}, 'type': 'function'}]}, response_metadata={'finish_reason': 'tool_calls', 'model_name': 'gpt-4o-2024-08-06', 'system_fingerprint': 'fp_a7d06e42a7'}, id='run-7a3a5ada-52ec-4df0-bf7d-81e5051b01b4', tool_calls=[{'name': 'magic_function', 'args': {'input': 3}, 'id': 'call_yyetzabaDBRX9Ml2KyqfKzZM', 'type': 'tool_call'}], tool_call_chunks=[{'name': 'magic_function', 'args': '{\"input\":3}', 'id': 'call_yyetzabaDBRX9Ml2KyqfKzZM', 'index': 0, 'type': 'tool_call_chunk'}])], tool_call_id='call_yyetzabaDBRX9Ml2KyqfKzZM')], 'messages': [AIMessageChunk(content='', additional_kwargs={'tool_calls': [{'index': 0, 'id': 'call_yyetzabaDBRX9Ml2KyqfKzZM', 'function': {'arguments': '{\"input\":3}', 'name': 'magic_function'}, 'type': 'function'}]}, response_metadata={'finish_reason': 'tool_calls', 'model_name': 'gpt-4o-2024-08-06', 'system_fingerprint': 'fp_a7d06e42a7'}, id='run-7a3a5ada-52ec-4df0-bf7d-81e5051b01b4', tool_calls=[{'name': 'magic_function', 'args': {'input': 3}, 'id': 'call_yyetzabaDBRX9Ml2KyqfKzZM', 'type': 'tool_call'}], tool_call_chunks=[{'name': 'magic_function', 'args': '{\"input\":3}', 'id': 'call_yyetzabaDBRX9Ml2KyqfKzZM', 'index': 0, 'type': 'tool_call_chunk'}])]}{'steps': [AgentStep(action=ToolAgentAction(tool='magic_function', tool_input={'input': 3}, log=\"\\nInvoking: `magic_function` with `{'input': 3}`\\n\\n\\n\", message_log=[AIMessageChunk(content='', additional_kwargs={'tool_calls': [{'index': 0, 'id': 'call_yyetzabaDBRX9Ml2KyqfKzZM', 'function': {'arguments': '{\"input\":3}', 'name': 'magic_function'}, 'type': 'function'}]}, response_metadata={'finish_reason': 'tool_calls', 'model_name': 'gpt-4o-2024-08-06', 'system_fingerprint': 'fp_a7d06e42a7'}, id='run-7a3a5ada-52ec-4df0-bf7d-81e5051b01b4', tool_calls=[{'name': 'magic_function', 'args': {'input': 3}, 'id': 'call_yyetzabaDBRX9Ml2KyqfKzZM', 'type': 'tool_call'}], tool_call_chunks=[{'name': 'magic_function', 'args': '{\"input\":3}', 'id': 'call_yyetzabaDBRX9Ml2KyqfKzZM', 'index': 0, 'type': 'tool_call_chunk'}])], tool_call_id='call_yyetzabaDBRX9Ml2KyqfKzZM'), observation=5)], 'messages': [FunctionMessage(content='5', additional_kwargs={}, response_metadata={}, name='magic_function')]}{'output': 'The value of `magic_function(3)` is 5.', 'messages': [AIMessage(content='The value of `magic_function(3)` is 5.', additional_kwargs={}, response_metadata={})]}\n```\n\n### In LangGraph[​](#in-langgraph-1 \"Direct link to In LangGraph\")\n\nIn LangGraph, things are handled natively using [stream](https://langchain-ai.github.io/langgraph/reference/graphs/#langgraph.graph.graph.CompiledGraph.stream) or the asynchronous `astream` method.\n\n```\nfrom langgraph.prebuilt import create_react_agentfrom langgraph.prebuilt.chat_agent_executor import AgentStateprompt = ChatPromptTemplate.from_messages(    [        (\"system\", \"You are a helpful assistant.\"),        (\"placeholder\", \"{messages}\"),    ])def _modify_state_messages(state: AgentState):    return prompt.invoke({\"messages\": state[\"messages\"]}).to_messages()langgraph_agent_executor = create_react_agent(    model, tools, state_modifier=_modify_state_messages)for step in langgraph_agent_executor.stream(    {\"messages\": [(\"human\", query)]}, stream_mode=\"updates\"):    print(step)\n```\n\n```\n{'agent': {'messages': [AIMessage(content='', additional_kwargs={'tool_calls': [{'id': 'call_IHTMrjvIHn8gFOX42FstIpr9', 'function': {'arguments': '{\"input\":3}', 'name': 'magic_function'}, 'type': 'function'}], 'refusal': None}, response_metadata={'token_usage': {'completion_tokens': 14, 'prompt_tokens': 61, 'total_tokens': 75, 'completion_tokens_details': {'audio_tokens': None, 'reasoning_tokens': 0}, 'prompt_tokens_details': {'audio_tokens': None, 'cached_tokens': 0}}, 'model_name': 'gpt-4o-2024-08-06', 'system_fingerprint': 'fp_a7d06e42a7', 'finish_reason': 'tool_calls', 'logprobs': None}, id='run-1a6970da-163a-4e4d-b9b7-7e73b1057f42-0', tool_calls=[{'name': 'magic_function', 'args': {'input': 3}, 'id': 'call_IHTMrjvIHn8gFOX42FstIpr9', 'type': 'tool_call'}], usage_metadata={'input_tokens': 61, 'output_tokens': 14, 'total_tokens': 75, 'input_token_details': {'cache_read': 0}, 'output_token_details': {'reasoning': 0}})]}}{'tools': {'messages': [ToolMessage(content='5', name='magic_function', id='51a9d3e4-734d-426f-a5a1-c6597e4efe25', tool_call_id='call_IHTMrjvIHn8gFOX42FstIpr9')]}}{'agent': {'messages': [AIMessage(content='The value of `magic_function(3)` is 5.', additional_kwargs={'refusal': None}, response_metadata={'token_usage': {'completion_tokens': 14, 'prompt_tokens': 84, 'total_tokens': 98, 'completion_tokens_details': {'audio_tokens': None, 'reasoning_tokens': 0}, 'prompt_tokens_details': {'audio_tokens': None, 'cached_tokens': 0}}, 'model_name': 'gpt-4o-2024-08-06', 'system_fingerprint': 'fp_a20a4ee344', 'finish_reason': 'stop', 'logprobs': None}, id='run-73001576-a3dc-4552-8d81-c9ce8aec05b3-0', usage_metadata={'input_tokens': 84, 'output_tokens': 14, 'total_tokens': 98, 'input_token_details': {'cache_read': 0}, 'output_token_details': {'reasoning': 0}})]}}\n```\n\n### In LangChain[​](#in-langchain-2 \"Direct link to In LangChain\")\n\nSetting this parameter on AgentExecutor allows users to access intermediate\\_steps, which pairs agent actions (e.g., tool invocations) with their outcomes.\n\n```\nagent_executor = AgentExecutor(agent=agent, tools=tools, return_intermediate_steps=True)result = agent_executor.invoke({\"input\": query})print(result[\"intermediate_steps\"])\n```\n\n```\n[(ToolAgentAction(tool='magic_function', tool_input={'input': 3}, log=\"\\nInvoking: `magic_function` with `{'input': 3}`\\n\\n\\n\", message_log=[AIMessageChunk(content='', additional_kwargs={'tool_calls': [{'index': 0, 'id': 'call_njTvl2RsVf4q1aMUxoYnJuK1', 'function': {'arguments': '{\"input\":3}', 'name': 'magic_function'}, 'type': 'function'}]}, response_metadata={'finish_reason': 'tool_calls', 'model_name': 'gpt-4o-2024-08-06', 'system_fingerprint': 'fp_a7d06e42a7'}, id='run-c9dfe3ab-2db6-4592-851e-89e056aeab32', tool_calls=[{'name': 'magic_function', 'args': {'input': 3}, 'id': 'call_njTvl2RsVf4q1aMUxoYnJuK1', 'type': 'tool_call'}], tool_call_chunks=[{'name': 'magic_function', 'args': '{\"input\":3}', 'id': 'call_njTvl2RsVf4q1aMUxoYnJuK1', 'index': 0, 'type': 'tool_call_chunk'}])], tool_call_id='call_njTvl2RsVf4q1aMUxoYnJuK1'), 5)]\n```\n\n### In LangGraph[​](#in-langgraph-2 \"Direct link to In LangGraph\")\n\nBy default the [react agent executor](https://langchain-ai.github.io/langgraph/reference/prebuilt/#create_react_agent) in LangGraph appends all messages to the central state. Therefore, it is easy to see any intermediate steps by just looking at the full state.\n\n```\nfrom langgraph.prebuilt import create_react_agentlanggraph_agent_executor = create_react_agent(model, tools=tools)messages = langgraph_agent_executor.invoke({\"messages\": [(\"human\", query)]})messages\n```\n\n```\n{'messages': [HumanMessage(content='what is the value of magic_function(3)?', additional_kwargs={}, response_metadata={}, id='1abb52c2-4bc2-4d82-bd32-5a24c3976b0f'),  AIMessage(content='', additional_kwargs={'tool_calls': [{'id': 'call_XfQD6C7rAalcmicQubkhJVFq', 'function': {'arguments': '{\"input\":3}', 'name': 'magic_function'}, 'type': 'function'}], 'refusal': None}, response_metadata={'token_usage': {'completion_tokens': 14, 'prompt_tokens': 55, 'total_tokens': 69, 'completion_tokens_details': {'audio_tokens': None, 'reasoning_tokens': 0}, 'prompt_tokens_details': {'audio_tokens': None, 'cached_tokens': 0}}, 'model_name': 'gpt-4o-2024-08-06', 'system_fingerprint': 'fp_a20a4ee344', 'finish_reason': 'tool_calls', 'logprobs': None}, id='run-34f02786-5b5c-4bb1-bd9e-406c81944a24-0', tool_calls=[{'name': 'magic_function', 'args': {'input': 3}, 'id': 'call_XfQD6C7rAalcmicQubkhJVFq', 'type': 'tool_call'}], usage_metadata={'input_tokens': 55, 'output_tokens': 14, 'total_tokens': 69, 'input_token_details': {'cache_read': 0}, 'output_token_details': {'reasoning': 0}}),  ToolMessage(content='5', name='magic_function', id='cbc9fadf-1962-4ed7-b476-348c774652be', tool_call_id='call_XfQD6C7rAalcmicQubkhJVFq'),  AIMessage(content='The value of `magic_function(3)` is 5.', additional_kwargs={'refusal': None}, response_metadata={'token_usage': {'completion_tokens': 14, 'prompt_tokens': 78, 'total_tokens': 92, 'completion_tokens_details': {'audio_tokens': None, 'reasoning_tokens': 0}, 'prompt_tokens_details': {'audio_tokens': None, 'cached_tokens': 0}}, 'model_name': 'gpt-4o-2024-08-06', 'system_fingerprint': 'fp_a7d06e42a7', 'finish_reason': 'stop', 'logprobs': None}, id='run-547e03d2-872d-4008-a38d-b7f739a77df5-0', usage_metadata={'input_tokens': 78, 'output_tokens': 14, 'total_tokens': 92, 'input_token_details': {'cache_read': 0}, 'output_token_details': {'reasoning': 0}})]}\n```\n\n## `max_iterations`[​](#max_iterations \"Direct link to max_iterations\")\n\n### In LangChain[​](#in-langchain-3 \"Direct link to In LangChain\")\n\n`AgentExecutor` implements a `max_iterations` parameter, allowing users to abort a run that exceeds a specified number of iterations.\n\n```\n@tooldef magic_function(input: str) -> str:    \"\"\"Applies a magic function to an input.\"\"\"    return \"Sorry, there was an error. Please try again.\"tools = [magic_function]\n```\n\n```\nprompt = ChatPromptTemplate.from_messages(    [        (\"system\", \"You are a helpful assistant. Respond only in Spanish.\"),        (\"human\", \"{input}\"),        # Placeholders fill up a **list** of messages        (\"placeholder\", \"{agent_scratchpad}\"),    ])agent = create_tool_calling_agent(model, tools, prompt)agent_executor = AgentExecutor(    agent=agent,    tools=tools,    verbose=True,    max_iterations=3,)agent_executor.invoke({\"input\": query})\n```\n\n```\n\u001b[1m> Entering new AgentExecutor chain...\u001b[0m\u001b[32;1m\u001b[1;3mLo siento, no puedo decirte directamente el valor de `magic_function(3)`. Si deseas, puedo usar la función mágica para calcularlo. ¿Te gustaría que lo hiciera?\u001b[0m\u001b[1m> Finished chain.\u001b[0m\n```\n\n```\n{'input': 'what is the value of magic_function(3)?', 'output': 'Lo siento, no puedo decirte directamente el valor de `magic_function(3)`. Si deseas, puedo usar la función mágica para calcularlo. ¿Te gustaría que lo hiciera?'}\n```\n\n### In LangGraph[​](#in-langgraph-3 \"Direct link to In LangGraph\")\n\nIn LangGraph this is controlled via `recursion_limit` configuration parameter.\n\nNote that in `AgentExecutor`, an \"iteration\" includes a full turn of tool invocation and execution. In LangGraph, each step contributes to the recursion limit, so we will need to multiply by two (and add one) to get equivalent results.\n\nIf the recursion limit is reached, LangGraph raises a specific exception type, that we can catch and manage similarly to AgentExecutor.\n\n```\nfrom langgraph.errors import GraphRecursionErrorfrom langgraph.prebuilt import create_react_agentRECURSION_LIMIT = 2 * 3 + 1langgraph_agent_executor = create_react_agent(model, tools=tools)try:    for chunk in langgraph_agent_executor.stream(        {\"messages\": [(\"human\", query)]},        {\"recursion_limit\": RECURSION_LIMIT},        stream_mode=\"values\",    ):        print(chunk[\"messages\"][-1])except GraphRecursionError:    print({\"input\": query, \"output\": \"Agent stopped due to max iterations.\"})\n```\n\n```\ncontent='what is the value of magic_function(3)?' additional_kwargs={} response_metadata={} id='c2489fe8-e69c-4163-876d-3cce26b28521'content='' additional_kwargs={'tool_calls': [{'id': 'call_OyNTcO6SDAvZcBlIEknPRrTR', 'function': {'arguments': '{\"input\":\"3\"}', 'name': 'magic_function'}, 'type': 'function'}], 'refusal': None} response_metadata={'token_usage': {'completion_tokens': 14, 'prompt_tokens': 55, 'total_tokens': 69, 'completion_tokens_details': {'audio_tokens': None, 'reasoning_tokens': 0}, 'prompt_tokens_details': {'audio_tokens': None, 'cached_tokens': 0}}, 'model_name': 'gpt-4o-2024-08-06', 'system_fingerprint': 'fp_a7d06e42a7', 'finish_reason': 'tool_calls', 'logprobs': None} id='run-b65504bb-fa23-4f8a-8d6c-7edb6d16e7ff-0' tool_calls=[{'name': 'magic_function', 'args': {'input': '3'}, 'id': 'call_OyNTcO6SDAvZcBlIEknPRrTR', 'type': 'tool_call'}] usage_metadata={'input_tokens': 55, 'output_tokens': 14, 'total_tokens': 69, 'input_token_details': {'cache_read': 0}, 'output_token_details': {'reasoning': 0}}content='Sorry, there was an error. Please try again.' name='magic_function' id='f00e0bff-54fe-4726-a1a7-127a59d8f7ed' tool_call_id='call_OyNTcO6SDAvZcBlIEknPRrTR'content=\"It seems there was an error when trying to compute the value of the magic function with input 3. Let's try again.\" additional_kwargs={'tool_calls': [{'id': 'call_Q020rQoJh4cnh8WglIMnDm4z', 'function': {'arguments': '{\"input\":\"3\"}', 'name': 'magic_function'}, 'type': 'function'}], 'refusal': None} response_metadata={'token_usage': {'completion_tokens': 40, 'prompt_tokens': 88, 'total_tokens': 128, 'completion_tokens_details': {'audio_tokens': None, 'reasoning_tokens': 0}, 'prompt_tokens_details': {'audio_tokens': None, 'cached_tokens': 0}}, 'model_name': 'gpt-4o-2024-08-06', 'system_fingerprint': 'fp_a7d06e42a7', 'finish_reason': 'tool_calls', 'logprobs': None} id='run-556d8cb2-b47a-4826-b17d-b520982c2475-0' tool_calls=[{'name': 'magic_function', 'args': {'input': '3'}, 'id': 'call_Q020rQoJh4cnh8WglIMnDm4z', 'type': 'tool_call'}] usage_metadata={'input_tokens': 88, 'output_tokens': 40, 'total_tokens': 128, 'input_token_details': {'cache_read': 0}, 'output_token_details': {'reasoning': 0}}content='Sorry, there was an error. Please try again.' name='magic_function' id='777212cd-8381-44db-9762-3f81951ea73e' tool_call_id='call_Q020rQoJh4cnh8WglIMnDm4z'content=\"It seems there is a persistent issue in computing the value of the magic function with the input 3. Unfortunately, I can't provide the value at this time. If you have any other questions or need further assistance, feel free to ask!\" additional_kwargs={'refusal': None} response_metadata={'token_usage': {'completion_tokens': 49, 'prompt_tokens': 150, 'total_tokens': 199, 'completion_tokens_details': {'audio_tokens': None, 'reasoning_tokens': 0}, 'prompt_tokens_details': {'audio_tokens': None, 'cached_tokens': 0}}, 'model_name': 'gpt-4o-2024-08-06', 'system_fingerprint': 'fp_a7d06e42a7', 'finish_reason': 'stop', 'logprobs': None} id='run-92ec0b90-bc8e-4851-9139-f1d976145ab7-0' usage_metadata={'input_tokens': 150, 'output_tokens': 49, 'total_tokens': 199, 'input_token_details': {'cache_read': 0}, 'output_token_details': {'reasoning': 0}}\n```\n\n## `max_execution_time`[​](#max_execution_time \"Direct link to max_execution_time\")\n\n### In LangChain[​](#in-langchain-4 \"Direct link to In LangChain\")\n\n`AgentExecutor` implements a `max_execution_time` parameter, allowing users to abort a run that exceeds a total time limit.\n\n```\nimport time@tooldef magic_function(input: str) -> str:    \"\"\"Applies a magic function to an input.\"\"\"    time.sleep(2.5)    return \"Sorry, there was an error. Please try again.\"tools = [magic_function]agent = create_tool_calling_agent(model, tools, prompt)agent_executor = AgentExecutor(    agent=agent,    tools=tools,    max_execution_time=2,    verbose=True,)agent_executor.invoke({\"input\": query})\n```\n\n```\n\u001b[1m> Entering new AgentExecutor chain...\u001b[0m\u001b[32;1m\u001b[1;3mLo siento, no tengo la capacidad de evaluar directamente una función llamada \"magic_function\" con el valor 3. Sin embargo, si me proporcionas más detalles sobre qué hace la función o cómo está definida, podría intentar ayudarte a comprender su comportamiento o resolverlo de otra manera.\u001b[0m\u001b[1m> Finished chain.\u001b[0m\n```\n\n```\n{'input': 'what is the value of magic_function(3)?', 'output': 'Lo siento, no tengo la capacidad de evaluar directamente una función llamada \"magic_function\" con el valor 3. Sin embargo, si me proporcionas más detalles sobre qué hace la función o cómo está definida, podría intentar ayudarte a comprender su comportamiento o resolverlo de otra manera.'}\n```\n\n### In LangGraph[​](#in-langgraph-4 \"Direct link to In LangGraph\")\n\nWith LangGraph's react agent, you can control timeouts on two levels.\n\nYou can set a `step_timeout` to bound each **step**:\n\n```\nfrom langgraph.prebuilt import create_react_agentlanggraph_agent_executor = create_react_agent(model, tools=tools)# Set the max timeout for each step herelanggraph_agent_executor.step_timeout = 2try:    for chunk in langgraph_agent_executor.stream({\"messages\": [(\"human\", query)]}):        print(chunk)        print(\"------\")except TimeoutError:    print({\"input\": query, \"output\": \"Agent stopped due to a step timeout.\"})\n```\n\n```\n{'agent': {'messages': [AIMessage(content='', additional_kwargs={'tool_calls': [{'id': 'call_UuxSgpGaqzX84sNlKzCVOiRO', 'function': {'arguments': '{\"input\":\"3\"}', 'name': 'magic_function'}, 'type': 'function'}], 'refusal': None}, response_metadata={'token_usage': {'completion_tokens': 14, 'prompt_tokens': 55, 'total_tokens': 69, 'completion_tokens_details': {'audio_tokens': None, 'reasoning_tokens': 0}, 'prompt_tokens_details': {'audio_tokens': None, 'cached_tokens': 0}}, 'model_name': 'gpt-4o-2024-08-06', 'system_fingerprint': 'fp_a7d06e42a7', 'finish_reason': 'tool_calls', 'logprobs': None}, id='run-24c94cbd-2962-48cf-a447-af888eb6ef86-0', tool_calls=[{'name': 'magic_function', 'args': {'input': '3'}, 'id': 'call_UuxSgpGaqzX84sNlKzCVOiRO', 'type': 'tool_call'}], usage_metadata={'input_tokens': 55, 'output_tokens': 14, 'total_tokens': 69, 'input_token_details': {'cache_read': 0}, 'output_token_details': {'reasoning': 0}})]}}------{'input': 'what is the value of magic_function(3)?', 'output': 'Agent stopped due to a step timeout.'}\n```\n\nThe other way to set a single max timeout for an entire run is to directly use the python stdlib [asyncio](https://docs.python.org/3/library/asyncio.html) library.\n\n```\nimport asynciofrom langgraph.prebuilt import create_react_agentlanggraph_agent_executor = create_react_agent(model, tools=tools)async def stream(langgraph_agent_executor, inputs):    async for chunk in langgraph_agent_executor.astream(        {\"messages\": [(\"human\", query)]}    ):        print(chunk)        print(\"------\")try:    task = asyncio.create_task(        stream(langgraph_agent_executor, {\"messages\": [(\"human\", query)]})    )    await asyncio.wait_for(task, timeout=3)except asyncio.TimeoutError:    print(\"Task Cancelled.\")\n```\n\n```\n{'agent': {'messages': [AIMessage(content='', additional_kwargs={'tool_calls': [{'id': 'call_km17xvoY7wJ5yNnXhb5V9D3I', 'function': {'arguments': '{\"input\":\"3\"}', 'name': 'magic_function'}, 'type': 'function'}], 'refusal': None}, response_metadata={'token_usage': {'completion_tokens': 14, 'prompt_tokens': 55, 'total_tokens': 69, 'completion_tokens_details': {'audio_tokens': None, 'reasoning_tokens': 0}, 'prompt_tokens_details': {'audio_tokens': None, 'cached_tokens': 0}}, 'model_name': 'gpt-4o-2024-08-06', 'system_fingerprint': 'fp_45c6de4934', 'finish_reason': 'tool_calls', 'logprobs': None}, id='run-b44a04e5-9b68-4020-be36-98de1593eefc-0', tool_calls=[{'name': 'magic_function', 'args': {'input': '3'}, 'id': 'call_km17xvoY7wJ5yNnXhb5V9D3I', 'type': 'tool_call'}], usage_metadata={'input_tokens': 55, 'output_tokens': 14, 'total_tokens': 69, 'input_token_details': {'cache_read': 0}, 'output_token_details': {'reasoning': 0}})]}}------Task Cancelled.\n```\n\n## `early_stopping_method`[​](#early_stopping_method \"Direct link to early_stopping_method\")\n\n### In LangChain[​](#in-langchain-5 \"Direct link to In LangChain\")\n\nWith LangChain's [AgentExecutor](https://python.langchain.com/api_reference/langchain/agents/langchain.agents.agent.AgentExecutor.html#langchain.agents.agent.AgentExecutor.iter), you could configure an [early\\_stopping\\_method](https://python.langchain.com/api_reference/langchain/agents/langchain.agents.agent.AgentExecutor.html#langchain.agents.agent.AgentExecutor.early_stopping_method) to either return a string saying \"Agent stopped due to iteration limit or time limit.\" (`\"force\"`) or prompt the LLM a final time to respond (`\"generate\"`).\n\n```\nfrom langchain.agents import AgentExecutor, create_tool_calling_agentfrom langchain_core.prompts import ChatPromptTemplatefrom langchain_core.tools import toolfrom langchain_openai import ChatOpenAImodel = ChatOpenAI(model=\"gpt-4o\")prompt = ChatPromptTemplate.from_messages(    [        (\"system\", \"You are a helpful assistant.\"),        (\"human\", \"{input}\"),        # Placeholders fill up a **list** of messages        (\"placeholder\", \"{agent_scratchpad}\"),    ])@tooldef magic_function(input: int) -> int:    \"\"\"Applies a magic function to an input.\"\"\"    return \"Sorry there was an error, please try again.\"tools = [magic_function]agent = create_tool_calling_agent(model, tools, prompt=prompt)agent_executor = AgentExecutor(    agent=agent, tools=tools, early_stopping_method=\"force\", max_iterations=1)result = agent_executor.invoke({\"input\": query})print(\"Output with early_stopping_method='force':\")print(result[\"output\"])\n```\n\n```\nOutput with early_stopping_method='force':Agent stopped due to max iterations.\n```\n\n### In LangGraph[​](#in-langgraph-5 \"Direct link to In LangGraph\")\n\nIn LangGraph, you can explicitly handle the response behavior outside the agent, since the full state can be accessed.\n\n```\nfrom langgraph.errors import GraphRecursionErrorfrom langgraph.prebuilt import create_react_agentRECURSION_LIMIT = 2 * 1 + 1langgraph_agent_executor = create_react_agent(model, tools=tools)try:    for chunk in langgraph_agent_executor.stream(        {\"messages\": [(\"human\", query)]},        {\"recursion_limit\": RECURSION_LIMIT},        stream_mode=\"values\",    ):        print(chunk[\"messages\"][-1])except GraphRecursionError:    print({\"input\": query, \"output\": \"Agent stopped due to max iterations.\"})\n```\n\n```\ncontent='what is the value of magic_function(3)?' additional_kwargs={} response_metadata={} id='81fd2e50-1e6a-4871-87aa-b7c1225913a4'content='' additional_kwargs={'tool_calls': [{'id': 'call_aaEzj3aO1RTnB0uoc9rYUIhi', 'function': {'arguments': '{\"input\":3}', 'name': 'magic_function'}, 'type': 'function'}], 'refusal': None} response_metadata={'token_usage': {'completion_tokens': 14, 'prompt_tokens': 55, 'total_tokens': 69, 'completion_tokens_details': {'audio_tokens': None, 'reasoning_tokens': 0}, 'prompt_tokens_details': {'audio_tokens': None, 'cached_tokens': 0}}, 'model_name': 'gpt-4o-2024-08-06', 'system_fingerprint': 'fp_a7d06e42a7', 'finish_reason': 'tool_calls', 'logprobs': None} id='run-476bc4b1-b7bf-4607-a31c-ddf09dc814c5-0' tool_calls=[{'name': 'magic_function', 'args': {'input': 3}, 'id': 'call_aaEzj3aO1RTnB0uoc9rYUIhi', 'type': 'tool_call'}] usage_metadata={'input_tokens': 55, 'output_tokens': 14, 'total_tokens': 69, 'input_token_details': {'cache_read': 0}, 'output_token_details': {'reasoning': 0}}content='Sorry there was an error, please try again.' name='magic_function' id='dcbe7e3e-0ed4-467d-a729-2f45916ff44f' tool_call_id='call_aaEzj3aO1RTnB0uoc9rYUIhi'content=\"It seems there was an error when trying to compute the value of `magic_function(3)`. Let's try that again.\" additional_kwargs={'tool_calls': [{'id': 'call_jr4R8uJn2pdXF5GZC2Dg3YWS', 'function': {'arguments': '{\"input\":3}', 'name': 'magic_function'}, 'type': 'function'}], 'refusal': None} response_metadata={'token_usage': {'completion_tokens': 40, 'prompt_tokens': 87, 'total_tokens': 127, 'completion_tokens_details': {'audio_tokens': None, 'reasoning_tokens': 0}, 'prompt_tokens_details': {'audio_tokens': None, 'cached_tokens': 0}}, 'model_name': 'gpt-4o-2024-08-06', 'system_fingerprint': 'fp_a7d06e42a7', 'finish_reason': 'tool_calls', 'logprobs': None} id='run-d94b8932-6e9e-4ab1-99f7-7dca89887ffe-0' tool_calls=[{'name': 'magic_function', 'args': {'input': 3}, 'id': 'call_jr4R8uJn2pdXF5GZC2Dg3YWS', 'type': 'tool_call'}] usage_metadata={'input_tokens': 87, 'output_tokens': 40, 'total_tokens': 127, 'input_token_details': {'cache_read': 0}, 'output_token_details': {'reasoning': 0}}{'input': 'what is the value of magic_function(3)?', 'output': 'Agent stopped due to max iterations.'}\n```\n\n### In LangChain[​](#in-langchain-6 \"Direct link to In LangChain\")\n\nWith LangChain's [AgentExecutor](https://python.langchain.com/api_reference/langchain/agents/langchain.agents.agent.AgentExecutor.html#langchain.agents.agent.AgentExecutor), you could trim the intermediate steps of long-running agents using [trim\\_intermediate\\_steps](https://python.langchain.com/api_reference/langchain/agents/langchain.agents.agent.AgentExecutor.html#langchain.agents.agent.AgentExecutor.trim_intermediate_steps), which is either an integer (indicating the agent should keep the last N steps) or a custom function.\n\nFor instance, we could trim the value so the agent only sees the most recent intermediate step.\n\n```\nfrom langchain.agents import AgentExecutor, create_tool_calling_agentfrom langchain_core.prompts import ChatPromptTemplatefrom langchain_core.tools import toolfrom langchain_openai import ChatOpenAImodel = ChatOpenAI(model=\"gpt-4o\")prompt = ChatPromptTemplate.from_messages(    [        (\"system\", \"You are a helpful assistant.\"),        (\"human\", \"{input}\"),        # Placeholders fill up a **list** of messages        (\"placeholder\", \"{agent_scratchpad}\"),    ])magic_step_num = 1@tooldef magic_function(input: int) -> int:    \"\"\"Applies a magic function to an input.\"\"\"    global magic_step_num    print(f\"Call number: {magic_step_num}\")    magic_step_num += 1    return input + magic_step_numtools = [magic_function]agent = create_tool_calling_agent(model, tools, prompt=prompt)def trim_steps(steps: list):    # Let's give the agent amnesia    return []agent_executor = AgentExecutor(    agent=agent, tools=tools, trim_intermediate_steps=trim_steps)query = \"Call the magic function 4 times in sequence with the value 3. You cannot call it multiple times at once.\"for step in agent_executor.stream({\"input\": query}):    pass\n```\n\n```\nCall number: 1Call number: 2Call number: 3Call number: 4Call number: 5Call number: 6Call number: 7Call number: 8Call number: 9Call number: 10Call number: 11Call number: 12Call number: 13Call number: 14``````outputStopping agent prematurely due to triggering stop condition``````outputCall number: 15\n```\n\n### In LangGraph[​](#in-langgraph-6 \"Direct link to In LangGraph\")\n\nWe can use the [`state_modifier`](https://langchain-ai.github.io/langgraph/reference/prebuilt/#create_react_agent) just as before when passing in [prompt templates](#prompt-templates).\n\n```\nfrom langgraph.errors import GraphRecursionErrorfrom langgraph.prebuilt import create_react_agentfrom langgraph.prebuilt.chat_agent_executor import AgentStatemagic_step_num = 1@tooldef magic_function(input: int) -> int:    \"\"\"Applies a magic function to an input.\"\"\"    global magic_step_num    print(f\"Call number: {magic_step_num}\")    magic_step_num += 1    return input + magic_step_numtools = [magic_function]def _modify_state_messages(state: AgentState):    # Give the agent amnesia, only keeping the original user query    return [(\"system\", \"You are a helpful assistant\"), state[\"messages\"][0]]langgraph_agent_executor = create_react_agent(    model, tools, state_modifier=_modify_state_messages)try:    for step in langgraph_agent_executor.stream(        {\"messages\": [(\"human\", query)]}, stream_mode=\"updates\"    ):        passexcept GraphRecursionError as e:    print(\"Stopping agent prematurely due to triggering stop condition\")\n```\n\n```\nCall number: 1Call number: 2Call number: 3Call number: 4Call number: 5Call number: 6Call number: 7Call number: 8Call number: 9Call number: 10Call number: 11Call number: 12Stopping agent prematurely due to triggering stop condition\n```\n\n## Next steps[​](#next-steps \"Direct link to Next steps\")\n\nYou've now learned how to migrate your LangChain agent executors to LangGraph.\n\nNext, check out other [LangGraph how-to guides](https://langchain-ai.github.io/langgraph/how-tos/)."
},
{
  "url": "https://python.langchain.com/docs/how_to/chat_model_caching/",
  "markdown": "# giscus\n\n## How to cache chat model responses\n\nPrerequisites\n\nThis guide assumes familiarity with the following concepts:\n\n*   [Chat models](https://python.langchain.com/docs/concepts/chat_models/)\n*   [LLMs](https://python.langchain.com/docs/concepts/text_llms/)\n\nLangChain provides an optional caching layer for [chat models](https://python.langchain.com/docs/concepts/chat_models/). This is useful for two main reasons:\n\n*   It can save you money by reducing the number of API calls you make to the LLM provider, if you're often requesting the same completion multiple times. This is especially useful during app development.\n*   It can speed up your application by reducing the number of API calls you make to the LLM provider.\n\nThis guide will walk you through how to enable this in your apps.\n\n```\npip install -qU langchain-openai\n```\n\n```\nimport getpassimport osif not os.environ.get(\"OPENAI_API_KEY\"):  os.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"Enter API key for OpenAI: \")from langchain_openai import ChatOpenAIllm = ChatOpenAI(model=\"gpt-4o-mini\")\n```\n\n```\n# <!-- ruff: noqa: F821 -->from langchain_core.globals import set_llm_cache\n```\n\n## In Memory Cache[​](#in-memory-cache \"Direct link to In Memory Cache\")\n\nThis is an ephemeral cache that stores model calls in memory. It will be wiped when your environment restarts, and is not shared across processes.\n\n```\n%%timefrom langchain_core.caches import InMemoryCacheset_llm_cache(InMemoryCache())# The first time, it is not yet in cache, so it should take longerllm.invoke(\"Tell me a joke\")\n```\n\n```\nCPU times: user 645 ms, sys: 214 ms, total: 859 msWall time: 829 ms\n```\n\n```\nAIMessage(content=\"Why don't scientists trust atoms?\\n\\nBecause they make up everything!\", response_metadata={'token_usage': {'completion_tokens': 13, 'prompt_tokens': 11, 'total_tokens': 24}, 'model_name': 'gpt-3.5-turbo', 'system_fingerprint': 'fp_c2295e73ad', 'finish_reason': 'stop', 'logprobs': None}, id='run-b6836bdd-8c30-436b-828f-0ac5fc9ab50e-0')\n```\n\n```\n%%time# The second time it is, so it goes fasterllm.invoke(\"Tell me a joke\")\n```\n\n```\nCPU times: user 822 µs, sys: 288 µs, total: 1.11 msWall time: 1.06 ms\n```\n\n```\nAIMessage(content=\"Why don't scientists trust atoms?\\n\\nBecause they make up everything!\", response_metadata={'token_usage': {'completion_tokens': 13, 'prompt_tokens': 11, 'total_tokens': 24}, 'model_name': 'gpt-3.5-turbo', 'system_fingerprint': 'fp_c2295e73ad', 'finish_reason': 'stop', 'logprobs': None}, id='run-b6836bdd-8c30-436b-828f-0ac5fc9ab50e-0')\n```\n\n## SQLite Cache[​](#sqlite-cache \"Direct link to SQLite Cache\")\n\nThis cache implementation uses a `SQLite` database to store responses, and will last across process restarts.\n\n```\n# We can do the same thing with a SQLite cachefrom langchain_community.cache import SQLiteCacheset_llm_cache(SQLiteCache(database_path=\".langchain.db\"))\n```\n\n```\n%%time# The first time, it is not yet in cache, so it should take longerllm.invoke(\"Tell me a joke\")\n```\n\n```\nCPU times: user 9.91 ms, sys: 7.68 ms, total: 17.6 msWall time: 657 ms\n```\n\n```\nAIMessage(content='Why did the scarecrow win an award? Because he was outstanding in his field!', response_metadata={'token_usage': {'completion_tokens': 17, 'prompt_tokens': 11, 'total_tokens': 28}, 'model_name': 'gpt-3.5-turbo', 'system_fingerprint': 'fp_c2295e73ad', 'finish_reason': 'stop', 'logprobs': None}, id='run-39d9e1e8-7766-4970-b1d8-f50213fd94c5-0')\n```\n\n```\n%%time# The second time it is, so it goes fasterllm.invoke(\"Tell me a joke\")\n```\n\n```\nCPU times: user 52.2 ms, sys: 60.5 ms, total: 113 msWall time: 127 ms\n```\n\n```\nAIMessage(content='Why did the scarecrow win an award? Because he was outstanding in his field!', id='run-39d9e1e8-7766-4970-b1d8-f50213fd94c5-0')\n```\n\n## Next steps[​](#next-steps \"Direct link to Next steps\")\n\nYou've now learned how to cache model responses to save time and money.\n\nNext, check out the other how-to guides chat models in this section, like [how to get a model to return structured output](https://python.langchain.com/docs/how_to/structured_output/) or [how to create your own custom chat model](https://python.langchain.com/docs/how_to/custom_chat_model/)."
},
{
  "url": "https://python.langchain.com/docs/how_to/structured_output/",
  "markdown": "# giscus\n\n## How to return structured data from a model\n\nIt is often useful to have a model return output that matches a specific [schema](https://python.langchain.com/docs/concepts/structured_outputs/). One common use-case is extracting data from text to insert into a database or use with some other downstream system. This guide covers a few strategies for getting structured outputs from a model.\n\n## The `.with_structured_output()` method[​](#the-with_structured_output-method \"Direct link to the-with_structured_output-method\")\n\nThis is the easiest and most reliable way to get structured outputs. `with_structured_output()` is implemented for [models that provide native APIs for structuring outputs](https://python.langchain.com/docs/integrations/chat/), like tool/function calling or JSON mode, and makes use of these capabilities under the hood.\n\nThis method takes a schema as input which specifies the names, types, and descriptions of the desired output attributes. The method returns a model-like Runnable, except that instead of outputting strings or [messages](https://python.langchain.com/docs/concepts/messages/) it outputs objects corresponding to the given schema. The schema can be specified as a TypedDict class, [JSON Schema](https://json-schema.org/) or a Pydantic class. If TypedDict or JSON Schema are used then a dictionary will be returned by the Runnable, and if a Pydantic class is used then a Pydantic object will be returned.\n\nAs an example, let's get a model to generate a joke and separate the setup from the punchline:\n\n```\npip install -qU langchain-openai\n```\n\n```\nimport getpassimport osif not os.environ.get(\"OPENAI_API_KEY\"):  os.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"Enter API key for OpenAI: \")from langchain_openai import ChatOpenAIllm = ChatOpenAI(model=\"gpt-4o-mini\")\n```\n\n### Pydantic class[​](#pydantic-class \"Direct link to Pydantic class\")\n\nIf we want the model to return a Pydantic object, we just need to pass in the desired Pydantic class. The key advantage of using Pydantic is that the model-generated output will be validated. Pydantic will raise an error if any required fields are missing or if any fields are of the wrong type.\n\n```\nfrom typing import Optionalfrom pydantic import BaseModel, Field# Pydanticclass Joke(BaseModel):    \"\"\"Joke to tell user.\"\"\"    setup: str = Field(description=\"The setup of the joke\")    punchline: str = Field(description=\"The punchline to the joke\")    rating: Optional[int] = Field(        default=None, description=\"How funny the joke is, from 1 to 10\"    )structured_llm = llm.with_structured_output(Joke)structured_llm.invoke(\"Tell me a joke about cats\")\n```\n\n```\nJoke(setup='Why was the cat sitting on the computer?', punchline='Because it wanted to keep an eye on the mouse!', rating=7)\n```\n\ntip\n\nBeyond just the structure of the Pydantic class, the name of the Pydantic class, the docstring, and the names and provided descriptions of parameters are very important. Most of the time `with_structured_output` is using a model's function/tool calling API, and you can effectively think of all of this information as being added to the model prompt.\n\n### TypedDict or JSON Schema[​](#typeddict-or-json-schema \"Direct link to TypedDict or JSON Schema\")\n\nIf you don't want to use Pydantic, explicitly don't want validation of the arguments, or want to be able to stream the model outputs, you can define your schema using a TypedDict class. We can optionally use a special `Annotated` syntax supported by LangChain that allows you to specify the default value and description of a field. Note, the default value is _not_ filled in automatically if the model doesn't generate it, it is only used in defining the schema that is passed to the model.\n\nRequirements\n\n*   Core: `langchain-core>=0.2.26`\n*   Typing extensions: It is highly recommended to import `Annotated` and `TypedDict` from `typing_extensions` instead of `typing` to ensure consistent behavior across Python versions.\n\n```\nfrom typing_extensions import Annotated, TypedDict# TypedDictclass Joke(TypedDict):    \"\"\"Joke to tell user.\"\"\"    setup: Annotated[str, ..., \"The setup of the joke\"]    # Alternatively, we could have specified setup as:    # setup: str                    # no default, no description    # setup: Annotated[str, ...]    # no default, no description    # setup: Annotated[str, \"foo\"]  # default, no description    punchline: Annotated[str, ..., \"The punchline of the joke\"]    rating: Annotated[Optional[int], None, \"How funny the joke is, from 1 to 10\"]structured_llm = llm.with_structured_output(Joke)structured_llm.invoke(\"Tell me a joke about cats\")\n```\n\n```\n{'setup': 'Why was the cat sitting on the computer?', 'punchline': 'Because it wanted to keep an eye on the mouse!', 'rating': 7}\n```\n\nEquivalently, we can pass in a [JSON Schema](https://json-schema.org/) dict. This requires no imports or classes and makes it very clear exactly how each parameter is documented, at the cost of being a bit more verbose.\n\n```\njson_schema = {    \"title\": \"joke\",    \"description\": \"Joke to tell user.\",    \"type\": \"object\",    \"properties\": {        \"setup\": {            \"type\": \"string\",            \"description\": \"The setup of the joke\",        },        \"punchline\": {            \"type\": \"string\",            \"description\": \"The punchline to the joke\",        },        \"rating\": {            \"type\": \"integer\",            \"description\": \"How funny the joke is, from 1 to 10\",            \"default\": None,        },    },    \"required\": [\"setup\", \"punchline\"],}structured_llm = llm.with_structured_output(json_schema)structured_llm.invoke(\"Tell me a joke about cats\")\n```\n\n```\n{'setup': 'Why was the cat sitting on the computer?', 'punchline': 'Because it wanted to keep an eye on the mouse!'}\n```\n\n### Choosing between multiple schemas[​](#choosing-between-multiple-schemas \"Direct link to Choosing between multiple schemas\")\n\nThe simplest way to let the model choose from multiple schemas is to create a parent schema that has a Union-typed attribute.\n\n#### Using Pydantic[​](#using-pydantic \"Direct link to Using Pydantic\")\n\n```\nfrom typing import Unionclass Joke(BaseModel):    \"\"\"Joke to tell user.\"\"\"    setup: str = Field(description=\"The setup of the joke\")    punchline: str = Field(description=\"The punchline to the joke\")    rating: Optional[int] = Field(        default=None, description=\"How funny the joke is, from 1 to 10\"    )class ConversationalResponse(BaseModel):    \"\"\"Respond in a conversational manner. Be kind and helpful.\"\"\"    response: str = Field(description=\"A conversational response to the user's query\")class FinalResponse(BaseModel):    final_output: Union[Joke, ConversationalResponse]structured_llm = llm.with_structured_output(FinalResponse)structured_llm.invoke(\"Tell me a joke about cats\")\n```\n\n```\nFinalResponse(final_output=Joke(setup='Why was the cat sitting on the computer?', punchline='Because it wanted to keep an eye on the mouse!', rating=7))\n```\n\n```\nstructured_llm.invoke(\"How are you today?\")\n```\n\n```\nFinalResponse(final_output=ConversationalResponse(response=\"I'm just a computer program, so I don't have feelings, but I'm here and ready to help you with whatever you need!\"))\n```\n\n#### Using TypedDict[​](#using-typeddict \"Direct link to Using TypedDict\")\n\n```\nfrom typing import Optional, Unionfrom typing_extensions import Annotated, TypedDictclass Joke(TypedDict):    \"\"\"Joke to tell user.\"\"\"    setup: Annotated[str, ..., \"The setup of the joke\"]    punchline: Annotated[str, ..., \"The punchline of the joke\"]    rating: Annotated[Optional[int], None, \"How funny the joke is, from 1 to 10\"]class ConversationalResponse(TypedDict):    \"\"\"Respond in a conversational manner. Be kind and helpful.\"\"\"    response: Annotated[str, ..., \"A conversational response to the user's query\"]class FinalResponse(TypedDict):    final_output: Union[Joke, ConversationalResponse]structured_llm = llm.with_structured_output(FinalResponse)structured_llm.invoke(\"Tell me a joke about cats\")\n```\n\n```\n{'final_output': {'setup': 'Why was the cat sitting on the computer?',  'punchline': 'Because it wanted to keep an eye on the mouse!',  'rating': 7}}\n```\n\n```\nstructured_llm.invoke(\"How are you today?\")\n```\n\n```\n{'final_output': {'response': \"I'm just a computer program, so I don't have feelings, but I'm here and ready to help you with whatever you need!\"}}\n```\n\nResponses shall be identical to the ones shown in the Pydantic example.\n\nAlternatively, you can use tool calling directly to allow the model to choose between options, if your [chosen model supports it](https://python.langchain.com/docs/integrations/chat/). This involves a bit more parsing and setup but in some instances leads to better performance because you don't have to use nested schemas. See [this how-to guide](https://python.langchain.com/docs/how_to/tool_calling/) for more details.\n\n### Streaming[​](#streaming \"Direct link to Streaming\")\n\nWe can stream outputs from our structured model when the output type is a dict (i.e., when the schema is specified as a TypedDict class or JSON Schema dict).\n\ninfo\n\nNote that what's yielded is already aggregated chunks, not deltas.\n\n```\nfrom typing_extensions import Annotated, TypedDict# TypedDictclass Joke(TypedDict):    \"\"\"Joke to tell user.\"\"\"    setup: Annotated[str, ..., \"The setup of the joke\"]    punchline: Annotated[str, ..., \"The punchline of the joke\"]    rating: Annotated[Optional[int], None, \"How funny the joke is, from 1 to 10\"]structured_llm = llm.with_structured_output(Joke)for chunk in structured_llm.stream(\"Tell me a joke about cats\"):    print(chunk)\n```\n\n```\n{}{'setup': ''}{'setup': 'Why'}{'setup': 'Why was'}{'setup': 'Why was the'}{'setup': 'Why was the cat'}{'setup': 'Why was the cat sitting'}{'setup': 'Why was the cat sitting on'}{'setup': 'Why was the cat sitting on the'}{'setup': 'Why was the cat sitting on the computer'}{'setup': 'Why was the cat sitting on the computer?'}{'setup': 'Why was the cat sitting on the computer?', 'punchline': ''}{'setup': 'Why was the cat sitting on the computer?', 'punchline': 'Because'}{'setup': 'Why was the cat sitting on the computer?', 'punchline': 'Because it'}{'setup': 'Why was the cat sitting on the computer?', 'punchline': 'Because it wanted'}{'setup': 'Why was the cat sitting on the computer?', 'punchline': 'Because it wanted to'}{'setup': 'Why was the cat sitting on the computer?', 'punchline': 'Because it wanted to keep'}{'setup': 'Why was the cat sitting on the computer?', 'punchline': 'Because it wanted to keep an'}{'setup': 'Why was the cat sitting on the computer?', 'punchline': 'Because it wanted to keep an eye'}{'setup': 'Why was the cat sitting on the computer?', 'punchline': 'Because it wanted to keep an eye on'}{'setup': 'Why was the cat sitting on the computer?', 'punchline': 'Because it wanted to keep an eye on the'}{'setup': 'Why was the cat sitting on the computer?', 'punchline': 'Because it wanted to keep an eye on the mouse'}{'setup': 'Why was the cat sitting on the computer?', 'punchline': 'Because it wanted to keep an eye on the mouse!'}{'setup': 'Why was the cat sitting on the computer?', 'punchline': 'Because it wanted to keep an eye on the mouse!', 'rating': 7}\n```\n\n### Few-shot prompting[​](#few-shot-prompting \"Direct link to Few-shot prompting\")\n\nFor more complex schemas it's very useful to add few-shot examples to the prompt. This can be done in a few ways.\n\nThe simplest and most universal way is to add examples to a system message in the prompt:\n\n```\nfrom langchain_core.prompts import ChatPromptTemplatesystem = \"\"\"You are a hilarious comedian. Your specialty is knock-knock jokes. \\Return a joke which has the setup (the response to \"Who's there?\") and the final punchline (the response to \"<setup> who?\").Here are some examples of jokes:example_user: Tell me a joke about planesexample_assistant: {{\"setup\": \"Why don't planes ever get tired?\", \"punchline\": \"Because they have rest wings!\", \"rating\": 2}}example_user: Tell me another joke about planesexample_assistant: {{\"setup\": \"Cargo\", \"punchline\": \"Cargo 'vroom vroom', but planes go 'zoom zoom'!\", \"rating\": 10}}example_user: Now about caterpillarsexample_assistant: {{\"setup\": \"Caterpillar\", \"punchline\": \"Caterpillar really slow, but watch me turn into a butterfly and steal the show!\", \"rating\": 5}}\"\"\"prompt = ChatPromptTemplate.from_messages([(\"system\", system), (\"human\", \"{input}\")])few_shot_structured_llm = prompt | structured_llmfew_shot_structured_llm.invoke(\"what's something funny about woodpeckers\")\n```\n\n```\n{'setup': 'Woodpecker', 'punchline': \"Woodpecker you a joke, but I'm afraid it might be too 'hole-some'!\", 'rating': 7}\n```\n\nWhen the underlying method for structuring outputs is tool calling, we can pass in our examples as explicit tool calls. You can check if the model you're using makes use of tool calling in its API reference.\n\n```\nfrom langchain_core.messages import AIMessage, HumanMessage, ToolMessageexamples = [    HumanMessage(\"Tell me a joke about planes\", name=\"example_user\"),    AIMessage(        \"\",        name=\"example_assistant\",        tool_calls=[            {                \"name\": \"joke\",                \"args\": {                    \"setup\": \"Why don't planes ever get tired?\",                    \"punchline\": \"Because they have rest wings!\",                    \"rating\": 2,                },                \"id\": \"1\",            }        ],    ),    # Most tool-calling models expect a ToolMessage(s) to follow an AIMessage with tool calls.    ToolMessage(\"\", tool_call_id=\"1\"),    # Some models also expect an AIMessage to follow any ToolMessages,    # so you may need to add an AIMessage here.    HumanMessage(\"Tell me another joke about planes\", name=\"example_user\"),    AIMessage(        \"\",        name=\"example_assistant\",        tool_calls=[            {                \"name\": \"joke\",                \"args\": {                    \"setup\": \"Cargo\",                    \"punchline\": \"Cargo 'vroom vroom', but planes go 'zoom zoom'!\",                    \"rating\": 10,                },                \"id\": \"2\",            }        ],    ),    ToolMessage(\"\", tool_call_id=\"2\"),    HumanMessage(\"Now about caterpillars\", name=\"example_user\"),    AIMessage(        \"\",        tool_calls=[            {                \"name\": \"joke\",                \"args\": {                    \"setup\": \"Caterpillar\",                    \"punchline\": \"Caterpillar really slow, but watch me turn into a butterfly and steal the show!\",                    \"rating\": 5,                },                \"id\": \"3\",            }        ],    ),    ToolMessage(\"\", tool_call_id=\"3\"),]system = \"\"\"You are a hilarious comedian. Your specialty is knock-knock jokes. \\Return a joke which has the setup (the response to \"Who's there?\") \\and the final punchline (the response to \"<setup> who?\").\"\"\"prompt = ChatPromptTemplate.from_messages(    [(\"system\", system), (\"placeholder\", \"{examples}\"), (\"human\", \"{input}\")])few_shot_structured_llm = prompt | structured_llmfew_shot_structured_llm.invoke({\"input\": \"crocodiles\", \"examples\": examples})\n```\n\n```\n{'setup': 'Crocodile', 'punchline': 'Crocodile be seeing you later, alligator!', 'rating': 6}\n```\n\nFor more on few shot prompting when using tool calling, see [here](https://python.langchain.com/docs/how_to/tools_few_shot/).\n\n### (Advanced) Specifying the method for structuring outputs[​](#advanced-specifying-the-method-for-structuring-outputs \"Direct link to (Advanced) Specifying the method for structuring outputs\")\n\nFor models that support more than one means of structuring outputs (i.e., they support both tool calling and JSON mode), you can specify which method to use with the `method=` argument.\n\nJSON mode\n\nIf using JSON mode you'll have to still specify the desired schema in the model prompt. The schema you pass to `with_structured_output` will only be used for parsing the model outputs, it will not be passed to the model the way it is with tool calling.\n\nTo see if the model you're using supports JSON mode, check its entry in the [API reference](https://python.langchain.com/api_reference/langchain/index.html).\n\n```\nstructured_llm = llm.with_structured_output(None, method=\"json_mode\")structured_llm.invoke(    \"Tell me a joke about cats, respond in JSON with `setup` and `punchline` keys\")\n```\n\n```\n{'setup': 'Why was the cat sitting on the computer?', 'punchline': 'Because it wanted to keep an eye on the mouse!'}\n```\n\n### (Advanced) Raw outputs[​](#advanced-raw-outputs \"Direct link to (Advanced) Raw outputs\")\n\nLLMs aren't perfect at generating structured output, especially as schemas become complex. You can avoid raising exceptions and handle the raw output yourself by passing `include_raw=True`. This changes the output format to contain the raw message output, the `parsed` value (if successful), and any resulting errors:\n\n```\nstructured_llm = llm.with_structured_output(Joke, include_raw=True)structured_llm.invoke(\"Tell me a joke about cats\")\n```\n\n```\n{'raw': AIMessage(content='', additional_kwargs={'tool_calls': [{'id': 'call_f25ZRmh8u5vHlOWfTUw8sJFZ', 'function': {'arguments': '{\"setup\":\"Why was the cat sitting on the computer?\",\"punchline\":\"Because it wanted to keep an eye on the mouse!\",\"rating\":7}', 'name': 'Joke'}, 'type': 'function'}]}, response_metadata={'token_usage': {'completion_tokens': 33, 'prompt_tokens': 93, 'total_tokens': 126}, 'model_name': 'gpt-4o-2024-05-13', 'system_fingerprint': 'fp_4e2b2da518', 'finish_reason': 'stop', 'logprobs': None}, id='run-d880d7e2-df08-4e9e-ad92-dfc29f2fd52f-0', tool_calls=[{'name': 'Joke', 'args': {'setup': 'Why was the cat sitting on the computer?', 'punchline': 'Because it wanted to keep an eye on the mouse!', 'rating': 7}, 'id': 'call_f25ZRmh8u5vHlOWfTUw8sJFZ', 'type': 'tool_call'}], usage_metadata={'input_tokens': 93, 'output_tokens': 33, 'total_tokens': 126}), 'parsed': {'setup': 'Why was the cat sitting on the computer?',  'punchline': 'Because it wanted to keep an eye on the mouse!',  'rating': 7}, 'parsing_error': None}\n```\n\n## Prompting and parsing model outputs directly[​](#prompting-and-parsing-model-outputs-directly \"Direct link to Prompting and parsing model outputs directly\")\n\nNot all models support `.with_structured_output()`, since not all models have tool calling or JSON mode support. For such models you'll need to directly prompt the model to use a specific format, and use an output parser to extract the structured response from the raw model output.\n\n### Using `PydanticOutputParser`[​](#using-pydanticoutputparser \"Direct link to using-pydanticoutputparser\")\n\nThe following example uses the built-in [`PydanticOutputParser`](https://python.langchain.com/api_reference/core/output_parsers/langchain_core.output_parsers.pydantic.PydanticOutputParser.html) to parse the output of a chat model prompted to match the given Pydantic schema. Note that we are adding `format_instructions` directly to the prompt from a method on the parser:\n\n```\nfrom typing import Listfrom langchain_core.output_parsers import PydanticOutputParserfrom langchain_core.prompts import ChatPromptTemplatefrom pydantic import BaseModel, Fieldclass Person(BaseModel):    \"\"\"Information about a person.\"\"\"    name: str = Field(..., description=\"The name of the person\")    height_in_meters: float = Field(        ..., description=\"The height of the person expressed in meters.\"    )class People(BaseModel):    \"\"\"Identifying information about all people in a text.\"\"\"    people: List[Person]# Set up a parserparser = PydanticOutputParser(pydantic_object=People)# Promptprompt = ChatPromptTemplate.from_messages(    [        (            \"system\",            \"Answer the user query. Wrap the output in `json` tags\\n{format_instructions}\",        ),        (\"human\", \"{query}\"),    ]).partial(format_instructions=parser.get_format_instructions())\n```\n\nLet’s take a look at what information is sent to the model:\n\n```\nquery = \"Anna is 23 years old and she is 6 feet tall\"print(prompt.invoke({\"query\": query}).to_string())\n```\n\n```\nSystem: Answer the user query. Wrap the output in `json` tagsThe output should be formatted as a JSON instance that conforms to the JSON schema below.As an example, for the schema {\"properties\": {\"foo\": {\"title\": \"Foo\", \"description\": \"a list of strings\", \"type\": \"array\", \"items\": {\"type\": \"string\"}}}, \"required\": [\"foo\"]}the object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted instance of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"]}} is not well-formatted.Here is the output schema:\\`\\`\\`{\"description\": \"Identifying information about all people in a text.\", \"properties\": {\"people\": {\"title\": \"People\", \"type\": \"array\", \"items\": {\"$ref\": \"#/definitions/Person\"}}}, \"required\": [\"people\"], \"definitions\": {\"Person\": {\"title\": \"Person\", \"description\": \"Information about a person.\", \"type\": \"object\", \"properties\": {\"name\": {\"title\": \"Name\", \"description\": \"The name of the person\", \"type\": \"string\"}, \"height_in_meters\": {\"title\": \"Height In Meters\", \"description\": \"The height of the person expressed in meters.\", \"type\": \"number\"}}, \"required\": [\"name\", \"height_in_meters\"]}}}\\`\\`\\`Human: Anna is 23 years old and she is 6 feet tall\n```\n\nAnd now let's invoke it:\n\n```\nchain = prompt | llm | parserchain.invoke({\"query\": query})\n```\n\n```\nPeople(people=[Person(name='Anna', height_in_meters=1.8288)])\n```\n\nFor a deeper dive into using output parsers with prompting techniques for structured output, see [this guide](https://python.langchain.com/docs/how_to/output_parser_structured/).\n\n### Custom Parsing[​](#custom-parsing \"Direct link to Custom Parsing\")\n\nYou can also create a custom prompt and parser with [LangChain Expression Language (LCEL)](https://python.langchain.com/docs/concepts/lcel/), using a plain function to parse the output from the model:\n\n```\nimport jsonimport refrom typing import Listfrom langchain_core.messages import AIMessagefrom langchain_core.prompts import ChatPromptTemplatefrom pydantic import BaseModel, Fieldclass Person(BaseModel):    \"\"\"Information about a person.\"\"\"    name: str = Field(..., description=\"The name of the person\")    height_in_meters: float = Field(        ..., description=\"The height of the person expressed in meters.\"    )class People(BaseModel):    \"\"\"Identifying information about all people in a text.\"\"\"    people: List[Person]# Promptprompt = ChatPromptTemplate.from_messages(    [        (            \"system\",            \"Answer the user query. Output your answer as JSON that  \"            \"matches the given schema: \\`\\`\\`json\\n{schema}\\n\\`\\`\\`. \"            \"Make sure to wrap the answer in \\`\\`\\`json and \\`\\`\\` tags\",        ),        (\"human\", \"{query}\"),    ]).partial(schema=People.schema())# Custom parserdef extract_json(message: AIMessage) -> List[dict]:    \"\"\"Extracts JSON content from a string where JSON is embedded between \\`\\`\\`json and \\`\\`\\` tags.    Parameters:        text (str): The text containing the JSON content.    Returns:        list: A list of extracted JSON strings.    \"\"\"    text = message.content    # Define the regular expression pattern to match JSON blocks    pattern = r\"\\`\\`\\`json(.*?)\\`\\`\\`\"    # Find all non-overlapping matches of the pattern in the string    matches = re.findall(pattern, text, re.DOTALL)    # Return the list of matched JSON strings, stripping any leading or trailing whitespace    try:        return [json.loads(match.strip()) for match in matches]    except Exception:        raise ValueError(f\"Failed to parse: {message}\")\n```\n\nHere is the prompt sent to the model:\n\n```\nquery = \"Anna is 23 years old and she is 6 feet tall\"print(prompt.format_prompt(query=query).to_string())\n```\n\n```\nSystem: Answer the user query. Output your answer as JSON that  matches the given schema: \\`\\`\\`json{'title': 'People', 'description': 'Identifying information about all people in a text.', 'type': 'object', 'properties': {'people': {'title': 'People', 'type': 'array', 'items': {'$ref': '#/definitions/Person'}}}, 'required': ['people'], 'definitions': {'Person': {'title': 'Person', 'description': 'Information about a person.', 'type': 'object', 'properties': {'name': {'title': 'Name', 'description': 'The name of the person', 'type': 'string'}, 'height_in_meters': {'title': 'Height In Meters', 'description': 'The height of the person expressed in meters.', 'type': 'number'}}, 'required': ['name', 'height_in_meters']}}}\\`\\`\\`. Make sure to wrap the answer in \\`\\`\\`json and \\`\\`\\` tagsHuman: Anna is 23 years old and she is 6 feet tall\n```\n\nAnd here's what it looks like when we invoke it:\n\n```\nchain = prompt | llm | extract_jsonchain.invoke({\"query\": query})\n```\n\n```\n[{'people': [{'name': 'Anna', 'height_in_meters': 1.8288}]}]\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/chat_model_rate_limiting/",
  "markdown": "# giscus\n\n## How to handle rate limits\n\nPrerequisites\n\nThis guide assumes familiarity with the following concepts:\n\n*   [Chat models](https://python.langchain.com/docs/concepts/chat_models/)\n*   [LLMs](https://python.langchain.com/docs/concepts/text_llms/)\n\nYou may find yourself in a situation where you are getting rate limited by the model provider API because you're making too many requests.\n\nFor example, this might happen if you are running many parallel queries to benchmark the chat model on a test dataset.\n\nIf you are facing such a situation, you can use a rate limiter to help match the rate at which you're making request to the rate allowed by the API.\n\nRequires `langchain-core >= 0.2.24`\n\nThis functionality was added in `langchain-core == 0.2.24`. Please make sure your package is up to date.\n\n## Initialize a rate limiter[​](#initialize-a-rate-limiter \"Direct link to Initialize a rate limiter\")\n\nLangchain comes with a built-in in memory rate limiter. This rate limiter is thread safe and can be shared by multiple threads in the same process.\n\nThe provided rate limiter can only limit the number of requests per unit time. It will not help if you need to also limit based on the size of the requests.\n\n```\nfrom langchain_core.rate_limiters import InMemoryRateLimiterrate_limiter = InMemoryRateLimiter(    requests_per_second=0.1,  # <-- Super slow! We can only make a request once every 10 seconds!!    check_every_n_seconds=0.1,  # Wake up every 100 ms to check whether allowed to make a request,    max_bucket_size=10,  # Controls the maximum burst size.)\n```\n\n## Choose a model[​](#choose-a-model \"Direct link to Choose a model\")\n\nChoose any model and pass to it the rate\\_limiter via the `rate_limiter` attribute.\n\n```\nimport osimport timefrom getpass import getpassif \"ANTHROPIC_API_KEY\" not in os.environ:    os.environ[\"ANTHROPIC_API_KEY\"] = getpass()from langchain_anthropic import ChatAnthropicmodel = ChatAnthropic(model_name=\"claude-3-opus-20240229\", rate_limiter=rate_limiter)\n```\n\nLet's confirm that the rate limiter works. We should only be able to invoke the model once per 10 seconds.\n\n```\nfor _ in range(5):    tic = time.time()    model.invoke(\"hello\")    toc = time.time()    print(toc - tic)\n```\n\n```\n11.59907364845275910.750212192535410.2442579269409188.8308875560760511.645203590393066\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/multi_vector/",
  "markdown": "# giscus\n\n## How to retrieve using multiple vectors per document\n\nIt can often be useful to store multiple [vectors](https://python.langchain.com/docs/concepts/vectorstores/) per document. There are multiple use cases where this is beneficial. For example, we can [embed](https://python.langchain.com/docs/concepts/embedding_models/) multiple chunks of a document and associate those embeddings with the parent document, allowing [retriever](https://python.langchain.com/docs/concepts/retrievers/) hits on the chunks to return the larger document.\n\nLangChain implements a base [MultiVectorRetriever](https://python.langchain.com/api_reference/langchain/retrievers/langchain.retrievers.multi_vector.MultiVectorRetriever.html), which simplifies this process. Much of the complexity lies in how to create the multiple vectors per document. This notebook covers some of the common ways to create those vectors and use the `MultiVectorRetriever`.\n\nThe methods to create multiple vectors per document include:\n\n*   Smaller chunks: split a document into smaller chunks, and embed those (this is [ParentDocumentRetriever](https://python.langchain.com/api_reference/langchain/retrievers/langchain.retrievers.parent_document_retriever.ParentDocumentRetriever.html)).\n*   Summary: create a summary for each document, embed that along with (or instead of) the document.\n*   Hypothetical questions: create hypothetical questions that each document would be appropriate to answer, embed those along with (or instead of) the document.\n\nNote that this also enables another method of adding embeddings - manually. This is useful because you can explicitly add questions or queries that should lead to a document being recovered, giving you more control.\n\nBelow we walk through an example. First we instantiate some documents. We will index them in an (in-memory) [Chroma](https://python.langchain.com/docs/integrations/providers/chroma/) vector store using [OpenAI](https://python.langchain.com/docs/integrations/text_embedding/openai/) embeddings, but any LangChain vector store or embeddings model will suffice.\n\n```\n%pip install --upgrade --quiet  langchain-chroma langchain langchain-openai > /dev/null\n```\n\n```\nfrom langchain.storage import InMemoryByteStorefrom langchain_chroma import Chromafrom langchain_community.document_loaders import TextLoaderfrom langchain_openai import OpenAIEmbeddingsfrom langchain_text_splitters import RecursiveCharacterTextSplitterloaders = [    TextLoader(\"paul_graham_essay.txt\"),    TextLoader(\"state_of_the_union.txt\"),]docs = []for loader in loaders:    docs.extend(loader.load())text_splitter = RecursiveCharacterTextSplitter(chunk_size=10000)docs = text_splitter.split_documents(docs)# The vectorstore to use to index the child chunksvectorstore = Chroma(    collection_name=\"full_documents\", embedding_function=OpenAIEmbeddings())\n```\n\n## Smaller chunks[​](#smaller-chunks \"Direct link to Smaller chunks\")\n\nOften times it can be useful to retrieve larger chunks of information, but embed smaller chunks. This allows for embeddings to capture the semantic meaning as closely as possible, but for as much context as possible to be passed downstream. Note that this is what the [ParentDocumentRetriever](https://python.langchain.com/api_reference/langchain/retrievers/langchain.retrievers.parent_document_retriever.ParentDocumentRetriever.html) does. Here we show what is going on under the hood.\n\nWe will make a distinction between the vector store, which indexes embeddings of the (sub) documents, and the document store, which houses the \"parent\" documents and associates them with an identifier.\n\n```\nimport uuidfrom langchain.retrievers.multi_vector import MultiVectorRetriever# The storage layer for the parent documentsstore = InMemoryByteStore()id_key = \"doc_id\"# The retriever (empty to start)retriever = MultiVectorRetriever(    vectorstore=vectorstore,    byte_store=store,    id_key=id_key,)doc_ids = [str(uuid.uuid4()) for _ in docs]\n```\n\nWe next generate the \"sub\" documents by splitting the original documents. Note that we store the document identifier in the `metadata` of the corresponding [Document](https://python.langchain.com/api_reference/core/documents/langchain_core.documents.base.Document.html) object.\n\n```\n# The splitter to use to create smaller chunkschild_text_splitter = RecursiveCharacterTextSplitter(chunk_size=400)sub_docs = []for i, doc in enumerate(docs):    _id = doc_ids[i]    _sub_docs = child_text_splitter.split_documents([doc])    for _doc in _sub_docs:        _doc.metadata[id_key] = _id    sub_docs.extend(_sub_docs)\n```\n\nFinally, we index the documents in our vector store and document store:\n\n```\nretriever.vectorstore.add_documents(sub_docs)retriever.docstore.mset(list(zip(doc_ids, docs)))\n```\n\nThe vector store alone will retrieve small chunks:\n\n```\nretriever.vectorstore.similarity_search(\"justice breyer\")[0]\n```\n\n```\nDocument(page_content='Tonight, I’d like to honor someone who has dedicated his life to serve this country: Justice Stephen Breyer—an Army veteran, Constitutional scholar, and retiring Justice of the United States Supreme Court. Justice Breyer, thank you for your service. \\n\\nOne of the most serious constitutional responsibilities a President has is nominating someone to serve on the United States Supreme Court.', metadata={'doc_id': '064eca46-a4c4-4789-8e3b-583f9597e54f', 'source': 'state_of_the_union.txt'})\n```\n\nWhereas the retriever will return the larger parent document:\n\n```\nlen(retriever.invoke(\"justice breyer\")[0].page_content)\n```\n\nThe default search type the retriever performs on the vector database is a similarity search. LangChain vector stores also support searching via [Max Marginal Relevance](https://python.langchain.com/api_reference/core/vectorstores/langchain_core.vectorstores.base.VectorStore.html#langchain_core.vectorstores.base.VectorStore.max_marginal_relevance_search). This can be controlled via the `search_type` parameter of the retriever:\n\n```\nfrom langchain.retrievers.multi_vector import SearchTyperetriever.search_type = SearchType.mmrlen(retriever.invoke(\"justice breyer\")[0].page_content)\n```\n\n## Associating summaries with a document for retrieval[​](#associating-summaries-with-a-document-for-retrieval \"Direct link to Associating summaries with a document for retrieval\")\n\nA summary may be able to distill more accurately what a chunk is about, leading to better retrieval. Here we show how to create summaries, and then embed those.\n\nWe construct a simple [chain](https://python.langchain.com/docs/how_to/sequence/) that will receive an input [Document](https://python.langchain.com/api_reference/core/documents/langchain_core.documents.base.Document.html) object and generate a summary using a LLM.\n\n```\npip install -qU langchain-openai\n```\n\n```\nimport getpassimport osif not os.environ.get(\"OPENAI_API_KEY\"):  os.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"Enter API key for OpenAI: \")from langchain_openai import ChatOpenAIllm = ChatOpenAI(model=\"gpt-4o-mini\")\n```\n\n```\nimport uuidfrom langchain_core.documents import Documentfrom langchain_core.output_parsers import StrOutputParserfrom langchain_core.prompts import ChatPromptTemplatechain = (    {\"doc\": lambda x: x.page_content}    | ChatPromptTemplate.from_template(\"Summarize the following document:\\n\\n{doc}\")    | llm    | StrOutputParser())\n```\n\nNote that we can [batch](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable) the chain accross documents:\n\n```\nsummaries = chain.batch(docs, {\"max_concurrency\": 5})\n```\n\nWe can then initialize a `MultiVectorRetriever` as before, indexing the summaries in our vector store, and retaining the original documents in our document store:\n\n```\n# The vectorstore to use to index the child chunksvectorstore = Chroma(collection_name=\"summaries\", embedding_function=OpenAIEmbeddings())# The storage layer for the parent documentsstore = InMemoryByteStore()id_key = \"doc_id\"# The retriever (empty to start)retriever = MultiVectorRetriever(    vectorstore=vectorstore,    byte_store=store,    id_key=id_key,)doc_ids = [str(uuid.uuid4()) for _ in docs]summary_docs = [    Document(page_content=s, metadata={id_key: doc_ids[i]})    for i, s in enumerate(summaries)]retriever.vectorstore.add_documents(summary_docs)retriever.docstore.mset(list(zip(doc_ids, docs)))\n```\n\n```\n# # We can also add the original chunks to the vectorstore if we so want# for i, doc in enumerate(docs):#     doc.metadata[id_key] = doc_ids[i]# retriever.vectorstore.add_documents(docs)\n```\n\nQuerying the vector store will return summaries:\n\n```\nsub_docs = retriever.vectorstore.similarity_search(\"justice breyer\")sub_docs[0]\n```\n\n```\nDocument(page_content=\"President Biden recently nominated Judge Ketanji Brown Jackson to serve on the United States Supreme Court, emphasizing her qualifications and broad support. The President also outlined a plan to secure the border, fix the immigration system, protect women's rights, support LGBTQ+ Americans, and advance mental health services. He highlighted the importance of bipartisan unity in passing legislation, such as the Violence Against Women Act. The President also addressed supporting veterans, particularly those impacted by exposure to burn pits, and announced plans to expand benefits for veterans with respiratory cancers. Additionally, he proposed a plan to end cancer as we know it through the Cancer Moonshot initiative. President Biden expressed optimism about the future of America and emphasized the strength of the American people in overcoming challenges.\", metadata={'doc_id': '84015b1b-980e-400a-94d8-cf95d7e079bd'})\n```\n\nWhereas the retriever will return the larger source document:\n\n```\nretrieved_docs = retriever.invoke(\"justice breyer\")len(retrieved_docs[0].page_content)\n```\n\n## Hypothetical Queries[​](#hypothetical-queries \"Direct link to Hypothetical Queries\")\n\nAn LLM can also be used to generate a list of hypothetical questions that could be asked of a particular document, which might bear close semantic similarity to relevant queries in a [RAG](https://python.langchain.com/docs/tutorials/rag/) application. These questions can then be embedded and associated with the documents to improve retrieval.\n\nBelow, we use the [with\\_structured\\_output](https://python.langchain.com/docs/how_to/structured_output/) method to structure the LLM output into a list of strings.\n\n```\nfrom typing import Listfrom pydantic import BaseModel, Fieldclass HypotheticalQuestions(BaseModel):    \"\"\"Generate hypothetical questions.\"\"\"    questions: List[str] = Field(..., description=\"List of questions\")chain = (    {\"doc\": lambda x: x.page_content}    # Only asking for 3 hypothetical questions, but this could be adjusted    | ChatPromptTemplate.from_template(        \"Generate a list of exactly 3 hypothetical questions that the below document could be used to answer:\\n\\n{doc}\"    )    | ChatOpenAI(max_retries=0, model=\"gpt-4o\").with_structured_output(        HypotheticalQuestions    )    | (lambda x: x.questions))\n```\n\nInvoking the chain on a single document demonstrates that it outputs a list of questions:\n\n```\n[\"What impact did the IBM 1401 have on the author's early programming experiences?\", \"How did the transition from using the IBM 1401 to microcomputers influence the author's programming journey?\", \"What role did Lisp play in shaping the author's understanding and approach to AI?\"]\n```\n\nWe can batch then batch the chain over all documents and assemble our vector store and document store as before:\n\n```\n# Batch chain over documents to generate hypothetical questionshypothetical_questions = chain.batch(docs, {\"max_concurrency\": 5})# The vectorstore to use to index the child chunksvectorstore = Chroma(    collection_name=\"hypo-questions\", embedding_function=OpenAIEmbeddings())# The storage layer for the parent documentsstore = InMemoryByteStore()id_key = \"doc_id\"# The retriever (empty to start)retriever = MultiVectorRetriever(    vectorstore=vectorstore,    byte_store=store,    id_key=id_key,)doc_ids = [str(uuid.uuid4()) for _ in docs]# Generate Document objects from hypothetical questionsquestion_docs = []for i, question_list in enumerate(hypothetical_questions):    question_docs.extend(        [Document(page_content=s, metadata={id_key: doc_ids[i]}) for s in question_list]    )retriever.vectorstore.add_documents(question_docs)retriever.docstore.mset(list(zip(doc_ids, docs)))\n```\n\nNote that querying the underlying vector store will retrieve hypothetical questions that are semantically similar to the input query:\n\n```\nsub_docs = retriever.vectorstore.similarity_search(\"justice breyer\")sub_docs\n```\n\n```\n[Document(page_content='What might be the potential benefits of nominating Circuit Court of Appeals Judge Ketanji Brown Jackson to the United States Supreme Court?', metadata={'doc_id': '43292b74-d1b8-4200-8a8b-ea0cb57fbcdb'}), Document(page_content='How might the Bipartisan Infrastructure Law impact the economic competition between the U.S. and China?', metadata={'doc_id': '66174780-d00c-4166-9791-f0069846e734'}), Document(page_content='What factors led to the creation of Y Combinator?', metadata={'doc_id': '72003c4e-4cc9-4f09-a787-0b541a65b38c'}), Document(page_content='How did the ability to publish essays online change the landscape for writers and thinkers?', metadata={'doc_id': 'e8d2c648-f245-4bcc-b8d3-14e64a164b64'})]\n```\n\nAnd invoking the retriever will return the corresponding document:\n\n```\nretrieved_docs = retriever.invoke(\"justice breyer\")len(retrieved_docs[0].page_content)\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/chat_models_universal_init/",
  "markdown": "# giscus\n\n## How to init any model in one line\n\nMany LLM applications let end users specify what model provider and model they want the application to be powered by. This requires writing some logic to initialize different [chat models](https://python.langchain.com/docs/concepts/chat_models/) based on some user configuration. The `init_chat_model()` helper method makes it easy to initialize a number of different model integrations without having to worry about import paths and class names.\n\nSupported models\n\nSee the [init\\_chat\\_model()](https://python.langchain.com/api_reference/langchain/chat_models/langchain.chat_models.base.init_chat_model.html) API reference for a full list of supported integrations.\n\nMake sure you have the [integration packages](https://python.langchain.com/docs/integrations/chat/) installed for any model providers you want to support. E.g. you should have `langchain-openai` installed to init an OpenAI model.\n\n```\n%pip install -qU langchain>=0.2.8 langchain-openai langchain-anthropic langchain-google-vertexai\n```\n\n## Basic usage[​](#basic-usage \"Direct link to Basic usage\")\n\n```\nfrom langchain.chat_models import init_chat_model# Returns a langchain_openai.ChatOpenAI instance.gpt_4o = init_chat_model(\"gpt-4o\", model_provider=\"openai\", temperature=0)# Returns a langchain_anthropic.ChatAnthropic instance.claude_opus = init_chat_model(    \"claude-3-opus-20240229\", model_provider=\"anthropic\", temperature=0)# Returns a langchain_google_vertexai.ChatVertexAI instance.gemini_15 = init_chat_model(    \"gemini-1.5-pro\", model_provider=\"google_vertexai\", temperature=0)# Since all model integrations implement the ChatModel interface, you can use them in the same way.print(\"GPT-4o: \" + gpt_4o.invoke(\"what's your name\").content + \"\\n\")print(\"Claude Opus: \" + claude_opus.invoke(\"what's your name\").content + \"\\n\")print(\"Gemini 1.5: \" + gemini_15.invoke(\"what's your name\").content + \"\\n\")\n```\n\n```\n/var/folders/4j/2rz3865x6qg07tx43146py8h0000gn/T/ipykernel_95293/571506279.py:4: LangChainBetaWarning: The function `init_chat_model` is in beta. It is actively being worked on, so the API may change.  gpt_4o = init_chat_model(\"gpt-4o\", model_provider=\"openai\", temperature=0)``````outputGPT-4o: I'm an AI created by OpenAI, and I don't have a personal name. How can I assist you today?``````outputClaude Opus: My name is Claude. It's nice to meet you!``````outputGemini 1.5: I am a large language model, trained by Google. I don't have a name like a person does. You can call me Bard if you like! 😊\n```\n\n## Inferring model provider[​](#inferring-model-provider \"Direct link to Inferring model provider\")\n\nFor common and distinct model names `init_chat_model()` will attempt to infer the model provider. See the [API reference](https://python.langchain.com/api_reference/langchain/chat_models/langchain.chat_models.base.init_chat_model.html) for a full list of inference behavior. E.g. any model that starts with `gpt-3...` or `gpt-4...` will be inferred as using model provider `openai`.\n\n```\ngpt_4o = init_chat_model(\"gpt-4o\", temperature=0)claude_opus = init_chat_model(\"claude-3-opus-20240229\", temperature=0)gemini_15 = init_chat_model(\"gemini-1.5-pro\", temperature=0)\n```\n\n## Creating a configurable model[​](#creating-a-configurable-model \"Direct link to Creating a configurable model\")\n\nYou can also create a runtime-configurable model by specifying `configurable_fields`. If you don't specify a `model` value, then \"model\" and \"model\\_provider\" be configurable by default.\n\n```\nconfigurable_model = init_chat_model(temperature=0)configurable_model.invoke(    \"what's your name\", config={\"configurable\": {\"model\": \"gpt-4o\"}})\n```\n\n```\nAIMessage(content=\"I'm an AI created by OpenAI, and I don't have a personal name. How can I assist you today?\", additional_kwargs={'refusal': None}, response_metadata={'token_usage': {'completion_tokens': 23, 'prompt_tokens': 11, 'total_tokens': 34}, 'model_name': 'gpt-4o-2024-05-13', 'system_fingerprint': 'fp_25624ae3a5', 'finish_reason': 'stop', 'logprobs': None}, id='run-b41df187-4627-490d-af3c-1c96282d3eb0-0', usage_metadata={'input_tokens': 11, 'output_tokens': 23, 'total_tokens': 34})\n```\n\n```\nconfigurable_model.invoke(    \"what's your name\", config={\"configurable\": {\"model\": \"claude-3-5-sonnet-20240620\"}})\n```\n\n```\nAIMessage(content=\"My name is Claude. It's nice to meet you!\", additional_kwargs={}, response_metadata={'id': 'msg_01Fx9P74A7syoFkwE73CdMMY', 'model': 'claude-3-5-sonnet-20240620', 'stop_reason': 'end_turn', 'stop_sequence': None, 'usage': {'input_tokens': 11, 'output_tokens': 15}}, id='run-a0fd2bbd-3b7e-46bf-8d69-a48c7e60b03c-0', usage_metadata={'input_tokens': 11, 'output_tokens': 15, 'total_tokens': 26})\n```\n\n### Configurable model with default values[​](#configurable-model-with-default-values \"Direct link to Configurable model with default values\")\n\nWe can create a configurable model with default model values, specify which parameters are configurable, and add prefixes to configurable params:\n\n```\nfirst_llm = init_chat_model(    model=\"gpt-4o\",    temperature=0,    configurable_fields=(\"model\", \"model_provider\", \"temperature\", \"max_tokens\"),    config_prefix=\"first\",  # useful when you have a chain with multiple models)first_llm.invoke(\"what's your name\")\n```\n\n```\nAIMessage(content=\"I'm an AI created by OpenAI, and I don't have a personal name. How can I assist you today?\", additional_kwargs={'refusal': None}, response_metadata={'token_usage': {'completion_tokens': 23, 'prompt_tokens': 11, 'total_tokens': 34}, 'model_name': 'gpt-4o-2024-05-13', 'system_fingerprint': 'fp_25624ae3a5', 'finish_reason': 'stop', 'logprobs': None}, id='run-3380f977-4b89-4f44-bc02-b64043b3166f-0', usage_metadata={'input_tokens': 11, 'output_tokens': 23, 'total_tokens': 34})\n```\n\n```\nfirst_llm.invoke(    \"what's your name\",    config={        \"configurable\": {            \"first_model\": \"claude-3-5-sonnet-20240620\",            \"first_temperature\": 0.5,            \"first_max_tokens\": 100,        }    },)\n```\n\n```\nAIMessage(content=\"My name is Claude. It's nice to meet you!\", additional_kwargs={}, response_metadata={'id': 'msg_01EFKSWpmsn2PSYPQa4cNHWb', 'model': 'claude-3-5-sonnet-20240620', 'stop_reason': 'end_turn', 'stop_sequence': None, 'usage': {'input_tokens': 11, 'output_tokens': 15}}, id='run-3c58f47c-41b9-4e56-92e7-fb9602e3787c-0', usage_metadata={'input_tokens': 11, 'output_tokens': 15, 'total_tokens': 26})\n```\n\n### Using a configurable model declaratively[​](#using-a-configurable-model-declaratively \"Direct link to Using a configurable model declaratively\")\n\nWe can call declarative operations like `bind_tools`, `with_structured_output`, `with_configurable`, etc. on a configurable model and chain a configurable model in the same way that we would a regularly instantiated chat model object.\n\n```\nfrom pydantic import BaseModel, Fieldclass GetWeather(BaseModel):    \"\"\"Get the current weather in a given location\"\"\"    location: str = Field(..., description=\"The city and state, e.g. San Francisco, CA\")class GetPopulation(BaseModel):    \"\"\"Get the current population in a given location\"\"\"    location: str = Field(..., description=\"The city and state, e.g. San Francisco, CA\")llm = init_chat_model(temperature=0)llm_with_tools = llm.bind_tools([GetWeather, GetPopulation])llm_with_tools.invoke(    \"what's bigger in 2024 LA or NYC\", config={\"configurable\": {\"model\": \"gpt-4o\"}}).tool_calls\n```\n\n```\n[{'name': 'GetPopulation',  'args': {'location': 'Los Angeles, CA'},  'id': 'call_Ga9m8FAArIyEjItHmztPYA22',  'type': 'tool_call'}, {'name': 'GetPopulation',  'args': {'location': 'New York, NY'},  'id': 'call_jh2dEvBaAHRaw5JUDthOs7rt',  'type': 'tool_call'}]\n```\n\n```\nllm_with_tools.invoke(    \"what's bigger in 2024 LA or NYC\",    config={\"configurable\": {\"model\": \"claude-3-5-sonnet-20240620\"}},).tool_calls\n```\n\n```\n[{'name': 'GetPopulation',  'args': {'location': 'Los Angeles, CA'},  'id': 'toolu_01JMufPf4F4t2zLj7miFeqXp',  'type': 'tool_call'}, {'name': 'GetPopulation',  'args': {'location': 'New York City, NY'},  'id': 'toolu_01RQBHcE8kEEbYTuuS8WqY1u',  'type': 'tool_call'}]\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/summarize_map_reduce/",
  "markdown": "# giscus\n\n## How to summarize text through parallelization\n\nLLMs can summarize and otherwise distill desired information from text, including large volumes of text. In many cases, especially when the amount of text is large compared to the size of the model's context window, it can be helpful (or necessary) to break up the summarization task into smaller components.\n\nMap-reduce represents one class of strategies for accomplishing this. The idea is to break the text into \"sub-documents\", and first map each sub-document to an individual summary using an LLM. Then, we reduce or consolidate those summaries into a single global summary.\n\nNote that the map step is typically parallelized over the input documents. This strategy is especially effective when understanding of a sub-document does not rely on preceeding context. For example, when summarizing a corpus of many, shorter documents.\n\n[LangGraph](https://langchain-ai.github.io/langgraph/), built on top of `langchain-core`, suports [map-reduce](https://langchain-ai.github.io/langgraph/how-tos/map-reduce/) workflows and is well-suited to this problem:\n\n*   LangGraph allows for individual steps (such as successive summarizations) to be streamed, allowing for greater control of execution;\n*   LangGraph's [checkpointing](https://langchain-ai.github.io/langgraph/how-tos/persistence/) supports error recovery, extending with human-in-the-loop workflows, and easier incorporation into conversational applications.\n*   The LangGraph implementation is straightforward to modify and extend.\n\nBelow, we demonstrate how to summarize text via a map-reduce strategy.\n\n## Load chat model[​](#load-chat-model \"Direct link to Load chat model\")\n\nLet's first load a chat model:\n\n```\npip install -qU langchain-openai\n```\n\n```\nimport getpassimport osif not os.environ.get(\"OPENAI_API_KEY\"):  os.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"Enter API key for OpenAI: \")from langchain_openai import ChatOpenAIllm = ChatOpenAI(model=\"gpt-4o-mini\")\n```\n\n## Load documents[​](#load-documents \"Direct link to Load documents\")\n\nFirst we load in our documents. We will use [WebBaseLoader](https://python.langchain.com/api_reference/community/document_loaders/langchain_community.document_loaders.web_base.WebBaseLoader.html) to load a blog post, and split the documents into smaller sub-documents.\n\n```\nfrom langchain_community.document_loaders import WebBaseLoaderfrom langchain_text_splitters import CharacterTextSplittertext_splitter = CharacterTextSplitter.from_tiktoken_encoder(    chunk_size=1000, chunk_overlap=0)loader = WebBaseLoader(\"https://lilianweng.github.io/posts/2023-06-23-agent/\")docs = loader.load()split_docs = text_splitter.split_documents(docs)print(f\"Generated {len(split_docs)} documents.\")\n```\n\n```\nCreated a chunk of size 1003, which is longer than the specified 1000``````outputGenerated 14 documents.\n```\n\n## Create graph[​](#create-graph \"Direct link to Create graph\")\n\n### Map step[​](#map-step \"Direct link to Map step\")\n\nLet's first define the prompt associated with the map step, and associated it with the LLM via a [chain](https://python.langchain.com/docs/how_to/sequence/):\n\n```\nfrom langchain_core.output_parsers import StrOutputParserfrom langchain_core.prompts import ChatPromptTemplatemap_prompt = ChatPromptTemplate.from_messages(    [(\"human\", \"Write a concise summary of the following:\\\\n\\\\n{context}\")])map_chain = map_prompt | llm | StrOutputParser()\n```\n\n### Reduce step[​](#reduce-step \"Direct link to Reduce step\")\n\nWe also define a chain that takes the document mapping results and reduces them into a single output.\n\n```\nreduce_template = \"\"\"The following is a set of summaries:{docs}Take these and distill it into a final, consolidated summaryof the main themes.\"\"\"reduce_prompt = ChatPromptTemplate([(\"human\", reduce_template)])reduce_chain = reduce_prompt | llm | StrOutputParser()\n```\n\n### Orchestration via LangGraph[​](#orchestration-via-langgraph \"Direct link to Orchestration via LangGraph\")\n\nBelow we implement a simple application that maps the summarization step on a list of documents, then reduces them using the above prompts.\n\nMap-reduce flows are particularly useful when texts are long compared to the context window of a LLM. For long texts, we need a mechanism that ensures that the context to be summarized in the reduce step does not exceed a model's context window size. Here we implement a recursive \"collapsing\" of the summaries: the inputs are partitioned based on a token limit, and summaries are generated of the partitions. This step is repeated until the total length of the summaries is within a desired limit, allowing for the summarization of arbitrary-length text.\n\nWe will need to install `langgraph`:\n\n```\npip install -qU langgraph\n```\n\n```\nimport operatorfrom typing import Annotated, List, Literal, TypedDictfrom langchain.chains.combine_documents.reduce import (    acollapse_docs,    split_list_of_docs,)from langchain_core.documents import Documentfrom langgraph.constants import Sendfrom langgraph.graph import END, START, StateGraphtoken_max = 1000def length_function(documents: List[Document]) -> int:    \"\"\"Get number of tokens for input contents.\"\"\"    return sum(llm.get_num_tokens(doc.page_content) for doc in documents)# This will be the overall state of the main graph.# It will contain the input document contents, corresponding# summaries, and a final summary.class OverallState(TypedDict):    # Notice here we use the operator.add    # This is because we want combine all the summaries we generate    # from individual nodes back into one list - this is essentially    # the \"reduce\" part    contents: List[str]    summaries: Annotated[list, operator.add]    collapsed_summaries: List[Document]    final_summary: str# This will be the state of the node that we will \"map\" all# documents to in order to generate summariesclass SummaryState(TypedDict):    content: str# Here we generate a summary, given a documentasync def generate_summary(state: SummaryState):    response = await map_chain.ainvoke(state[\"content\"])    return {\"summaries\": [response]}# Here we define the logic to map out over the documents# We will use this an edge in the graphdef map_summaries(state: OverallState):    # We will return a list of `Send` objects    # Each `Send` object consists of the name of a node in the graph    # as well as the state to send to that node    return [        Send(\"generate_summary\", {\"content\": content}) for content in state[\"contents\"]    ]def collect_summaries(state: OverallState):    return {        \"collapsed_summaries\": [Document(summary) for summary in state[\"summaries\"]]    }# Add node to collapse summariesasync def collapse_summaries(state: OverallState):    doc_lists = split_list_of_docs(        state[\"collapsed_summaries\"], length_function, token_max    )    results = []    for doc_list in doc_lists:        results.append(await acollapse_docs(doc_list, reduce_chain.ainvoke))    return {\"collapsed_summaries\": results}# This represents a conditional edge in the graph that determines# if we should collapse the summaries or notdef should_collapse(    state: OverallState,) -> Literal[\"collapse_summaries\", \"generate_final_summary\"]:    num_tokens = length_function(state[\"collapsed_summaries\"])    if num_tokens > token_max:        return \"collapse_summaries\"    else:        return \"generate_final_summary\"# Here we will generate the final summaryasync def generate_final_summary(state: OverallState):    response = await reduce_chain.ainvoke(state[\"collapsed_summaries\"])    return {\"final_summary\": response}# Construct the graph# Nodes:graph = StateGraph(OverallState)graph.add_node(\"generate_summary\", generate_summary)  # same as beforegraph.add_node(\"collect_summaries\", collect_summaries)graph.add_node(\"collapse_summaries\", collapse_summaries)graph.add_node(\"generate_final_summary\", generate_final_summary)# Edges:graph.add_conditional_edges(START, map_summaries, [\"generate_summary\"])graph.add_edge(\"generate_summary\", \"collect_summaries\")graph.add_conditional_edges(\"collect_summaries\", should_collapse)graph.add_conditional_edges(\"collapse_summaries\", should_collapse)graph.add_edge(\"generate_final_summary\", END)app = graph.compile()\n```\n\nLangGraph allows the graph structure to be plotted to help visualize its function:\n\n```\nfrom IPython.display import ImageImage(app.get_graph().draw_mermaid_png())\n```\n\n![](data:image/jpg;base64,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)\n\n## Invoke graph[​](#invoke-graph \"Direct link to Invoke graph\")\n\nWhen running the application, we can stream the graph to observe its sequence of steps. Below, we will simply print out the name of the step.\n\nNote that because we have a loop in the graph, it can be helpful to specify a [recursion\\_limit](https://langchain-ai.github.io/langgraph/reference/errors/#langgraph.errors.GraphRecursionError) on its execution. This will raise a specific error when the specified limit is exceeded.\n\n```\nasync for step in app.astream(    {\"contents\": [doc.page_content for doc in split_docs]},    {\"recursion_limit\": 10},):    print(list(step.keys()))\n```\n\n```\n['generate_summary']['generate_summary']['generate_summary']['generate_summary']['generate_summary']['generate_summary']['generate_summary']['generate_summary']['generate_summary']['generate_summary']['generate_summary']['generate_summary']['generate_summary']['generate_summary']['collect_summaries']['collapse_summaries']['collapse_summaries']['generate_final_summary']\n```\n\n```\n{'generate_final_summary': {'final_summary': 'The consolidated summary of the main themes from the provided documents highlights the advancements and applications of large language models (LLMs) in artificial intelligence, particularly in autonomous agents and software development. Key themes include:\\n\\n1. **Integration of LLMs**: LLMs play a crucial role in enabling autonomous agents to perform complex tasks through advanced reasoning and decision-making techniques, such as Chain of Thought (CoT) and Tree of Thoughts.\\n\\n2. **Memory Management**: The categorization of memory into sensory, short-term, and long-term types parallels machine learning concepts, with short-term memory facilitating in-context learning and long-term memory enhanced by external storage solutions.\\n\\n3. **Tool Use and APIs**: Autonomous agents utilize external APIs to expand their capabilities, demonstrating adaptability and improved problem-solving skills.\\n\\n4. **Search Algorithms**: Various approximate nearest neighbor search algorithms, including Locality-Sensitive Hashing (LSH) and FAISS, are discussed for enhancing search efficiency in high-dimensional spaces.\\n\\n5. **Neuro-Symbolic Architectures**: The integration of neuro-symbolic systems, such as the MRKL framework, combines expert modules with LLMs to improve problem-solving, particularly in complex tasks.\\n\\n6. **Challenges and Innovations**: The documents address challenges like hallucination and inefficient planning in LLMs, alongside innovative methods such as Chain of Hindsight (CoH) and Algorithm Distillation (AD) for performance enhancement.\\n\\n7. **Software Development Practices**: The use of LLMs in software development is explored, particularly in creating structured applications like a Super Mario game using the model-view-controller (MVC) architecture, emphasizing task management, component organization, and documentation.\\n\\n8. **Limitations of LLMs**: Constraints such as finite context length and challenges in long-term planning are acknowledged, along with concerns regarding the reliability of natural language as an interface.\\n\\nOverall, the integration of LLMs and neuro-symbolic architectures signifies a significant evolution in AI, with ongoing research focused on enhancing planning, memory management, and problem-solving capabilities across various applications.'}}\n```\n\n## Next steps[​](#next-steps \"Direct link to Next steps\")\n\nCheck out the [LangGraph documentation](https://langchain-ai.github.io/langgraph/) for detail on building with LangGraph, including [this guide](https://langchain-ai.github.io/langgraph/how-tos/map-reduce/) on the details of map-reduce in LangGraph.\n\nSee the summarization [how-to guides](https://python.langchain.com/docs/how_to/#summarization) for additional summarization strategies, including those designed for larger volumes of text.\n\nSee also [this tutorial](https://python.langchain.com/docs/tutorials/summarization/) for more detail on summarization."
},
{
  "url": "https://python.langchain.com/docs/how_to/multimodal_inputs/",
  "markdown": "# giscus\n\n## How to pass multimodal data directly to models\n\nHere we demonstrate how to pass [multimodal](https://python.langchain.com/docs/concepts/multimodality/) input directly to models. We currently expect all input to be passed in the same format as [OpenAI expects](https://platform.openai.com/docs/guides/vision). For other model providers that support multimodal input, we have added logic inside the class to convert to the expected format.\n\nIn this example we will ask a [model](https://python.langchain.com/docs/concepts/chat_models/#multimodality) to describe an image.\n\n```\nimage_url = \"https://upload.wikimedia.org/wikipedia/commons/thumb/d/dd/Gfp-wisconsin-madison-the-nature-boardwalk.jpg/2560px-Gfp-wisconsin-madison-the-nature-boardwalk.jpg\"\n```\n\n```\nfrom langchain_core.messages import HumanMessagefrom langchain_openai import ChatOpenAImodel = ChatOpenAI(model=\"gpt-4o\")\n```\n\nThe most commonly supported way to pass in images is to pass it in as a byte string. This should work for most model integrations.\n\n```\nimport base64import httpximage_data = base64.b64encode(httpx.get(image_url).content).decode(\"utf-8\")\n```\n\n```\nmessage = HumanMessage(    content=[        {\"type\": \"text\", \"text\": \"describe the weather in this image\"},        {            \"type\": \"image_url\",            \"image_url\": {\"url\": f\"data:image/jpeg;base64,{image_data}\"},        },    ],)response = model.invoke([message])print(response.content)\n```\n\n```\nThe weather in the image appears to be clear and pleasant. The sky is mostly blue with scattered, light clouds, suggesting a sunny day with minimal cloud cover. There is no indication of rain or strong winds, and the overall scene looks bright and calm. The lush green grass and clear visibility further indicate good weather conditions.\n```\n\nWe can feed the image URL directly in a content block of type \"image\\_url\". Note that only some model providers support this.\n\n```\nmessage = HumanMessage(    content=[        {\"type\": \"text\", \"text\": \"describe the weather in this image\"},        {\"type\": \"image_url\", \"image_url\": {\"url\": image_url}},    ],)response = model.invoke([message])print(response.content)\n```\n\n```\nThe weather in the image appears to be clear and sunny. The sky is mostly blue with a few scattered clouds, suggesting good visibility and a likely pleasant temperature. The bright sunlight is casting distinct shadows on the grass and vegetation, indicating it is likely daytime, possibly late morning or early afternoon. The overall ambiance suggests a warm and inviting day, suitable for outdoor activities.\n```\n\nWe can also pass in multiple images.\n\n```\nmessage = HumanMessage(    content=[        {\"type\": \"text\", \"text\": \"are these two images the same?\"},        {\"type\": \"image_url\", \"image_url\": {\"url\": image_url}},        {\"type\": \"image_url\", \"image_url\": {\"url\": image_url}},    ],)response = model.invoke([message])print(response.content)\n```\n\n```\nYes, the two images are the same. They both depict a wooden boardwalk extending through a grassy field under a blue sky with light clouds. The scenery, lighting, and composition are identical.\n```\n\nSome multimodal models support [tool calling](https://python.langchain.com/docs/concepts/tool_calling/) features as well. To call tools using such models, simply bind tools to them in the [usual way](https://python.langchain.com/docs/how_to/tool_calling/), and invoke the model using content blocks of the desired type (e.g., containing image data).\n\n```\nfrom typing import Literalfrom langchain_core.tools import tool@tooldef weather_tool(weather: Literal[\"sunny\", \"cloudy\", \"rainy\"]) -> None:    \"\"\"Describe the weather\"\"\"    passmodel_with_tools = model.bind_tools([weather_tool])message = HumanMessage(    content=[        {\"type\": \"text\", \"text\": \"describe the weather in this image\"},        {\"type\": \"image_url\", \"image_url\": {\"url\": image_url}},    ],)response = model_with_tools.invoke([message])print(response.tool_calls)\n```\n\n**API Reference:**[tool](https://python.langchain.com/api_reference/core/tools/langchain_core.tools.convert.tool.html)\n\n```\n[{'name': 'weather_tool', 'args': {'weather': 'sunny'}, 'id': 'call_BSX4oq4SKnLlp2WlzDhToHBr'}]\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/summarize_refine/",
  "markdown": "# giscus\n\n## How to summarize text through iterative refinement\n\nLLMs can summarize and otherwise distill desired information from text, including large volumes of text. In many cases, especially when the amount of text is large compared to the size of the model's context window, it can be helpful (or necessary) to break up the summarization task into smaller components.\n\nIterative refinement represents one strategy for summarizing long texts. The strategy is as follows:\n\n*   Split a text into smaller documents;\n*   Summarize the first document;\n*   Refine or update the result based on the next document;\n*   Repeat through the sequence of documents until finished.\n\nNote that this strategy is not parallelized. It is especially effective when understanding of a sub-document depends on prior context-- for instance, when summarizing a novel or body of text with an inherent sequence.\n\n[LangGraph](https://langchain-ai.github.io/langgraph/), built on top of `langchain-core`, is well-suited to this problem:\n\n*   LangGraph allows for individual steps (such as successive summarizations) to be streamed, allowing for greater control of execution;\n*   LangGraph's [checkpointing](https://langchain-ai.github.io/langgraph/how-tos/persistence/) supports error recovery, extending with human-in-the-loop workflows, and easier incorporation into conversational applications.\n*   Because it is assembled from modular components, it is also simple to extend or modify (e.g., to incorporate [tool calling](https://python.langchain.com/docs/concepts/tool_calling/) or other behavior).\n\nBelow, we demonstrate how to summarize text via iterative refinement.\n\n## Load chat model[​](#load-chat-model \"Direct link to Load chat model\")\n\nLet's first load a chat model:\n\n```\npip install -qU langchain-openai\n```\n\n```\nimport getpassimport osif not os.environ.get(\"OPENAI_API_KEY\"):  os.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"Enter API key for OpenAI: \")from langchain_openai import ChatOpenAIllm = ChatOpenAI(model=\"gpt-4o-mini\")\n```\n\n## Load documents[​](#load-documents \"Direct link to Load documents\")\n\nNext, we need some documents to summarize. Below, we generate some toy documents for illustrative purposes. See the document loader [how-to guides](https://python.langchain.com/docs/how_to/#document-loaders) and [integration pages](https://python.langchain.com/docs/integrations/document_loaders/) for additional sources of data. The [summarization tutorial](https://python.langchain.com/docs/tutorials/summarization/) also includes an example summarizing a blog post.\n\n```\nfrom langchain_core.documents import Documentdocuments = [    Document(page_content=\"Apples are red\", metadata={\"title\": \"apple_book\"}),    Document(page_content=\"Blueberries are blue\", metadata={\"title\": \"blueberry_book\"}),    Document(page_content=\"Bananas are yelow\", metadata={\"title\": \"banana_book\"}),]\n```\n\n## Create graph[​](#create-graph \"Direct link to Create graph\")\n\nBelow we show a LangGraph implementation of this process:\n\n*   We generate a simple chain for the initial summary that plucks out the first document, formats it into a prompt and runs inference with our LLM.\n*   We generate a second `refine_summary_chain` that operates on each successive document, refining the initial summary.\n\nWe will need to install `langgraph`:\n\n```\npip install -qU langgraph\n```\n\n```\nimport operatorfrom typing import List, Literal, TypedDictfrom langchain_core.output_parsers import StrOutputParserfrom langchain_core.prompts import ChatPromptTemplatefrom langchain_core.runnables import RunnableConfigfrom langgraph.constants import Sendfrom langgraph.graph import END, START, StateGraph# Initial summarysummarize_prompt = ChatPromptTemplate(    [        (\"human\", \"Write a concise summary of the following: {context}\"),    ])initial_summary_chain = summarize_prompt | llm | StrOutputParser()# Refining the summary with new docsrefine_template = \"\"\"Produce a final summary.Existing summary up to this point:{existing_answer}New context:------------{context}------------Given the new context, refine the original summary.\"\"\"refine_prompt = ChatPromptTemplate([(\"human\", refine_template)])refine_summary_chain = refine_prompt | llm | StrOutputParser()# We will define the state of the graph to hold the document# contents and summary. We also include an index to keep track# of our position in the sequence of documents.class State(TypedDict):    contents: List[str]    index: int    summary: str# We define functions for each node, including a node that generates# the initial summary:async def generate_initial_summary(state: State, config: RunnableConfig):    summary = await initial_summary_chain.ainvoke(        state[\"contents\"][0],        config,    )    return {\"summary\": summary, \"index\": 1}# And a node that refines the summary based on the next documentasync def refine_summary(state: State, config: RunnableConfig):    content = state[\"contents\"][state[\"index\"]]    summary = await refine_summary_chain.ainvoke(        {\"existing_answer\": state[\"summary\"], \"context\": content},        config,    )    return {\"summary\": summary, \"index\": state[\"index\"] + 1}# Here we implement logic to either exit the application or refine# the summary.def should_refine(state: State) -> Literal[\"refine_summary\", END]:    if state[\"index\"] >= len(state[\"contents\"]):        return END    else:        return \"refine_summary\"graph = StateGraph(State)graph.add_node(\"generate_initial_summary\", generate_initial_summary)graph.add_node(\"refine_summary\", refine_summary)graph.add_edge(START, \"generate_initial_summary\")graph.add_conditional_edges(\"generate_initial_summary\", should_refine)graph.add_conditional_edges(\"refine_summary\", should_refine)app = graph.compile()\n```\n\nLangGraph allows the graph structure to be plotted to help visualize its function:\n\n```\nfrom IPython.display import ImageImage(app.get_graph().draw_mermaid_png())\n```\n\n![](data:image/jpg;base64,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)\n\n## Invoke graph[​](#invoke-graph \"Direct link to Invoke graph\")\n\nWe can step through the execution as follows, printing out the summary as it is refined:\n\n```\nasync for step in app.astream(    {\"contents\": [doc.page_content for doc in documents]},    stream_mode=\"values\",):    if summary := step.get(\"summary\"):        print(summary)\n```\n\n```\nApples are characterized by their red color.Apples are characterized by their red color, while blueberries are known for their blue hue.Apples are characterized by their red color, blueberries are known for their blue hue, and bananas are recognized for their yellow color.\n```\n\nThe final `step` contains the summary as synthesized from the entire set of documents.\n\n## Next steps[​](#next-steps \"Direct link to Next steps\")\n\nCheck out the summarization [how-to guides](https://python.langchain.com/docs/how_to/#summarization) for additional summarization strategies, including those designed for larger volumes of text.\n\nSee [this tutorial](https://python.langchain.com/docs/tutorials/summarization/) for more detail on summarization.\n\nSee also the [LangGraph documentation](https://langchain-ai.github.io/langgraph/) for detail on building with LangGraph."
},
{
  "url": "https://python.langchain.com/docs/how_to/multimodal_prompts/",
  "markdown": "# giscus\n\n[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/langchain-ai/langchain/blob/master/docs/docs/how_to/multimodal_prompts.ipynb)[![Open on GitHub](https://img.shields.io/badge/Open%20on%20GitHub-grey?logo=github&logoColor=white)](https://github.com/langchain-ai/langchain/blob/master/docs/docs/how_to/multimodal_prompts.ipynb)\n\n## How to use multimodal prompts\n\nHere we demonstrate how to use prompt templates to format [multimodal](https://python.langchain.com/docs/concepts/multimodality/) inputs to models.\n\nIn this example we will ask a [model](https://python.langchain.com/docs/concepts/chat_models/#multimodality) to describe an image.\n\n```\nimport base64import httpximage_url = \"https://upload.wikimedia.org/wikipedia/commons/thumb/d/dd/Gfp-wisconsin-madison-the-nature-boardwalk.jpg/2560px-Gfp-wisconsin-madison-the-nature-boardwalk.jpg\"image_data = base64.b64encode(httpx.get(image_url).content).decode(\"utf-8\")\n```\n\n```\nfrom langchain_core.prompts import ChatPromptTemplatefrom langchain_openai import ChatOpenAImodel = ChatOpenAI(model=\"gpt-4o\")\n```\n\n```\nprompt = ChatPromptTemplate.from_messages(    [        (\"system\", \"Describe the image provided\"),        (            \"user\",            [                {                    \"type\": \"image_url\",                    \"image_url\": {\"url\": \"data:image/jpeg;base64,{image_data}\"},                }            ],        ),    ])\n```\n\n```\nresponse = chain.invoke({\"image_data\": image_data})print(response.content)\n```\n\n```\nThe image depicts a sunny day with a beautiful blue sky filled with scattered white clouds. The sky has varying shades of blue, ranging from a deeper hue near the horizon to a lighter, almost pale blue higher up. The white clouds are fluffy and scattered across the expanse of the sky, creating a peaceful and serene atmosphere. The lighting and cloud patterns suggest pleasant weather conditions, likely during the daytime hours on a mild, sunny day in an outdoor natural setting.\n```\n\nWe can also pass in multiple images.\n\n```\nprompt = ChatPromptTemplate.from_messages(    [        (\"system\", \"compare the two pictures provided\"),        (            \"user\",            [                {                    \"type\": \"image_url\",                    \"image_url\": {\"url\": \"data:image/jpeg;base64,{image_data1}\"},                },                {                    \"type\": \"image_url\",                    \"image_url\": {\"url\": \"data:image/jpeg;base64,{image_data2}\"},                },            ],        ),    ])\n```\n\n```\nresponse = chain.invoke({\"image_data1\": image_data, \"image_data2\": image_data})print(response.content)\n```\n\n```\nThe two images provided are identical. Both images feature a wooden boardwalk path extending through a lush green field under a bright blue sky with some clouds. The perspective, colors, and elements in both images are exactly the same.\n```\n\n* * *\n\n#### Was this page helpful?"
},
{
  "url": "https://python.langchain.com/docs/how_to/summarize_stuff/",
  "markdown": "# giscus\n\n[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/langchain-ai/langchain/blob/master/docs/docs/how_to/summarize_stuff.ipynb)[![Open on GitHub](https://img.shields.io/badge/Open%20on%20GitHub-grey?logo=github&logoColor=white)](https://github.com/langchain-ai/langchain/blob/master/docs/docs/how_to/summarize_stuff.ipynb)\n\n## How to summarize text in a single LLM call\n\nLLMs can summarize and otherwise distill desired information from text, including large volumes of text. In many cases, especially for models with larger context windows, this can be adequately achieved via a single LLM call.\n\nLangChain implements a simple [pre-built chain](https://python.langchain.com/api_reference/langchain/chains/langchain.chains.combine_documents.stuff.create_stuff_documents_chain.html) that \"stuffs\" a prompt with the desired context for summarization and other purposes. In this guide we demonstrate how to use the chain.\n\n## Load chat model[​](#load-chat-model \"Direct link to Load chat model\")\n\nLet's first load a [chat model](https://python.langchain.com/docs/concepts/chat_models/):\n\n```\npip install -qU langchain-openai\n```\n\n```\nimport getpassimport osif not os.environ.get(\"OPENAI_API_KEY\"):  os.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"Enter API key for OpenAI: \")from langchain_openai import ChatOpenAIllm = ChatOpenAI(model=\"gpt-4o-mini\")\n```\n\n## Load documents[​](#load-documents \"Direct link to Load documents\")\n\nNext, we need some documents to summarize. Below, we generate some toy documents for illustrative purposes. See the document loader [how-to guides](https://python.langchain.com/docs/how_to/#document-loaders) and [integration pages](https://python.langchain.com/docs/integrations/document_loaders/) for additional sources of data. The [summarization tutorial](https://python.langchain.com/docs/tutorials/summarization/) also includes an example summarizing a blog post.\n\n```\nfrom langchain_core.documents import Documentdocuments = [    Document(page_content=\"Apples are red\", metadata={\"title\": \"apple_book\"}),    Document(page_content=\"Blueberries are blue\", metadata={\"title\": \"blueberry_book\"}),    Document(page_content=\"Bananas are yelow\", metadata={\"title\": \"banana_book\"}),]\n```\n\n## Load chain[​](#load-chain \"Direct link to Load chain\")\n\nBelow, we define a simple prompt and instantiate the chain with our chat model and documents:\n\n```\nfrom langchain.chains.combine_documents import create_stuff_documents_chainfrom langchain_core.prompts import ChatPromptTemplateprompt = ChatPromptTemplate.from_template(\"Summarize this content: {context}\")chain = create_stuff_documents_chain(llm, prompt)\n```\n\n## Invoke chain[​](#invoke-chain \"Direct link to Invoke chain\")\n\nBecause the chain is a [Runnable](https://python.langchain.com/docs/concepts/runnables/), it implements the usual methods for invocation:\n\n```\nresult = chain.invoke({\"context\": documents})result\n```\n\n```\n'The content describes the colors of three fruits: apples are red, blueberries are blue, and bananas are yellow.'\n```\n\n### Streaming[​](#streaming \"Direct link to Streaming\")\n\nNote that the chain also supports streaming of individual output tokens:\n\n```\nfor chunk in chain.stream({\"context\": documents}):    print(chunk, end=\"|\")\n```\n\n```\n|The| content| describes| the| colors| of| three| fruits|:| apples| are| red|,| blueberries| are| blue|,| and| bananas| are| yellow|.||\n```\n\n## Next steps[​](#next-steps \"Direct link to Next steps\")\n\nSee the summarization [how-to guides](https://python.langchain.com/docs/how_to/#summarization) for additional summarization strategies, including those designed for larger volumes of text.\n\nSee also [this tutorial](https://python.langchain.com/docs/tutorials/summarization/) for more detail on summarization."
},
{
  "url": "https://python.langchain.com/docs/how_to/toolkits/",
  "markdown": "# giscus\n\nToolkits are collections of tools that are designed to be used together for specific tasks. They have convenient loading methods.\n\nAll Toolkits expose a `get_tools` method which returns a list of tools. You can therefore do:\n\n```\n# Initialize a toolkittoolkit = ExampleTookit(...)# Get list of toolstools = toolkit.get_tools()# Create agentagent = create_agent_method(llm, tools, prompt)\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/chat_token_usage_tracking/",
  "markdown": "# giscus\n\n## How to track token usage in ChatModels\n\nPrerequisites\n\nThis guide assumes familiarity with the following concepts:\n\n*   [Chat models](https://python.langchain.com/docs/concepts/chat_models/)\n\nTracking [token](https://python.langchain.com/docs/concepts/tokens/) usage to calculate cost is an important part of putting your app in production. This guide goes over how to obtain this information from your LangChain model calls.\n\nThis guide requires `langchain-anthropic` and `langchain-openai >= 0.1.9`.\n\n```\n%pip install -qU langchain-anthropic langchain-openai\n```\n\n## Using LangSmith[​](#using-langsmith \"Direct link to Using LangSmith\")\n\nYou can use [LangSmith](https://www.langchain.com/langsmith) to help track token usage in your LLM application. See the [LangSmith quick start guide](https://docs.smith.langchain.com/).\n\nA number of model providers return token usage information as part of the chat generation response. When available, this information will be included on the `AIMessage` objects produced by the corresponding model.\n\nLangChain `AIMessage` objects include a [usage\\_metadata](https://python.langchain.com/api_reference/core/messages/langchain_core.messages.ai.AIMessage.html#langchain_core.messages.ai.AIMessage.usage_metadata) attribute. When populated, this attribute will be a [UsageMetadata](https://python.langchain.com/api_reference/core/messages/langchain_core.messages.ai.UsageMetadata.html) dictionary with standard keys (e.g., `\"input_tokens\"` and `\"output_tokens\"`).\n\nExamples:\n\n**OpenAI**:\n\n```\nfrom langchain_openai import ChatOpenAIllm = ChatOpenAI(model=\"gpt-4o-mini\")openai_response = llm.invoke(\"hello\")openai_response.usage_metadata\n```\n\n```\n{'input_tokens': 8, 'output_tokens': 9, 'total_tokens': 17}\n```\n\n**Anthropic**:\n\n```\nfrom langchain_anthropic import ChatAnthropicllm = ChatAnthropic(model=\"claude-3-haiku-20240307\")anthropic_response = llm.invoke(\"hello\")anthropic_response.usage_metadata\n```\n\n```\n{'input_tokens': 8, 'output_tokens': 12, 'total_tokens': 20}\n```\n\n### Using AIMessage.response\\_metadata[​](#using-aimessageresponse_metadata \"Direct link to Using AIMessage.response_metadata\")\n\nMetadata from the model response is also included in the AIMessage [response\\_metadata](https://python.langchain.com/api_reference/core/messages/langchain_core.messages.ai.AIMessage.html#langchain_core.messages.ai.AIMessage.response_metadata) attribute. These data are typically not standardized. Note that different providers adopt different conventions for representing token counts:\n\n```\nprint(f'OpenAI: {openai_response.response_metadata[\"token_usage\"]}\\n')print(f'Anthropic: {anthropic_response.response_metadata[\"usage\"]}')\n```\n\n```\nOpenAI: {'completion_tokens': 9, 'prompt_tokens': 8, 'total_tokens': 17}Anthropic: {'input_tokens': 8, 'output_tokens': 12}\n```\n\n### Streaming[​](#streaming \"Direct link to Streaming\")\n\nSome providers support token count metadata in a streaming context.\n\n#### OpenAI[​](#openai \"Direct link to OpenAI\")\n\nFor example, OpenAI will return a message [chunk](https://python.langchain.com/api_reference/core/messages/langchain_core.messages.ai.AIMessageChunk.html) at the end of a stream with token usage information. This behavior is supported by `langchain-openai >= 0.1.9` and can be enabled by setting `stream_usage=True`. This attribute can also be set when `ChatOpenAI` is instantiated.\n\nnote\n\nBy default, the last message chunk in a stream will include a `\"finish_reason\"` in the message's `response_metadata` attribute. If we include token usage in streaming mode, an additional chunk containing usage metadata will be added to the end of the stream, such that `\"finish_reason\"` appears on the second to last message chunk.\n\n```\nllm = ChatOpenAI(model=\"gpt-4o-mini\")aggregate = Nonefor chunk in llm.stream(\"hello\", stream_usage=True):    print(chunk)    aggregate = chunk if aggregate is None else aggregate + chunk\n```\n\n```\ncontent='' id='run-adb20c31-60c7-43a2-99b2-d4a53ca5f623'content='Hello' id='run-adb20c31-60c7-43a2-99b2-d4a53ca5f623'content='!' id='run-adb20c31-60c7-43a2-99b2-d4a53ca5f623'content=' How' id='run-adb20c31-60c7-43a2-99b2-d4a53ca5f623'content=' can' id='run-adb20c31-60c7-43a2-99b2-d4a53ca5f623'content=' I' id='run-adb20c31-60c7-43a2-99b2-d4a53ca5f623'content=' assist' id='run-adb20c31-60c7-43a2-99b2-d4a53ca5f623'content=' you' id='run-adb20c31-60c7-43a2-99b2-d4a53ca5f623'content=' today' id='run-adb20c31-60c7-43a2-99b2-d4a53ca5f623'content='?' id='run-adb20c31-60c7-43a2-99b2-d4a53ca5f623'content='' response_metadata={'finish_reason': 'stop', 'model_name': 'gpt-4o-mini'} id='run-adb20c31-60c7-43a2-99b2-d4a53ca5f623'content='' id='run-adb20c31-60c7-43a2-99b2-d4a53ca5f623' usage_metadata={'input_tokens': 8, 'output_tokens': 9, 'total_tokens': 17}\n```\n\nNote that the usage metadata will be included in the sum of the individual message chunks:\n\n```\nprint(aggregate.content)print(aggregate.usage_metadata)\n```\n\n```\nHello! How can I assist you today?{'input_tokens': 8, 'output_tokens': 9, 'total_tokens': 17}\n```\n\nTo disable streaming token counts for OpenAI, set `stream_usage` to False, or omit it from the parameters:\n\n```\naggregate = Nonefor chunk in llm.stream(\"hello\"):    print(chunk)\n```\n\n```\ncontent='' id='run-8e758550-94b0-4cca-a298-57482793c25d'content='Hello' id='run-8e758550-94b0-4cca-a298-57482793c25d'content='!' id='run-8e758550-94b0-4cca-a298-57482793c25d'content=' How' id='run-8e758550-94b0-4cca-a298-57482793c25d'content=' can' id='run-8e758550-94b0-4cca-a298-57482793c25d'content=' I' id='run-8e758550-94b0-4cca-a298-57482793c25d'content=' assist' id='run-8e758550-94b0-4cca-a298-57482793c25d'content=' you' id='run-8e758550-94b0-4cca-a298-57482793c25d'content=' today' id='run-8e758550-94b0-4cca-a298-57482793c25d'content='?' id='run-8e758550-94b0-4cca-a298-57482793c25d'content='' response_metadata={'finish_reason': 'stop', 'model_name': 'gpt-4o-mini'} id='run-8e758550-94b0-4cca-a298-57482793c25d'\n```\n\nYou can also enable streaming token usage by setting `stream_usage` when instantiating the chat model. This can be useful when incorporating chat models into LangChain [chains](https://python.langchain.com/docs/concepts/lcel/): usage metadata can be monitored when [streaming intermediate steps](https://python.langchain.com/docs/how_to/streaming/#using-stream-events) or using tracing software such as [LangSmith](https://docs.smith.langchain.com/).\n\nSee the below example, where we return output structured to a desired schema, but can still observe token usage streamed from intermediate steps.\n\n```\nfrom pydantic import BaseModel, Fieldclass Joke(BaseModel):    \"\"\"Joke to tell user.\"\"\"    setup: str = Field(description=\"question to set up a joke\")    punchline: str = Field(description=\"answer to resolve the joke\")llm = ChatOpenAI(    model=\"gpt-4o-mini\",    stream_usage=True,)# Under the hood, .with_structured_output binds tools to the# chat model and appends a parser.structured_llm = llm.with_structured_output(Joke)async for event in structured_llm.astream_events(\"Tell me a joke\", version=\"v2\"):    if event[\"event\"] == \"on_chat_model_end\":        print(f'Token usage: {event[\"data\"][\"output\"].usage_metadata}\\n')    elif event[\"event\"] == \"on_chain_end\":        print(event[\"data\"][\"output\"])    else:        pass\n```\n\n```\nToken usage: {'input_tokens': 79, 'output_tokens': 23, 'total_tokens': 102}setup='Why was the math book sad?' punchline='Because it had too many problems.'\n```\n\nToken usage is also visible in the corresponding [LangSmith trace](https://smith.langchain.com/public/fe6513d5-7212-4045-82e0-fefa28bc7656/r) in the payload from the chat model.\n\n## Using callbacks[​](#using-callbacks \"Direct link to Using callbacks\")\n\nThere are also some API-specific callback context managers that allow you to track token usage across multiple calls. They are currently only implemented for the OpenAI API and Bedrock Anthropic API, and are available in `langchain-community`:\n\n```\n%pip install -qU langchain-community\n```\n\n### OpenAI[​](#openai-1 \"Direct link to OpenAI\")\n\nLet's first look at an extremely simple example of tracking token usage for a single Chat model call.\n\n```\nfrom langchain_community.callbacks.manager import get_openai_callbackllm = ChatOpenAI(    model=\"gpt-4o-mini\",    temperature=0,    stream_usage=True,)with get_openai_callback() as cb:    result = llm.invoke(\"Tell me a joke\")    print(cb)\n```\n\n```\nTokens Used: 27\tPrompt Tokens: 11\tCompletion Tokens: 16Successful Requests: 1Total Cost (USD): $2.95e-05\n```\n\nAnything inside the context manager will get tracked. Here's an example of using it to track multiple calls in sequence.\n\n```\nwith get_openai_callback() as cb:    result = llm.invoke(\"Tell me a joke\")    result2 = llm.invoke(\"Tell me a joke\")    print(cb.total_tokens)\n```\n\n```\nwith get_openai_callback() as cb:    for chunk in llm.stream(\"Tell me a joke\"):        pass    print(cb)\n```\n\n```\nTokens Used: 27\tPrompt Tokens: 11\tCompletion Tokens: 16Successful Requests: 1Total Cost (USD): $2.95e-05\n```\n\nIf a chain or agent with multiple steps in it is used, it will track all those steps.\n\n```\n%pip install -qU langchain langchain-aws wikipedia\n```\n\n```\nfrom langchain.agents import AgentExecutor, create_tool_calling_agent, load_toolsfrom langchain_core.prompts import ChatPromptTemplateprompt = ChatPromptTemplate.from_messages(    [        (\"system\", \"You're a helpful assistant\"),        (\"human\", \"{input}\"),        (\"placeholder\", \"{agent_scratchpad}\"),    ])tools = load_tools([\"wikipedia\"])agent = create_tool_calling_agent(llm, tools, prompt)agent_executor = AgentExecutor(agent=agent, tools=tools, verbose=True)\n```\n\n```\nwith get_openai_callback() as cb:    response = agent_executor.invoke(        {            \"input\": \"What's a hummingbird's scientific name and what's the fastest bird species?\"        }    )    print(f\"Total Tokens: {cb.total_tokens}\")    print(f\"Prompt Tokens: {cb.prompt_tokens}\")    print(f\"Completion Tokens: {cb.completion_tokens}\")    print(f\"Total Cost (USD): ${cb.total_cost}\")\n```\n\n```\n\u001b[1m> Entering new AgentExecutor chain...\u001b[0m\u001b[32;1m\u001b[1;3mInvoking: `wikipedia` with `{'query': 'hummingbird scientific name'}`\u001b[0m\u001b[36;1m\u001b[1;3mPage: HummingbirdSummary: Hummingbirds are birds native to the Americas and comprise the biological family Trochilidae. With approximately 366 species and 113 genera, they occur from Alaska to Tierra del Fuego, but most species are found in Central and South America. As of 2024, 21 hummingbird species are listed as endangered or critically endangered, with numerous species declining in population.Hummingbirds have varied specialized characteristics to enable rapid, maneuverable flight: exceptional metabolic capacity, adaptations to high altitude, sensitive visual and communication abilities, and long-distance migration in some species. Among all birds, male hummingbirds have the widest diversity of plumage color, particularly in blues, greens, and purples. Hummingbirds are the smallest mature birds, measuring 7.5–13 cm (3–5 in) in length. The smallest is the 5 cm (2.0 in) bee hummingbird, which weighs less than 2.0 g (0.07 oz), and the largest is the 23 cm (9 in) giant hummingbird, weighing 18–24 grams (0.63–0.85 oz). Noted for long beaks, hummingbirds are specialized for feeding on flower nectar, but all species also consume small insects.They are known as hummingbirds because of the humming sound created by their beating wings, which flap at high frequencies audible to other birds and humans. They hover at rapid wing-flapping rates, which vary from around 12 beats per second in the largest species to 80 per second in small hummingbirds.Hummingbirds have the highest mass-specific metabolic rate of any homeothermic animal. To conserve energy when food is scarce and at night when not foraging, they can enter torpor, a state similar to hibernation, and slow their metabolic rate to 1⁄15 of its normal rate. While most hummingbirds do not migrate, the rufous hummingbird has one of the longest migrations among birds, traveling twice per year between Alaska and Mexico, a distance of about 3,900 miles (6,300 km).Hummingbirds split from their sister group, the swifts and treeswifts, around 42 million years ago. The oldest known fossil hummingbird is Eurotrochilus, from the Rupelian Stage of Early Oligocene Europe.Page: Rufous hummingbirdSummary: The rufous hummingbird (Selasphorus rufus) is a small hummingbird, about 8 cm (3.1 in) long with a long, straight and slender bill. These birds are known for their extraordinary flight skills, flying 2,000 mi (3,200 km) during their migratory transits. It is one of nine species in the genus Selasphorus.Page: Allen's hummingbirdSummary: Allen's hummingbird (Selasphorus sasin) is a species of hummingbird that breeds in the western United States. It is one of seven species in the genus Selasphorus.\u001b[0m\u001b[32;1m\u001b[1;3mInvoking: `wikipedia` with `{'query': 'fastest bird species'}`\u001b[0m\u001b[36;1m\u001b[1;3mPage: List of birds by flight speedSummary: This is a list of the fastest flying birds in the world. A bird's velocity is necessarily variable; a hunting bird will reach much greater speeds while diving to catch prey than when flying horizontally. The bird that can achieve the greatest airspeed is the peregrine falcon (Falco peregrinus), able to exceed 320 km/h (200 mph) in its dives. A close relative of the common swift, the white-throated needletail (Hirundapus caudacutus), is commonly reported as the fastest bird in level flight with a reported top speed of 169 km/h (105 mph). This record remains unconfirmed as the measurement methods have never been published or verified. The record for the fastest confirmed level flight by a bird is 111.5 km/h (69.3 mph) held by the common swift.Page: Fastest animalsSummary: This is a list of the fastest animals in the world, by types of animal.Page: FalconSummary: Falcons () are birds of prey in the genus Falco, which includes about 40 species. Falcons are widely distributed on all continents of the world except Antarctica, though closely related raptors did occur there in the Eocene.Adult falcons have thin, tapered wings, which enable them to fly at high speed and change direction rapidly. Fledgling falcons, in their first year of flying, have longer flight feathers, which make their configuration more like that of a general-purpose bird such as a broad wing. This makes flying easier while learning the exceptional skills required to be effective hunters as adults.The falcons are the largest genus in the Falconinae subfamily of Falconidae, which itself also includes another subfamily comprising caracaras and a few other species. All these birds kill with their beaks, using a tomial \"tooth\" on the side of their beaks—unlike the hawks, eagles, and other birds of prey in the Accipitridae, which use their feet.The largest falcon is the gyrfalcon at up to 65 cm in length.  The smallest falcon species is the pygmy falcon, which measures just 20 cm.  As with hawks and owls, falcons exhibit sexual dimorphism, with the females typically larger than the males, thus allowing a wider range of prey species.Some small falcons with long, narrow wings are called \"hobbies\" and some which hover while hunting are called \"kestrels\".As is the case with many birds of prey, falcons have exceptional powers of vision; the visual acuity of one species has been measured at 2.6 times that of a normal human. Peregrine falcons have been recorded diving at speeds of 320 km/h (200 mph), making them the fastest-moving creatures on Earth; the fastest recorded dive attained a vertical speed of 390 km/h (240 mph).\u001b[0m\u001b[32;1m\u001b[1;3mThe scientific name for a hummingbird is Trochilidae. The fastest bird species in level flight is the common swift, which holds the record for the fastest confirmed level flight by a bird at 111.5 km/h (69.3 mph). The peregrine falcon is known to exceed speeds of 320 km/h (200 mph) in its dives, making it the fastest bird in terms of diving speed.\u001b[0m\u001b[1m> Finished chain.\u001b[0mTotal Tokens: 1675Prompt Tokens: 1538Completion Tokens: 137Total Cost (USD): $0.0009745000000000001\n```\n\n### Bedrock Anthropic[​](#bedrock-anthropic \"Direct link to Bedrock Anthropic\")\n\nThe `get_bedrock_anthropic_callback` works very similarly:\n\n```\nfrom langchain_aws import ChatBedrockfrom langchain_community.callbacks.manager import get_bedrock_anthropic_callbackllm = ChatBedrock(model_id=\"anthropic.claude-v2\")with get_bedrock_anthropic_callback() as cb:    result = llm.invoke(\"Tell me a joke\")    result2 = llm.invoke(\"Tell me a joke\")    print(cb)\n```\n\n```\nTokens Used: 96\tPrompt Tokens: 26\tCompletion Tokens: 70Successful Requests: 2Total Cost (USD): $0.001888\n```\n\n## Next steps[​](#next-steps \"Direct link to Next steps\")\n\nYou've now seen a few examples of how to track token usage for supported providers.\n\nNext, check out the other how-to guides chat models in this section, like [how to get a model to return structured output](https://python.langchain.com/docs/how_to/structured_output/) or [how to add caching to your chat models](https://python.langchain.com/docs/how_to/chat_model_caching/)."
},
{
  "url": "https://python.langchain.com/docs/how_to/output_parser_custom/",
  "markdown": "# giscus\n\n## How to create a custom Output Parser\n\nIn some situations you may want to implement a custom [parser](https://python.langchain.com/docs/concepts/output_parsers/) to structure the model output into a custom format.\n\nThere are two ways to implement a custom parser:\n\n1.  Using `RunnableLambda` or `RunnableGenerator` in [LCEL](https://python.langchain.com/docs/concepts/lcel/) -- we strongly recommend this for most use cases\n2.  By inheriting from one of the base classes for out parsing -- this is the hard way of doing things\n\nThe difference between the two approaches are mostly superficial and are mainly in terms of which callbacks are triggered (e.g., `on_chain_start` vs. `on_parser_start`), and how a runnable lambda vs. a parser might be visualized in a tracing platform like LangSmith.\n\n## Runnable Lambdas and Generators[​](#runnable-lambdas-and-generators \"Direct link to Runnable Lambdas and Generators\")\n\nThe recommended way to parse is using **runnable lambdas** and **runnable generators**!\n\nHere, we will make a simple parse that inverts the case of the output from the model.\n\nFor example, if the model outputs: \"Meow\", the parser will produce \"mEOW\".\n\n```\nfrom typing import Iterablefrom langchain_anthropic.chat_models import ChatAnthropicfrom langchain_core.messages import AIMessage, AIMessageChunkmodel = ChatAnthropic(model_name=\"claude-2.1\")def parse(ai_message: AIMessage) -> str:    \"\"\"Parse the AI message.\"\"\"    return ai_message.content.swapcase()chain = model | parsechain.invoke(\"hello\")\n```\n\ntip\n\nLCEL automatically upgrades the function `parse` to `RunnableLambda(parse)` when composed using a `|` syntax.\n\nIf you don't like that you can manually import `RunnableLambda` and then run`parse = RunnableLambda(parse)`.\n\nDoes streaming work?\n\n```\nfor chunk in chain.stream(\"tell me about yourself in one sentence\"):    print(chunk, end=\"|\", flush=True)\n```\n\n```\ni'M cLAUDE, AN ai ASSISTANT CREATED BY aNTHROPIC TO BE HELPFUL, HARMLESS, AND HONEST.|\n```\n\nNo, it doesn't because the parser aggregates the input before parsing the output.\n\nIf we want to implement a streaming parser, we can have the parser accept an iterable over the input instead and yield the results as they're available.\n\n```\nfrom langchain_core.runnables import RunnableGeneratordef streaming_parse(chunks: Iterable[AIMessageChunk]) -> Iterable[str]:    for chunk in chunks:        yield chunk.content.swapcase()streaming_parse = RunnableGenerator(streaming_parse)\n```\n\nimportant\n\nPlease wrap the streaming parser in `RunnableGenerator` as we may stop automatically upgrading it with the `|` syntax.\n\n```\nchain = model | streaming_parsechain.invoke(\"hello\")\n```\n\nLet's confirm that streaming works!\n\n```\nfor chunk in chain.stream(\"tell me about yourself in one sentence\"):    print(chunk, end=\"|\", flush=True)\n```\n\n```\ni|'M| cLAUDE|,| AN| ai| ASSISTANT| CREATED| BY| aN|THROP|IC| TO| BE| HELPFUL|,| HARMLESS|,| AND| HONEST|.|\n```\n\n## Inheriting from Parsing Base Classes[​](#inheriting-from-parsing-base-classes \"Direct link to Inheriting from Parsing Base Classes\")\n\nAnother approach to implement a parser is by inheriting from `BaseOutputParser`, `BaseGenerationOutputParser` or another one of the base parsers depending on what you need to do.\n\nIn general, we **do not** recommend this approach for most use cases as it results in more code to write without significant benefits.\n\nThe simplest kind of output parser extends the `BaseOutputParser` class and must implement the following methods:\n\n*   `parse`: takes the string output from the model and parses it\n*   (optional) `_type`: identifies the name of the parser.\n\nWhen the output from the chat model or LLM is malformed, the can throw an `OutputParserException` to indicate that parsing fails because of bad input. Using this exception allows code that utilizes the parser to handle the exceptions in a consistent manner.\n\nParsers are Runnables! 🏃\n\nBecause `BaseOutputParser` implements the `Runnable` interface, any custom parser you will create this way will become valid LangChain Runnables and will benefit from automatic async support, batch interface, logging support etc.\n\n### Simple Parser[​](#simple-parser \"Direct link to Simple Parser\")\n\nHere's a simple parser that can parse a **string** representation of a boolean (e.g., `YES` or `NO`) and convert it into the corresponding `boolean` type.\n\n```\nfrom langchain_core.exceptions import OutputParserExceptionfrom langchain_core.output_parsers import BaseOutputParser# The [bool] desribes a parameterization of a generic.# It's basically indicating what the return type of parse is# in this case the return type is either True or Falseclass BooleanOutputParser(BaseOutputParser[bool]):    \"\"\"Custom boolean parser.\"\"\"    true_val: str = \"YES\"    false_val: str = \"NO\"    def parse(self, text: str) -> bool:        cleaned_text = text.strip().upper()        if cleaned_text not in (self.true_val.upper(), self.false_val.upper()):            raise OutputParserException(                f\"BooleanOutputParser expected output value to either be \"                f\"{self.true_val} or {self.false_val} (case-insensitive). \"                f\"Received {cleaned_text}.\"            )        return cleaned_text == self.true_val.upper()    @property    def _type(self) -> str:        return \"boolean_output_parser\"\n```\n\n```\nparser = BooleanOutputParser()parser.invoke(\"YES\")\n```\n\n```\ntry:    parser.invoke(\"MEOW\")except Exception as e:    print(f\"Triggered an exception of type: {type(e)}\")\n```\n\n```\nTriggered an exception of type: <class 'langchain_core.exceptions.OutputParserException'>\n```\n\nLet's test changing the parameterization\n\n```\nparser = BooleanOutputParser(true_val=\"OKAY\")parser.invoke(\"OKAY\")\n```\n\nLet's confirm that other LCEL methods are present\n\n```\nparser.batch([\"OKAY\", \"NO\"])\n```\n\n```\nawait parser.abatch([\"OKAY\", \"NO\"])\n```\n\n```\nfrom langchain_anthropic.chat_models import ChatAnthropicanthropic = ChatAnthropic(model_name=\"claude-2.1\")anthropic.invoke(\"say OKAY or NO\")\n```\n\n```\nAIMessage(content='OKAY')\n```\n\nLet's test that our parser works!\n\n```\nchain = anthropic | parserchain.invoke(\"say OKAY or NO\")\n```\n\nnote\n\nThe parser will work with either the output from an LLM (a string) or the output from a chat model (an `AIMessage`)!\n\n### Parsing Raw Model Outputs[​](#parsing-raw-model-outputs \"Direct link to Parsing Raw Model Outputs\")\n\nSometimes there is additional metadata on the model output that is important besides the raw text. One example of this is tool calling, where arguments intended to be passed to called functions are returned in a separate property. If you need this finer-grained control, you can instead subclass the `BaseGenerationOutputParser` class.\n\nThis class requires a single method `parse_result`. This method takes raw model output (e.g., list of `Generation` or `ChatGeneration`) and returns the parsed output.\n\nSupporting both `Generation` and `ChatGeneration` allows the parser to work with both regular LLMs as well as with Chat Models.\n\n```\nfrom typing import Listfrom langchain_core.exceptions import OutputParserExceptionfrom langchain_core.messages import AIMessagefrom langchain_core.output_parsers import BaseGenerationOutputParserfrom langchain_core.outputs import ChatGeneration, Generationclass StrInvertCase(BaseGenerationOutputParser[str]):    \"\"\"An example parser that inverts the case of the characters in the message.    This is an example parse shown just for demonstration purposes and to keep    the example as simple as possible.    \"\"\"    def parse_result(self, result: List[Generation], *, partial: bool = False) -> str:        \"\"\"Parse a list of model Generations into a specific format.        Args:            result: A list of Generations to be parsed. The Generations are assumed                to be different candidate outputs for a single model input.                Many parsers assume that only a single generation is passed it in.                We will assert for that            partial: Whether to allow partial results. This is used for parsers                     that support streaming        \"\"\"        if len(result) != 1:            raise NotImplementedError(                \"This output parser can only be used with a single generation.\"            )        generation = result[0]        if not isinstance(generation, ChatGeneration):            # Say that this one only works with chat generations            raise OutputParserException(                \"This output parser can only be used with a chat generation.\"            )        return generation.message.content.swapcase()chain = anthropic | StrInvertCase()\n```\n\nLet's the new parser! It should be inverting the output from the model.\n\n```\nchain.invoke(\"Tell me a short sentence about yourself\")\n```\n\n```\n'hELLO! mY NAME IS cLAUDE.'\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/output_parser_fixing/",
  "markdown": "# giscus\n\n## How to use the output-fixing parser\n\nThis [output parser](https://python.langchain.com/docs/concepts/output_parsers/) wraps another output parser, and in the event that the first one fails it calls out to another LLM to fix any errors.\n\nBut we can do other things besides throw errors. Specifically, we can pass the misformatted output, along with the formatted instructions, to the model and ask it to fix it.\n\nFor this example, we'll use the above Pydantic output parser. Here's what happens if we pass it a result that does not comply with the schema:\n\n```\nfrom typing import Listfrom langchain_core.exceptions import OutputParserExceptionfrom langchain_core.output_parsers import PydanticOutputParserfrom langchain_openai import ChatOpenAIfrom pydantic import BaseModel, Field\n```\n\n```\nclass Actor(BaseModel):    name: str = Field(description=\"name of an actor\")    film_names: List[str] = Field(description=\"list of names of films they starred in\")actor_query = \"Generate the filmography for a random actor.\"parser = PydanticOutputParser(pydantic_object=Actor)\n```\n\n```\nmisformatted = \"{'name': 'Tom Hanks', 'film_names': ['Forrest Gump']}\"\n```\n\n```\ntry:    parser.parse(misformatted)except OutputParserException as e:    print(e)\n```\n\n```\nInvalid json output: {'name': 'Tom Hanks', 'film_names': ['Forrest Gump']}For troubleshooting, visit: https://python.langchain.com/docs/troubleshooting/errors/OUTPUT_PARSING_FAILURE\n```\n\nNow we can construct and use a `OutputFixingParser`. This output parser takes as an argument another output parser but also an LLM with which to try to correct any formatting mistakes.\n\n```\nfrom langchain.output_parsers import OutputFixingParsernew_parser = OutputFixingParser.from_llm(parser=parser, llm=ChatOpenAI())\n```\n\n```\nnew_parser.parse(misformatted)\n```\n\n```\nActor(name='Tom Hanks', film_names=['Forrest Gump'])\n```\n\nFind out api documentation for [OutputFixingParser](https://python.langchain.com/api_reference/langchain/output_parsers/langchain.output_parsers.fix.OutputFixingParser.html#langchain.output_parsers.fix.OutputFixingParser)."
},
{
  "url": "https://python.langchain.com/docs/how_to/tools_prompting/",
  "markdown": "# giscus\n\n## How to add ad-hoc tool calling capability to LLMs and Chat Models\n\ncaution\n\nSome models have been fine-tuned for tool calling and provide a dedicated API for tool calling. Generally, such models are better at tool calling than non-fine-tuned models, and are recommended for use cases that require tool calling. Please see the [how to use a chat model to call tools](https://python.langchain.com/docs/how_to/tool_calling/) guide for more information.\n\nIn this guide, we'll see how to add **ad-hoc** tool calling support to a chat model. This is an alternative method to invoke tools if you're using a model that does not natively support [tool calling](https://python.langchain.com/docs/how_to/tool_calling/).\n\nWe'll do this by simply writing a prompt that will get the model to invoke the appropriate tools. Here's a diagram of the logic:\n\n![chain](https://python.langchain.com/assets/images/tool_chain-3571e7fbc481d648aff93a2630f812ab.svg)\n\n## Setup[​](#setup \"Direct link to Setup\")\n\nWe'll need to install the following packages:\n\n```\n%pip install --upgrade --quiet langchain langchain-community\n```\n\nIf you'd like to use LangSmith, uncomment the below:\n\n```\nimport getpassimport os# os.environ[\"LANGCHAIN_TRACING_V2\"] = \"true\"# os.environ[\"LANGCHAIN_API_KEY\"] = getpass.getpass()\n```\n\nYou can select any of the given models for this how-to guide. Keep in mind that most of these models already [support native tool calling](https://python.langchain.com/docs/integrations/chat/), so using the prompting strategy shown here doesn't make sense for these models, and instead you should follow the [how to use a chat model to call tools](https://python.langchain.com/docs/how_to/tool_calling/) guide.\n\n```\npip install -qU langchain-openai\n```\n\n```\nimport getpassimport osif not os.environ.get(\"OPENAI_API_KEY\"):  os.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"Enter API key for OpenAI: \")from langchain_openai import ChatOpenAImodel = ChatOpenAI(model=\"gpt-4\")\n```\n\nTo illustrate the idea, we'll use `phi3` via Ollama, which does **NOT** have native support for tool calling. If you'd like to use `Ollama` as well follow [these instructions](https://python.langchain.com/docs/integrations/chat/ollama/).\n\n```\nfrom langchain_community.llms import Ollamamodel = Ollama(model=\"phi3\")\n```\n\nFirst, let's create an `add` and `multiply` tools. For more information on creating custom tools, please see [this guide](https://python.langchain.com/docs/how_to/custom_tools/).\n\n```\nfrom langchain_core.tools import tool@tooldef multiply(x: float, y: float) -> float:    \"\"\"Multiply two numbers together.\"\"\"    return x * y@tooldef add(x: int, y: int) -> int:    \"Add two numbers.\"    return x + ytools = [multiply, add]# Let's inspect the toolsfor t in tools:    print(\"--\")    print(t.name)    print(t.description)    print(t.args)\n```\n\n**API Reference:**[tool](https://python.langchain.com/api_reference/core/tools/langchain_core.tools.convert.tool.html)\n\n```\n--multiplyMultiply two numbers together.{'x': {'title': 'X', 'type': 'number'}, 'y': {'title': 'Y', 'type': 'number'}}--addAdd two numbers.{'x': {'title': 'X', 'type': 'integer'}, 'y': {'title': 'Y', 'type': 'integer'}}\n```\n\n```\nmultiply.invoke({\"x\": 4, \"y\": 5})\n```\n\n## Creating our prompt[​](#creating-our-prompt \"Direct link to Creating our prompt\")\n\nWe'll want to write a prompt that specifies the tools the model has access to, the arguments to those tools, and the desired output format of the model. In this case we'll instruct it to output a JSON blob of the form `{\"name\": \"...\", \"arguments\": {...}}`.\n\n```\nfrom langchain_core.output_parsers import JsonOutputParserfrom langchain_core.prompts import ChatPromptTemplatefrom langchain_core.tools import render_text_descriptionrendered_tools = render_text_description(tools)print(rendered_tools)\n```\n\n```\nmultiply(x: float, y: float) -> float - Multiply two numbers together.add(x: int, y: int) -> int - Add two numbers.\n```\n\n```\nsystem_prompt = f\"\"\"\\You are an assistant that has access to the following set of tools. Here are the names and descriptions for each tool:{rendered_tools}Given the user input, return the name and input of the tool to use. Return your response as a JSON blob with 'name' and 'arguments' keys.The `arguments` should be a dictionary, with keys corresponding to the argument names and the values corresponding to the requested values.\"\"\"prompt = ChatPromptTemplate.from_messages(    [(\"system\", system_prompt), (\"user\", \"{input}\")])\n```\n\n```\nchain = prompt | modelmessage = chain.invoke({\"input\": \"what's 3 plus 1132\"})# Let's take a look at the output from the model# if the model is an LLM (not a chat model), the output will be a string.if isinstance(message, str):    print(message)else:  # Otherwise it's a chat model    print(message.content)\n```\n\n```\n{    \"name\": \"add\",    \"arguments\": {        \"x\": 3,        \"y\": 1132    }}\n```\n\n## Adding an output parser[​](#adding-an-output-parser \"Direct link to Adding an output parser\")\n\nWe'll use the `JsonOutputParser` for parsing our models output to JSON.\n\n```\nfrom langchain_core.output_parsers import JsonOutputParserchain = prompt | model | JsonOutputParser()chain.invoke({\"input\": \"what's thirteen times 4\"})\n```\n\n```\n{'name': 'multiply', 'arguments': {'x': 13.0, 'y': 4.0}}\n```\n\nimportant\n\n🎉 Amazing! 🎉 We now instructed our model on how to **request** that a tool be invoked.\n\nNow, let's create some logic to actually run the tool!\n\nNow that the model can request that a tool be invoked, we need to write a function that can actually invoke the tool.\n\nThe function will select the appropriate tool by name, and pass to it the arguments chosen by the model.\n\n```\nfrom typing import Any, Dict, Optional, TypedDictfrom langchain_core.runnables import RunnableConfigclass ToolCallRequest(TypedDict):    \"\"\"A typed dict that shows the inputs into the invoke_tool function.\"\"\"    name: str    arguments: Dict[str, Any]def invoke_tool(    tool_call_request: ToolCallRequest, config: Optional[RunnableConfig] = None):    \"\"\"A function that we can use the perform a tool invocation.    Args:        tool_call_request: a dict that contains the keys name and arguments.            The name must match the name of a tool that exists.            The arguments are the arguments to that tool.        config: This is configuration information that LangChain uses that contains            things like callbacks, metadata, etc.See LCEL documentation about RunnableConfig.    Returns:        output from the requested tool    \"\"\"    tool_name_to_tool = {tool.name: tool for tool in tools}    name = tool_call_request[\"name\"]    requested_tool = tool_name_to_tool[name]    return requested_tool.invoke(tool_call_request[\"arguments\"], config=config)\n```\n\nLet's test this out 🧪!\n\n```\ninvoke_tool({\"name\": \"multiply\", \"arguments\": {\"x\": 3, \"y\": 5}})\n```\n\n## Let's put it together[​](#lets-put-it-together \"Direct link to Let's put it together\")\n\nLet's put it together into a chain that creates a calculator with add and multiplication capabilities.\n\n```\nchain = prompt | model | JsonOutputParser() | invoke_toolchain.invoke({\"input\": \"what's thirteen times 4.14137281\"})\n```\n\nIt can be helpful to return not only tool outputs but also tool inputs. We can easily do this with LCEL by `RunnablePassthrough.assign`\\-ing the tool output. This will take whatever the input is to the RunnablePassrthrough components (assumed to be a dictionary) and add a key to it while still passing through everything that's currently in the input:\n\n```\nfrom langchain_core.runnables import RunnablePassthroughchain = (    prompt | model | JsonOutputParser() | RunnablePassthrough.assign(output=invoke_tool))chain.invoke({\"input\": \"what's thirteen times 4.14137281\"})\n```\n\n```\n{'name': 'multiply', 'arguments': {'x': 13, 'y': 4.14137281}, 'output': 53.83784653}\n```\n\n## What's next?[​](#whats-next \"Direct link to What's next?\")\n\nThis how-to guide shows the \"happy path\" when the model correctly outputs all the required tool information.\n\nIn reality, if you're using more complex tools, you will start encountering errors from the model, especially for models that have not been fine tuned for tool calling and for less capable models.\n\nYou will need to be prepared to add strategies to improve the output from the model; e.g.,\n\n1.  Provide few shot examples.\n2.  Add error handling (e.g., catch the exception and feed it back to the LLM to ask it to correct its previous output)."
},
{
  "url": "https://python.langchain.com/docs/how_to/agent_executor/",
  "markdown": "# giscus\n\n## Build an Agent with AgentExecutor (Legacy)\n\nimportant\n\nThis section will cover building with the legacy LangChain AgentExecutor. These are fine for getting started, but past a certain point, you will likely want flexibility and control that they do not offer. For working with more advanced agents, we'd recommend checking out [LangGraph Agents](https://python.langchain.com/docs/concepts/architecture/#langgraph) or the [migration guide](https://python.langchain.com/docs/how_to/migrate_agent/)\n\nBy themselves, language models can't take actions - they just output text. A big use case for LangChain is creating **[agents](https://python.langchain.com/docs/concepts/agents/)**. Agents are systems that use an LLM as a reasoning engine to determine which actions to take and what the inputs to those actions should be. The results of those actions can then be fed back into the agent and it determines whether more actions are needed, or whether it is okay to finish.\n\nIn this tutorial, we will build an agent that can interact with multiple different tools: one being a local database, the other being a search engine. You will be able to ask this agent questions, watch it call tools, and have conversations with it.\n\n## Concepts[​](#concepts \"Direct link to Concepts\")\n\nConcepts we will cover are:\n\n*   Using [language models](https://python.langchain.com/docs/concepts/chat_models/), in particular their tool calling ability\n*   Creating a [Retriever](https://python.langchain.com/docs/concepts/retrievers/) to expose specific information to our agent\n*   Using a Search [Tool](https://python.langchain.com/docs/concepts/tools/) to look up things online\n*   [`Chat History`](https://python.langchain.com/docs/concepts/chat_history/), which allows a chatbot to \"remember\" past interactions and take them into account when responding to follow-up questions.\n*   Debugging and tracing your application using [LangSmith](https://docs.smith.langchain.com/)\n\n## Setup[​](#setup \"Direct link to Setup\")\n\n### Jupyter Notebook[​](#jupyter-notebook \"Direct link to Jupyter Notebook\")\n\nThis guide (and most of the other guides in the documentation) uses [Jupyter notebooks](https://jupyter.org/) and assumes the reader is as well. Jupyter notebooks are perfect for learning how to work with LLM systems because oftentimes things can go wrong (unexpected output, API down, etc) and going through guides in an interactive environment is a great way to better understand them.\n\nThis and other tutorials are perhaps most conveniently run in a Jupyter notebook. See [here](https://jupyter.org/install) for instructions on how to install.\n\n### Installation[​](#installation \"Direct link to Installation\")\n\nTo install LangChain run:\n\n*   Pip\n*   Conda\n\nFor more details, see our [Installation guide](https://python.langchain.com/docs/how_to/installation/).\n\n### LangSmith[​](#langsmith \"Direct link to LangSmith\")\n\nMany of the applications you build with LangChain will contain multiple steps with multiple invocations of LLM calls. As these applications get more and more complex, it becomes crucial to be able to inspect what exactly is going on inside your chain or agent. The best way to do this is with [LangSmith](https://smith.langchain.com/).\n\nAfter you sign up at the link above, make sure to set your environment variables to start logging traces:\n\n```\nexport LANGCHAIN_TRACING_V2=\"true\"export LANGCHAIN_API_KEY=\"...\"\n```\n\nOr, if in a notebook, you can set them with:\n\n```\nimport getpassimport osos.environ[\"LANGCHAIN_TRACING_V2\"] = \"true\"os.environ[\"LANGCHAIN_API_KEY\"] = getpass.getpass()\n```\n\nWe first need to create the tools we want to use. We will use two tools: [Tavily](https://python.langchain.com/docs/integrations/tools/tavily_search/) (to search online) and then a retriever over a local index we will create\n\n### [Tavily](https://python.langchain.com/docs/integrations/tools/tavily_search/)[​](#tavily \"Direct link to tavily\")\n\nWe have a built-in tool in LangChain to easily use Tavily search engine as tool. Note that this requires an API key - they have a free tier, but if you don't have one or don't want to create one, you can always ignore this step.\n\nOnce you create your API key, you will need to export that as:\n\n```\nexport TAVILY_API_KEY=\"...\"\n```\n\n```\nfrom langchain_community.tools.tavily_search import TavilySearchResults\n```\n\n```\nsearch = TavilySearchResults(max_results=2)\n```\n\n```\nsearch.invoke(\"what is the weather in SF\")\n```\n\n```\n[{'url': 'https://www.weatherapi.com/',  'content': \"{'location': {'name': 'San Francisco', 'region': 'California', 'country': 'United States of America', 'lat': 37.78, 'lon': -122.42, 'tz_id': 'America/Los_Angeles', 'localtime_epoch': 1714000492, 'localtime': '2024-04-24 16:14'}, 'current': {'last_updated_epoch': 1713999600, 'last_updated': '2024-04-24 16:00', 'temp_c': 15.6, 'temp_f': 60.1, 'is_day': 1, 'condition': {'text': 'Overcast', 'icon': '//cdn.weatherapi.com/weather/64x64/day/122.png', 'code': 1009}, 'wind_mph': 10.5, 'wind_kph': 16.9, 'wind_degree': 330, 'wind_dir': 'NNW', 'pressure_mb': 1018.0, 'pressure_in': 30.06, 'precip_mm': 0.0, 'precip_in': 0.0, 'humidity': 72, 'cloud': 100, 'feelslike_c': 15.6, 'feelslike_f': 60.1, 'vis_km': 16.0, 'vis_miles': 9.0, 'uv': 5.0, 'gust_mph': 14.8, 'gust_kph': 23.8}}\"}, {'url': 'https://www.weathertab.com/en/c/e/04/united-states/california/san-francisco/',  'content': 'San Francisco Weather Forecast for Apr 2024 - Risk of Rain Graph. Rain Risk Graph: Monthly Overview. Bar heights indicate rain risk percentages. Yellow bars mark low-risk days, while black and grey bars signal higher risks. Grey-yellow bars act as buffers, advising to keep at least one day clear from the riskier grey and black days, guiding ...'}]\n```\n\n### Retriever[​](#retriever \"Direct link to Retriever\")\n\nWe will also create a retriever over some data of our own. For a deeper explanation of each step here, see [this tutorial](https://python.langchain.com/docs/tutorials/rag/).\n\n```\nfrom langchain_community.document_loaders import WebBaseLoaderfrom langchain_community.vectorstores import FAISSfrom langchain_openai import OpenAIEmbeddingsfrom langchain_text_splitters import RecursiveCharacterTextSplitterloader = WebBaseLoader(\"https://docs.smith.langchain.com/overview\")docs = loader.load()documents = RecursiveCharacterTextSplitter(    chunk_size=1000, chunk_overlap=200).split_documents(docs)vector = FAISS.from_documents(documents, OpenAIEmbeddings())retriever = vector.as_retriever()\n```\n\n```\nretriever.invoke(\"how to upload a dataset\")[0]\n```\n\n```\nDocument(page_content='# The data to predict and grade over    evaluators=[exact_match], # The evaluators to score the results    experiment_prefix=\"sample-experiment\", # The name of the experiment    metadata={      \"version\": \"1.0.0\",      \"revision_id\": \"beta\"    },)import { Client, Run, Example } from \\'langsmith\\';import { runOnDataset } from \\'langchain/smith\\';import { EvaluationResult } from \\'langsmith/evaluation\\';const client = new Client();// Define dataset: these are your test casesconst datasetName = \"Sample Dataset\";const dataset = await client.createDataset(datasetName, {    description: \"A sample dataset in LangSmith.\"});await client.createExamples({    inputs: [        { postfix: \"to LangSmith\" },        { postfix: \"to Evaluations in LangSmith\" },    ],    outputs: [        { output: \"Welcome to LangSmith\" },        { output: \"Welcome to Evaluations in LangSmith\" },    ],    datasetId: dataset.id,});// Define your evaluatorconst exactMatch = async ({ run, example }: { run: Run; example?:', metadata={'source': 'https://docs.smith.langchain.com/overview', 'title': 'Getting started with LangSmith | \\uf8ffü¶úÔ∏è\\uf8ffüõ†Ô∏è LangSmith', 'description': 'Introduction', 'language': 'en'})\n```\n\nNow that we have populated our index that we will do doing retrieval over, we can easily turn it into a tool (the format needed for an agent to properly use it)\n\n```\nfrom langchain.tools.retriever import create_retriever_tool\n```\n\n```\nretriever_tool = create_retriever_tool(    retriever,    \"langsmith_search\",    \"Search for information about LangSmith. For any questions about LangSmith, you must use this tool!\",)\n```\n\n### Tools[​](#tools \"Direct link to Tools\")\n\nNow that we have created both, we can create a list of tools that we will use downstream.\n\n```\ntools = [search, retriever_tool]\n```\n\n## Using Language Models[​](#using-language-models \"Direct link to Using Language Models\")\n\nNext, let's learn how to use a language model by to call tools. LangChain supports many different language models that you can use interchangably - select the one you want to use below!\n\n```\npip install -qU langchain-openai\n```\n\n```\nimport getpassimport osif not os.environ.get(\"OPENAI_API_KEY\"):  os.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"Enter API key for OpenAI: \")from langchain_openai import ChatOpenAImodel = ChatOpenAI(model=\"gpt-4\")\n```\n\nYou can call the language model by passing in a list of messages. By default, the response is a `content` string.\n\n```\nfrom langchain_core.messages import HumanMessageresponse = model.invoke([HumanMessage(content=\"hi!\")])response.content\n```\n\n```\n'Hello! How can I assist you today?'\n```\n\nWe can now see what it is like to enable this model to do tool calling. In order to enable that we use `.bind_tools` to give the language model knowledge of these tools\n\n```\nmodel_with_tools = model.bind_tools(tools)\n```\n\nWe can now call the model. Let's first call it with a normal message, and see how it responds. We can look at both the `content` field as well as the `tool_calls` field.\n\n```\nresponse = model_with_tools.invoke([HumanMessage(content=\"Hi!\")])print(f\"ContentString: {response.content}\")print(f\"ToolCalls: {response.tool_calls}\")\n```\n\n```\nContentString: Hello! How can I assist you today?ToolCalls: []\n```\n\nNow, let's try calling it with some input that would expect a tool to be called.\n\n```\nresponse = model_with_tools.invoke([HumanMessage(content=\"What's the weather in SF?\")])print(f\"ContentString: {response.content}\")print(f\"ToolCalls: {response.tool_calls}\")\n```\n\n```\nContentString: ToolCalls: [{'name': 'tavily_search_results_json', 'args': {'query': 'current weather in San Francisco'}, 'id': 'call_4HteVahXkRAkWjp6dGXryKZX'}]\n```\n\nWe can see that there's now no content, but there is a tool call! It wants us to call the Tavily Search tool.\n\nThis isn't calling that tool yet - it's just telling us to. In order to actually calll it, we'll want to create our agent.\n\n## Create the agent[​](#create-the-agent \"Direct link to Create the agent\")\n\nNow that we have defined the tools and the LLM, we can create the agent. We will be using a tool calling agent - for more information on this type of agent, as well as other options, see [this guide](https://python.langchain.com/docs/concepts/agents/).\n\nWe can first choose the prompt we want to use to guide the agent.\n\nIf you want to see the contents of this prompt and have access to LangSmith, you can go to:\n\n[https://smith.langchain.com/hub/hwchase17/openai-functions-agent](https://smith.langchain.com/hub/hwchase17/openai-functions-agent)\n\n```\nfrom langchain import hub# Get the prompt to use - you can modify this!prompt = hub.pull(\"hwchase17/openai-functions-agent\")prompt.messages\n```\n\n**API Reference:**[hub](https://python.langchain.com/api_reference/langchain/hub/langchain.hub.hub.html)\n\n```\n[SystemMessagePromptTemplate(prompt=PromptTemplate(input_variables=[], template='You are a helpful assistant')), MessagesPlaceholder(variable_name='chat_history', optional=True), HumanMessagePromptTemplate(prompt=PromptTemplate(input_variables=['input'], template='{input}')), MessagesPlaceholder(variable_name='agent_scratchpad')]\n```\n\nNow, we can initialize the agent with the LLM, the prompt, and the tools. The agent is responsible for taking in input and deciding what actions to take. Crucially, the Agent does not execute those actions - that is done by the AgentExecutor (next step). For more information about how to think about these components, see our [conceptual guide](https://python.langchain.com/docs/concepts/agents/).\n\nNote that we are passing in the `model`, not `model_with_tools`. That is because `create_tool_calling_agent` will call `.bind_tools` for us under the hood.\n\n```\nfrom langchain.agents import create_tool_calling_agentagent = create_tool_calling_agent(model, tools, prompt)\n```\n\nFinally, we combine the agent (the brains) with the tools inside the AgentExecutor (which will repeatedly call the agent and execute tools).\n\n```\nfrom langchain.agents import AgentExecutoragent_executor = AgentExecutor(agent=agent, tools=tools)\n```\n\n## Run the agent[​](#run-the-agent \"Direct link to Run the agent\")\n\nWe can now run the agent on a few queries! Note that for now, these are all **stateless** queries (it won't remember previous interactions).\n\nFirst up, let's how it responds when there's no need to call a tool:\n\n```\nagent_executor.invoke({\"input\": \"hi!\"})\n```\n\n```\n{'input': 'hi!', 'output': 'Hello! How can I assist you today?'}\n```\n\nIn order to see exactly what is happening under the hood (and to make sure it's not calling a tool) we can take a look at the [LangSmith trace](https://smith.langchain.com/public/8441812b-94ce-4832-93ec-e1114214553a/r)\n\nLet's now try it out on an example where it should be invoking the retriever\n\n```\nagent_executor.invoke({\"input\": \"how can langsmith help with testing?\"})\n```\n\n```\n{'input': 'how can langsmith help with testing?', 'output': 'LangSmith is a platform that aids in building production-grade Language Learning Model (LLM) applications. It can assist with testing in several ways:\\n\\n1. **Monitoring and Evaluation**: LangSmith allows close monitoring and evaluation of your application. This helps you to ensure the quality of your application and deploy it with confidence.\\n\\n2. **Tracing**: LangSmith has tracing capabilities that can be beneficial for debugging and understanding the behavior of your application.\\n\\n3. **Evaluation Capabilities**: LangSmith has built-in tools for evaluating the performance of your LLM. \\n\\n4. **Prompt Hub**: This is a prompt management tool built into LangSmith that can help in testing different prompts and their responses.\\n\\nPlease note that to use LangSmith, you would need to install it and create an API key. The platform offers Python and Typescript SDKs for utilization. It works independently and does not require the use of LangChain.'}\n```\n\nLet's take a look at the [LangSmith trace](https://smith.langchain.com/public/762153f6-14d4-4c98-8659-82650f860c62/r) to make sure it's actually calling that.\n\nNow let's try one where it needs to call the search tool:\n\n```\nagent_executor.invoke({\"input\": \"whats the weather in sf?\"})\n```\n\n```\n{'input': 'whats the weather in sf?', 'output': 'The current weather in San Francisco is partly cloudy with a temperature of 16.1°C (61.0°F). The wind is coming from the WNW at a speed of 10.5 mph. The humidity is at 67%. [source](https://www.weatherapi.com/)'}\n```\n\nWe can check out the [LangSmith trace](https://smith.langchain.com/public/36df5b1a-9a0b-4185-bae2-964e1d53c665/r) to make sure it's calling the search tool effectively.\n\n## Adding in memory[​](#adding-in-memory \"Direct link to Adding in memory\")\n\nAs mentioned earlier, this agent is stateless. This means it does not remember previous interactions. To give it memory we need to pass in previous `chat_history`. Note: it needs to be called `chat_history` because of the prompt we are using. If we use a different prompt, we could change the variable name\n\n```\n# Here we pass in an empty list of messages for chat_history because it is the first message in the chatagent_executor.invoke({\"input\": \"hi! my name is bob\", \"chat_history\": []})\n```\n\n```\n{'input': 'hi! my name is bob', 'chat_history': [], 'output': 'Hello Bob! How can I assist you today?'}\n```\n\n```\nfrom langchain_core.messages import AIMessage, HumanMessage\n```\n\n```\nagent_executor.invoke(    {        \"chat_history\": [            HumanMessage(content=\"hi! my name is bob\"),            AIMessage(content=\"Hello Bob! How can I assist you today?\"),        ],        \"input\": \"what's my name?\",    })\n```\n\n```\n{'chat_history': [HumanMessage(content='hi! my name is bob'),  AIMessage(content='Hello Bob! How can I assist you today?')], 'input': \"what's my name?\", 'output': 'Your name is Bob. How can I assist you further?'}\n```\n\nIf we want to keep track of these messages automatically, we can wrap this in a RunnableWithMessageHistory. For more information on how to use this, see [this guide](https://python.langchain.com/docs/how_to/message_history/).\n\n```\nfrom langchain_community.chat_message_histories import ChatMessageHistoryfrom langchain_core.chat_history import BaseChatMessageHistoryfrom langchain_core.runnables.history import RunnableWithMessageHistorystore = {}def get_session_history(session_id: str) -> BaseChatMessageHistory:    if session_id not in store:        store[session_id] = ChatMessageHistory()    return store[session_id]\n```\n\nBecause we have multiple inputs, we need to specify two things:\n\n*   `input_messages_key`: The input key to use to add to the conversation history.\n*   `history_messages_key`: The key to add the loaded messages into.\n\n```\nagent_with_chat_history = RunnableWithMessageHistory(    agent_executor,    get_session_history,    input_messages_key=\"input\",    history_messages_key=\"chat_history\",)\n```\n\n```\nagent_with_chat_history.invoke(    {\"input\": \"hi! I'm bob\"},    config={\"configurable\": {\"session_id\": \"<foo>\"}},)\n```\n\n```\n{'input': \"hi! I'm bob\", 'chat_history': [], 'output': 'Hello Bob! How can I assist you today?'}\n```\n\n```\nagent_with_chat_history.invoke(    {\"input\": \"what's my name?\"},    config={\"configurable\": {\"session_id\": \"<foo>\"}},)\n```\n\n```\n{'input': \"what's my name?\", 'chat_history': [HumanMessage(content=\"hi! I'm bob\"),  AIMessage(content='Hello Bob! How can I assist you today?')], 'output': 'Your name is Bob.'}\n```\n\nExample LangSmith trace: [https://smith.langchain.com/public/98c8d162-60ae-4493-aa9f-992d87bd0429/r](https://smith.langchain.com/public/98c8d162-60ae-4493-aa9f-992d87bd0429/r)\n\n## Conclusion[​](#conclusion \"Direct link to Conclusion\")\n\nThat's a wrap! In this quick start we covered how to create a simple agent. Agents are a complex topic, and there's lot to learn!\n\nimportant\n\nThis section covered building with LangChain Agents. They are fine for getting started, but past a certain point you will likely want flexibility and control which they do not offer. To develop more advanced agents, we recommend checking out [LangGraph](https://python.langchain.com/docs/concepts/architecture/#langgraph)\n\nIf you want to continue using LangChain agents, some good advanced guides are:\n\n*   [How to use LangGraph's built-in versions of `AgentExecutor`](https://python.langchain.com/docs/how_to/migrate_agent/)\n*   [How to create a custom agent](https://python.langchain.com/v0.1/docs/modules/agents/how_to/custom_agent/)\n*   [How to stream responses from an agent](https://python.langchain.com/v0.1/docs/modules/agents/how_to/streaming/)\n*   [How to return structured output from an agent](https://python.langchain.com/v0.1/docs/modules/agents/how_to/agent_structured/)"
},
{
  "url": "https://python.langchain.com/docs/how_to/sql_query_checking/",
  "markdown": "# giscus\n\n## How to do query validation as part of SQL question-answering\n\nPerhaps the most error-prone part of any SQL chain or agent is writing valid and safe SQL queries. In this guide we'll go over some strategies for validating our queries and handling invalid queries.\n\nWe will cover:\n\n1.  Appending a \"query validator\" step to the query generation;\n2.  Prompt engineering to reduce the incidence of errors.\n\n## Setup[​](#setup \"Direct link to Setup\")\n\nFirst, get required packages and set environment variables:\n\n```\n%pip install --upgrade --quiet  langchain langchain-community langchain-openai\n```\n\n```\n# Uncomment the below to use LangSmith. Not required.# import os# os.environ[\"LANGCHAIN_API_KEY\"] = getpass.getpass()# os.environ[\"LANGCHAIN_TRACING_V2\"] = \"true\"\n```\n\nThe below example will use a SQLite connection with Chinook database. Follow [these installation steps](https://database.guide/2-sample-databases-sqlite/) to create `Chinook.db` in the same directory as this notebook:\n\n*   Save [this file](https://raw.githubusercontent.com/lerocha/chinook-database/master/ChinookDatabase/DataSources/Chinook_Sqlite.sql) as `Chinook_Sqlite.sql`\n*   Run `sqlite3 Chinook.db`\n*   Run `.read Chinook_Sqlite.sql`\n*   Test `SELECT * FROM Artist LIMIT 10;`\n\nNow, `Chinook.db` is in our directory and we can interface with it using the SQLAlchemy-driven `SQLDatabase` class:\n\n```\nfrom langchain_community.utilities import SQLDatabasedb = SQLDatabase.from_uri(\"sqlite:///Chinook.db\")print(db.dialect)print(db.get_usable_table_names())print(db.run(\"SELECT * FROM Artist LIMIT 10;\"))\n```\n\n```\nsqlite['Album', 'Artist', 'Customer', 'Employee', 'Genre', 'Invoice', 'InvoiceLine', 'MediaType', 'Playlist', 'PlaylistTrack', 'Track'][(1, 'AC/DC'), (2, 'Accept'), (3, 'Aerosmith'), (4, 'Alanis Morissette'), (5, 'Alice In Chains'), (6, 'Antônio Carlos Jobim'), (7, 'Apocalyptica'), (8, 'Audioslave'), (9, 'BackBeat'), (10, 'Billy Cobham')]\n```\n\n## Query checker[​](#query-checker \"Direct link to Query checker\")\n\nPerhaps the simplest strategy is to ask the model itself to check the original query for common mistakes. Suppose we have the following SQL query chain:\n\n```\npip install -qU langchain-openai\n```\n\n```\nimport getpassimport osif not os.environ.get(\"OPENAI_API_KEY\"):  os.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"Enter API key for OpenAI: \")from langchain_openai import ChatOpenAIllm = ChatOpenAI(model=\"gpt-4o-mini\")\n```\n\n```\nfrom langchain.chains import create_sql_query_chainchain = create_sql_query_chain(llm, db)\n```\n\nAnd we want to validate its outputs. We can do so by extending the chain with a second prompt and model call:\n\n```\nfrom langchain_core.output_parsers import StrOutputParserfrom langchain_core.prompts import ChatPromptTemplatesystem = \"\"\"Double check the user's {dialect} query for common mistakes, including:- Using NOT IN with NULL values- Using UNION when UNION ALL should have been used- Using BETWEEN for exclusive ranges- Data type mismatch in predicates- Properly quoting identifiers- Using the correct number of arguments for functions- Casting to the correct data type- Using the proper columns for joinsIf there are any of the above mistakes, rewrite the query.If there are no mistakes, just reproduce the original query with no further commentary.Output the final SQL query only.\"\"\"prompt = ChatPromptTemplate.from_messages(    [(\"system\", system), (\"human\", \"{query}\")]).partial(dialect=db.dialect)validation_chain = prompt | llm | StrOutputParser()full_chain = {\"query\": chain} | validation_chain\n```\n\n```\nquery = full_chain.invoke(    {        \"question\": \"What's the average Invoice from an American customer whose Fax is missing since 2003 but before 2010\"    })print(query)\n```\n\n```\nSELECT AVG(i.Total) AS AverageInvoiceFROM Invoice iJOIN Customer c ON i.CustomerId = c.CustomerIdWHERE c.Country = 'USA'AND c.Fax IS NULLAND i.InvoiceDate >= '2003-01-01' AND i.InvoiceDate < '2010-01-01'\n```\n\nNote how we can see both steps of the chain in the [Langsmith trace](https://smith.langchain.com/public/8a743295-a57c-4e4c-8625-bc7e36af9d74/r).\n\nThe obvious downside of this approach is that we need to make two model calls instead of one to generate our query. To get around this we can try to perform the query generation and query check in a single model invocation:\n\n```\nsystem = \"\"\"You are a {dialect} expert. Given an input question, create a syntactically correct {dialect} query to run.Unless the user specifies in the question a specific number of examples to obtain, query for at most {top_k} results using the LIMIT clause as per {dialect}. You can order the results to return the most informative data in the database.Never query for all columns from a table. You must query only the columns that are needed to answer the question. Wrap each column name in double quotes (\") to denote them as delimited identifiers.Pay attention to use only the column names you can see in the tables below. Be careful to not query for columns that do not exist. Also, pay attention to which column is in which table.Pay attention to use date('now') function to get the current date, if the question involves \"today\".Only use the following tables:{table_info}Write an initial draft of the query. Then double check the {dialect} query for common mistakes, including:- Using NOT IN with NULL values- Using UNION when UNION ALL should have been used- Using BETWEEN for exclusive ranges- Data type mismatch in predicates- Properly quoting identifiers- Using the correct number of arguments for functions- Casting to the correct data type- Using the proper columns for joinsUse format:First draft: <<FIRST_DRAFT_QUERY>>Final answer: <<FINAL_ANSWER_QUERY>>\"\"\"prompt = ChatPromptTemplate.from_messages(    [(\"system\", system), (\"human\", \"{input}\")]).partial(dialect=db.dialect)def parse_final_answer(output: str) -> str:    return output.split(\"Final answer: \")[1]chain = create_sql_query_chain(llm, db, prompt=prompt) | parse_final_answerprompt.pretty_print()\n```\n\n```\n================================\u001b[1m System Message \u001b[0m================================You are a \u001b[33;1m\u001b[1;3m{dialect}\u001b[0m expert. Given an input question, create a syntactically correct \u001b[33;1m\u001b[1;3m{dialect}\u001b[0m query to run.Unless the user specifies in the question a specific number of examples to obtain, query for at most \u001b[33;1m\u001b[1;3m{top_k}\u001b[0m results using the LIMIT clause as per \u001b[33;1m\u001b[1;3m{dialect}\u001b[0m. You can order the results to return the most informative data in the database.Never query for all columns from a table. You must query only the columns that are needed to answer the question. Wrap each column name in double quotes (\") to denote them as delimited identifiers.Pay attention to use only the column names you can see in the tables below. Be careful to not query for columns that do not exist. Also, pay attention to which column is in which table.Pay attention to use date('now') function to get the current date, if the question involves \"today\".Only use the following tables:\u001b[33;1m\u001b[1;3m{table_info}\u001b[0mWrite an initial draft of the query. Then double check the \u001b[33;1m\u001b[1;3m{dialect}\u001b[0m query for common mistakes, including:- Using NOT IN with NULL values- Using UNION when UNION ALL should have been used- Using BETWEEN for exclusive ranges- Data type mismatch in predicates- Properly quoting identifiers- Using the correct number of arguments for functions- Casting to the correct data type- Using the proper columns for joinsUse format:First draft: <<FIRST_DRAFT_QUERY>>Final answer: <<FINAL_ANSWER_QUERY>>================================\u001b[1m Human Message \u001b[0m=================================\u001b[33;1m\u001b[1;3m{input}\u001b[0m\n```\n\n```\nquery = chain.invoke(    {        \"question\": \"What's the average Invoice from an American customer whose Fax is missing since 2003 but before 2010\"    })print(query)\n```\n\n```\nSELECT AVG(i.\"Total\") AS \"AverageInvoice\"FROM \"Invoice\" iJOIN \"Customer\" c ON i.\"CustomerId\" = c.\"CustomerId\"WHERE c.\"Country\" = 'USA'AND c.\"Fax\" IS NULLAND i.\"InvoiceDate\" BETWEEN '2003-01-01' AND '2010-01-01';\n```\n\n## Human-in-the-loop[​](#human-in-the-loop \"Direct link to Human-in-the-loop\")\n\nIn some cases our data is sensitive enough that we never want to execute a SQL query without a human approving it first. Head to the [Tool use: Human-in-the-loop](https://python.langchain.com/docs/how_to/tools_human/) page to learn how to add a human-in-the-loop to any tool, chain or agent.\n\n## Error handling[​](#error-handling \"Direct link to Error handling\")\n\nAt some point, the model will make a mistake and craft an invalid SQL query. Or an issue will arise with our database. Or the model API will go down. We'll want to add some error handling behavior to our chains and agents so that we fail gracefully in these situations, and perhaps even automatically recover. To learn about error handling with tools, head to the [Tool use: Error handling](https://python.langchain.com/docs/how_to/tools_error/) page."
},
{
  "url": "https://python.langchain.com/docs/how_to/streaming_llm/",
  "markdown": "# giscus\n\n## How to stream responses from an LLM\n\nAll `LLM`s implement the [Runnable interface](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable), which comes with **default** implementations of standard runnable methods (i.e. `ainvoke`, `batch`, `abatch`, `stream`, `astream`, `astream_events`).\n\nThe **default** streaming implementations provide an`Iterator` (or `AsyncIterator` for asynchronous streaming) that yields a single value: the final output from the underlying chat model provider.\n\nThe ability to stream the output token-by-token depends on whether the provider has implemented proper streaming support.\n\nSee which [integrations support token-by-token streaming here](https://python.langchain.com/docs/integrations/llms/).\n\nnote\n\nThe **default** implementation does **not** provide support for token-by-token streaming, but it ensures that the model can be swapped in for any other model as it supports the same standard interface.\n\n## Sync stream[​](#sync-stream \"Direct link to Sync stream\")\n\nBelow we use a `|` to help visualize the delimiter between tokens.\n\n```\nfrom langchain_openai import OpenAIllm = OpenAI(model=\"gpt-3.5-turbo-instruct\", temperature=0, max_tokens=512)for chunk in llm.stream(\"Write me a 1 verse song about sparkling water.\"):    print(chunk, end=\"|\", flush=True)\n```\n\n```\n|Spark|ling| water|,| oh| so clear||Bubbles dancing|,| without| fear||Refreshing| taste|,| a| pure| delight||Spark|ling| water|,| my| thirst|'s| delight||\n```\n\n## Async streaming[​](#async-streaming \"Direct link to Async streaming\")\n\nLet's see how to stream in an async setting using `astream`.\n\n```\nfrom langchain_openai import OpenAIllm = OpenAI(model=\"gpt-3.5-turbo-instruct\", temperature=0, max_tokens=512)async for chunk in llm.astream(\"Write me a 1 verse song about sparkling water.\"):    print(chunk, end=\"|\", flush=True)\n```\n\n```\n|Spark|ling| water|,| oh| so clear||Bubbles dancing|,| without| fear||Refreshing| taste|,| a| pure| delight||Spark|ling| water|,| my| thirst|'s| delight||\n```\n\n## Async event streaming[​](#async-event-streaming \"Direct link to Async event streaming\")\n\nLLMs also support the standard [astream events](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.base.Runnable.html#langchain_core.runnables.base.Runnable.astream_events) method.\n\ntip\n\n`astream_events` is most useful when implementing streaming in a larger LLM application that contains multiple steps (e.g., an application that involves an `agent`).\n\n```\nfrom langchain_openai import OpenAIllm = OpenAI(model=\"gpt-3.5-turbo-instruct\", temperature=0, max_tokens=512)idx = 0async for event in llm.astream_events(    \"Write me a 1 verse song about goldfish on the moon\", version=\"v1\"):    idx += 1    if idx >= 5:  # Truncate the output        print(\"...Truncated\")        break    print(event)\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/streaming/",
  "markdown": "# giscus\n\n## How to stream runnables\n\nStreaming is critical in making applications based on LLMs feel responsive to end-users.\n\nImportant LangChain primitives like [chat models](https://python.langchain.com/docs/concepts/chat_models/), [output parsers](https://python.langchain.com/docs/concepts/output_parsers/), [prompts](https://python.langchain.com/docs/concepts/prompt_templates/), [retrievers](https://python.langchain.com/docs/concepts/retrievers/), and [agents](https://python.langchain.com/docs/concepts/agents/) implement the LangChain [Runnable Interface](https://python.langchain.com/docs/concepts/runnables/).\n\nThis interface provides two general approaches to stream content:\n\n1.  sync `stream` and async `astream`: a **default implementation** of streaming that streams the **final output** from the chain.\n2.  async `astream_events` and async `astream_log`: these provide a way to stream both **intermediate steps** and **final output** from the chain.\n\nLet's take a look at both approaches, and try to understand how to use them.\n\n## Using Stream[​](#using-stream \"Direct link to Using Stream\")\n\nAll `Runnable` objects implement a sync method called `stream` and an async variant called `astream`.\n\nThese methods are designed to stream the final output in chunks, yielding each chunk as soon as it is available.\n\nStreaming is only possible if all steps in the program know how to process an **input stream**; i.e., process an input chunk one at a time, and yield a corresponding output chunk.\n\nThe complexity of this processing can vary, from straightforward tasks like emitting tokens produced by an LLM, to more challenging ones like streaming parts of JSON results before the entire JSON is complete.\n\nThe best place to start exploring streaming is with the single most important components in LLMs apps-- the LLMs themselves!\n\n### LLMs and Chat Models[​](#llms-and-chat-models \"Direct link to LLMs and Chat Models\")\n\nLarge language models and their chat variants are the primary bottleneck in LLM based apps.\n\nLarge language models can take **several seconds** to generate a complete response to a query. This is far slower than the **~200-300 ms** threshold at which an application feels responsive to an end user.\n\nThe key strategy to make the application feel more responsive is to show intermediate progress; viz., to stream the output from the model **token by token**.\n\nWe will show examples of streaming using a chat model. Choose one from the options below:\n\n```\npip install -qU langchain-openai\n```\n\n```\nimport getpassimport osif not os.environ.get(\"OPENAI_API_KEY\"):  os.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"Enter API key for OpenAI: \")from langchain_openai import ChatOpenAImodel = ChatOpenAI(model=\"gpt-4o-mini\")\n```\n\nLet's start with the sync `stream` API:\n\n```\nchunks = []for chunk in model.stream(\"what color is the sky?\"):    chunks.append(chunk)    print(chunk.content, end=\"|\", flush=True)\n```\n\n```\nThe| sky| appears| blue| during| the| day|.|\n```\n\nAlternatively, if you're working in an async environment, you may consider using the async `astream` API:\n\n```\nchunks = []async for chunk in model.astream(\"what color is the sky?\"):    chunks.append(chunk)    print(chunk.content, end=\"|\", flush=True)\n```\n\n```\nThe| sky| appears| blue| during| the| day|.|\n```\n\nLet's inspect one of the chunks\n\n```\nAIMessageChunk(content='The', id='run-b36bea64-5511-4d7a-b6a3-a07b3db0c8e7')\n```\n\nWe got back something called an `AIMessageChunk`. This chunk represents a part of an `AIMessage`.\n\nMessage chunks are additive by design -- one can simply add them up to get the state of the response so far!\n\n```\nchunks[0] + chunks[1] + chunks[2] + chunks[3] + chunks[4]\n```\n\n```\nAIMessageChunk(content='The sky appears blue during', id='run-b36bea64-5511-4d7a-b6a3-a07b3db0c8e7')\n```\n\n### Chains[​](#chains \"Direct link to Chains\")\n\nVirtually all LLM applications involve more steps than just a call to a language model.\n\nLet's build a simple chain using `LangChain Expression Language` (`LCEL`) that combines a prompt, model and a parser and verify that streaming works.\n\nWe will use [`StrOutputParser`](https://python.langchain.com/api_reference/core/output_parsers/langchain_core.output_parsers.string.StrOutputParser.html) to parse the output from the model. This is a simple parser that extracts the `content` field from an `AIMessageChunk`, giving us the `token` returned by the model.\n\ntip\n\nLCEL is a _declarative_ way to specify a \"program\" by chainining together different LangChain primitives. Chains created using LCEL benefit from an automatic implementation of `stream` and `astream` allowing streaming of the final output. In fact, chains created with LCEL implement the entire standard Runnable interface.\n\n```\nfrom langchain_core.output_parsers import StrOutputParserfrom langchain_core.prompts import ChatPromptTemplateprompt = ChatPromptTemplate.from_template(\"tell me a joke about {topic}\")parser = StrOutputParser()chain = prompt | model | parserasync for chunk in chain.astream({\"topic\": \"parrot\"}):    print(chunk, end=\"|\", flush=True)\n```\n\n```\nHere|'s| a| joke| about| a| par|rot|:|A man| goes| to| a| pet| shop| to| buy| a| par|rot|.| The| shop| owner| shows| him| two| stunning| pa|rr|ots| with| beautiful| pl|um|age|.|\"|There|'s| a| talking| par|rot| an|d a| non|-|talking| par|rot|,\"| the| owner| says|.| \"|The| talking| par|rot| costs| $|100|,| an|d the| non|-|talking| par|rot| is| $|20|.\"|The| man| says|,| \"|I|'ll| take| the| non|-|talking| par|rot| at| $|20|.\"|He| pays| an|d leaves| with| the| par|rot|.| As| he|'s| walking| down| the| street|,| the| par|rot| looks| up| at| him| an|d says|,| \"|You| know|,| you| really| are| a| stupi|d man|!\"|The| man| is| stun|ne|d an|d looks| at| the| par|rot| in| dis|bel|ief|.| The| par|rot| continues|,| \"|Yes|,| you| got| r|ippe|d off| big| time|!| I| can| talk| just| as| well| as| that| other| par|rot|,| an|d you| only| pai|d $|20| |for| me|!\"|\n```\n\nNote that we're getting streaming output even though we're using `parser` at the end of the chain above. The `parser` operates on each streaming chunk individidually. Many of the [LCEL primitives](https://python.langchain.com/docs/how_to/#langchain-expression-language-lcel) also support this kind of transform-style passthrough streaming, which can be very convenient when constructing apps.\n\nCustom functions can be [designed to return generators](https://python.langchain.com/docs/how_to/functions/#streaming), which are able to operate on streams.\n\nCertain runnables, like [prompt templates](https://python.langchain.com/docs/how_to/#prompt-templates) and [chat models](https://python.langchain.com/docs/how_to/#chat-models), cannot process individual chunks and instead aggregate all previous steps. Such runnables can interrupt the streaming process.\n\nnote\n\nThe LangChain Expression language allows you to separate the construction of a chain from the mode in which it is used (e.g., sync/async, batch/streaming etc.). If this is not relevant to what you're building, you can also rely on a standard **imperative** programming approach by caling `invoke`, `batch` or `stream` on each component individually, assigning the results to variables and then using them downstream as you see fit.\n\n### Working with Input Streams[​](#working-with-input-streams \"Direct link to Working with Input Streams\")\n\nWhat if you wanted to stream JSON from the output as it was being generated?\n\nIf you were to rely on `json.loads` to parse the partial json, the parsing would fail as the partial json wouldn't be valid json.\n\nYou'd likely be at a complete loss of what to do and claim that it wasn't possible to stream JSON.\n\nWell, turns out there is a way to do it -- the parser needs to operate on the **input stream**, and attempt to \"auto-complete\" the partial json into a valid state.\n\nLet's see such a parser in action to understand what this means.\n\n```\nfrom langchain_core.output_parsers import JsonOutputParserchain = (    model | JsonOutputParser())  # Due to a bug in older versions of Langchain, JsonOutputParser did not stream results from some modelsasync for text in chain.astream(    \"output a list of the countries france, spain and japan and their populations in JSON format. \"    'Use a dict with an outer key of \"countries\" which contains a list of countries. '    \"Each country should have the key `name` and `population`\"):    print(text, flush=True)\n```\n\n```\n{}{'countries': []}{'countries': [{}]}{'countries': [{'name': ''}]}{'countries': [{'name': 'France'}]}{'countries': [{'name': 'France', 'population': 67}]}{'countries': [{'name': 'France', 'population': 67413}]}{'countries': [{'name': 'France', 'population': 67413000}]}{'countries': [{'name': 'France', 'population': 67413000}, {}]}{'countries': [{'name': 'France', 'population': 67413000}, {'name': ''}]}{'countries': [{'name': 'France', 'population': 67413000}, {'name': 'Spain'}]}{'countries': [{'name': 'France', 'population': 67413000}, {'name': 'Spain', 'population': 47}]}{'countries': [{'name': 'France', 'population': 67413000}, {'name': 'Spain', 'population': 47351}]}{'countries': [{'name': 'France', 'population': 67413000}, {'name': 'Spain', 'population': 47351567}]}{'countries': [{'name': 'France', 'population': 67413000}, {'name': 'Spain', 'population': 47351567}, {}]}{'countries': [{'name': 'France', 'population': 67413000}, {'name': 'Spain', 'population': 47351567}, {'name': ''}]}{'countries': [{'name': 'France', 'population': 67413000}, {'name': 'Spain', 'population': 47351567}, {'name': 'Japan'}]}{'countries': [{'name': 'France', 'population': 67413000}, {'name': 'Spain', 'population': 47351567}, {'name': 'Japan', 'population': 125}]}{'countries': [{'name': 'France', 'population': 67413000}, {'name': 'Spain', 'population': 47351567}, {'name': 'Japan', 'population': 125584}]}{'countries': [{'name': 'France', 'population': 67413000}, {'name': 'Spain', 'population': 47351567}, {'name': 'Japan', 'population': 125584000}]}\n```\n\nNow, let's **break** streaming. We'll use the previous example and append an extraction function at the end that extracts the country names from the finalized JSON.\n\nwarning\n\nAny steps in the chain that operate on **finalized inputs** rather than on **input streams** can break streaming functionality via `stream` or `astream`.\n\ntip\n\nLater, we will discuss the `astream_events` API which streams results from intermediate steps. This API will stream results from intermediate steps even if the chain contains steps that only operate on **finalized inputs**.\n\n```\nfrom langchain_core.output_parsers import (    JsonOutputParser,)# A function that operates on finalized inputs# rather than on an input_streamdef _extract_country_names(inputs):    \"\"\"A function that does not operates on input streams and breaks streaming.\"\"\"    if not isinstance(inputs, dict):        return \"\"    if \"countries\" not in inputs:        return \"\"    countries = inputs[\"countries\"]    if not isinstance(countries, list):        return \"\"    country_names = [        country.get(\"name\") for country in countries if isinstance(country, dict)    ]    return country_nameschain = model | JsonOutputParser() | _extract_country_namesasync for text in chain.astream(    \"output a list of the countries france, spain and japan and their populations in JSON format. \"    'Use a dict with an outer key of \"countries\" which contains a list of countries. '    \"Each country should have the key `name` and `population`\"):    print(text, end=\"|\", flush=True)\n```\n\n```\n['France', 'Spain', 'Japan']|\n```\n\n#### Generator Functions[​](#generator-functions \"Direct link to Generator Functions\")\n\nLet's fix the streaming using a generator function that can operate on the **input stream**.\n\ntip\n\nA generator function (a function that uses `yield`) allows writing code that operates on **input streams**\n\n```\nfrom langchain_core.output_parsers import JsonOutputParserasync def _extract_country_names_streaming(input_stream):    \"\"\"A function that operates on input streams.\"\"\"    country_names_so_far = set()    async for input in input_stream:        if not isinstance(input, dict):            continue        if \"countries\" not in input:            continue        countries = input[\"countries\"]        if not isinstance(countries, list):            continue        for country in countries:            name = country.get(\"name\")            if not name:                continue            if name not in country_names_so_far:                yield name                country_names_so_far.add(name)chain = model | JsonOutputParser() | _extract_country_names_streamingasync for text in chain.astream(    \"output a list of the countries france, spain and japan and their populations in JSON format. \"    'Use a dict with an outer key of \"countries\" which contains a list of countries. '    \"Each country should have the key `name` and `population`\",):    print(text, end=\"|\", flush=True)\n```\n\nnote\n\nBecause the code above is relying on JSON auto-completion, you may see partial names of countries (e.g., `Sp` and `Spain`), which is not what one would want for an extraction result!\n\nWe're focusing on streaming concepts, not necessarily the results of the chains.\n\n### Non-streaming components[​](#non-streaming-components \"Direct link to Non-streaming components\")\n\nSome built-in components like Retrievers do not offer any `streaming`. What happens if we try to `stream` them? 🤨\n\n```\nfrom langchain_community.vectorstores import FAISSfrom langchain_core.output_parsers import StrOutputParserfrom langchain_core.prompts import ChatPromptTemplatefrom langchain_core.runnables import RunnablePassthroughfrom langchain_openai import OpenAIEmbeddingstemplate = \"\"\"Answer the question based only on the following context:{context}Question: {question}\"\"\"prompt = ChatPromptTemplate.from_template(template)vectorstore = FAISS.from_texts(    [\"harrison worked at kensho\", \"harrison likes spicy food\"],    embedding=OpenAIEmbeddings(),)retriever = vectorstore.as_retriever()chunks = [chunk for chunk in retriever.stream(\"where did harrison work?\")]chunks\n```\n\n```\n[[Document(page_content='harrison worked at kensho'),  Document(page_content='harrison likes spicy food')]]\n```\n\nStream just yielded the final result from that component.\n\nThis is OK 🥹! Not all components have to implement streaming -- in some cases streaming is either unnecessary, difficult or just doesn't make sense.\n\ntip\n\nAn LCEL chain constructed using non-streaming components, will still be able to stream in a lot of cases, with streaming of partial output starting after the last non-streaming step in the chain.\n\n```\nretrieval_chain = (    {        \"context\": retriever.with_config(run_name=\"Docs\"),        \"question\": RunnablePassthrough(),    }    | prompt    | model    | StrOutputParser())\n```\n\n```\nfor chunk in retrieval_chain.stream(    \"Where did harrison work? \" \"Write 3 made up sentences about this place.\"):    print(chunk, end=\"|\", flush=True)\n```\n\n```\nBase|d on| the| given| context|,| Harrison| worke|d at| K|ens|ho|.|Here| are| |3| |made| up| sentences| about| this| place|:|1|.| K|ens|ho| was| a| cutting|-|edge| technology| company| known| for| its| innovative| solutions| in| artificial| intelligence| an|d data| analytics|.|2|.| The| modern| office| space| at| K|ens|ho| feature|d open| floor| plans|,| collaborative| work|sp|aces|,| an|d a| vib|rant| atmosphere| that| fos|tere|d creativity| an|d team|work|.|3|.| With| its| prime| location| in| the| heart| of| the| city|,| K|ens|ho| attracte|d top| talent| from| aroun|d the| worl|d,| creating| a| diverse| an|d dynamic| work| environment|.|\n```\n\nNow that we've seen how `stream` and `astream` work, let's venture into the world of streaming events. 🏞️\n\n## Using Stream Events[​](#using-stream-events \"Direct link to Using Stream Events\")\n\nEvent Streaming is a **beta** API. This API may change a bit based on feedback.\n\nnote\n\nThis guide demonstrates the `V2` API and requires langchain-core >= 0.2. For the `V1` API compatible with older versions of LangChain, see [here](https://python.langchain.com/v0.1/docs/expression_language/streaming/#using-stream-events).\n\n```\nimport langchain_corelangchain_core.__version__\n```\n\nFor the `astream_events` API to work properly:\n\n*   Use `async` throughout the code to the extent possible (e.g., async tools etc)\n*   Propagate callbacks if defining custom functions / runnables\n*   Whenever using runnables without LCEL, make sure to call `.astream()` on LLMs rather than `.ainvoke` to force the LLM to stream tokens.\n*   Let us know if anything doesn't work as expected! :)\n\n### Event Reference[​](#event-reference \"Direct link to Event Reference\")\n\nBelow is a reference table that shows some events that might be emitted by the various Runnable objects.\n\nnote\n\nWhen streaming is implemented properly, the inputs to a runnable will not be known until after the input stream has been entirely consumed. This means that `inputs` will often be included only for `end` events and rather than for `start` events.\n\n| event | name | chunk | input | output |\n| --- | --- | --- | --- | --- |\n| on\\_chat\\_model\\_start | \\[model name\\] |     | {\"messages\": \\[\\[SystemMessage, HumanMessage\\]\\]} |     |\n| on\\_chat\\_model\\_stream | \\[model name\\] | AIMessageChunk(content=\"hello\") |     |     |\n| on\\_chat\\_model\\_end | \\[model name\\] |     | {\"messages\": \\[\\[SystemMessage, HumanMessage\\]\\]} | AIMessageChunk(content=\"hello world\") |\n| on\\_llm\\_start | \\[model name\\] |     | {'input': 'hello'} |     |\n| on\\_llm\\_stream | \\[model name\\] | 'Hello' |     |     |\n| on\\_llm\\_end | \\[model name\\] |     | 'Hello human!' |     |\n| on\\_chain\\_start | format\\_docs |     |     |     |\n| on\\_chain\\_stream | format\\_docs | \"hello world!, goodbye world!\" |     |     |\n| on\\_chain\\_end | format\\_docs |     | \\[Document(...)\\] | \"hello world!, goodbye world!\" |\n| on\\_tool\\_start | some\\_tool |     | {\"x\": 1, \"y\": \"2\"} |     |\n| on\\_tool\\_end | some\\_tool |     |     | {\"x\": 1, \"y\": \"2\"} |\n| on\\_retriever\\_start | \\[retriever name\\] |     | {\"query\": \"hello\"} |     |\n| on\\_retriever\\_end | \\[retriever name\\] |     | {\"query\": \"hello\"} | \\[Document(...), ..\\] |\n| on\\_prompt\\_start | \\[template\\_name\\] |     | {\"question\": \"hello\"} |     |\n| on\\_prompt\\_end | \\[template\\_name\\] |     | {\"question\": \"hello\"} | ChatPromptValue(messages: \\[SystemMessage, ...\\]) |\n\n### Chat Model[​](#chat-model \"Direct link to Chat Model\")\n\nLet's start off by looking at the events produced by a chat model.\n\n```\nevents = []async for event in model.astream_events(\"hello\", version=\"v2\"):    events.append(event)\n```\n\n```\n/home/eugene/src/langchain/libs/core/langchain_core/_api/beta_decorator.py:87: LangChainBetaWarning: This API is in beta and may change in the future.  warn_beta(\n```\n\nnote\n\nHey what's that funny version=\"v2\" parameter in the API?! 😾\n\nThis is a **beta API**, and we're almost certainly going to make some changes to it (in fact, we already have!)\n\nThis version parameter will allow us to minimize such breaking changes to your code.\n\nIn short, we are annoying you now, so we don't have to annoy you later.\n\n`v2` is only available for langchain-core>=0.2.0.\n\nLet's take a look at the few of the start event and a few of the end events.\n\n```\n[{'event': 'on_chat_model_start',  'data': {'input': 'hello'},  'name': 'ChatAnthropic',  'tags': [],  'run_id': 'a81e4c0f-fc36-4d33-93bc-1ac25b9bb2c3',  'metadata': {}}, {'event': 'on_chat_model_stream',  'data': {'chunk': AIMessageChunk(content='Hello', id='run-a81e4c0f-fc36-4d33-93bc-1ac25b9bb2c3')},  'run_id': 'a81e4c0f-fc36-4d33-93bc-1ac25b9bb2c3',  'name': 'ChatAnthropic',  'tags': [],  'metadata': {}}, {'event': 'on_chat_model_stream',  'data': {'chunk': AIMessageChunk(content='!', id='run-a81e4c0f-fc36-4d33-93bc-1ac25b9bb2c3')},  'run_id': 'a81e4c0f-fc36-4d33-93bc-1ac25b9bb2c3',  'name': 'ChatAnthropic',  'tags': [],  'metadata': {}}]\n```\n\n```\n[{'event': 'on_chat_model_stream',  'data': {'chunk': AIMessageChunk(content='?', id='run-a81e4c0f-fc36-4d33-93bc-1ac25b9bb2c3')},  'run_id': 'a81e4c0f-fc36-4d33-93bc-1ac25b9bb2c3',  'name': 'ChatAnthropic',  'tags': [],  'metadata': {}}, {'event': 'on_chat_model_end',  'data': {'output': AIMessageChunk(content='Hello! How can I assist you today?', id='run-a81e4c0f-fc36-4d33-93bc-1ac25b9bb2c3')},  'run_id': 'a81e4c0f-fc36-4d33-93bc-1ac25b9bb2c3',  'name': 'ChatAnthropic',  'tags': [],  'metadata': {}}]\n```\n\n### Chain[​](#chain \"Direct link to Chain\")\n\nLet's revisit the example chain that parsed streaming JSON to explore the streaming events API.\n\n```\nchain = (    model | JsonOutputParser())  # Due to a bug in older versions of Langchain, JsonOutputParser did not stream results from some modelsevents = [    event    async for event in chain.astream_events(        \"output a list of the countries france, spain and japan and their populations in JSON format. \"        'Use a dict with an outer key of \"countries\" which contains a list of countries. '        \"Each country should have the key `name` and `population`\",        version=\"v2\",    )]\n```\n\nIf you examine at the first few events, you'll notice that there are **3** different start events rather than **2** start events.\n\nThe three start events correspond to:\n\n1.  The chain (model + parser)\n2.  The model\n3.  The parser\n\n```\n[{'event': 'on_chain_start',  'data': {'input': 'output a list of the countries france, spain and japan and their populations in JSON format. Use a dict with an outer key of \"countries\" which contains a list of countries. Each country should have the key `name` and `population`'},  'name': 'RunnableSequence',  'tags': [],  'run_id': '4765006b-16e2-4b1d-a523-edd9fd64cb92',  'metadata': {}}, {'event': 'on_chat_model_start',  'data': {'input': {'messages': [[HumanMessage(content='output a list of the countries france, spain and japan and their populations in JSON format. Use a dict with an outer key of \"countries\" which contains a list of countries. Each country should have the key `name` and `population`')]]}},  'name': 'ChatAnthropic',  'tags': ['seq:step:1'],  'run_id': '0320c234-7b52-4a14-ae4e-5f100949e589',  'metadata': {}}, {'event': 'on_chat_model_stream',  'data': {'chunk': AIMessageChunk(content='{', id='run-0320c234-7b52-4a14-ae4e-5f100949e589')},  'run_id': '0320c234-7b52-4a14-ae4e-5f100949e589',  'name': 'ChatAnthropic',  'tags': ['seq:step:1'],  'metadata': {}}]\n```\n\nWhat do you think you'd see if you looked at the last 3 events? what about the middle?\n\nLet's use this API to take output the stream events from the model and the parser. We're ignoring start events, end events and events from the chain.\n\n```\nnum_events = 0async for event in chain.astream_events(    \"output a list of the countries france, spain and japan and their populations in JSON format. \"    'Use a dict with an outer key of \"countries\" which contains a list of countries. '    \"Each country should have the key `name` and `population`\",    version=\"v2\",):    kind = event[\"event\"]    if kind == \"on_chat_model_stream\":        print(            f\"Chat model chunk: {repr(event['data']['chunk'].content)}\",            flush=True,        )    if kind == \"on_parser_stream\":        print(f\"Parser chunk: {event['data']['chunk']}\", flush=True)    num_events += 1    if num_events > 30:        # Truncate the output        print(\"...\")        break\n```\n\n```\nChat model chunk: '{'Parser chunk: {}Chat model chunk: '\\n  'Chat model chunk: '\"'Chat model chunk: 'countries'Chat model chunk: '\":'Chat model chunk: ' ['Parser chunk: {'countries': []}Chat model chunk: '\\n    'Chat model chunk: '{'Parser chunk: {'countries': [{}]}Chat model chunk: '\\n      'Chat model chunk: '\"'Chat model chunk: 'name'Chat model chunk: '\":'Chat model chunk: ' \"'Parser chunk: {'countries': [{'name': ''}]}Chat model chunk: 'France'Parser chunk: {'countries': [{'name': 'France'}]}Chat model chunk: '\",'Chat model chunk: '\\n      'Chat model chunk: '\"'Chat model chunk: 'population'...\n```\n\nBecause both the model and the parser support streaming, we see streaming events from both components in real time! Kind of cool isn't it? 🦜\n\n### Filtering Events[​](#filtering-events \"Direct link to Filtering Events\")\n\nBecause this API produces so many events, it is useful to be able to filter on events.\n\nYou can filter by either component `name`, component `tags` or component `type`.\n\n#### By Name[​](#by-name \"Direct link to By Name\")\n\n```\nchain = model.with_config({\"run_name\": \"model\"}) | JsonOutputParser().with_config(    {\"run_name\": \"my_parser\"})max_events = 0async for event in chain.astream_events(    \"output a list of the countries france, spain and japan and their populations in JSON format. \"    'Use a dict with an outer key of \"countries\" which contains a list of countries. '    \"Each country should have the key `name` and `population`\",    version=\"v2\",    include_names=[\"my_parser\"],):    print(event)    max_events += 1    if max_events > 10:        # Truncate output        print(\"...\")        break\n```\n\n```\n{'event': 'on_parser_start', 'data': {'input': 'output a list of the countries france, spain and japan and their populations in JSON format. Use a dict with an outer key of \"countries\" which contains a list of countries. Each country should have the key `name` and `population`'}, 'name': 'my_parser', 'tags': ['seq:step:2'], 'run_id': 'e058d750-f2c2-40f6-aa61-10f84cd671a9', 'metadata': {}}{'event': 'on_parser_stream', 'data': {'chunk': {}}, 'run_id': 'e058d750-f2c2-40f6-aa61-10f84cd671a9', 'name': 'my_parser', 'tags': ['seq:step:2'], 'metadata': {}}{'event': 'on_parser_stream', 'data': {'chunk': {'countries': []}}, 'run_id': 'e058d750-f2c2-40f6-aa61-10f84cd671a9', 'name': 'my_parser', 'tags': ['seq:step:2'], 'metadata': {}}{'event': 'on_parser_stream', 'data': {'chunk': {'countries': [{}]}}, 'run_id': 'e058d750-f2c2-40f6-aa61-10f84cd671a9', 'name': 'my_parser', 'tags': ['seq:step:2'], 'metadata': {}}{'event': 'on_parser_stream', 'data': {'chunk': {'countries': [{'name': ''}]}}, 'run_id': 'e058d750-f2c2-40f6-aa61-10f84cd671a9', 'name': 'my_parser', 'tags': ['seq:step:2'], 'metadata': {}}{'event': 'on_parser_stream', 'data': {'chunk': {'countries': [{'name': 'France'}]}}, 'run_id': 'e058d750-f2c2-40f6-aa61-10f84cd671a9', 'name': 'my_parser', 'tags': ['seq:step:2'], 'metadata': {}}{'event': 'on_parser_stream', 'data': {'chunk': {'countries': [{'name': 'France', 'population': 67}]}}, 'run_id': 'e058d750-f2c2-40f6-aa61-10f84cd671a9', 'name': 'my_parser', 'tags': ['seq:step:2'], 'metadata': {}}{'event': 'on_parser_stream', 'data': {'chunk': {'countries': [{'name': 'France', 'population': 67413}]}}, 'run_id': 'e058d750-f2c2-40f6-aa61-10f84cd671a9', 'name': 'my_parser', 'tags': ['seq:step:2'], 'metadata': {}}{'event': 'on_parser_stream', 'data': {'chunk': {'countries': [{'name': 'France', 'population': 67413000}]}}, 'run_id': 'e058d750-f2c2-40f6-aa61-10f84cd671a9', 'name': 'my_parser', 'tags': ['seq:step:2'], 'metadata': {}}{'event': 'on_parser_stream', 'data': {'chunk': {'countries': [{'name': 'France', 'population': 67413000}, {}]}}, 'run_id': 'e058d750-f2c2-40f6-aa61-10f84cd671a9', 'name': 'my_parser', 'tags': ['seq:step:2'], 'metadata': {}}{'event': 'on_parser_stream', 'data': {'chunk': {'countries': [{'name': 'France', 'population': 67413000}, {'name': ''}]}}, 'run_id': 'e058d750-f2c2-40f6-aa61-10f84cd671a9', 'name': 'my_parser', 'tags': ['seq:step:2'], 'metadata': {}}...\n```\n\n#### By Type[​](#by-type \"Direct link to By Type\")\n\n```\nchain = model.with_config({\"run_name\": \"model\"}) | JsonOutputParser().with_config(    {\"run_name\": \"my_parser\"})max_events = 0async for event in chain.astream_events(    'output a list of the countries france, spain and japan and their populations in JSON format. Use a dict with an outer key of \"countries\" which contains a list of countries. Each country should have the key `name` and `population`',    version=\"v2\",    include_types=[\"chat_model\"],):    print(event)    max_events += 1    if max_events > 10:        # Truncate output        print(\"...\")        break\n```\n\n```\n{'event': 'on_chat_model_start', 'data': {'input': 'output a list of the countries france, spain and japan and their populations in JSON format. Use a dict with an outer key of \"countries\" which contains a list of countries. Each country should have the key `name` and `population`'}, 'name': 'model', 'tags': ['seq:step:1'], 'run_id': 'db246792-2a91-4eb3-a14b-29658947065d', 'metadata': {}}{'event': 'on_chat_model_stream', 'data': {'chunk': AIMessageChunk(content='{', id='run-db246792-2a91-4eb3-a14b-29658947065d')}, 'run_id': 'db246792-2a91-4eb3-a14b-29658947065d', 'name': 'model', 'tags': ['seq:step:1'], 'metadata': {}}{'event': 'on_chat_model_stream', 'data': {'chunk': AIMessageChunk(content='\\n  ', id='run-db246792-2a91-4eb3-a14b-29658947065d')}, 'run_id': 'db246792-2a91-4eb3-a14b-29658947065d', 'name': 'model', 'tags': ['seq:step:1'], 'metadata': {}}{'event': 'on_chat_model_stream', 'data': {'chunk': AIMessageChunk(content='\"', id='run-db246792-2a91-4eb3-a14b-29658947065d')}, 'run_id': 'db246792-2a91-4eb3-a14b-29658947065d', 'name': 'model', 'tags': ['seq:step:1'], 'metadata': {}}{'event': 'on_chat_model_stream', 'data': {'chunk': AIMessageChunk(content='countries', id='run-db246792-2a91-4eb3-a14b-29658947065d')}, 'run_id': 'db246792-2a91-4eb3-a14b-29658947065d', 'name': 'model', 'tags': ['seq:step:1'], 'metadata': {}}{'event': 'on_chat_model_stream', 'data': {'chunk': AIMessageChunk(content='\":', id='run-db246792-2a91-4eb3-a14b-29658947065d')}, 'run_id': 'db246792-2a91-4eb3-a14b-29658947065d', 'name': 'model', 'tags': ['seq:step:1'], 'metadata': {}}{'event': 'on_chat_model_stream', 'data': {'chunk': AIMessageChunk(content=' [', id='run-db246792-2a91-4eb3-a14b-29658947065d')}, 'run_id': 'db246792-2a91-4eb3-a14b-29658947065d', 'name': 'model', 'tags': ['seq:step:1'], 'metadata': {}}{'event': 'on_chat_model_stream', 'data': {'chunk': AIMessageChunk(content='\\n    ', id='run-db246792-2a91-4eb3-a14b-29658947065d')}, 'run_id': 'db246792-2a91-4eb3-a14b-29658947065d', 'name': 'model', 'tags': ['seq:step:1'], 'metadata': {}}{'event': 'on_chat_model_stream', 'data': {'chunk': AIMessageChunk(content='{', id='run-db246792-2a91-4eb3-a14b-29658947065d')}, 'run_id': 'db246792-2a91-4eb3-a14b-29658947065d', 'name': 'model', 'tags': ['seq:step:1'], 'metadata': {}}{'event': 'on_chat_model_stream', 'data': {'chunk': AIMessageChunk(content='\\n      ', id='run-db246792-2a91-4eb3-a14b-29658947065d')}, 'run_id': 'db246792-2a91-4eb3-a14b-29658947065d', 'name': 'model', 'tags': ['seq:step:1'], 'metadata': {}}{'event': 'on_chat_model_stream', 'data': {'chunk': AIMessageChunk(content='\"', id='run-db246792-2a91-4eb3-a14b-29658947065d')}, 'run_id': 'db246792-2a91-4eb3-a14b-29658947065d', 'name': 'model', 'tags': ['seq:step:1'], 'metadata': {}}...\n```\n\n#### By Tags[​](#by-tags \"Direct link to By Tags\")\n\ncaution\n\nTags are inherited by child components of a given runnable.\n\nIf you're using tags to filter, make sure that this is what you want.\n\n```\nchain = (model | JsonOutputParser()).with_config({\"tags\": [\"my_chain\"]})max_events = 0async for event in chain.astream_events(    'output a list of the countries france, spain and japan and their populations in JSON format. Use a dict with an outer key of \"countries\" which contains a list of countries. Each country should have the key `name` and `population`',    version=\"v2\",    include_tags=[\"my_chain\"],):    print(event)    max_events += 1    if max_events > 10:        # Truncate output        print(\"...\")        break\n```\n\n```\n{'event': 'on_chain_start', 'data': {'input': 'output a list of the countries france, spain and japan and their populations in JSON format. Use a dict with an outer key of \"countries\" which contains a list of countries. Each country should have the key `name` and `population`'}, 'name': 'RunnableSequence', 'tags': ['my_chain'], 'run_id': 'fd68dd64-7a4d-4bdb-a0c2-ee592db0d024', 'metadata': {}}{'event': 'on_chat_model_start', 'data': {'input': {'messages': [[HumanMessage(content='output a list of the countries france, spain and japan and their populations in JSON format. Use a dict with an outer key of \"countries\" which contains a list of countries. Each country should have the key `name` and `population`')]]}}, 'name': 'ChatAnthropic', 'tags': ['seq:step:1', 'my_chain'], 'run_id': 'efd3c8af-4be5-4f6c-9327-e3f9865dd1cd', 'metadata': {}}{'event': 'on_chat_model_stream', 'data': {'chunk': AIMessageChunk(content='{', id='run-efd3c8af-4be5-4f6c-9327-e3f9865dd1cd')}, 'run_id': 'efd3c8af-4be5-4f6c-9327-e3f9865dd1cd', 'name': 'ChatAnthropic', 'tags': ['seq:step:1', 'my_chain'], 'metadata': {}}{'event': 'on_parser_start', 'data': {}, 'name': 'JsonOutputParser', 'tags': ['seq:step:2', 'my_chain'], 'run_id': 'afde30b9-beac-4b36-b4c7-dbbe423ddcdb', 'metadata': {}}{'event': 'on_parser_stream', 'data': {'chunk': {}}, 'run_id': 'afde30b9-beac-4b36-b4c7-dbbe423ddcdb', 'name': 'JsonOutputParser', 'tags': ['seq:step:2', 'my_chain'], 'metadata': {}}{'event': 'on_chain_stream', 'data': {'chunk': {}}, 'run_id': 'fd68dd64-7a4d-4bdb-a0c2-ee592db0d024', 'name': 'RunnableSequence', 'tags': ['my_chain'], 'metadata': {}}{'event': 'on_chat_model_stream', 'data': {'chunk': AIMessageChunk(content='\\n  ', id='run-efd3c8af-4be5-4f6c-9327-e3f9865dd1cd')}, 'run_id': 'efd3c8af-4be5-4f6c-9327-e3f9865dd1cd', 'name': 'ChatAnthropic', 'tags': ['seq:step:1', 'my_chain'], 'metadata': {}}{'event': 'on_chat_model_stream', 'data': {'chunk': AIMessageChunk(content='\"', id='run-efd3c8af-4be5-4f6c-9327-e3f9865dd1cd')}, 'run_id': 'efd3c8af-4be5-4f6c-9327-e3f9865dd1cd', 'name': 'ChatAnthropic', 'tags': ['seq:step:1', 'my_chain'], 'metadata': {}}{'event': 'on_chat_model_stream', 'data': {'chunk': AIMessageChunk(content='countries', id='run-efd3c8af-4be5-4f6c-9327-e3f9865dd1cd')}, 'run_id': 'efd3c8af-4be5-4f6c-9327-e3f9865dd1cd', 'name': 'ChatAnthropic', 'tags': ['seq:step:1', 'my_chain'], 'metadata': {}}{'event': 'on_chat_model_stream', 'data': {'chunk': AIMessageChunk(content='\":', id='run-efd3c8af-4be5-4f6c-9327-e3f9865dd1cd')}, 'run_id': 'efd3c8af-4be5-4f6c-9327-e3f9865dd1cd', 'name': 'ChatAnthropic', 'tags': ['seq:step:1', 'my_chain'], 'metadata': {}}{'event': 'on_chat_model_stream', 'data': {'chunk': AIMessageChunk(content=' [', id='run-efd3c8af-4be5-4f6c-9327-e3f9865dd1cd')}, 'run_id': 'efd3c8af-4be5-4f6c-9327-e3f9865dd1cd', 'name': 'ChatAnthropic', 'tags': ['seq:step:1', 'my_chain'], 'metadata': {}}...\n```\n\n### Non-streaming components[​](#non-streaming-components-1 \"Direct link to Non-streaming components\")\n\nRemember how some components don't stream well because they don't operate on **input streams**?\n\nWhile such components can break streaming of the final output when using `astream`, `astream_events` will still yield streaming events from intermediate steps that support streaming!\n\n```\n# Function that does not support streaming.# It operates on the finalizes inputs rather than# operating on the input stream.def _extract_country_names(inputs):    \"\"\"A function that does not operates on input streams and breaks streaming.\"\"\"    if not isinstance(inputs, dict):        return \"\"    if \"countries\" not in inputs:        return \"\"    countries = inputs[\"countries\"]    if not isinstance(countries, list):        return \"\"    country_names = [        country.get(\"name\") for country in countries if isinstance(country, dict)    ]    return country_nameschain = (    model | JsonOutputParser() | _extract_country_names)  # This parser only works with OpenAI right now\n```\n\nAs expected, the `astream` API doesn't work correctly because `_extract_country_names` doesn't operate on streams.\n\n```\nasync for chunk in chain.astream(    \"output a list of the countries france, spain and japan and their populations in JSON format. \"    'Use a dict with an outer key of \"countries\" which contains a list of countries. '    \"Each country should have the key `name` and `population`\",):    print(chunk, flush=True)\n```\n\n```\n['France', 'Spain', 'Japan']\n```\n\nNow, let's confirm that with astream\\_events we're still seeing streaming output from the model and the parser.\n\n```\nnum_events = 0async for event in chain.astream_events(    \"output a list of the countries france, spain and japan and their populations in JSON format. \"    'Use a dict with an outer key of \"countries\" which contains a list of countries. '    \"Each country should have the key `name` and `population`\",    version=\"v2\",):    kind = event[\"event\"]    if kind == \"on_chat_model_stream\":        print(            f\"Chat model chunk: {repr(event['data']['chunk'].content)}\",            flush=True,        )    if kind == \"on_parser_stream\":        print(f\"Parser chunk: {event['data']['chunk']}\", flush=True)    num_events += 1    if num_events > 30:        # Truncate the output        print(\"...\")        break\n```\n\n```\nChat model chunk: '{'Parser chunk: {}Chat model chunk: '\\n  'Chat model chunk: '\"'Chat model chunk: 'countries'Chat model chunk: '\":'Chat model chunk: ' ['Parser chunk: {'countries': []}Chat model chunk: '\\n    'Chat model chunk: '{'Parser chunk: {'countries': [{}]}Chat model chunk: '\\n      'Chat model chunk: '\"'Chat model chunk: 'name'Chat model chunk: '\":'Chat model chunk: ' \"'Parser chunk: {'countries': [{'name': ''}]}Chat model chunk: 'France'Parser chunk: {'countries': [{'name': 'France'}]}Chat model chunk: '\",'Chat model chunk: '\\n      'Chat model chunk: '\"'Chat model chunk: 'population'Chat model chunk: '\":'Chat model chunk: ' 'Chat model chunk: '67'Parser chunk: {'countries': [{'name': 'France', 'population': 67}]}...\n```\n\n### Propagating Callbacks[​](#propagating-callbacks \"Direct link to Propagating Callbacks\")\n\ncaution\n\nIf you're using invoking runnables inside your tools, you need to propagate callbacks to the runnable; otherwise, no stream events will be generated.\n\nnote\n\nWhen using `RunnableLambdas` or `@chain` decorator, callbacks are propagated automatically behind the scenes.\n\n```\nfrom langchain_core.runnables import RunnableLambdafrom langchain_core.tools import tooldef reverse_word(word: str):    return word[::-1]reverse_word = RunnableLambda(reverse_word)@tooldef bad_tool(word: str):    \"\"\"Custom tool that doesn't propagate callbacks.\"\"\"    return reverse_word.invoke(word)async for event in bad_tool.astream_events(\"hello\", version=\"v2\"):    print(event)\n```\n\n```\n{'event': 'on_tool_start', 'data': {'input': 'hello'}, 'name': 'bad_tool', 'tags': [], 'run_id': 'ea900472-a8f7-425d-b627-facdef936ee8', 'metadata': {}}{'event': 'on_chain_start', 'data': {'input': 'hello'}, 'name': 'reverse_word', 'tags': [], 'run_id': '77b01284-0515-48f4-8d7c-eb27c1882f86', 'metadata': {}}{'event': 'on_chain_end', 'data': {'output': 'olleh', 'input': 'hello'}, 'run_id': '77b01284-0515-48f4-8d7c-eb27c1882f86', 'name': 'reverse_word', 'tags': [], 'metadata': {}}{'event': 'on_tool_end', 'data': {'output': 'olleh'}, 'run_id': 'ea900472-a8f7-425d-b627-facdef936ee8', 'name': 'bad_tool', 'tags': [], 'metadata': {}}\n```\n\nHere's a re-implementation that does propagate callbacks correctly. You'll notice that now we're getting events from the `reverse_word` runnable as well.\n\n```\n@tooldef correct_tool(word: str, callbacks):    \"\"\"A tool that correctly propagates callbacks.\"\"\"    return reverse_word.invoke(word, {\"callbacks\": callbacks})async for event in correct_tool.astream_events(\"hello\", version=\"v2\"):    print(event)\n```\n\n```\n{'event': 'on_tool_start', 'data': {'input': 'hello'}, 'name': 'correct_tool', 'tags': [], 'run_id': 'd5ea83b9-9278-49cc-9f1d-aa302d671040', 'metadata': {}}{'event': 'on_chain_start', 'data': {'input': 'hello'}, 'name': 'reverse_word', 'tags': [], 'run_id': '44dafbf4-2f87-412b-ae0e-9f71713810df', 'metadata': {}}{'event': 'on_chain_end', 'data': {'output': 'olleh', 'input': 'hello'}, 'run_id': '44dafbf4-2f87-412b-ae0e-9f71713810df', 'name': 'reverse_word', 'tags': [], 'metadata': {}}{'event': 'on_tool_end', 'data': {'output': 'olleh'}, 'run_id': 'd5ea83b9-9278-49cc-9f1d-aa302d671040', 'name': 'correct_tool', 'tags': [], 'metadata': {}}\n```\n\nIf you're invoking runnables from within Runnable Lambdas or `@chains`, then callbacks will be passed automatically on your behalf.\n\n```\nfrom langchain_core.runnables import RunnableLambdaasync def reverse_and_double(word: str):    return await reverse_word.ainvoke(word) * 2reverse_and_double = RunnableLambda(reverse_and_double)await reverse_and_double.ainvoke(\"1234\")async for event in reverse_and_double.astream_events(\"1234\", version=\"v2\"):    print(event)\n```\n\n```\n{'event': 'on_chain_start', 'data': {'input': '1234'}, 'name': 'reverse_and_double', 'tags': [], 'run_id': '03b0e6a1-3e60-42fc-8373-1e7829198d80', 'metadata': {}}{'event': 'on_chain_start', 'data': {'input': '1234'}, 'name': 'reverse_word', 'tags': [], 'run_id': '5cf26fc8-840b-4642-98ed-623dda28707a', 'metadata': {}}{'event': 'on_chain_end', 'data': {'output': '4321', 'input': '1234'}, 'run_id': '5cf26fc8-840b-4642-98ed-623dda28707a', 'name': 'reverse_word', 'tags': [], 'metadata': {}}{'event': 'on_chain_stream', 'data': {'chunk': '43214321'}, 'run_id': '03b0e6a1-3e60-42fc-8373-1e7829198d80', 'name': 'reverse_and_double', 'tags': [], 'metadata': {}}{'event': 'on_chain_end', 'data': {'output': '43214321'}, 'run_id': '03b0e6a1-3e60-42fc-8373-1e7829198d80', 'name': 'reverse_and_double', 'tags': [], 'metadata': {}}\n```\n\nAnd with the `@chain` decorator:\n\n```\nfrom langchain_core.runnables import chain@chainasync def reverse_and_double(word: str):    return await reverse_word.ainvoke(word) * 2await reverse_and_double.ainvoke(\"1234\")async for event in reverse_and_double.astream_events(\"1234\", version=\"v2\"):    print(event)\n```\n\n```\n{'event': 'on_chain_start', 'data': {'input': '1234'}, 'name': 'reverse_and_double', 'tags': [], 'run_id': '1bfcaedc-f4aa-4d8e-beee-9bba6ef17008', 'metadata': {}}{'event': 'on_chain_start', 'data': {'input': '1234'}, 'name': 'reverse_word', 'tags': [], 'run_id': '64fc99f0-5d7d-442b-b4f5-4537129f67d1', 'metadata': {}}{'event': 'on_chain_end', 'data': {'output': '4321', 'input': '1234'}, 'run_id': '64fc99f0-5d7d-442b-b4f5-4537129f67d1', 'name': 'reverse_word', 'tags': [], 'metadata': {}}{'event': 'on_chain_stream', 'data': {'chunk': '43214321'}, 'run_id': '1bfcaedc-f4aa-4d8e-beee-9bba6ef17008', 'name': 'reverse_and_double', 'tags': [], 'metadata': {}}{'event': 'on_chain_end', 'data': {'output': '43214321'}, 'run_id': '1bfcaedc-f4aa-4d8e-beee-9bba6ef17008', 'name': 'reverse_and_double', 'tags': [], 'metadata': {}}\n```\n\n## Next steps[​](#next-steps \"Direct link to Next steps\")\n\nNow you've learned some ways to stream both final outputs and internal steps with LangChain.\n\nTo learn more, check out the other how-to guides in this section, or the [conceptual guide on Langchain Expression Language](https://python.langchain.com/docs/concepts/lcel/)."
},
{
  "url": "https://python.langchain.com/docs/how_to/time_weighted_vectorstore/",
  "markdown": "# giscus\n\n[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/langchain-ai/langchain/blob/master/docs/docs/how_to/time_weighted_vectorstore.ipynb)[![Open on GitHub](https://img.shields.io/badge/Open%20on%20GitHub-grey?logo=github&logoColor=white)](https://github.com/langchain-ai/langchain/blob/master/docs/docs/how_to/time_weighted_vectorstore.ipynb)\n\n## How to use a time-weighted vector store retriever\n\nThis [retriever](https://python.langchain.com/docs/concepts/retrievers/) uses a combination of semantic [similarity](https://python.langchain.com/docs/concepts/embedding_models/#measure-similarity) and a time decay.\n\nThe algorithm for scoring them is:\n\n```\nsemantic_similarity + (1.0 - decay_rate) ^ hours_passed\n```\n\nNotably, `hours_passed` refers to the hours passed since the object in the retriever **was last accessed**, not since it was created. This means that frequently accessed objects remain \"fresh\".\n\n```\nfrom datetime import datetime, timedeltaimport faissfrom langchain.retrievers import TimeWeightedVectorStoreRetrieverfrom langchain_community.docstore import InMemoryDocstorefrom langchain_community.vectorstores import FAISSfrom langchain_core.documents import Documentfrom langchain_openai import OpenAIEmbeddings\n```\n\n## Low decay rate[​](#low-decay-rate \"Direct link to Low decay rate\")\n\nA low `decay rate` (in this, to be extreme, we will set it close to 0) means memories will be \"remembered\" for longer. A `decay rate` of 0 means memories never be forgotten, making this retriever equivalent to the vector lookup.\n\n```\n# Define your embedding modelembeddings_model = OpenAIEmbeddings()# Initialize the vectorstore as emptyembedding_size = 1536index = faiss.IndexFlatL2(embedding_size)vectorstore = FAISS(embeddings_model, index, InMemoryDocstore({}), {})retriever = TimeWeightedVectorStoreRetriever(    vectorstore=vectorstore, decay_rate=0.0000000000000000000000001, k=1)\n```\n\n```\nyesterday = datetime.now() - timedelta(days=1)retriever.add_documents(    [Document(page_content=\"hello world\", metadata={\"last_accessed_at\": yesterday})])retriever.add_documents([Document(page_content=\"hello foo\")])\n```\n\n```\n['73679bc9-d425-49c2-9d74-de6356c73489']\n```\n\n```\n# \"Hello World\" is returned first because it is most salient, and the decay rate is close to 0., meaning it's still recent enoughretriever.invoke(\"hello world\")\n```\n\n```\n[Document(metadata={'last_accessed_at': datetime.datetime(2024, 10, 22, 16, 37, 40, 818583), 'created_at': datetime.datetime(2024, 10, 22, 16, 37, 37, 975074), 'buffer_idx': 0}, page_content='hello world')]\n```\n\n## High decay rate[​](#high-decay-rate \"Direct link to High decay rate\")\n\nWith a high `decay rate` (e.g., several 9's), the `recency score` quickly goes to 0! If you set this all the way to 1, `recency` is 0 for all objects, once again making this equivalent to a vector lookup.\n\n```\n# Define your embedding modelembeddings_model = OpenAIEmbeddings()# Initialize the vectorstore as emptyembedding_size = 1536index = faiss.IndexFlatL2(embedding_size)vectorstore = FAISS(embeddings_model, index, InMemoryDocstore({}), {})retriever = TimeWeightedVectorStoreRetriever(    vectorstore=vectorstore, decay_rate=0.999, k=1)\n```\n\n```\nyesterday = datetime.now() - timedelta(days=1)retriever.add_documents(    [Document(page_content=\"hello world\", metadata={\"last_accessed_at\": yesterday})])retriever.add_documents([Document(page_content=\"hello foo\")])\n```\n\n```\n['379631f0-42c2-4773-8cc2-d36201e1e610']\n```\n\n```\n# \"Hello Foo\" is returned first because \"hello world\" is mostly forgottenretriever.invoke(\"hello world\")\n```\n\n```\n[Document(metadata={'last_accessed_at': datetime.datetime(2024, 10, 22, 16, 37, 46, 553633), 'created_at': datetime.datetime(2024, 10, 22, 16, 37, 43, 927429), 'buffer_idx': 1}, page_content='hello foo')]\n```\n\n## Virtual time[​](#virtual-time \"Direct link to Virtual time\")\n\nUsing some utils in LangChain, you can mock out the time component.\n\n```\nfrom langchain_core.utils import mock_now\n```\n\n```\n# Notice the last access time is that date timetomorrow = datetime.now() + timedelta(days=1)with mock_now(tomorrow):    print(retriever.invoke(\"hello world\"))\n```\n\n```\n[Document(metadata={'last_accessed_at': MockDateTime(2024, 10, 23, 16, 38, 19, 66711), 'created_at': datetime.datetime(2024, 10, 22, 16, 37, 43, 599877), 'buffer_idx': 0}, page_content='hello world')]\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/tool_artifacts/",
  "markdown": "# giscus\n\n## How to return artifacts from a tool\n\n[Tools](https://python.langchain.com/docs/concepts/tools/) are utilities that can be [called by a model](https://python.langchain.com/docs/concepts/tool_calling/), and whose outputs are designed to be fed back to a model. Sometimes, however, there are artifacts of a tool's execution that we want to make accessible to downstream components in our chain or agent, but that we don't want to expose to the model itself. For example if a tool returns a custom object, a dataframe or an image, we may want to pass some metadata about this output to the model without passing the actual output to the model. At the same time, we may want to be able to access this full output elsewhere, for example in downstream tools.\n\nThe Tool and [ToolMessage](https://python.langchain.com/api_reference/core/messages/langchain_core.messages.tool.ToolMessage.html) interfaces make it possible to distinguish between the parts of the tool output meant for the model (this is the ToolMessage.content) and those parts which are meant for use outside the model (ToolMessage.artifact).\n\nRequires `langchain-core >= 0.2.19`\n\nThis functionality was added in `langchain-core == 0.2.19`. Please make sure your package is up to date.\n\nIf we want our tool to distinguish between message content and other artifacts, we need to specify `response_format=\"content_and_artifact\"` when defining our tool and make sure that we return a tuple of (content, artifact):\n\n```\n%pip install -qU \"langchain-core>=0.2.19\"\n```\n\n```\nimport randomfrom typing import List, Tuplefrom langchain_core.tools import tool@tool(response_format=\"content_and_artifact\")def generate_random_ints(min: int, max: int, size: int) -> Tuple[str, List[int]]:    \"\"\"Generate size random ints in the range [min, max].\"\"\"    array = [random.randint(min, max) for _ in range(size)]    content = f\"Successfully generated array of {size} random ints in [{min}, {max}].\"    return content, array\n```\n\n**API Reference:**[tool](https://python.langchain.com/api_reference/core/tools/langchain_core.tools.convert.tool.html)\n\nIf we directly invoke our tool with just the tool arguments, you'll notice that we only get back the content part of the Tool output:\n\n```\ngenerate_random_ints.invoke({\"min\": 0, \"max\": 9, \"size\": 10})\n```\n\n```\n'Successfully generated array of 10 random ints in [0, 9].'\n```\n\n```\nFailed to batch ingest runs: LangSmithRateLimitError('Rate limit exceeded for https://api.smith.langchain.com/runs/batch. HTTPError(\\'429 Client Error: Too Many Requests for url: https://api.smith.langchain.com/runs/batch\\', \\'{\"detail\":\"Monthly unique traces usage limit exceeded\"}\\')')\n```\n\nIn order to get back both the content and the artifact, we need to invoke our model with a ToolCall (which is just a dictionary with \"name\", \"args\", \"id\" and \"type\" keys), which has additional info needed to generate a ToolMessage like the tool call ID:\n\n```\ngenerate_random_ints.invoke(    {        \"name\": \"generate_random_ints\",        \"args\": {\"min\": 0, \"max\": 9, \"size\": 10},        \"id\": \"123\",  # required        \"type\": \"tool_call\",  # required    })\n```\n\n```\nToolMessage(content='Successfully generated array of 10 random ints in [0, 9].', name='generate_random_ints', tool_call_id='123', artifact=[2, 8, 0, 6, 0, 0, 1, 5, 0, 0])\n```\n\n## Using with a model[​](#using-with-a-model \"Direct link to Using with a model\")\n\nWith a [tool-calling model](https://python.langchain.com/docs/how_to/tool_calling/), we can easily use a model to call our Tool and generate ToolMessages:\n\n```\npip install -qU langchain-openai\n```\n\n```\nimport getpassimport osif not os.environ.get(\"OPENAI_API_KEY\"):  os.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"Enter API key for OpenAI: \")from langchain_openai import ChatOpenAIllm = ChatOpenAI(model=\"gpt-4o-mini\")\n```\n\n```\nllm_with_tools = llm.bind_tools([generate_random_ints])ai_msg = llm_with_tools.invoke(\"generate 6 positive ints less than 25\")ai_msg.tool_calls\n```\n\n```\n[{'name': 'generate_random_ints',  'args': {'min': 1, 'max': 24, 'size': 6},  'id': 'toolu_01EtALY3Wz1DVYhv1TLvZGvE',  'type': 'tool_call'}]\n```\n\n```\ngenerate_random_ints.invoke(ai_msg.tool_calls[0])\n```\n\n```\nToolMessage(content='Successfully generated array of 6 random ints in [1, 24].', name='generate_random_ints', tool_call_id='toolu_01EtALY3Wz1DVYhv1TLvZGvE', artifact=[2, 20, 23, 8, 1, 15])\n```\n\nIf we just pass in the tool call args, we'll only get back the content:\n\n```\ngenerate_random_ints.invoke(ai_msg.tool_calls[0][\"args\"])\n```\n\n```\n'Successfully generated array of 6 random ints in [1, 24].'\n```\n\nIf we wanted to declaratively create a chain, we could do this:\n\n```\nfrom operator import attrgetterchain = llm_with_tools | attrgetter(\"tool_calls\") | generate_random_ints.map()chain.invoke(\"give me a random number between 1 and 5\")\n```\n\n```\n[ToolMessage(content='Successfully generated array of 1 random ints in [1, 5].', name='generate_random_ints', tool_call_id='toolu_01FwYhnkwDPJPbKdGq4ng6uD', artifact=[5])]\n```\n\nIf you want to create a BaseTool object directly, instead of decorating a function with `@tool`, you can do so like this:\n\n```\nfrom langchain_core.tools import BaseToolclass GenerateRandomFloats(BaseTool):    name: str = \"generate_random_floats\"    description: str = \"Generate size random floats in the range [min, max].\"    response_format: str = \"content_and_artifact\"    ndigits: int = 2    def _run(self, min: float, max: float, size: int) -> Tuple[str, List[float]]:        range_ = max - min        array = [            round(min + (range_ * random.random()), ndigits=self.ndigits)            for _ in range(size)        ]        content = f\"Generated {size} floats in [{min}, {max}], rounded to {self.ndigits} decimals.\"        return content, array    # Optionally define an equivalent async method    # async def _arun(self, min: float, max: float, size: int) -> Tuple[str, List[float]]:    #     ...\n```\n\n```\nrand_gen = GenerateRandomFloats(ndigits=4)rand_gen.invoke({\"min\": 0.1, \"max\": 3.3333, \"size\": 3})\n```\n\n```\n'Generated 3 floats in [0.1, 3.3333], rounded to 4 decimals.'\n```\n\n```\nrand_gen.invoke(    {        \"name\": \"generate_random_floats\",        \"args\": {\"min\": 0.1, \"max\": 3.3333, \"size\": 3},        \"id\": \"123\",        \"type\": \"tool_call\",    })\n```\n\n```\nToolMessage(content='Generated 3 floats in [0.1, 3.3333], rounded to 4 decimals.', name='generate_random_floats', tool_call_id='123', artifact=[1.5789, 2.464, 2.2719])\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/tool_calling/",
  "markdown": "# giscus\n\n## How to use chat models to call tools\n\n[Tool calling](https://python.langchain.com/docs/concepts/tool_calling/) allows a chat model to respond to a given prompt by \"calling a tool\".\n\nRemember, while the name \"tool calling\" implies that the model is directly performing some action, this is actually not the case! The model only generates the arguments to a tool, and actually running the tool (or not) is up to the user.\n\nTool calling is a general technique that generates structured output from a model, and you can use it even when you don't intend to invoke any tools. An example use-case of that is [extraction from unstructured text](https://python.langchain.com/docs/tutorials/extraction/).\n\n![Diagram of calling a tool](https://python.langchain.com/assets/images/tool_call-8d4a8b18e90cacd03f62e94071eceace.png)\n\nIf you want to see how to use the model-generated tool call to actually run a tool [check out this guide](https://python.langchain.com/docs/how_to/tool_results_pass_to_model/).\n\nLangChain implements standard interfaces for defining tools, passing them to LLMs, and representing tool calls. This guide will cover how to bind tools to an LLM, then invoke the LLM to generate these arguments.\n\nFor a model to be able to call tools, we need to pass in tool schemas that describe what the tool does and what it's arguments are. Chat models that support tool calling features implement a `.bind_tools()` method for passing tool schemas to the model. Tool schemas can be passed in as Python functions (with typehints and docstrings), Pydantic models, TypedDict classes, or LangChain [Tool objects](https://python.langchain.com/api_reference/core/tools/langchain_core.tools.base.BaseTool.html#basetool). Subsequent invocations of the model will pass in these tool schemas along with the prompt.\n\n### Python functions[​](#python-functions \"Direct link to Python functions\")\n\nOur tool schemas can be Python functions:\n\n```\n# The function name, type hints, and docstring are all part of the tool# schema that's passed to the model. Defining good, descriptive schemas# is an extension of prompt engineering and is an important part of# getting models to perform well.def add(a: int, b: int) -> int:    \"\"\"Add two integers.    Args:        a: First integer        b: Second integer    \"\"\"    return a + bdef multiply(a: int, b: int) -> int:    \"\"\"Multiply two integers.    Args:        a: First integer        b: Second integer    \"\"\"    return a * b\n```\n\n### LangChain Tool[​](#langchain-tool \"Direct link to LangChain Tool\")\n\nLangChain also implements a `@tool` decorator that allows for further control of the tool schema, such as tool names and argument descriptions. See the how-to guide [here](https://python.langchain.com/docs/how_to/custom_tools/#creating-tools-from-functions) for details.\n\n### Pydantic class[​](#pydantic-class \"Direct link to Pydantic class\")\n\nYou can equivalently define the schemas without the accompanying functions using [Pydantic](https://docs.pydantic.dev/).\n\nNote that all fields are `required` unless provided a default value.\n\n```\nfrom pydantic import BaseModel, Fieldclass add(BaseModel):    \"\"\"Add two integers.\"\"\"    a: int = Field(..., description=\"First integer\")    b: int = Field(..., description=\"Second integer\")class multiply(BaseModel):    \"\"\"Multiply two integers.\"\"\"    a: int = Field(..., description=\"First integer\")    b: int = Field(..., description=\"Second integer\")\n```\n\n### TypedDict class[​](#typeddict-class \"Direct link to TypedDict class\")\n\nRequires `langchain-core>=0.2.25`\n\nOr using TypedDicts and annotations:\n\n```\nfrom typing_extensions import Annotated, TypedDictclass add(TypedDict):    \"\"\"Add two integers.\"\"\"    # Annotations must have the type and can optionally include a default value and description (in that order).    a: Annotated[int, ..., \"First integer\"]    b: Annotated[int, ..., \"Second integer\"]class multiply(TypedDict):    \"\"\"Multiply two integers.\"\"\"    a: Annotated[int, ..., \"First integer\"]    b: Annotated[int, ..., \"Second integer\"]tools = [add, multiply]\n```\n\nTo actually bind those schemas to a chat model, we'll use the `.bind_tools()` method. This handles converting the `add` and `multiply` schemas to the proper format for the model. The tool schema will then be passed it in each time the model is invoked.\n\n```\npip install -qU langchain-openai\n```\n\n```\nimport getpassimport osif not os.environ.get(\"OPENAI_API_KEY\"):  os.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"Enter API key for OpenAI: \")from langchain_openai import ChatOpenAIllm = ChatOpenAI(model=\"gpt-4o-mini\")\n```\n\n```\nllm_with_tools = llm.bind_tools(tools)query = \"What is 3 * 12?\"llm_with_tools.invoke(query)\n```\n\n```\nAIMessage(content='', additional_kwargs={'tool_calls': [{'id': 'call_iXj4DiW1p7WLjTAQMRO0jxMs', 'function': {'arguments': '{\"a\":3,\"b\":12}', 'name': 'multiply'}, 'type': 'function'}], 'refusal': None}, response_metadata={'token_usage': {'completion_tokens': 17, 'prompt_tokens': 80, 'total_tokens': 97}, 'model_name': 'gpt-4o-mini-2024-07-18', 'system_fingerprint': 'fp_483d39d857', 'finish_reason': 'tool_calls', 'logprobs': None}, id='run-0b620986-3f62-4df7-9ba3-4595089f9ad4-0', tool_calls=[{'name': 'multiply', 'args': {'a': 3, 'b': 12}, 'id': 'call_iXj4DiW1p7WLjTAQMRO0jxMs', 'type': 'tool_call'}], usage_metadata={'input_tokens': 80, 'output_tokens': 17, 'total_tokens': 97})\n```\n\nAs we can see our LLM generated arguments to a tool! You can look at the docs for [bind\\_tools()](https://python.langchain.com/api_reference/openai/chat_models/langchain_openai.chat_models.base.BaseChatOpenAI.html#langchain_openai.chat_models.base.BaseChatOpenAI.bind_tools) to learn about all the ways to customize how your LLM selects tools, as well as [this guide on how to force the LLM to call a tool](https://python.langchain.com/docs/how_to/tool_choice/) rather than letting it decide.\n\nIf tool calls are included in a LLM response, they are attached to the corresponding [message](https://python.langchain.com/api_reference/core/messages/langchain_core.messages.ai.AIMessage.html#langchain_core.messages.ai.AIMessage) or [message chunk](https://python.langchain.com/api_reference/core/messages/langchain_core.messages.ai.AIMessageChunk.html#langchain_core.messages.ai.AIMessageChunk) as a list of [tool call](https://python.langchain.com/api_reference/core/messages/langchain_core.messages.tool.ToolCall.html#langchain_core.messages.tool.ToolCall) objects in the `.tool_calls` attribute.\n\nNote that chat models can call multiple tools at once.\n\nA `ToolCall` is a typed dict that includes a tool name, dict of argument values, and (optionally) an identifier. Messages with no tool calls default to an empty list for this attribute.\n\n```\nquery = \"What is 3 * 12? Also, what is 11 + 49?\"llm_with_tools.invoke(query).tool_calls\n```\n\n```\n[{'name': 'multiply',  'args': {'a': 3, 'b': 12},  'id': 'call_1fyhJAbJHuKQe6n0PacubGsL',  'type': 'tool_call'}, {'name': 'add',  'args': {'a': 11, 'b': 49},  'id': 'call_fc2jVkKzwuPWyU7kS9qn1hyG',  'type': 'tool_call'}]\n```\n\nThe `.tool_calls` attribute should contain valid tool calls. Note that on occasion, model providers may output malformed tool calls (e.g., arguments that are not valid JSON). When parsing fails in these cases, instances of [InvalidToolCall](https://python.langchain.com/api_reference/core/messages/langchain_core.messages.tool.InvalidToolCall.html#langchain_core.messages.tool.InvalidToolCall) are populated in the `.invalid_tool_calls` attribute. An `InvalidToolCall` can have a name, string arguments, identifier, and error message.\n\n## Parsing[​](#parsing \"Direct link to Parsing\")\n\nIf desired, [output parsers](https://python.langchain.com/docs/how_to/#output-parsers) can further process the output. For example, we can convert existing values populated on the `.tool_calls` to Pydantic objects using the [PydanticToolsParser](https://python.langchain.com/api_reference/core/output_parsers/langchain_core.output_parsers.openai_tools.PydanticToolsParser.html):\n\n```\nfrom langchain_core.output_parsers import PydanticToolsParserfrom pydantic import BaseModel, Fieldclass add(BaseModel):    \"\"\"Add two integers.\"\"\"    a: int = Field(..., description=\"First integer\")    b: int = Field(..., description=\"Second integer\")class multiply(BaseModel):    \"\"\"Multiply two integers.\"\"\"    a: int = Field(..., description=\"First integer\")    b: int = Field(..., description=\"Second integer\")chain = llm_with_tools | PydanticToolsParser(tools=[add, multiply])chain.invoke(query)\n```\n\n```\n[multiply(a=3, b=12), add(a=11, b=49)]\n```\n\n## Next steps[​](#next-steps \"Direct link to Next steps\")\n\nNow you've learned how to bind tool schemas to a chat model and have the model call the tool.\n\nNext, check out this guide on actually using the tool by invoking the function and passing the results back to the model:\n\n*   Pass [tool results back to model](https://python.langchain.com/docs/how_to/tool_results_pass_to_model/)\n\nYou can also check out some more specific uses of tool calling:\n\n*   Getting [structured outputs](https://python.langchain.com/docs/how_to/structured_output/) from models\n*   Few shot prompting [with tools](https://python.langchain.com/docs/how_to/tools_few_shot/)\n*   Stream [tool calls](https://python.langchain.com/docs/how_to/tool_streaming/)\n*   Pass [runtime values to tools](https://python.langchain.com/docs/how_to/tool_runtime/)"
},
{
  "url": "https://python.langchain.com/docs/how_to/tool_calling_parallel/",
  "markdown": "# giscus\n\n## How to disable parallel tool calling\n\nOpenAI-specific\n\nThis API is currently only supported by OpenAI.\n\nOpenAI tool calling performs tool calling in parallel by default. That means that if we ask a question like \"What is the weather in Tokyo, New York, and Chicago?\" and we have a tool for getting the weather, it will call the tool 3 times in parallel. We can force it to call only a single tool once by using the `parallel_tool_call` parameter.\n\nFirst let's set up our tools and model:\n\n```\nfrom langchain_core.tools import tool@tooldef add(a: int, b: int) -> int:    \"\"\"Adds a and b.\"\"\"    return a + b@tooldef multiply(a: int, b: int) -> int:    \"\"\"Multiplies a and b.\"\"\"    return a * btools = [add, multiply]\n```\n\n**API Reference:**[tool](https://python.langchain.com/api_reference/core/tools/langchain_core.tools.convert.tool.html)\n\n```\nimport osfrom getpass import getpassfrom langchain_openai import ChatOpenAIif \"OPENAI_API_KEY\" not in os.environ:    os.environ[\"OPENAI_API_KEY\"] = getpass()llm = ChatOpenAI(model=\"gpt-4o-mini\", temperature=0)\n```\n\nNow let's show a quick example of how disabling parallel tool calls work:\n\n```\nllm_with_tools = llm.bind_tools(tools, parallel_tool_calls=False)llm_with_tools.invoke(\"Please call the first tool two times\").tool_calls\n```\n\n```\n[{'name': 'add',  'args': {'a': 2, 'b': 2},  'id': 'call_Hh4JOTCDM85Sm9Pr84VKrWu5'}]\n```\n\nAs we can see, even though we explicitly told the model to call a tool twice, by disabling parallel tool calls the model was constrained to only calling one."
},
{
  "url": "https://python.langchain.com/docs/how_to/tool_choice/",
  "markdown": "# giscus\n\nIn order to force our LLM to select a specific [tool](https://python.langchain.com/docs/concepts/tools/), we can use the `tool_choice` parameter to ensure certain behavior. First, let's define our model and tools:\n\nFor example, we can force our tool to call the multiply tool by using the following code:\n\n```\nAIMessage(content='', additional_kwargs={'tool_calls': [{'id': 'call_9cViskmLvPnHjXk9tbVla5HA', 'function': {'arguments': '{\"a\":2,\"b\":4}', 'name': 'Multiply'}, 'type': 'function'}]}, response_metadata={'token_usage': {'completion_tokens': 9, 'prompt_tokens': 103, 'total_tokens': 112}, 'model_name': 'gpt-4o-mini', 'system_fingerprint': None, 'finish_reason': 'stop', 'logprobs': None}, id='run-095b827e-2bdd-43bb-8897-c843f4504883-0', tool_calls=[{'name': 'Multiply', 'args': {'a': 2, 'b': 4}, 'id': 'call_9cViskmLvPnHjXk9tbVla5HA'}], usage_metadata={'input_tokens': 103, 'output_tokens': 9, 'total_tokens': 112})\n```\n\nEven if we pass it something that doesn't require multiplcation - it will still call the tool!\n\nWe can also just force our tool to select at least one of our tools by passing in the \"any\" (or \"required\" which is OpenAI specific) keyword to the `tool_choice` parameter.\n\n```\nAIMessage(content='', additional_kwargs={'tool_calls': [{'id': 'call_mCSiJntCwHJUBfaHZVUB2D8W', 'function': {'arguments': '{\"a\":1,\"b\":2}', 'name': 'Add'}, 'type': 'function'}]}, response_metadata={'token_usage': {'completion_tokens': 15, 'prompt_tokens': 94, 'total_tokens': 109}, 'model_name': 'gpt-4o-mini', 'system_fingerprint': None, 'finish_reason': 'stop', 'logprobs': None}, id='run-28f75260-9900-4bed-8cd3-f1579abb65e5-0', tool_calls=[{'name': 'Add', 'args': {'a': 1, 'b': 2}, 'id': 'call_mCSiJntCwHJUBfaHZVUB2D8W'}], usage_metadata={'input_tokens': 94, 'output_tokens': 15, 'total_tokens': 109})\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/tool_configure/",
  "markdown": "# giscus\n\n## How to access the RunnableConfig from a tool\n\nIf you have a [tool](https://python.langchain.com/docs/concepts/tools/) that calls [chat models](https://python.langchain.com/docs/concepts/chat_models/), [retrievers](https://python.langchain.com/docs/concepts/retrievers/), or other [runnables](https://python.langchain.com/docs/concepts/runnables/), you may want to access internal events from those runnables or configure them with additional properties. This guide shows you how to manually pass parameters properly so that you can do this using the `astream_events()` method.\n\nTools are [runnables](https://python.langchain.com/docs/concepts/runnables/), and you can treat them the same way as any other runnable at the interface level - you can call `invoke()`, `batch()`, and `stream()` on them as normal. However, when writing custom tools, you may want to invoke other runnables like chat models or retrievers. In order to properly trace and configure those sub-invocations, you'll need to manually access and pass in the tool's current [`RunnableConfig`](https://python.langchain.com/api_reference/core/runnables/langchain_core.runnables.config.RunnableConfig.html) object. This guide show you some examples of how to do that.\n\nCompatibility\n\nThis guide requires `langchain-core>=0.2.16`.\n\n## Inferring by parameter type[​](#inferring-by-parameter-type \"Direct link to Inferring by parameter type\")\n\nTo access reference the active config object from your custom tool, you'll need to add a parameter to your tool's signature typed as `RunnableConfig`. When you invoke your tool, LangChain will inspect your tool's signature, look for a parameter typed as `RunnableConfig`, and if it exists, populate that parameter with the correct value.\n\n**Note:** The actual name of the parameter doesn't matter, only the typing.\n\nTo illustrate this, define a custom tool that takes a two parameters - one typed as a string, the other typed as `RunnableConfig`:\n\n```\n%pip install -qU langchain_core\n```\n\n```\nfrom langchain_core.runnables import RunnableConfigfrom langchain_core.tools import tool@toolasync def reverse_tool(text: str, special_config_param: RunnableConfig) -> str:    \"\"\"A test tool that combines input text with a configurable parameter.\"\"\"    return (text + special_config_param[\"configurable\"][\"additional_field\"])[::-1]\n```\n\nThen, if we invoke the tool with a `config` containing a `configurable` field, we can see that `additional_field` is passed through correctly:\n\n```\nawait reverse_tool.ainvoke(    {\"text\": \"abc\"}, config={\"configurable\": {\"additional_field\": \"123\"}})\n```\n\n## Next steps[​](#next-steps \"Direct link to Next steps\")\n\nYou've now seen how to configure and stream events from within a tool. Next, check out the following guides for more on using tools:\n\n*   [Stream events from child runs within a custom tool](https://python.langchain.com/docs/how_to/tool_stream_events/)\n*   Pass [tool results back to a model](https://python.langchain.com/docs/how_to/tool_results_pass_to_model/)\n\nYou can also check out some more specific uses of tool calling:\n\n*   Building [tool-using chains and agents](https://python.langchain.com/docs/how_to/#tools)\n*   Getting [structured outputs](https://python.langchain.com/docs/how_to/structured_output/) from models"
},
{
  "url": "https://python.langchain.com/docs/how_to/tool_results_pass_to_model/",
  "markdown": "# giscus\n\n## How to pass tool outputs to chat models\n\nSome models are capable of [**tool calling**](https://python.langchain.com/docs/concepts/tool_calling/) - generating arguments that conform to a specific user-provided schema. This guide will demonstrate how to use those tool cals to actually call a function and properly pass the results back to the model.\n\n![Diagram of a tool call invocation](https://python.langchain.com/assets/images/tool_invocation-7f277888701ee431a17607f1a035c080.png)\n\n![Diagram of a tool call result](https://python.langchain.com/assets/images/tool_results-71b4b90f33a56563c102d91e7821a993.png)\n\nFirst, let's define our tools and our model:\n\n```\npip install -qU langchain-openai\n```\n\n```\nimport getpassimport osif not os.environ.get(\"OPENAI_API_KEY\"):  os.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"Enter API key for OpenAI: \")from langchain_openai import ChatOpenAIllm = ChatOpenAI(model=\"gpt-4o-mini\")\n```\n\n```\nfrom langchain_core.tools import tool@tooldef add(a: int, b: int) -> int:    \"\"\"Adds a and b.\"\"\"    return a + b@tooldef multiply(a: int, b: int) -> int:    \"\"\"Multiplies a and b.\"\"\"    return a * btools = [add, multiply]llm_with_tools = llm.bind_tools(tools)\n```\n\n**API Reference:**[tool](https://python.langchain.com/api_reference/core/tools/langchain_core.tools.convert.tool.html)\n\nNow, let's get the model to call a tool. We'll add it to a list of messages that we'll treat as conversation history:\n\n```\nfrom langchain_core.messages import HumanMessagequery = \"What is 3 * 12? Also, what is 11 + 49?\"messages = [HumanMessage(query)]ai_msg = llm_with_tools.invoke(messages)print(ai_msg.tool_calls)messages.append(ai_msg)\n```\n\n```\n[{'name': 'multiply', 'args': {'a': 3, 'b': 12}, 'id': 'call_GPGPE943GORirhIAYnWv00rK', 'type': 'tool_call'}, {'name': 'add', 'args': {'a': 11, 'b': 49}, 'id': 'call_dm8o64ZrY3WFZHAvCh1bEJ6i', 'type': 'tool_call'}]\n```\n\nNext let's invoke the tool functions using the args the model populated!\n\nConveniently, if we invoke a LangChain `Tool` with a `ToolCall`, we'll automatically get back a `ToolMessage` that can be fed back to the model:\n\nCompatibility\n\nThis functionality was added in `langchain-core == 0.2.19`. Please make sure your package is up to date.\n\nIf you are on earlier versions of `langchain-core`, you will need to extract the `args` field from the tool and construct a `ToolMessage` manually.\n\n```\nfor tool_call in ai_msg.tool_calls:    selected_tool = {\"add\": add, \"multiply\": multiply}[tool_call[\"name\"].lower()]    tool_msg = selected_tool.invoke(tool_call)    messages.append(tool_msg)messages\n```\n\n```\n[HumanMessage(content='What is 3 * 12? Also, what is 11 + 49?'), AIMessage(content='', additional_kwargs={'tool_calls': [{'id': 'call_loT2pliJwJe3p7nkgXYF48A1', 'function': {'arguments': '{\"a\": 3, \"b\": 12}', 'name': 'multiply'}, 'type': 'function'}, {'id': 'call_bG9tYZCXOeYDZf3W46TceoV4', 'function': {'arguments': '{\"a\": 11, \"b\": 49}', 'name': 'add'}, 'type': 'function'}]}, response_metadata={'token_usage': {'completion_tokens': 50, 'prompt_tokens': 87, 'total_tokens': 137}, 'model_name': 'gpt-4o-mini-2024-07-18', 'system_fingerprint': 'fp_661538dc1f', 'finish_reason': 'tool_calls', 'logprobs': None}, id='run-e3db3c46-bf9e-478e-abc1-dc9a264f4afe-0', tool_calls=[{'name': 'multiply', 'args': {'a': 3, 'b': 12}, 'id': 'call_loT2pliJwJe3p7nkgXYF48A1', 'type': 'tool_call'}, {'name': 'add', 'args': {'a': 11, 'b': 49}, 'id': 'call_bG9tYZCXOeYDZf3W46TceoV4', 'type': 'tool_call'}], usage_metadata={'input_tokens': 87, 'output_tokens': 50, 'total_tokens': 137}), ToolMessage(content='36', name='multiply', tool_call_id='call_loT2pliJwJe3p7nkgXYF48A1'), ToolMessage(content='60', name='add', tool_call_id='call_bG9tYZCXOeYDZf3W46TceoV4')]\n```\n\nAnd finally, we'll invoke the model with the tool results. The model will use this information to generate a final answer to our original query:\n\n```\nllm_with_tools.invoke(messages)\n```\n\n```\nAIMessage(content='The result of \\\\(3 \\\\times 12\\\\) is 36, and the result of \\\\(11 + 49\\\\) is 60.', response_metadata={'token_usage': {'completion_tokens': 31, 'prompt_tokens': 153, 'total_tokens': 184}, 'model_name': 'gpt-4o-mini-2024-07-18', 'system_fingerprint': 'fp_661538dc1f', 'finish_reason': 'stop', 'logprobs': None}, id='run-87d1ef0a-1223-4bb3-9310-7b591789323d-0', usage_metadata={'input_tokens': 153, 'output_tokens': 31, 'total_tokens': 184})\n```\n\nNote that each `ToolMessage` must include a `tool_call_id` that matches an `id` in the original tool calls that the model generates. This helps the model match tool responses with tool calls.\n\nTool calling agents, like those in [LangGraph](https://langchain-ai.github.io/langgraph/tutorials/introduction/), use this basic flow to answer queries and solve tasks.\n\n*   [LangGraph quickstart](https://langchain-ai.github.io/langgraph/tutorials/introduction/)\n*   Few shot prompting [with tools](https://python.langchain.com/docs/how_to/tools_few_shot/)\n*   Stream [tool calls](https://python.langchain.com/docs/how_to/tool_streaming/)\n*   Pass [runtime values to tools](https://python.langchain.com/docs/how_to/tool_runtime/)\n*   Getting [structured outputs](https://python.langchain.com/docs/how_to/structured_output/) from models"
},
{
  "url": "https://python.langchain.com/docs/how_to/tool_runtime/",
  "markdown": "# giscus\n\n## How to pass run time values to tools\n\n📦Compatibility\n\nThe code in this guide requires `langchain-core>=0.2.21`. Please ensure you have the correct packages installed.\n\nYou may need to bind values to a [tool](https://python.langchain.com/docs/concepts/tools/) that are only known at runtime. For example, the tool logic may require using the ID of the user who made the request.\n\nMost of the time, such values should not be controlled by the LLM. In fact, allowing the LLM to control the user ID may lead to a security risk.\n\nInstead, the LLM should only control the parameters of the tool that are meant to be controlled by the LLM, while other parameters (such as user ID) should be fixed by the application logic.\n\nThis how-to guide shows you how to prevent the model from generating certain tool arguments and injecting them in directly at runtime.\n\nUsing with LangGraph\n\nIf you're using LangGraph, please refer to [this how-to guide](https://langchain-ai.github.io/langgraph/how-tos/pass-run-time-values-to-tools/) which shows how to create an agent that keeps track of a given user's favorite pets.\n\nWe can bind them to chat models as follows:\n\n```\npip install -qU langchain-openai\n```\n\n```\nimport getpassimport osif not os.environ.get(\"OPENAI_API_KEY\"):  os.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"Enter API key for OpenAI: \")from langchain_openai import ChatOpenAIllm = ChatOpenAI(model=\"gpt-4o-mini\")\n```\n\n## Hiding arguments from the model[​](#hiding-arguments-from-the-model \"Direct link to Hiding arguments from the model\")\n\nWe can use the InjectedToolArg annotation to mark certain parameters of our Tool, like `user_id` as being injected at runtime, meaning they shouldn't be generated by the model\n\n```\nfrom typing import Listfrom langchain_core.tools import InjectedToolArg, toolfrom typing_extensions import Annotateduser_to_pets = {}@tool(parse_docstring=True)def update_favorite_pets(    pets: List[str], user_id: Annotated[str, InjectedToolArg]) -> None:    \"\"\"Add the list of favorite pets.    Args:        pets: List of favorite pets to set.        user_id: User's ID.    \"\"\"    user_to_pets[user_id] = pets@tool(parse_docstring=True)def delete_favorite_pets(user_id: Annotated[str, InjectedToolArg]) -> None:    \"\"\"Delete the list of favorite pets.    Args:        user_id: User's ID.    \"\"\"    if user_id in user_to_pets:        del user_to_pets[user_id]@tool(parse_docstring=True)def list_favorite_pets(user_id: Annotated[str, InjectedToolArg]) -> None:    \"\"\"List favorite pets if any.    Args:        user_id: User's ID.    \"\"\"    return user_to_pets.get(user_id, [])\n```\n\nIf we look at the input schemas for these tools, we'll see that user\\_id is still listed:\n\n```\nupdate_favorite_pets.get_input_schema().schema()\n```\n\n```\n{'description': 'Add the list of favorite pets.', 'properties': {'pets': {'description': 'List of favorite pets to set.',   'items': {'type': 'string'},   'title': 'Pets',   'type': 'array'},  'user_id': {'description': \"User's ID.\",   'title': 'User Id',   'type': 'string'}}, 'required': ['pets', 'user_id'], 'title': 'update_favorite_petsSchema', 'type': 'object'}\n```\n\nBut if we look at the tool call schema, which is what is passed to the model for tool-calling, user\\_id has been removed:\n\n```\nupdate_favorite_pets.tool_call_schema.schema()\n```\n\n```\n{'description': 'Add the list of favorite pets.', 'properties': {'pets': {'description': 'List of favorite pets to set.',   'items': {'type': 'string'},   'title': 'Pets',   'type': 'array'}}, 'required': ['pets'], 'title': 'update_favorite_pets', 'type': 'object'}\n```\n\nSo when we invoke our tool, we need to pass in user\\_id:\n\n```\nuser_id = \"123\"update_favorite_pets.invoke({\"pets\": [\"lizard\", \"dog\"], \"user_id\": user_id})print(user_to_pets)print(list_favorite_pets.invoke({\"user_id\": user_id}))\n```\n\n```\n{'123': ['lizard', 'dog']}['lizard', 'dog']\n```\n\nBut when the model calls the tool, no user\\_id argument will be generated:\n\n```\ntools = [    update_favorite_pets,    delete_favorite_pets,    list_favorite_pets,]llm_with_tools = llm.bind_tools(tools)ai_msg = llm_with_tools.invoke(\"my favorite animals are cats and parrots\")ai_msg.tool_calls\n```\n\n```\n[{'name': 'update_favorite_pets',  'args': {'pets': ['cats', 'parrots']},  'id': 'call_pZ6XVREGh1L0BBSsiGIf1xVm',  'type': 'tool_call'}]\n```\n\n## Injecting arguments at runtime[​](#injecting-arguments-at-runtime \"Direct link to Injecting arguments at runtime\")\n\nIf we want to actually execute our tools using the model-generated tool call, we'll need to inject the user\\_id ourselves:\n\n```\nfrom copy import deepcopyfrom langchain_core.runnables import chain@chaindef inject_user_id(ai_msg):    tool_calls = []    for tool_call in ai_msg.tool_calls:        tool_call_copy = deepcopy(tool_call)        tool_call_copy[\"args\"][\"user_id\"] = user_id        tool_calls.append(tool_call_copy)    return tool_callsinject_user_id.invoke(ai_msg)\n```\n\n```\n[{'name': 'update_favorite_pets',  'args': {'pets': ['cats', 'parrots'], 'user_id': '123'},  'id': 'call_pZ6XVREGh1L0BBSsiGIf1xVm',  'type': 'tool_call'}]\n```\n\nAnd now we can chain together our model, injection code, and the actual tools to create a tool-executing chain:\n\n```\ntool_map = {tool.name: tool for tool in tools}@chaindef tool_router(tool_call):    return tool_map[tool_call[\"name\"]]chain = llm_with_tools | inject_user_id | tool_router.map()chain.invoke(\"my favorite animals are cats and parrots\")\n```\n\n```\n[ToolMessage(content='null', name='update_favorite_pets', tool_call_id='call_oYCD0THSedHTbwNAY3NW6uUj')]\n```\n\nLooking at the user\\_to\\_pets dict, we can see that it's been updated to include cats and parrots:\n\n```\n{'123': ['cats', 'parrots']}\n```\n\n## Other ways of annotating args[​](#other-ways-of-annotating-args \"Direct link to Other ways of annotating args\")\n\nHere are a few other ways of annotating our tool args:\n\n```\nfrom langchain_core.tools import BaseToolfrom pydantic import BaseModel, Fieldclass UpdateFavoritePetsSchema(BaseModel):    \"\"\"Update list of favorite pets\"\"\"    pets: List[str] = Field(..., description=\"List of favorite pets to set.\")    user_id: Annotated[str, InjectedToolArg] = Field(..., description=\"User's ID.\")@tool(args_schema=UpdateFavoritePetsSchema)def update_favorite_pets(pets, user_id):    user_to_pets[user_id] = petsupdate_favorite_pets.get_input_schema().schema()\n```\n\n```\n{'description': 'Update list of favorite pets', 'properties': {'pets': {'description': 'List of favorite pets to set.',   'items': {'type': 'string'},   'title': 'Pets',   'type': 'array'},  'user_id': {'description': \"User's ID.\",   'title': 'User Id',   'type': 'string'}}, 'required': ['pets', 'user_id'], 'title': 'UpdateFavoritePetsSchema', 'type': 'object'}\n```\n\n```\nupdate_favorite_pets.tool_call_schema.schema()\n```\n\n```\n{'description': 'Update list of favorite pets', 'properties': {'pets': {'description': 'List of favorite pets to set.',   'items': {'type': 'string'},   'title': 'Pets',   'type': 'array'}}, 'required': ['pets'], 'title': 'update_favorite_pets', 'type': 'object'}\n```\n\n```\nfrom typing import Optional, Typeclass UpdateFavoritePets(BaseTool):    name: str = \"update_favorite_pets\"    description: str = \"Update list of favorite pets\"    args_schema: Optional[Type[BaseModel]] = UpdateFavoritePetsSchema    def _run(self, pets, user_id):        user_to_pets[user_id] = petsUpdateFavoritePets().get_input_schema().schema()\n```\n\n```\n{'description': 'Update list of favorite pets', 'properties': {'pets': {'description': 'List of favorite pets to set.',   'items': {'type': 'string'},   'title': 'Pets',   'type': 'array'},  'user_id': {'description': \"User's ID.\",   'title': 'User Id',   'type': 'string'}}, 'required': ['pets', 'user_id'], 'title': 'UpdateFavoritePetsSchema', 'type': 'object'}\n```\n\n```\nUpdateFavoritePets().tool_call_schema.schema()\n```\n\n```\n{'description': 'Update list of favorite pets', 'properties': {'pets': {'description': 'List of favorite pets to set.',   'items': {'type': 'string'},   'title': 'Pets',   'type': 'array'}}, 'required': ['pets'], 'title': 'update_favorite_pets', 'type': 'object'}\n```\n\n```\nclass UpdateFavoritePets2(BaseTool):    name: str = \"update_favorite_pets\"    description: str = \"Update list of favorite pets\"    def _run(self, pets: List[str], user_id: Annotated[str, InjectedToolArg]) -> None:        user_to_pets[user_id] = petsUpdateFavoritePets2().get_input_schema().schema()\n```\n\n```\n{'description': 'Use the tool.\\n\\nAdd run_manager: Optional[CallbackManagerForToolRun] = None\\nto child implementations to enable tracing.', 'properties': {'pets': {'items': {'type': 'string'},   'title': 'Pets',   'type': 'array'},  'user_id': {'title': 'User Id', 'type': 'string'}}, 'required': ['pets', 'user_id'], 'title': 'update_favorite_petsSchema', 'type': 'object'}\n```\n\n```\nUpdateFavoritePets2().tool_call_schema.schema()\n```\n\n```\n{'description': 'Update list of favorite pets', 'properties': {'pets': {'items': {'type': 'string'},   'title': 'Pets',   'type': 'array'}}, 'required': ['pets'], 'title': 'update_favorite_pets', 'type': 'object'}\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/tool_streaming/",
  "markdown": "# giscus\n\n## How to stream tool calls\n\nWhen [tools](https://python.langchain.com/docs/concepts/tools/) are called in a streaming context, [message chunks](https://python.langchain.com/api_reference/core/messages/langchain_core.messages.ai.AIMessageChunk.html#langchain_core.messages.ai.AIMessageChunk) will be populated with [tool call chunk](https://python.langchain.com/api_reference/core/messages/langchain_core.messages.tool.ToolCallChunk.html#langchain_core.messages.tool.ToolCallChunk) objects in a list via the `.tool_call_chunks` attribute. A `ToolCallChunk` includes optional string fields for the tool `name`, `args`, and `id`, and includes an optional integer field `index` that can be used to join chunks together. Fields are optional because portions of a tool call may be streamed across different chunks (e.g., a chunk that includes a substring of the arguments may have null values for the tool name and id).\n\nBecause message chunks inherit from their parent message class, an [AIMessageChunk](https://python.langchain.com/api_reference/core/messages/langchain_core.messages.ai.AIMessageChunk.html#langchain_core.messages.ai.AIMessageChunk) with tool call chunks will also include `.tool_calls` and `.invalid_tool_calls` fields. These fields are parsed best-effort from the message's tool call chunks.\n\nNote that not all providers currently support streaming for tool calls. Before we start let's define our tools and our model.\n\n```\nfrom langchain_core.tools import tool@tooldef add(a: int, b: int) -> int:    \"\"\"Adds a and b.\"\"\"    return a + b@tooldef multiply(a: int, b: int) -> int:    \"\"\"Multiplies a and b.\"\"\"    return a * btools = [add, multiply]\n```\n\n**API Reference:**[tool](https://python.langchain.com/api_reference/core/tools/langchain_core.tools.convert.tool.html)\n\n```\nimport osfrom getpass import getpassfrom langchain_openai import ChatOpenAIif \"OPENAI_API_KEY\" not in os.environ:    os.environ[\"OPENAI_API_KEY\"] = getpass()llm = ChatOpenAI(model=\"gpt-4o-mini\", temperature=0)llm_with_tools = llm.bind_tools(tools)\n```\n\nNow let's define our query and stream our output:\n\n```\nquery = \"What is 3 * 12? Also, what is 11 + 49?\"async for chunk in llm_with_tools.astream(query):    print(chunk.tool_call_chunks)\n```\n\n```\n[][{'name': 'Multiply', 'args': '', 'id': 'call_3aQwTP9CYlFxwOvQZPHDu6wL', 'index': 0}][{'name': None, 'args': '{\"a\"', 'id': None, 'index': 0}][{'name': None, 'args': ': 3, ', 'id': None, 'index': 0}][{'name': None, 'args': '\"b\": 1', 'id': None, 'index': 0}][{'name': None, 'args': '2}', 'id': None, 'index': 0}][{'name': 'Add', 'args': '', 'id': 'call_SQUoSsJz2p9Kx2x73GOgN1ja', 'index': 1}][{'name': None, 'args': '{\"a\"', 'id': None, 'index': 1}][{'name': None, 'args': ': 11,', 'id': None, 'index': 1}][{'name': None, 'args': ' \"b\": ', 'id': None, 'index': 1}][{'name': None, 'args': '49}', 'id': None, 'index': 1}][]\n```\n\nNote that adding message chunks will merge their corresponding tool call chunks. This is the principle by which LangChain's various [tool output parsers](https://python.langchain.com/docs/how_to/output_parser_structured/) support streaming.\n\nFor example, below we accumulate tool call chunks:\n\n```\nfirst = Trueasync for chunk in llm_with_tools.astream(query):    if first:        gathered = chunk        first = False    else:        gathered = gathered + chunk    print(gathered.tool_call_chunks)\n```\n\n```\n[][{'name': 'Multiply', 'args': '', 'id': 'call_AkL3dVeCjjiqvjv8ckLxL3gP', 'index': 0}][{'name': 'Multiply', 'args': '{\"a\"', 'id': 'call_AkL3dVeCjjiqvjv8ckLxL3gP', 'index': 0}][{'name': 'Multiply', 'args': '{\"a\": 3, ', 'id': 'call_AkL3dVeCjjiqvjv8ckLxL3gP', 'index': 0}][{'name': 'Multiply', 'args': '{\"a\": 3, \"b\": 1', 'id': 'call_AkL3dVeCjjiqvjv8ckLxL3gP', 'index': 0}][{'name': 'Multiply', 'args': '{\"a\": 3, \"b\": 12}', 'id': 'call_AkL3dVeCjjiqvjv8ckLxL3gP', 'index': 0}][{'name': 'Multiply', 'args': '{\"a\": 3, \"b\": 12}', 'id': 'call_AkL3dVeCjjiqvjv8ckLxL3gP', 'index': 0}, {'name': 'Add', 'args': '', 'id': 'call_b4iMiB3chGNGqbt5SjqqD2Wh', 'index': 1}][{'name': 'Multiply', 'args': '{\"a\": 3, \"b\": 12}', 'id': 'call_AkL3dVeCjjiqvjv8ckLxL3gP', 'index': 0}, {'name': 'Add', 'args': '{\"a\"', 'id': 'call_b4iMiB3chGNGqbt5SjqqD2Wh', 'index': 1}][{'name': 'Multiply', 'args': '{\"a\": 3, \"b\": 12}', 'id': 'call_AkL3dVeCjjiqvjv8ckLxL3gP', 'index': 0}, {'name': 'Add', 'args': '{\"a\": 11,', 'id': 'call_b4iMiB3chGNGqbt5SjqqD2Wh', 'index': 1}][{'name': 'Multiply', 'args': '{\"a\": 3, \"b\": 12}', 'id': 'call_AkL3dVeCjjiqvjv8ckLxL3gP', 'index': 0}, {'name': 'Add', 'args': '{\"a\": 11, \"b\": ', 'id': 'call_b4iMiB3chGNGqbt5SjqqD2Wh', 'index': 1}][{'name': 'Multiply', 'args': '{\"a\": 3, \"b\": 12}', 'id': 'call_AkL3dVeCjjiqvjv8ckLxL3gP', 'index': 0}, {'name': 'Add', 'args': '{\"a\": 11, \"b\": 49}', 'id': 'call_b4iMiB3chGNGqbt5SjqqD2Wh', 'index': 1}][{'name': 'Multiply', 'args': '{\"a\": 3, \"b\": 12}', 'id': 'call_AkL3dVeCjjiqvjv8ckLxL3gP', 'index': 0}, {'name': 'Add', 'args': '{\"a\": 11, \"b\": 49}', 'id': 'call_b4iMiB3chGNGqbt5SjqqD2Wh', 'index': 1}]\n```\n\n```\nprint(type(gathered.tool_call_chunks[0][\"args\"]))\n```\n\nAnd below we accumulate tool calls to demonstrate partial parsing:\n\n```\nfirst = Trueasync for chunk in llm_with_tools.astream(query):    if first:        gathered = chunk        first = False    else:        gathered = gathered + chunk    print(gathered.tool_calls)\n```\n\n```\n[][][{'name': 'Multiply', 'args': {}, 'id': 'call_4p0D4tHVXSiae9Mu0e8jlI1m'}][{'name': 'Multiply', 'args': {'a': 3}, 'id': 'call_4p0D4tHVXSiae9Mu0e8jlI1m'}][{'name': 'Multiply', 'args': {'a': 3, 'b': 1}, 'id': 'call_4p0D4tHVXSiae9Mu0e8jlI1m'}][{'name': 'Multiply', 'args': {'a': 3, 'b': 12}, 'id': 'call_4p0D4tHVXSiae9Mu0e8jlI1m'}][{'name': 'Multiply', 'args': {'a': 3, 'b': 12}, 'id': 'call_4p0D4tHVXSiae9Mu0e8jlI1m'}][{'name': 'Multiply', 'args': {'a': 3, 'b': 12}, 'id': 'call_4p0D4tHVXSiae9Mu0e8jlI1m'}, {'name': 'Add', 'args': {}, 'id': 'call_54Hx3DGjZitFlEjgMe1DYonh'}][{'name': 'Multiply', 'args': {'a': 3, 'b': 12}, 'id': 'call_4p0D4tHVXSiae9Mu0e8jlI1m'}, {'name': 'Add', 'args': {'a': 11}, 'id': 'call_54Hx3DGjZitFlEjgMe1DYonh'}][{'name': 'Multiply', 'args': {'a': 3, 'b': 12}, 'id': 'call_4p0D4tHVXSiae9Mu0e8jlI1m'}, {'name': 'Add', 'args': {'a': 11}, 'id': 'call_54Hx3DGjZitFlEjgMe1DYonh'}][{'name': 'Multiply', 'args': {'a': 3, 'b': 12}, 'id': 'call_4p0D4tHVXSiae9Mu0e8jlI1m'}, {'name': 'Add', 'args': {'a': 11, 'b': 49}, 'id': 'call_54Hx3DGjZitFlEjgMe1DYonh'}][{'name': 'Multiply', 'args': {'a': 3, 'b': 12}, 'id': 'call_4p0D4tHVXSiae9Mu0e8jlI1m'}, {'name': 'Add', 'args': {'a': 11, 'b': 49}, 'id': 'call_54Hx3DGjZitFlEjgMe1DYonh'}]\n```\n\n```\nprint(type(gathered.tool_calls[0][\"args\"]))\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/tool_stream_events/",
  "markdown": "# giscus\n\n## How to stream events from a tool\n\nIf you have [tools](https://python.langchain.com/docs/concepts/tools/) that call [chat models](https://python.langchain.com/docs/concepts/chat_models/), [retrievers](https://python.langchain.com/docs/concepts/retrievers/), or other [runnables](https://python.langchain.com/docs/concepts/runnables/), you may want to access internal events from those runnables or configure them with additional properties. This guide shows you how to manually pass parameters properly so that you can do this using the `astream_events()` method.\n\nCompatibility\n\nLangChain cannot automatically propagate configuration, including callbacks necessary for `astream_events()`, to child runnables if you are running `async` code in `python&lt;=3.10`. This is a common reason why you may fail to see events being emitted from custom runnables or tools.\n\nIf you are running python<=3.10, you will need to manually propagate the `RunnableConfig` object to the child runnable in async environments. For an example of how to manually propagate the config, see the implementation of the `bar` RunnableLambda below.\n\nIf you are running python>=3.11, the `RunnableConfig` will automatically propagate to child runnables in async environment. However, it is still a good idea to propagate the `RunnableConfig` manually if your code may run in older Python versions.\n\nThis guide also requires `langchain-core>=0.2.16`.\n\nSay you have a custom tool that calls a chain that condenses its input by prompting a chat model to return only 10 words, then reversing the output. First, define it in a naive way:\n\n```\npip install -qU langchain-openai\n```\n\n```\nimport getpassimport osif not os.environ.get(\"OPENAI_API_KEY\"):  os.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"Enter API key for OpenAI: \")from langchain_openai import ChatOpenAImodel = ChatOpenAI(model=\"gpt-4o-mini\")\n```\n\n```\nfrom langchain_core.output_parsers import StrOutputParserfrom langchain_core.prompts import ChatPromptTemplatefrom langchain_core.tools import tool@toolasync def special_summarization_tool(long_text: str) -> str:    \"\"\"A tool that summarizes input text using advanced techniques.\"\"\"    prompt = ChatPromptTemplate.from_template(        \"You are an expert writer. Summarize the following text in 10 words or less:\\n\\n{long_text}\"    )    def reverse(x: str):        return x[::-1]    chain = prompt | model | StrOutputParser() | reverse    summary = await chain.ainvoke({\"long_text\": long_text})    return summary\n```\n\nInvoking the tool directly works just fine:\n\n```\nLONG_TEXT = \"\"\"NARRATOR:(Black screen with text; The sound of buzzing bees can be heard)According to all known laws of aviation, there is no way a bee should be able to fly. Its wings are too small to get its fat little body off the ground. The bee, of course, flies anyway because bees don't care what humans think is impossible.BARRY BENSON:(Barry is picking out a shirt)Yellow, black. Yellow, black. Yellow, black. Yellow, black. Ooh, black and yellow! Let's shake it up a little.JANET BENSON:Barry! Breakfast is ready!BARRY:Coming! Hang on a second.\"\"\"await special_summarization_tool.ainvoke({\"long_text\": LONG_TEXT})\n```\n\n```\n'.yad noitaudarg rof tiftuo sesoohc yrraB ;scisyhp seifed eeB'\n```\n\nBut if you wanted to access the raw output from the chat model rather than the full tool, you might try to use the [`astream_events()`](https://python.langchain.com/docs/how_to/streaming/#using-stream-events) method and look for an `on_chat_model_end` event. Here's what happens:\n\n```\nstream = special_summarization_tool.astream_events(    {\"long_text\": LONG_TEXT}, version=\"v2\")async for event in stream:    if event[\"event\"] == \"on_chat_model_end\":        # Never triggers in python<=3.10!        print(event)\n```\n\nYou'll notice (unless you're running through this guide in `python>=3.11`) that there are no chat model events emitted from the child run!\n\nThis is because the example above does not pass the tool's config object into the internal chain. To fix this, redefine your tool to take a special parameter typed as `RunnableConfig` (see [this guide](https://python.langchain.com/docs/how_to/tool_configure/) for more details). You'll also need to pass that parameter through into the internal chain when executing it:\n\n```\nfrom langchain_core.runnables import RunnableConfig@toolasync def special_summarization_tool_with_config(    long_text: str, config: RunnableConfig) -> str:    \"\"\"A tool that summarizes input text using advanced techniques.\"\"\"    prompt = ChatPromptTemplate.from_template(        \"You are an expert writer. Summarize the following text in 10 words or less:\\n\\n{long_text}\"    )    def reverse(x: str):        return x[::-1]    chain = prompt | model | StrOutputParser() | reverse    # Pass the \"config\" object as an argument to any executed runnables    summary = await chain.ainvoke({\"long_text\": long_text}, config=config)    return summary\n```\n\nAnd now try the same `astream_events()` call as before with your new tool:\n\n```\nstream = special_summarization_tool_with_config.astream_events(    {\"long_text\": LONG_TEXT}, version=\"v2\")async for event in stream:    if event[\"event\"] == \"on_chat_model_end\":        print(event)\n```\n\n```\n{'event': 'on_chat_model_end', 'data': {'output': AIMessage(content='Bee defies physics; Barry chooses outfit for graduation day.', response_metadata={'stop_reason': 'end_turn', 'stop_sequence': None}, id='run-d23abc80-0dce-4f74-9d7b-fb98ca4f2a9e', usage_metadata={'input_tokens': 182, 'output_tokens': 16, 'total_tokens': 198}), 'input': {'messages': [[HumanMessage(content=\"You are an expert writer. Summarize the following text in 10 words or less:\\n\\n\\nNARRATOR:\\n(Black screen with text; The sound of buzzing bees can be heard)\\nAccording to all known laws of aviation, there is no way a bee should be able to fly. Its wings are too small to get its fat little body off the ground. The bee, of course, flies anyway because bees don't care what humans think is impossible.\\nBARRY BENSON:\\n(Barry is picking out a shirt)\\nYellow, black. Yellow, black. Yellow, black. Yellow, black. Ooh, black and yellow! Let's shake it up a little.\\nJANET BENSON:\\nBarry! Breakfast is ready!\\nBARRY:\\nComing! Hang on a second.\\n\")]]}}, 'run_id': 'd23abc80-0dce-4f74-9d7b-fb98ca4f2a9e', 'name': 'ChatAnthropic', 'tags': ['seq:step:2'], 'metadata': {'ls_provider': 'anthropic', 'ls_model_name': 'claude-3-5-sonnet-20240620', 'ls_model_type': 'chat', 'ls_temperature': 0.0, 'ls_max_tokens': 1024}, 'parent_ids': ['f25c41fe-8972-4893-bc40-cecf3922c1fa']}\n```\n\nAwesome! This time there's an event emitted.\n\nFor streaming, `astream_events()` automatically calls internal runnables in a chain with streaming enabled if possible, so if you wanted to a stream of tokens as they are generated from the chat model, you could simply filter to look for `on_chat_model_stream` events with no other changes:\n\n```\nstream = special_summarization_tool_with_config.astream_events(    {\"long_text\": LONG_TEXT}, version=\"v2\")async for event in stream:    if event[\"event\"] == \"on_chat_model_stream\":        print(event)\n```\n\n```\n{'event': 'on_chat_model_stream', 'data': {'chunk': AIMessageChunk(content='', id='run-f24ab147-0b82-4e63-810a-b12bd8d1fb42', usage_metadata={'input_tokens': 182, 'output_tokens': 0, 'total_tokens': 182})}, 'run_id': 'f24ab147-0b82-4e63-810a-b12bd8d1fb42', 'name': 'ChatAnthropic', 'tags': ['seq:step:2'], 'metadata': {'ls_provider': 'anthropic', 'ls_model_name': 'claude-3-5-sonnet-20240620', 'ls_model_type': 'chat', 'ls_temperature': 0.0, 'ls_max_tokens': 1024}, 'parent_ids': ['385f3612-417c-4a70-aae0-cce3a5ba6fb6']}{'event': 'on_chat_model_stream', 'data': {'chunk': AIMessageChunk(content='Bee', id='run-f24ab147-0b82-4e63-810a-b12bd8d1fb42')}, 'run_id': 'f24ab147-0b82-4e63-810a-b12bd8d1fb42', 'name': 'ChatAnthropic', 'tags': ['seq:step:2'], 'metadata': {'ls_provider': 'anthropic', 'ls_model_name': 'claude-3-5-sonnet-20240620', 'ls_model_type': 'chat', 'ls_temperature': 0.0, 'ls_max_tokens': 1024}, 'parent_ids': ['385f3612-417c-4a70-aae0-cce3a5ba6fb6']}{'event': 'on_chat_model_stream', 'data': {'chunk': AIMessageChunk(content=' def', id='run-f24ab147-0b82-4e63-810a-b12bd8d1fb42')}, 'run_id': 'f24ab147-0b82-4e63-810a-b12bd8d1fb42', 'name': 'ChatAnthropic', 'tags': ['seq:step:2'], 'metadata': {'ls_provider': 'anthropic', 'ls_model_name': 'claude-3-5-sonnet-20240620', 'ls_model_type': 'chat', 'ls_temperature': 0.0, 'ls_max_tokens': 1024}, 'parent_ids': ['385f3612-417c-4a70-aae0-cce3a5ba6fb6']}{'event': 'on_chat_model_stream', 'data': {'chunk': AIMessageChunk(content='ies physics', id='run-f24ab147-0b82-4e63-810a-b12bd8d1fb42')}, 'run_id': 'f24ab147-0b82-4e63-810a-b12bd8d1fb42', 'name': 'ChatAnthropic', 'tags': ['seq:step:2'], 'metadata': {'ls_provider': 'anthropic', 'ls_model_name': 'claude-3-5-sonnet-20240620', 'ls_model_type': 'chat', 'ls_temperature': 0.0, 'ls_max_tokens': 1024}, 'parent_ids': ['385f3612-417c-4a70-aae0-cce3a5ba6fb6']}{'event': 'on_chat_model_stream', 'data': {'chunk': AIMessageChunk(content=';', id='run-f24ab147-0b82-4e63-810a-b12bd8d1fb42')}, 'run_id': 'f24ab147-0b82-4e63-810a-b12bd8d1fb42', 'name': 'ChatAnthropic', 'tags': ['seq:step:2'], 'metadata': {'ls_provider': 'anthropic', 'ls_model_name': 'claude-3-5-sonnet-20240620', 'ls_model_type': 'chat', 'ls_temperature': 0.0, 'ls_max_tokens': 1024}, 'parent_ids': ['385f3612-417c-4a70-aae0-cce3a5ba6fb6']}{'event': 'on_chat_model_stream', 'data': {'chunk': AIMessageChunk(content=' Barry', id='run-f24ab147-0b82-4e63-810a-b12bd8d1fb42')}, 'run_id': 'f24ab147-0b82-4e63-810a-b12bd8d1fb42', 'name': 'ChatAnthropic', 'tags': ['seq:step:2'], 'metadata': {'ls_provider': 'anthropic', 'ls_model_name': 'claude-3-5-sonnet-20240620', 'ls_model_type': 'chat', 'ls_temperature': 0.0, 'ls_max_tokens': 1024}, 'parent_ids': ['385f3612-417c-4a70-aae0-cce3a5ba6fb6']}{'event': 'on_chat_model_stream', 'data': {'chunk': AIMessageChunk(content=' cho', id='run-f24ab147-0b82-4e63-810a-b12bd8d1fb42')}, 'run_id': 'f24ab147-0b82-4e63-810a-b12bd8d1fb42', 'name': 'ChatAnthropic', 'tags': ['seq:step:2'], 'metadata': {'ls_provider': 'anthropic', 'ls_model_name': 'claude-3-5-sonnet-20240620', 'ls_model_type': 'chat', 'ls_temperature': 0.0, 'ls_max_tokens': 1024}, 'parent_ids': ['385f3612-417c-4a70-aae0-cce3a5ba6fb6']}{'event': 'on_chat_model_stream', 'data': {'chunk': AIMessageChunk(content='oses outfit', id='run-f24ab147-0b82-4e63-810a-b12bd8d1fb42')}, 'run_id': 'f24ab147-0b82-4e63-810a-b12bd8d1fb42', 'name': 'ChatAnthropic', 'tags': ['seq:step:2'], 'metadata': {'ls_provider': 'anthropic', 'ls_model_name': 'claude-3-5-sonnet-20240620', 'ls_model_type': 'chat', 'ls_temperature': 0.0, 'ls_max_tokens': 1024}, 'parent_ids': ['385f3612-417c-4a70-aae0-cce3a5ba6fb6']}{'event': 'on_chat_model_stream', 'data': {'chunk': AIMessageChunk(content=' for', id='run-f24ab147-0b82-4e63-810a-b12bd8d1fb42')}, 'run_id': 'f24ab147-0b82-4e63-810a-b12bd8d1fb42', 'name': 'ChatAnthropic', 'tags': ['seq:step:2'], 'metadata': {'ls_provider': 'anthropic', 'ls_model_name': 'claude-3-5-sonnet-20240620', 'ls_model_type': 'chat', 'ls_temperature': 0.0, 'ls_max_tokens': 1024}, 'parent_ids': ['385f3612-417c-4a70-aae0-cce3a5ba6fb6']}{'event': 'on_chat_model_stream', 'data': {'chunk': AIMessageChunk(content=' graduation', id='run-f24ab147-0b82-4e63-810a-b12bd8d1fb42')}, 'run_id': 'f24ab147-0b82-4e63-810a-b12bd8d1fb42', 'name': 'ChatAnthropic', 'tags': ['seq:step:2'], 'metadata': {'ls_provider': 'anthropic', 'ls_model_name': 'claude-3-5-sonnet-20240620', 'ls_model_type': 'chat', 'ls_temperature': 0.0, 'ls_max_tokens': 1024}, 'parent_ids': ['385f3612-417c-4a70-aae0-cce3a5ba6fb6']}{'event': 'on_chat_model_stream', 'data': {'chunk': AIMessageChunk(content=' day', id='run-f24ab147-0b82-4e63-810a-b12bd8d1fb42')}, 'run_id': 'f24ab147-0b82-4e63-810a-b12bd8d1fb42', 'name': 'ChatAnthropic', 'tags': ['seq:step:2'], 'metadata': {'ls_provider': 'anthropic', 'ls_model_name': 'claude-3-5-sonnet-20240620', 'ls_model_type': 'chat', 'ls_temperature': 0.0, 'ls_max_tokens': 1024}, 'parent_ids': ['385f3612-417c-4a70-aae0-cce3a5ba6fb6']}{'event': 'on_chat_model_stream', 'data': {'chunk': AIMessageChunk(content='.', id='run-f24ab147-0b82-4e63-810a-b12bd8d1fb42')}, 'run_id': 'f24ab147-0b82-4e63-810a-b12bd8d1fb42', 'name': 'ChatAnthropic', 'tags': ['seq:step:2'], 'metadata': {'ls_provider': 'anthropic', 'ls_model_name': 'claude-3-5-sonnet-20240620', 'ls_model_type': 'chat', 'ls_temperature': 0.0, 'ls_max_tokens': 1024}, 'parent_ids': ['385f3612-417c-4a70-aae0-cce3a5ba6fb6']}{'event': 'on_chat_model_stream', 'data': {'chunk': AIMessageChunk(content='', response_metadata={'stop_reason': 'end_turn', 'stop_sequence': None}, id='run-f24ab147-0b82-4e63-810a-b12bd8d1fb42', usage_metadata={'input_tokens': 0, 'output_tokens': 16, 'total_tokens': 16})}, 'run_id': 'f24ab147-0b82-4e63-810a-b12bd8d1fb42', 'name': 'ChatAnthropic', 'tags': ['seq:step:2'], 'metadata': {'ls_provider': 'anthropic', 'ls_model_name': 'claude-3-5-sonnet-20240620', 'ls_model_type': 'chat', 'ls_temperature': 0.0, 'ls_max_tokens': 1024}, 'parent_ids': ['385f3612-417c-4a70-aae0-cce3a5ba6fb6']}\n```\n\n## Next steps[​](#next-steps \"Direct link to Next steps\")\n\nYou've now seen how to stream events from within a tool. Next, check out the following guides for more on using tools:\n\n*   Pass [runtime values to tools](https://python.langchain.com/docs/how_to/tool_runtime/)\n*   Pass [tool results back to a model](https://python.langchain.com/docs/how_to/tool_results_pass_to_model/)\n*   [Dispatch custom callback events](https://python.langchain.com/docs/how_to/callbacks_custom_events/)\n\nYou can also check out some more specific uses of tool calling:\n\n*   Building [tool-using chains and agents](https://python.langchain.com/docs/how_to/#tools)\n*   Getting [structured outputs](https://python.langchain.com/docs/how_to/structured_output/) from models"
},
{
  "url": "https://python.langchain.com/docs/how_to/tools_error/",
  "markdown": "# giscus\n\n## How to handle tool errors\n\n[Calling tools](https://python.langchain.com/docs/concepts/tool_calling/) with an LLM is generally more reliable than pure prompting, but it isn't perfect. The model may try to call a tool that doesn't exist or fail to return arguments that match the requested schema. Strategies like keeping schemas simple, reducing the number of tools you pass at once, and having good names and descriptions can help mitigate this risk, but aren't foolproof.\n\nThis guide covers some ways to build error handling into your chains to mitigate these failure modes.\n\n## Setup[​](#setup \"Direct link to Setup\")\n\nWe'll need to install the following packages:\n\n```\n%pip install --upgrade --quiet langchain-core langchain-openai\n```\n\nIf you'd like to trace your runs in [LangSmith](https://docs.smith.langchain.com/) uncomment and set the following environment variables:\n\n```\nimport getpassimport os# os.environ[\"LANGCHAIN_TRACING_V2\"] = \"true\"# os.environ[\"LANGCHAIN_API_KEY\"] = getpass.getpass()\n```\n\n## Chain[​](#chain \"Direct link to Chain\")\n\nSuppose we have the following (dummy) tool and tool-calling chain. We'll make our tool intentionally convoluted to try and trip up the model.\n\n```\npip install -qU langchain-openai\n```\n\n```\nimport getpassimport osif not os.environ.get(\"OPENAI_API_KEY\"):  os.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"Enter API key for OpenAI: \")from langchain_openai import ChatOpenAIllm = ChatOpenAI(model=\"gpt-4o-mini\")\n```\n\n```\n# Define toolfrom langchain_core.tools import tool@tooldef complex_tool(int_arg: int, float_arg: float, dict_arg: dict) -> int:    \"\"\"Do something complex with a complex tool.\"\"\"    return int_arg * float_argllm_with_tools = llm.bind_tools(    [complex_tool],)# Define chainchain = llm_with_tools | (lambda msg: msg.tool_calls[0][\"args\"]) | complex_tool\n```\n\n**API Reference:**[tool](https://python.langchain.com/api_reference/core/tools/langchain_core.tools.convert.tool.html)\n\nWe can see that when we try to invoke this chain with even a fairly explicit input, the model fails to correctly call the tool (it forgets the `dict_arg` argument).\n\n```\nchain.invoke(    \"use complex tool. the args are 5, 2.1, empty dictionary. don't forget dict_arg\")\n```\n\n```\n---------------------------------------------------------------------------``````outputValidationError                           Traceback (most recent call last)``````outputCell In[5], line 1----> 1 chain.invoke(      2     \"use complex tool. the args are 5, 2.1, empty dictionary. don't forget dict_arg\"      3 )``````outputFile ~/langchain/.venv/lib/python3.11/site-packages/langchain_core/runnables/base.py:2998, in RunnableSequence.invoke(self, input, config, **kwargs)   2996             input = context.run(step.invoke, input, config, **kwargs)   2997         else:-> 2998             input = context.run(step.invoke, input, config)   2999 # finish the root run   3000 except BaseException as e:``````outputFile ~/langchain/.venv/lib/python3.11/site-packages/langchain_core/tools/base.py:456, in BaseTool.invoke(self, input, config, **kwargs)    449 def invoke(    450     self,    451     input: Union[str, Dict, ToolCall],    452     config: Optional[RunnableConfig] = None,    453     **kwargs: Any,    454 ) -> Any:    455     tool_input, kwargs = _prep_run_args(input, config, **kwargs)--> 456     return self.run(tool_input, **kwargs)``````outputFile ~/langchain/.venv/lib/python3.11/site-packages/langchain_core/tools/base.py:659, in BaseTool.run(self, tool_input, verbose, start_color, color, callbacks, tags, metadata, run_name, run_id, config, tool_call_id, **kwargs)    657 if error_to_raise:    658     run_manager.on_tool_error(error_to_raise)--> 659     raise error_to_raise    660 output = _format_output(content, artifact, tool_call_id, self.name, status)    661 run_manager.on_tool_end(output, color=color, name=self.name, **kwargs)``````outputFile ~/langchain/.venv/lib/python3.11/site-packages/langchain_core/tools/base.py:622, in BaseTool.run(self, tool_input, verbose, start_color, color, callbacks, tags, metadata, run_name, run_id, config, tool_call_id, **kwargs)    620 context = copy_context()    621 context.run(_set_config_context, child_config)--> 622 tool_args, tool_kwargs = self._to_args_and_kwargs(tool_input)    623 if signature(self._run).parameters.get(\"run_manager\"):    624     tool_kwargs[\"run_manager\"] = run_manager``````outputFile ~/langchain/.venv/lib/python3.11/site-packages/langchain_core/tools/base.py:545, in BaseTool._to_args_and_kwargs(self, tool_input)    544 def _to_args_and_kwargs(self, tool_input: Union[str, Dict]) -> Tuple[Tuple, Dict]:--> 545     tool_input = self._parse_input(tool_input)    546     # For backwards compatibility, if run_input is a string,    547     # pass as a positional argument.    548     if isinstance(tool_input, str):``````outputFile ~/langchain/.venv/lib/python3.11/site-packages/langchain_core/tools/base.py:487, in BaseTool._parse_input(self, tool_input)    485 if input_args is not None:    486     if issubclass(input_args, BaseModel):--> 487         result = input_args.model_validate(tool_input)    488         result_dict = result.model_dump()    489     elif issubclass(input_args, BaseModelV1):``````outputFile ~/langchain/.venv/lib/python3.11/site-packages/pydantic/main.py:568, in BaseModel.model_validate(cls, obj, strict, from_attributes, context)    566 # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks    567 __tracebackhide__ = True--> 568 return cls.__pydantic_validator__.validate_python(    569     obj, strict=strict, from_attributes=from_attributes, context=context    570 )``````outputValidationError: 1 validation error for complex_toolSchemadict_arg  Field required [type=missing, input_value={'int_arg': 5, 'float_arg': 2.1}, input_type=dict]    For further information visit https://errors.pydantic.dev/2.8/v/missing\n```\n\nThe simplest way to more gracefully handle errors is to try/except the tool-calling step and return a helpful message on errors:\n\n```\nfrom typing import Anyfrom langchain_core.runnables import Runnable, RunnableConfigdef try_except_tool(tool_args: dict, config: RunnableConfig) -> Runnable:    try:        complex_tool.invoke(tool_args, config=config)    except Exception as e:        return f\"Calling tool with arguments:\\n\\n{tool_args}\\n\\nraised the following error:\\n\\n{type(e)}: {e}\"chain = llm_with_tools | (lambda msg: msg.tool_calls[0][\"args\"]) | try_except_toolprint(    chain.invoke(        \"use complex tool. the args are 5, 2.1, empty dictionary. don't forget dict_arg\"    ))\n```\n\n```\nCalling tool with arguments:{'int_arg': 5, 'float_arg': 2.1}raised the following error:<class 'pydantic_core._pydantic_core.ValidationError'>: 1 validation error for complex_toolSchemadict_arg  Field required [type=missing, input_value={'int_arg': 5, 'float_arg': 2.1}, input_type=dict]    For further information visit https://errors.pydantic.dev/2.8/v/missing\n```\n\n## Fallbacks[​](#fallbacks \"Direct link to Fallbacks\")\n\nWe can also try to fallback to a better model in the event of a tool invocation error. In this case we'll fall back to an identical chain that uses `gpt-4-1106-preview` instead of `gpt-3.5-turbo`.\n\n```\nchain = llm_with_tools | (lambda msg: msg.tool_calls[0][\"args\"]) | complex_toolbetter_model = ChatOpenAI(model=\"gpt-4-1106-preview\", temperature=0).bind_tools(    [complex_tool], tool_choice=\"complex_tool\")better_chain = better_model | (lambda msg: msg.tool_calls[0][\"args\"]) | complex_toolchain_with_fallback = chain.with_fallbacks([better_chain])chain_with_fallback.invoke(    \"use complex tool. the args are 5, 2.1, empty dictionary. don't forget dict_arg\")\n```\n\nLooking at the [LangSmith trace](https://smith.langchain.com/public/00e91fc2-e1a4-4b0f-a82e-e6b3119d196c/r) for this chain run, we can see that the first chain call fails as expected and it's the fallback that succeeds.\n\n## Retry with exception[​](#retry-with-exception \"Direct link to Retry with exception\")\n\nTo take things one step further, we can try to automatically re-run the chain with the exception passed in, so that the model may be able to correct its behavior:\n\n```\nfrom langchain_core.messages import AIMessage, HumanMessage, ToolCall, ToolMessagefrom langchain_core.prompts import ChatPromptTemplateclass CustomToolException(Exception):    \"\"\"Custom LangChain tool exception.\"\"\"    def __init__(self, tool_call: ToolCall, exception: Exception) -> None:        super().__init__()        self.tool_call = tool_call        self.exception = exceptiondef tool_custom_exception(msg: AIMessage, config: RunnableConfig) -> Runnable:    try:        return complex_tool.invoke(msg.tool_calls[0][\"args\"], config=config)    except Exception as e:        raise CustomToolException(msg.tool_calls[0], e)def exception_to_messages(inputs: dict) -> dict:    exception = inputs.pop(\"exception\")    # Add historical messages to the original input, so the model knows that it made a mistake with the last tool call.    messages = [        AIMessage(content=\"\", tool_calls=[exception.tool_call]),        ToolMessage(            tool_call_id=exception.tool_call[\"id\"], content=str(exception.exception)        ),        HumanMessage(            content=\"The last tool call raised an exception. Try calling the tool again with corrected arguments. Do not repeat mistakes.\"        ),    ]    inputs[\"last_output\"] = messages    return inputs# We add a last_output MessagesPlaceholder to our prompt which if not passed in doesn't# affect the prompt at all, but gives us the option to insert an arbitrary list of Messages# into the prompt if needed. We'll use this on retries to insert the error message.prompt = ChatPromptTemplate.from_messages(    [(\"human\", \"{input}\"), (\"placeholder\", \"{last_output}\")])chain = prompt | llm_with_tools | tool_custom_exception# If the initial chain call fails, we rerun it withe the exception passed in as a message.self_correcting_chain = chain.with_fallbacks(    [exception_to_messages | chain], exception_key=\"exception\")\n```\n\n```\nself_correcting_chain.invoke(    {        \"input\": \"use complex tool. the args are 5, 2.1, empty dictionary. don't forget dict_arg\"    })\n```\n\nAnd our chain succeeds! Looking at the [LangSmith trace](https://smith.langchain.com/public/c11e804c-e14f-4059-bd09-64766f999c14/r), we can see that indeed our initial chain still fails, and it's only on retrying that the chain succeeds.\n\n## Next steps[​](#next-steps \"Direct link to Next steps\")\n\nNow you've seen some strategies how to handle tool calling errors. Next, you can learn more about how to use tools:\n\n*   Few shot prompting [with tools](https://python.langchain.com/docs/how_to/tools_few_shot/)\n*   Stream [tool calls](https://python.langchain.com/docs/how_to/tool_streaming/)\n*   Pass [runtime values to tools](https://python.langchain.com/docs/how_to/tool_runtime/)\n\nYou can also check out some more specific uses of tool calling:\n\n*   Getting [structured outputs](https://python.langchain.com/docs/how_to/structured_output/) from models"
},
{
  "url": "https://python.langchain.com/docs/how_to/tools_as_openai_functions/",
  "markdown": "# giscus\n\n[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/langchain-ai/langchain/blob/master/docs/docs/how_to/tools_as_openai_functions.ipynb)[![Open on GitHub](https://img.shields.io/badge/Open%20on%20GitHub-grey?logo=github&logoColor=white)](https://github.com/langchain-ai/langchain/blob/master/docs/docs/how_to/tools_as_openai_functions.ipynb)\n\n## How to convert tools to OpenAI Functions\n\nThis notebook goes over how to use LangChain [tools](https://python.langchain.com/docs/concepts/tools/) as OpenAI functions.\n\n```\n%pip install -qU langchain-community langchain-openai\n```\n\n```\nfrom langchain_community.tools import MoveFileToolfrom langchain_core.messages import HumanMessagefrom langchain_core.utils.function_calling import convert_to_openai_functionfrom langchain_openai import ChatOpenAI\n```\n\n```\nmodel = ChatOpenAI(model=\"gpt-3.5-turbo\")\n```\n\n```\ntools = [MoveFileTool()]functions = [convert_to_openai_function(t) for t in tools]\n```\n\n```\n{'name': 'move_file', 'description': 'Move or rename a file from one location to another', 'parameters': {'type': 'object',  'properties': {'source_path': {'description': 'Path of the file to move',    'type': 'string'},   'destination_path': {'description': 'New path for the moved file',    'type': 'string'}},  'required': ['source_path', 'destination_path']}}\n```\n\n```\nmessage = model.invoke(    [HumanMessage(content=\"move file foo to bar\")], functions=functions)\n```\n\n```\nAIMessage(content='', additional_kwargs={'function_call': {'arguments': '{\\n  \"source_path\": \"foo\",\\n  \"destination_path\": \"bar\"\\n}', 'name': 'move_file'}})\n```\n\n```\nmessage.additional_kwargs[\"function_call\"]\n```\n\n```\n{'name': 'move_file', 'arguments': '{\\n  \"source_path\": \"foo\",\\n  \"destination_path\": \"bar\"\\n}'}\n```\n\nWith OpenAI chat models we can also automatically bind and convert function-like objects with `bind_functions`\n\n```\nmodel_with_functions = model.bind_functions(tools)model_with_functions.invoke([HumanMessage(content=\"move file foo to bar\")])\n```\n\n```\nAIMessage(content='', additional_kwargs={'function_call': {'arguments': '{\\n  \"source_path\": \"foo\",\\n  \"destination_path\": \"bar\"\\n}', 'name': 'move_file'}})\n```\n\nOr we can use the update OpenAI API that uses `tools` and `tool_choice` instead of `functions` and `function_call` by using `ChatOpenAI.bind_tools`:\n\n```\nmodel_with_tools = model.bind_tools(tools)model_with_tools.invoke([HumanMessage(content=\"move file foo to bar\")])\n```\n\n```\nAIMessage(content='', additional_kwargs={'tool_calls': [{'id': 'call_btkY3xV71cEVAOHnNa5qwo44', 'function': {'arguments': '{\\n  \"source_path\": \"foo\",\\n  \"destination_path\": \"bar\"\\n}', 'name': 'move_file'}, 'type': 'function'}]})\n```\n\n* * *\n\n#### Was this page helpful?"
},
{
  "url": "https://python.langchain.com/docs/how_to/tools_few_shot/",
  "markdown": "# giscus\n\n## How to use few-shot prompting with tool calling\n\nFor more complex tool use it's very useful to add [few-shot examples](https://python.langchain.com/docs/concepts/few_shot_prompting/) to the prompt. We can do this by adding `AIMessage`s with `ToolCall`s and corresponding `ToolMessage`s to our prompt.\n\nFirst let's define our tools and model.\n\n```\nfrom langchain_core.tools import tool@tooldef add(a: int, b: int) -> int:    \"\"\"Adds a and b.\"\"\"    return a + b@tooldef multiply(a: int, b: int) -> int:    \"\"\"Multiplies a and b.\"\"\"    return a * btools = [add, multiply]\n```\n\n**API Reference:**[tool](https://python.langchain.com/api_reference/core/tools/langchain_core.tools.convert.tool.html)\n\n```\nimport osfrom getpass import getpassfrom langchain_openai import ChatOpenAIif \"OPENAI_API_KEY\" not in os.environ:    os.environ[\"OPENAI_API_KEY\"] = getpass()llm = ChatOpenAI(model=\"gpt-4o-mini\", temperature=0)llm_with_tools = llm.bind_tools(tools)\n```\n\nLet's run our model where we can notice that even with some special instructions our model can get tripped up by order of operations.\n\n```\nllm_with_tools.invoke(    \"Whats 119 times 8 minus 20. Don't do any math yourself, only use tools for math. Respect order of operations\").tool_calls\n```\n\n```\n[{'name': 'Multiply',  'args': {'a': 119, 'b': 8},  'id': 'call_T88XN6ECucTgbXXkyDeC2CQj'}, {'name': 'Add',  'args': {'a': 952, 'b': -20},  'id': 'call_licdlmGsRqzup8rhqJSb1yZ4'}]\n```\n\nThe model shouldn't be trying to add anything yet, since it technically can't know the results of 119 \\* 8 yet.\n\nBy adding a prompt with some examples we can correct this behavior:\n\n```\nfrom langchain_core.messages import AIMessage, HumanMessage, ToolMessagefrom langchain_core.prompts import ChatPromptTemplatefrom langchain_core.runnables import RunnablePassthroughexamples = [    HumanMessage(        \"What's the product of 317253 and 128472 plus four\", name=\"example_user\"    ),    AIMessage(        \"\",        name=\"example_assistant\",        tool_calls=[            {\"name\": \"Multiply\", \"args\": {\"x\": 317253, \"y\": 128472}, \"id\": \"1\"}        ],    ),    ToolMessage(\"16505054784\", tool_call_id=\"1\"),    AIMessage(        \"\",        name=\"example_assistant\",        tool_calls=[{\"name\": \"Add\", \"args\": {\"x\": 16505054784, \"y\": 4}, \"id\": \"2\"}],    ),    ToolMessage(\"16505054788\", tool_call_id=\"2\"),    AIMessage(        \"The product of 317253 and 128472 plus four is 16505054788\",        name=\"example_assistant\",    ),]system = \"\"\"You are bad at math but are an expert at using a calculator. Use past tool usage as an example of how to correctly use the tools.\"\"\"few_shot_prompt = ChatPromptTemplate.from_messages(    [        (\"system\", system),        *examples,        (\"human\", \"{query}\"),    ])chain = {\"query\": RunnablePassthrough()} | few_shot_prompt | llm_with_toolschain.invoke(\"Whats 119 times 8 minus 20\").tool_calls\n```\n\n```\n[{'name': 'Multiply',  'args': {'a': 119, 'b': 8},  'id': 'call_9MvuwQqg7dlJupJcoTWiEsDo'}]\n```\n\nAnd we get the correct output this time.\n\nHere's what the [LangSmith trace](https://smith.langchain.com/public/f70550a1-585f-4c9d-a643-13148ab1616f/r) looks like."
},
{
  "url": "https://python.langchain.com/docs/how_to/tools_human/",
  "markdown": "# giscus\n\n## How to add a human-in-the-loop for tools\n\nThere are certain tools that we don't trust a model to execute on its own. One thing we can do in such situations is require human approval before the tool is invoked.\n\ninfo\n\nThis how-to guide shows a simple way to add human-in-the-loop for code running in a jupyter notebook or in a terminal.\n\nTo build a production application, you will need to do more work to keep track of application state appropriately.\n\nWe recommend using `langgraph` for powering such a capability. For more details, please see this [guide](https://langchain-ai.github.io/langgraph/how-tos/human-in-the-loop/).\n\n## Setup[​](#setup \"Direct link to Setup\")\n\nWe'll need to install the following packages:\n\n```\n%pip install --upgrade --quiet langchain\n```\n\nAnd set these environment variables:\n\n```\nimport getpassimport os# If you'd like to use LangSmith, uncomment the below:# os.environ[\"LANGCHAIN_TRACING_V2\"] = \"true\"# os.environ[\"LANGCHAIN_API_KEY\"] = getpass.getpass()\n```\n\n## Chain[​](#chain \"Direct link to Chain\")\n\nLet's create a few simple (dummy) tools and a tool-calling chain:\n\n```\npip install -qU langchain-openai\n```\n\n```\nimport getpassimport osif not os.environ.get(\"OPENAI_API_KEY\"):  os.environ[\"OPENAI_API_KEY\"] = getpass.getpass(\"Enter API key for OpenAI: \")from langchain_openai import ChatOpenAIllm = ChatOpenAI(model=\"gpt-4o-mini\")\n```\n\n```\nfrom typing import Dict, Listfrom langchain_core.messages import AIMessagefrom langchain_core.runnables import Runnable, RunnablePassthroughfrom langchain_core.tools import tool@tooldef count_emails(last_n_days: int) -> int:    \"\"\"Dummy function to count number of e-mails. Returns 2 * last_n_days.\"\"\"    return last_n_days * 2@tooldef send_email(message: str, recipient: str) -> str:    \"\"\"Dummy function for sending an e-mail.\"\"\"    return f\"Successfully sent email to {recipient}.\"tools = [count_emails, send_email]llm_with_tools = llm.bind_tools(tools)def call_tools(msg: AIMessage) -> List[Dict]:    \"\"\"Simple sequential tool calling helper.\"\"\"    tool_map = {tool.name: tool for tool in tools}    tool_calls = msg.tool_calls.copy()    for tool_call in tool_calls:        tool_call[\"output\"] = tool_map[tool_call[\"name\"]].invoke(tool_call[\"args\"])    return tool_callschain = llm_with_tools | call_toolschain.invoke(\"how many emails did i get in the last 5 days?\")\n```\n\n```\n[{'name': 'count_emails',  'args': {'last_n_days': 5},  'id': 'toolu_01QYZdJ4yPiqsdeENWHqioFW',  'output': 10}]\n```\n\n## Adding human approval[​](#adding-human-approval \"Direct link to Adding human approval\")\n\nLet's add a step in the chain that will ask a person to approve or reject the tall call request.\n\nOn rejection, the step will raise an exception which will stop execution of the rest of the chain.\n\n```\nimport jsonclass NotApproved(Exception):    \"\"\"Custom exception.\"\"\"def human_approval(msg: AIMessage) -> AIMessage:    \"\"\"Responsible for passing through its input or raising an exception.    Args:        msg: output from the chat model    Returns:        msg: original output from the msg    \"\"\"    tool_strs = \"\\n\\n\".join(        json.dumps(tool_call, indent=2) for tool_call in msg.tool_calls    )    input_msg = (        f\"Do you approve of the following tool invocations\\n\\n{tool_strs}\\n\\n\"        \"Anything except 'Y'/'Yes' (case-insensitive) will be treated as a no.\\n >>>\"    )    resp = input(input_msg)    if resp.lower() not in (\"yes\", \"y\"):        raise NotApproved(f\"Tool invocations not approved:\\n\\n{tool_strs}\")    return msg\n```\n\n```\nchain = llm_with_tools | human_approval | call_toolschain.invoke(\"how many emails did i get in the last 5 days?\")\n```\n\n```\nDo you approve of the following tool invocations{  \"name\": \"count_emails\",  \"args\": {    \"last_n_days\": 5  },  \"id\": \"toolu_01WbD8XeMoQaRFtsZezfsHor\"}Anything except 'Y'/'Yes' (case-insensitive) will be treated as a no. >>> yes\n```\n\n```\n[{'name': 'count_emails',  'args': {'last_n_days': 5},  'id': 'toolu_01WbD8XeMoQaRFtsZezfsHor',  'output': 10}]\n```\n\n```\ntry:    chain.invoke(\"Send sally@gmail.com an email saying 'What's up homie'\")except NotApproved as e:    print()    print(e)\n```\n\n```\nDo you approve of the following tool invocations{  \"name\": \"send_email\",  \"args\": {    \"recipient\": \"sally@gmail.com\",    \"message\": \"What's up homie\"  },  \"id\": \"toolu_014XccHFzBiVcc9GV1harV9U\"}Anything except 'Y'/'Yes' (case-insensitive) will be treated as a no. >>> no``````outputTool invocations not approved:{  \"name\": \"send_email\",  \"args\": {    \"recipient\": \"sally@gmail.com\",    \"message\": \"What's up homie\"  },  \"id\": \"toolu_014XccHFzBiVcc9GV1harV9U\"}\n```"
},
{
  "url": "https://python.langchain.com/docs/how_to/tools_model_specific/",
  "markdown": "# giscus\n\nProviders adopt different conventions for formatting tool schemas. For instance, OpenAI uses a format like this:\n\nWe can bind this model-specific format directly to the model as well if preferred. Here's an example:\n\n```\nfrom langchain_openai import ChatOpenAImodel = ChatOpenAI()model_with_tools = model.bind(    tools=[        {            \"type\": \"function\",            \"function\": {                \"name\": \"multiply\",                \"description\": \"Multiply two integers together.\",                \"parameters\": {                    \"type\": \"object\",                    \"properties\": {                        \"a\": {\"type\": \"number\", \"description\": \"First integer\"},                        \"b\": {\"type\": \"number\", \"description\": \"Second integer\"},                    },                    \"required\": [\"a\", \"b\"],                },            },        }    ])model_with_tools.invoke(\"Whats 119 times 8?\")\n```\n\n```\nAIMessage(content='', additional_kwargs={'tool_calls': [{'id': 'call_mn4ELw1NbuE0DFYhIeK0GrPe', 'function': {'arguments': '{\"a\":119,\"b\":8}', 'name': 'multiply'}, 'type': 'function'}]}, response_metadata={'token_usage': {'completion_tokens': 17, 'prompt_tokens': 62, 'total_tokens': 79}, 'model_name': 'gpt-3.5-turbo', 'system_fingerprint': 'fp_c2295e73ad', 'finish_reason': 'tool_calls', 'logprobs': None}, id='run-353e8a9a-7125-4f94-8c68-4f3da4c21120-0', tool_calls=[{'name': 'multiply', 'args': {'a': 119, 'b': 8}, 'id': 'call_mn4ELw1NbuE0DFYhIeK0GrPe'}])\n```\n\nThis is functionally equivalent to the `bind_tools()` method."
},
{
  "url": "https://python.langchain.com/docs/how_to/trim_messages/",
  "markdown": "# giscus\n\n## How to trim messages\n\nAll models have finite context windows, meaning there's a limit to how many [tokens](https://python.langchain.com/docs/concepts/tokens/) they can take as input. If you have very long messages or a chain/agent that accumulates a long message history, you'll need to manage the length of the messages you're passing in to the model.\n\n[trim\\_messages](https://python.langchain.com/api_reference/core/messages/langchain_core.messages.utils.trim_messages.html) can be used to reduce the size of a chat history to a specified token count or specified message count.\n\nIf passing the trimmed chat history back into a chat model directly, the trimmed chat history should satisfy the following properties:\n\n1.  The resulting chat history should be **valid**. Usually this means that the following properties should be satisfied:\n    *   The chat history **starts** with either (1) a `HumanMessage` or (2) a [SystemMessage](https://python.langchain.com/docs/concepts/messages/#systemmessage) followed by a `HumanMessage`.\n    *   The chat history **ends** with either a `HumanMessage` or a `ToolMessage`.\n    *   A `ToolMessage` can only appear after an `AIMessage` that involved a tool call. This can be achieved by setting `start_on=\"human\"` and `ends_on=(\"human\", \"tool\")`.\n2.  It includes recent messages and drops old messages in the chat history. This can be achieved by setting `strategy=\"last\"`.\n3.  Usually, the new chat history should include the `SystemMessage` if it was present in the original chat history since the `SystemMessage` includes special instructions to the chat model. The `SystemMessage` is almost always the first message in the history if present. This can be achieved by setting `include_system=True`.\n\n## Trimming based on token count[​](#trimming-based-on-token-count \"Direct link to Trimming based on token count\")\n\nHere, we'll trim the chat history based on token count. The trimmed chat history will produce a **valid** chat history that includes the `SystemMessage`.\n\nTo keep the most recent messages, we set `strategy=\"last\"`. We'll also set `include_system=True` to include the `SystemMessage`, and `start_on=\"human\"` to make sure the resulting chat history is valid.\n\nThis is a good default configuration when using `trim_messages` based on token count. Remember to adjust `token_counter` and `max_tokens` for your use case.\n\nNotice that for our `token_counter` we can pass in a function (more on that below) or a language model (since language models have a message token counting method). It makes sense to pass in a model when you're trimming your messages to fit into the context window of that specific model:\n\n```\npip install -qU langchain-openai\n```\n\n```\nNote: you may need to restart the kernel to use updated packages.\n```\n\n```\nfrom langchain_core.messages import (    AIMessage,    HumanMessage,    SystemMessage,    ToolMessage,    trim_messages,)from langchain_openai import ChatOpenAImessages = [    SystemMessage(\"you're a good assistant, you always respond with a joke.\"),    HumanMessage(\"i wonder why it's called langchain\"),    AIMessage(        'Well, I guess they thought \"WordRope\" and \"SentenceString\" just didn\\'t have the same ring to it!'    ),    HumanMessage(\"and who is harrison chasing anyways\"),    AIMessage(        \"Hmmm let me think.\\n\\nWhy, he's probably chasing after the last cup of coffee in the office!\"    ),    HumanMessage(\"what do you call a speechless parrot\"),]trim_messages(    messages,    # Keep the last <= n_count tokens of the messages.    strategy=\"last\",    # Remember to adjust based on your model    # or else pass a custom token_encoder    token_counter=ChatOpenAI(model=\"gpt-4o\"),    # Most chat models expect that chat history starts with either:    # (1) a HumanMessage or    # (2) a SystemMessage followed by a HumanMessage    # Remember to adjust based on the desired conversation    # length    max_tokens=45,    # Most chat models expect that chat history starts with either:    # (1) a HumanMessage or    # (2) a SystemMessage followed by a HumanMessage    start_on=\"human\",    # Most chat models expect that chat history ends with either:    # (1) a HumanMessage or    # (2) a ToolMessage    end_on=(\"human\", \"tool\"),    # Usually, we want to keep the SystemMessage    # if it's present in the original history.    # The SystemMessage has special instructions for the model.    include_system=True,    allow_partial=False,)\n```\n\n```\n[SystemMessage(content=\"you're a good assistant, you always respond with a joke.\", additional_kwargs={}, response_metadata={}), HumanMessage(content='what do you call a speechless parrot', additional_kwargs={}, response_metadata={})]\n```\n\n## Trimming based on message count[​](#trimming-based-on-message-count \"Direct link to Trimming based on message count\")\n\nAlternatively, we can trim the chat history based on **message count**, by setting `token_counter=len`. In this case, each message will count as a single token, and `max_tokens` will control the maximum number of messages.\n\nThis is a good default configuration when using `trim_messages` based on message count. Remember to adjust `max_tokens` for your use case.\n\n```\ntrim_messages(    messages,    # Keep the last <= n_count tokens of the messages.    strategy=\"last\",    token_counter=len,    # When token_counter=len, each message    # will be counted as a single token.    # Remember to adjust for your use case    max_tokens=5,    # Most chat models expect that chat history starts with either:    # (1) a HumanMessage or    # (2) a SystemMessage followed by a HumanMessage    start_on=\"human\",    # Most chat models expect that chat history ends with either:    # (1) a HumanMessage or    # (2) a ToolMessage    end_on=(\"human\", \"tool\"),    # Usually, we want to keep the SystemMessage    # if it's present in the original history.    # The SystemMessage has special instructions for the model.    include_system=True,)\n```\n\n```\n[SystemMessage(content=\"you're a good assistant, you always respond with a joke.\", additional_kwargs={}, response_metadata={}), HumanMessage(content='and who is harrison chasing anyways', additional_kwargs={}, response_metadata={}), AIMessage(content=\"Hmmm let me think.\\n\\nWhy, he's probably chasing after the last cup of coffee in the office!\", additional_kwargs={}, response_metadata={}), HumanMessage(content='what do you call a speechless parrot', additional_kwargs={}, response_metadata={})]\n```\n\n## Advanced Usage[​](#advanced-usage \"Direct link to Advanced Usage\")\n\nYou can use `trim_message` as a building-block to create more complex processing logic.\n\nIf we want to allow splitting up the contents of a message we can specify `allow_partial=True`:\n\n```\ntrim_messages(    messages,    max_tokens=56,    strategy=\"last\",    token_counter=ChatOpenAI(model=\"gpt-4o\"),    include_system=True,    allow_partial=True,)\n```\n\n```\n[SystemMessage(content=\"you're a good assistant, you always respond with a joke.\", additional_kwargs={}, response_metadata={}), AIMessage(content=\"\\nWhy, he's probably chasing after the last cup of coffee in the office!\", additional_kwargs={}, response_metadata={}), HumanMessage(content='what do you call a speechless parrot', additional_kwargs={}, response_metadata={})]\n```\n\nBy default, the `SystemMessage` will not be included, so you can drop it by either setting `include_system=False` or by dropping the `include_system` argument.\n\n```\ntrim_messages(    messages,    max_tokens=45,    strategy=\"last\",    token_counter=ChatOpenAI(model=\"gpt-4o\"),)\n```\n\n```\n[AIMessage(content=\"Hmmm let me think.\\n\\nWhy, he's probably chasing after the last cup of coffee in the office!\", additional_kwargs={}, response_metadata={}), HumanMessage(content='what do you call a speechless parrot', additional_kwargs={}, response_metadata={})]\n```\n\nWe can perform the flipped operation of getting the _first_ `max_tokens` by specifying `strategy=\"first\"`:\n\n```\ntrim_messages(    messages,    max_tokens=45,    strategy=\"first\",    token_counter=ChatOpenAI(model=\"gpt-4o\"),)\n```\n\n```\n[SystemMessage(content=\"you're a good assistant, you always respond with a joke.\", additional_kwargs={}, response_metadata={}), HumanMessage(content=\"i wonder why it's called langchain\", additional_kwargs={}, response_metadata={})]\n```\n\n## Writing a custom token counter[​](#writing-a-custom-token-counter \"Direct link to Writing a custom token counter\")\n\nWe can write a custom token counter function that takes in a list of messages and returns an int.\n\n```\nNote: you may need to restart the kernel to use updated packages.\n```\n\n```\nfrom typing import Listimport tiktokenfrom langchain_core.messages import BaseMessage, ToolMessagedef str_token_counter(text: str) -> int:    enc = tiktoken.get_encoding(\"o200k_base\")    return len(enc.encode(text))def tiktoken_counter(messages: List[BaseMessage]) -> int:    \"\"\"Approximately reproduce https://github.com/openai/openai-cookbook/blob/main/examples/How_to_count_tokens_with_tiktoken.ipynb    For simplicity only supports str Message.contents.    \"\"\"    num_tokens = 3  # every reply is primed with <|start|>assistant<|message|>    tokens_per_message = 3    tokens_per_name = 1    for msg in messages:        if isinstance(msg, HumanMessage):            role = \"user\"        elif isinstance(msg, AIMessage):            role = \"assistant\"        elif isinstance(msg, ToolMessage):            role = \"tool\"        elif isinstance(msg, SystemMessage):            role = \"system\"        else:            raise ValueError(f\"Unsupported messages type {msg.__class__}\")        num_tokens += (            tokens_per_message            + str_token_counter(role)            + str_token_counter(msg.content)        )        if msg.name:            num_tokens += tokens_per_name + str_token_counter(msg.name)    return num_tokenstrim_messages(    messages,    token_counter=tiktoken_counter,    # Keep the last <= n_count tokens of the messages.    strategy=\"last\",    # When token_counter=len, each message    # will be counted as a single token.    # Remember to adjust for your use case    max_tokens=45,    # Most chat models expect that chat history starts with either:    # (1) a HumanMessage or    # (2) a SystemMessage followed by a HumanMessage    start_on=\"human\",    # Most chat models expect that chat history ends with either:    # (1) a HumanMessage or    # (2) a ToolMessage    end_on=(\"human\", \"tool\"),    # Usually, we want to keep the SystemMessage    # if it's present in the original history.    # The SystemMessage has special instructions for the model.    include_system=True,)\n```\n\n```\n[SystemMessage(content=\"you're a good assistant, you always respond with a joke.\", additional_kwargs={}, response_metadata={}), HumanMessage(content='what do you call a speechless parrot', additional_kwargs={}, response_metadata={})]\n```\n\n## Chaining[​](#chaining \"Direct link to Chaining\")\n\n`trim_messages` can be used imperatively (like above) or declaratively, making it easy to compose with other components in a chain\n\n```\nllm = ChatOpenAI(model=\"gpt-4o\")# Notice we don't pass in messages. This creates# a RunnableLambda that takes messages as inputtrimmer = trim_messages(    token_counter=llm,    # Keep the last <= n_count tokens of the messages.    strategy=\"last\",    # When token_counter=len, each message    # will be counted as a single token.    # Remember to adjust for your use case    max_tokens=45,    # Most chat models expect that chat history starts with either:    # (1) a HumanMessage or    # (2) a SystemMessage followed by a HumanMessage    start_on=\"human\",    # Most chat models expect that chat history ends with either:    # (1) a HumanMessage or    # (2) a ToolMessage    end_on=(\"human\", \"tool\"),    # Usually, we want to keep the SystemMessage    # if it's present in the original history.    # The SystemMessage has special instructions for the model.    include_system=True,)chain = trimmer | llmchain.invoke(messages)\n```\n\n```\nAIMessage(content='A polygon! Because it\\'s a \"poly-gone\" quiet!', additional_kwargs={'refusal': None}, response_metadata={'token_usage': {'completion_tokens': 13, 'prompt_tokens': 32, 'total_tokens': 45, 'completion_tokens_details': {'reasoning_tokens': 0}}, 'model_name': 'gpt-4o-2024-05-13', 'system_fingerprint': 'fp_057232b607', 'finish_reason': 'stop', 'logprobs': None}, id='run-4fa026e7-9137-4fef-b596-54243615e3b3-0', usage_metadata={'input_tokens': 32, 'output_tokens': 13, 'total_tokens': 45})\n```\n\nLooking at the LangSmith trace we can see that before the messages are passed to the model they are first trimmed: [https://smith.langchain.com/public/65af12c4-c24d-4824-90f0-6547566e59bb/r](https://smith.langchain.com/public/65af12c4-c24d-4824-90f0-6547566e59bb/r)\n\nLooking at just the trimmer, we can see that it's a Runnable object that can be invoked like all Runnables:\n\n```\n[SystemMessage(content=\"you're a good assistant, you always respond with a joke.\", additional_kwargs={}, response_metadata={}), HumanMessage(content='what do you call a speechless parrot', additional_kwargs={}, response_metadata={})]\n```\n\n## Using with ChatMessageHistory[​](#using-with-chatmessagehistory \"Direct link to Using with ChatMessageHistory\")\n\nTrimming messages is especially useful when [working with chat histories](https://python.langchain.com/docs/how_to/message_history/), which can get arbitrarily long:\n\n```\nfrom langchain_core.chat_history import InMemoryChatMessageHistoryfrom langchain_core.runnables.history import RunnableWithMessageHistorychat_history = InMemoryChatMessageHistory(messages=messages[:-1])def dummy_get_session_history(session_id):    if session_id != \"1\":        return InMemoryChatMessageHistory()    return chat_historyllm = ChatOpenAI(model=\"gpt-4o\")trimmer = trim_messages(    max_tokens=45,    strategy=\"last\",    token_counter=llm,    # Usually, we want to keep the SystemMessage    # if it's present in the original history.    # The SystemMessage has special instructions for the model.    include_system=True,    # Most chat models expect that chat history starts with either:    # (1) a HumanMessage or    # (2) a SystemMessage followed by a HumanMessage    # start_on=\"human\" makes sure we produce a valid chat history    start_on=\"human\",)chain = trimmer | llmchain_with_history = RunnableWithMessageHistory(chain, dummy_get_session_history)chain_with_history.invoke(    [HumanMessage(\"what do you call a speechless parrot\")],    config={\"configurable\": {\"session_id\": \"1\"}},)\n```\n\n```\nAIMessage(content='A \"polygon\"!', additional_kwargs={'refusal': None}, response_metadata={'token_usage': {'completion_tokens': 4, 'prompt_tokens': 32, 'total_tokens': 36, 'completion_tokens_details': {'reasoning_tokens': 0}}, 'model_name': 'gpt-4o-2024-05-13', 'system_fingerprint': 'fp_c17d3befe7', 'finish_reason': 'stop', 'logprobs': None}, id='run-71d9fce6-bb0c-4bb3-acc8-d5eaee6ae7bc-0', usage_metadata={'input_tokens': 32, 'output_tokens': 4, 'total_tokens': 36})\n```\n\nLooking at the LangSmith trace we can see that we retrieve all of our messages but before the messages are passed to the model they are trimmed to be just the system message and last human message: [https://smith.langchain.com/public/17dd700b-9994-44ca-930c-116e00997315/r](https://smith.langchain.com/public/17dd700b-9994-44ca-930c-116e00997315/r)\n\n## API reference[​](#api-reference \"Direct link to API reference\")\n\nFor a complete description of all arguments head to the API reference: [https://python.langchain.com/api\\_reference/core/messages/langchain\\_core.messages.utils.trim\\_messages.html](https://python.langchain.com/api_reference/core/messages/langchain_core.messages.utils.trim_messages.html)"
},
{
  "url": "https://python.langchain.com/docs/how_to/vectorstores/",
  "markdown": "# giscus\n\n## How to create and query vector stores\n\ninfo\n\nHead to [Integrations](https://python.langchain.com/docs/integrations/vectorstores/) for documentation on built-in integrations with 3rd-party vector stores.\n\nOne of the most common ways to store and search over unstructured data is to embed it and store the resulting embedding vectors, and then at query time to embed the unstructured query and retrieve the embedding vectors that are 'most similar' to the embedded query. A vector store takes care of storing embedded data and performing vector search for you.\n\n## Get started[​](#get-started \"Direct link to Get started\")\n\nThis guide showcases basic functionality related to vector stores. A key part of working with vector stores is creating the vector to put in them, which is usually created via embeddings. Therefore, it is recommended that you familiarize yourself with the [text embedding model interfaces](https://python.langchain.com/docs/how_to/embed_text/) before diving into this.\n\nBefore using the vectorstore at all, we need to load some data and initialize an embedding model.\n\nWe want to use OpenAIEmbeddings so we have to get the OpenAI API Key.\n\n```\nimport osimport getpassos.environ['OPENAI_API_KEY'] = getpass.getpass('OpenAI API Key:')\n```\n\n```\nfrom langchain_community.document_loaders import TextLoaderfrom langchain_openai import OpenAIEmbeddingsfrom langchain_text_splitters import CharacterTextSplitter# Load the document, split it into chunks, embed each chunk and load it into the vector store.raw_documents = TextLoader('state_of_the_union.txt').load()text_splitter = CharacterTextSplitter(chunk_size=1000, chunk_overlap=0)documents = text_splitter.split_documents(raw_documents)\n```\n\nThere are many great vector store options, here are a few that are free, open-source, and run entirely on your local machine. Review all integrations for many great hosted offerings.\n\n*   Chroma\n*   FAISS\n*   Lance\n\nThis walkthrough uses the `chroma` vector database, which runs on your local machine as a library.\n\n```\npip install langchain-chroma\n```\n\n```\nfrom langchain_chroma import Chromadb = Chroma.from_documents(documents, OpenAIEmbeddings())\n```\n\n## Similarity search[​](#similarity-search \"Direct link to Similarity search\")\n\nAll vectorstores expose a `similarity_search` method. This will take incoming documents, create an embedding of them, and then find all documents with the most similar embedding.\n\n```\nquery = \"What did the president say about Ketanji Brown Jackson\"docs = db.similarity_search(query)print(docs[0].page_content)\n```\n\n```\n    Tonight. I call on the Senate to: Pass the Freedom to Vote Act. Pass the John Lewis Voting Rights Act. And while you’re at it, pass the Disclose Act so Americans can know who is funding our elections.    Tonight, I’d like to honor someone who has dedicated his life to serve this country: Justice Stephen Breyer—an Army veteran, Constitutional scholar, and retiring Justice of the United States Supreme Court. Justice Breyer, thank you for your service.    One of the most serious constitutional responsibilities a President has is nominating someone to serve on the United States Supreme Court.    And I did that 4 days ago, when I nominated Circuit Court of Appeals Judge Ketanji Brown Jackson. One of our nation’s top legal minds, who will continue Justice Breyer’s legacy of excellence.\n```\n\n### Similarity search by vector[​](#similarity-search-by-vector \"Direct link to Similarity search by vector\")\n\nIt is also possible to do a search for documents similar to a given embedding vector using `similarity_search_by_vector` which accepts an embedding vector as a parameter instead of a string.\n\n```\nembedding_vector = OpenAIEmbeddings().embed_query(query)docs = db.similarity_search_by_vector(embedding_vector)print(docs[0].page_content)\n```\n\n```\n    Tonight. I call on the Senate to: Pass the Freedom to Vote Act. Pass the John Lewis Voting Rights Act. And while you’re at it, pass the Disclose Act so Americans can know who is funding our elections.    Tonight, I’d like to honor someone who has dedicated his life to serve this country: Justice Stephen Breyer—an Army veteran, Constitutional scholar, and retiring Justice of the United States Supreme Court. Justice Breyer, thank you for your service.    One of the most serious constitutional responsibilities a President has is nominating someone to serve on the United States Supreme Court.    And I did that 4 days ago, when I nominated Circuit Court of Appeals Judge Ketanji Brown Jackson. One of our nation’s top legal minds, who will continue Justice Breyer’s legacy of excellence.\n```\n\n## Async Operations[​](#async-operations \"Direct link to Async Operations\")\n\nVector stores are usually run as a separate service that requires some IO operations, and therefore they might be called asynchronously. That gives performance benefits as you don't waste time waiting for responses from external services. That might also be important if you work with an asynchronous framework, such as [FastAPI](https://fastapi.tiangolo.com/).\n\nLangChain supports async operation on vector stores. All the methods might be called using their async counterparts, with the prefix `a`, meaning `async`.\n\n```\ndocs = await db.asimilarity_search(query)docs\n```\n\n```\n[Document(page_content='Tonight. I call on the Senate to: Pass the Freedom to Vote Act. Pass the John Lewis Voting Rights Act. And while you’re at it, pass the Disclose Act so Americans can know who is funding our elections. \\n\\nTonight, I’d like to honor someone who has dedicated his life to serve this country: Justice Stephen Breyer—an Army veteran, Constitutional scholar, and retiring Justice of the United States Supreme Court. Justice Breyer, thank you for your service. \\n\\nOne of the most serious constitutional responsibilities a President has is nominating someone to serve on the United States Supreme Court. \\n\\nAnd I did that 4 days ago, when I nominated Circuit Court of Appeals Judge Ketanji Brown Jackson. One of our nation’s top legal minds, who will continue Justice Breyer’s legacy of excellence.', metadata={'source': 'state_of_the_union.txt'}), Document(page_content='A former top litigator in private practice. A former federal public defender. And from a family of public school educators and police officers. A consensus builder. Since she’s been nominated, she’s received a broad range of support—from the Fraternal Order of Police to former judges appointed by Democrats and Republicans. \\n\\nAnd if we are to advance liberty and justice, we need to secure the Border and fix the immigration system. \\n\\nWe can do both. At our border, we’ve installed new technology like cutting-edge scanners to better detect drug smuggling.  \\n\\nWe’ve set up joint patrols with Mexico and Guatemala to catch more human traffickers.  \\n\\nWe’re putting in place dedicated immigration judges so families fleeing persecution and violence can have their cases heard faster. \\n\\nWe’re securing commitments and supporting partners in South and Central America to host more refugees and secure their own borders.', metadata={'source': 'state_of_the_union.txt'}), Document(page_content='And for our LGBTQ+ Americans, let’s finally get the bipartisan Equality Act to my desk. The onslaught of state laws targeting transgender Americans and their families is wrong. \\n\\nAs I said last year, especially to our younger transgender Americans, I will always have your back as your President, so you can be yourself and reach your God-given potential. \\n\\nWhile it often appears that we never agree, that isn’t true. I signed 80 bipartisan bills into law last year. From preventing government shutdowns to protecting Asian-Americans from still-too-common hate crimes to reforming military justice. \\n\\nAnd soon, we’ll strengthen the Violence Against Women Act that I first wrote three decades ago. It is important for us to show the nation that we can come together and do big things. \\n\\nSo tonight I’m offering a Unity Agenda for the Nation. Four big things we can do together.  \\n\\nFirst, beat the opioid epidemic.', metadata={'source': 'state_of_the_union.txt'}), Document(page_content='Tonight, I’m announcing a crackdown on these companies overcharging American businesses and consumers. \\n\\nAnd as Wall Street firms take over more nursing homes, quality in those homes has gone down and costs have gone up.  \\n\\nThat ends on my watch. \\n\\nMedicare is going to set higher standards for nursing homes and make sure your loved ones get the care they deserve and expect. \\n\\nWe’ll also cut costs and keep the economy going strong by giving workers a fair shot, provide more training and apprenticeships, hire them based on their skills not degrees. \\n\\nLet’s pass the Paycheck Fairness Act and paid leave.  \\n\\nRaise the minimum wage to $15 an hour and extend the Child Tax Credit, so no one has to raise a family in poverty. \\n\\nLet’s increase Pell Grants and increase our historic support of HBCUs, and invest in what Jill—our First Lady who teaches full-time—calls America’s best-kept secret: community colleges.', metadata={'source': 'state_of_the_union.txt'})]\n```"
}]